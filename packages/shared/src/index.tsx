/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: any;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: any;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. */
  node: Maybe<Node>;
  /** Reads a set of `GameState`. */
  gameStates: Maybe<Array<GameState>>;
  /** Reads a set of `Player`. */
  players: Maybe<Array<Player>>;
  gameState: Maybe<GameState>;
  player: Maybe<Player>;
  /** Reads a single `GameState` using its globally unique `ID`. */
  gameStateByNodeId: Maybe<GameState>;
  /** Reads a single `Player` using its globally unique `ID`. */
  playerByNodeId: Maybe<Player>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameStatesOrderBy>>;
  condition?: Maybe<GameStateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlayersOrderBy>>;
  condition?: Maybe<PlayerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGameStateArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameStateByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type GameState = Node & {
  __typename?: 'GameState';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  base: BaseType;
};

export enum BaseType {
  FIRST = 'FIRST',
  SECOND = 'SECOND',
  THIRD = 'THIRD'
}

/** Methods to use when ordering `GameState`. */
export enum GameStatesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  BASE_ASC = 'BASE_ASC',
  BASE_DESC = 'BASE_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `GameState` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GameStateCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `base` field. */
  base?: Maybe<BaseType>;
};

export type Player = Node & {
  __typename?: 'Player';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  firstName: Scalars['String'];
  lastName: Maybe<Scalars['String']>;
  createdAt: Maybe<Scalars['Datetime']>;
};



/** Methods to use when ordering `Player`. */
export enum PlayersOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  FIRST_NAME_ASC = 'FIRST_NAME_ASC',
  FIRST_NAME_DESC = 'FIRST_NAME_DESC',
  LAST_NAME_ASC = 'LAST_NAME_ASC',
  LAST_NAME_DESC = 'LAST_NAME_DESC',
  CREATED_AT_ASC = 'CREATED_AT_ASC',
  CREATED_AT_DESC = 'CREATED_AT_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `Player` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PlayerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `createdAt` field. */
  createdAt?: Maybe<Scalars['Datetime']>;
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a single `GameState`. */
  createGameState: Maybe<CreateGameStatePayload>;
  /** Creates a single `Player`. */
  createPlayer: Maybe<CreatePlayerPayload>;
  /** Updates a single `GameState` using its globally unique id and a patch. */
  updateGameStateByNodeId: Maybe<UpdateGameStatePayload>;
  /** Updates a single `GameState` using a unique key and a patch. */
  updateGameState: Maybe<UpdateGameStatePayload>;
  /** Updates a single `Player` using its globally unique id and a patch. */
  updatePlayerByNodeId: Maybe<UpdatePlayerPayload>;
  /** Updates a single `Player` using a unique key and a patch. */
  updatePlayer: Maybe<UpdatePlayerPayload>;
  /** Deletes a single `GameState` using its globally unique id. */
  deleteGameStateByNodeId: Maybe<DeleteGameStatePayload>;
  /** Deletes a single `GameState` using a unique key. */
  deleteGameState: Maybe<DeleteGameStatePayload>;
  /** Deletes a single `Player` using its globally unique id. */
  deletePlayerByNodeId: Maybe<DeletePlayerPayload>;
  /** Deletes a single `Player` using a unique key. */
  deletePlayer: Maybe<DeletePlayerPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameStateArgs = {
  input: CreateGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlayerArgs = {
  input: CreatePlayerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameStateByNodeIdArgs = {
  input: UpdateGameStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameStateArgs = {
  input: UpdateGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerByNodeIdArgs = {
  input: UpdatePlayerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerArgs = {
  input: UpdatePlayerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameStateByNodeIdArgs = {
  input: DeleteGameStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameStateArgs = {
  input: DeleteGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerByNodeIdArgs = {
  input: DeletePlayerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerArgs = {
  input: DeletePlayerInput;
};

/** The output of our create `GameState` mutation. */
export type CreateGameStatePayload = {
  __typename?: 'CreateGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameState` that was created by this mutation. */
  gameState: Maybe<GameState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `GameState` mutation. */
export type CreateGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GameState` to be created by this mutation. */
  gameState: GameStateInput;
};

/** An input for mutations affecting `GameState` */
export type GameStateInput = {
  id?: Maybe<Scalars['Int']>;
  base: BaseType;
};

/** The output of our create `Player` mutation. */
export type CreatePlayerPayload = {
  __typename?: 'CreatePlayerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Player` that was created by this mutation. */
  player: Maybe<Player>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `Player` mutation. */
export type CreatePlayerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Player` to be created by this mutation. */
  player: PlayerInput;
};

/** An input for mutations affecting `Player` */
export type PlayerInput = {
  id?: Maybe<Scalars['UUID']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
};

/** The output of our update `GameState` mutation. */
export type UpdateGameStatePayload = {
  __typename?: 'UpdateGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameState` that was updated by this mutation. */
  gameState: Maybe<GameState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updateGameStateByNodeId` mutation. */
export type UpdateGameStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameState` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GameState` being updated. */
  patch: GameStatePatch;
};

/** Represents an update to a `GameState`. Fields that are set will be updated. */
export type GameStatePatch = {
  id?: Maybe<Scalars['Int']>;
  base?: Maybe<BaseType>;
};

/** All input for the `updateGameState` mutation. */
export type UpdateGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GameState` being updated. */
  patch: GameStatePatch;
  id: Scalars['Int'];
};

/** The output of our update `Player` mutation. */
export type UpdatePlayerPayload = {
  __typename?: 'UpdatePlayerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Player` that was updated by this mutation. */
  player: Maybe<Player>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updatePlayerByNodeId` mutation. */
export type UpdatePlayerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Player` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Player` being updated. */
  patch: PlayerPatch;
};

/** Represents an update to a `Player`. Fields that are set will be updated. */
export type PlayerPatch = {
  id?: Maybe<Scalars['UUID']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Datetime']>;
};

/** All input for the `updatePlayer` mutation. */
export type UpdatePlayerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Player` being updated. */
  patch: PlayerPatch;
  id: Scalars['UUID'];
};

/** The output of our delete `GameState` mutation. */
export type DeleteGameStatePayload = {
  __typename?: 'DeleteGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameState` that was deleted by this mutation. */
  gameState: Maybe<GameState>;
  deletedGameStateNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteGameStateByNodeId` mutation. */
export type DeleteGameStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameState` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGameState` mutation. */
export type DeleteGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Player` mutation. */
export type DeletePlayerPayload = {
  __typename?: 'DeletePlayerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Player` that was deleted by this mutation. */
  player: Maybe<Player>;
  deletedPlayerNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deletePlayerByNodeId` mutation. */
export type DeletePlayerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Player` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlayer` mutation. */
export type DeletePlayerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

export type AddGameStateMutationVariables = Exact<{
  base: BaseType;
}>;


export type AddGameStateMutation = (
  { __typename?: 'Mutation' }
  & { createGameState: Maybe<(
    { __typename?: 'CreateGameStatePayload' }
    & { gameState: Maybe<(
      { __typename?: 'GameState' }
      & Pick<GameState, 'id' | 'base'>
    )> }
  )> }
);

export type CreatePlayerMutationVariables = Exact<{
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
}>;


export type CreatePlayerMutation = (
  { __typename?: 'Mutation' }
  & { createPlayer: Maybe<(
    { __typename?: 'CreatePlayerPayload' }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'firstName' | 'lastName'>
    )> }
  )> }
);

export type GetAllPlayersQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllPlayersQuery = (
  { __typename?: 'Query' }
  & { players: Maybe<Array<(
    { __typename?: 'Player' }
    & Pick<Player, 'id' | 'firstName' | 'lastName'>
  )>> }
);


export const AddGameStateDocument = gql`
    mutation AddGameState($base: BaseType!) {
  createGameState(input: {gameState: {base: $base}}) {
    gameState {
      id
      base
    }
  }
}
    `;
export type AddGameStateMutationFn = Apollo.MutationFunction<AddGameStateMutation, AddGameStateMutationVariables>;

/**
 * __useAddGameStateMutation__
 *
 * To run a mutation, you first call `useAddGameStateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddGameStateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addGameStateMutation, { data, loading, error }] = useAddGameStateMutation({
 *   variables: {
 *      base: // value for 'base'
 *   },
 * });
 */
export function useAddGameStateMutation(baseOptions?: Apollo.MutationHookOptions<AddGameStateMutation, AddGameStateMutationVariables>) {
        return Apollo.useMutation<AddGameStateMutation, AddGameStateMutationVariables>(AddGameStateDocument, baseOptions);
      }
export type AddGameStateMutationHookResult = ReturnType<typeof useAddGameStateMutation>;
export type AddGameStateMutationResult = Apollo.MutationResult<AddGameStateMutation>;
export type AddGameStateMutationOptions = Apollo.BaseMutationOptions<AddGameStateMutation, AddGameStateMutationVariables>;
export const CreatePlayerDocument = gql`
    mutation CreatePlayer($firstName: String!, $lastName: String) {
  createPlayer(input: {player: {firstName: $firstName, lastName: $lastName}}) {
    player {
      id
      firstName
      lastName
    }
  }
}
    `;
export type CreatePlayerMutationFn = Apollo.MutationFunction<CreatePlayerMutation, CreatePlayerMutationVariables>;

/**
 * __useCreatePlayerMutation__
 *
 * To run a mutation, you first call `useCreatePlayerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlayerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlayerMutation, { data, loading, error }] = useCreatePlayerMutation({
 *   variables: {
 *      firstName: // value for 'firstName'
 *      lastName: // value for 'lastName'
 *   },
 * });
 */
export function useCreatePlayerMutation(baseOptions?: Apollo.MutationHookOptions<CreatePlayerMutation, CreatePlayerMutationVariables>) {
        return Apollo.useMutation<CreatePlayerMutation, CreatePlayerMutationVariables>(CreatePlayerDocument, baseOptions);
      }
export type CreatePlayerMutationHookResult = ReturnType<typeof useCreatePlayerMutation>;
export type CreatePlayerMutationResult = Apollo.MutationResult<CreatePlayerMutation>;
export type CreatePlayerMutationOptions = Apollo.BaseMutationOptions<CreatePlayerMutation, CreatePlayerMutationVariables>;
export const GetAllPlayersDocument = gql`
    query GetAllPlayers {
  players {
    id
    firstName
    lastName
  }
}
    `;

/**
 * __useGetAllPlayersQuery__
 *
 * To run a query within a React component, call `useGetAllPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllPlayersQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllPlayersQuery(baseOptions?: Apollo.QueryHookOptions<GetAllPlayersQuery, GetAllPlayersQueryVariables>) {
        return Apollo.useQuery<GetAllPlayersQuery, GetAllPlayersQueryVariables>(GetAllPlayersDocument, baseOptions);
      }
export function useGetAllPlayersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllPlayersQuery, GetAllPlayersQueryVariables>) {
          return Apollo.useLazyQuery<GetAllPlayersQuery, GetAllPlayersQueryVariables>(GetAllPlayersDocument, baseOptions);
        }
export type GetAllPlayersQueryHookResult = ReturnType<typeof useGetAllPlayersQuery>;
export type GetAllPlayersLazyQueryHookResult = ReturnType<typeof useGetAllPlayersLazyQuery>;
export type GetAllPlayersQueryResult = Apollo.QueryResult<GetAllPlayersQuery, GetAllPlayersQueryVariables>;
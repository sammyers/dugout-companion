/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** The day, does not include a time. */
  Date: string;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: string;
  /** A JavaScript object encoded in the JSON format as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: any;
  /**
   * A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519)
   * which securely represents claims between two parties.
   */
  Jwt: any;
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: string;
};

export type AtBatSkip = Node & {
  __typename?: 'AtBatSkip';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  batterId: Scalars['UUID'];
  gameId: Scalars['UUID'];
  /** Reads a single `Player` that is related to this `AtBatSkip`. */
  batter: Maybe<Player>;
  /** Reads a single `Game` that is related to this `AtBatSkip`. */
  game: Maybe<Game>;
};

/** The fields on `atBatSkip` to look up the row to connect. */
export type AtBatSkipAtBatSkipPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `atBatSkip` to look up the row to delete. */
export type AtBatSkipAtBatSkipPkeyDelete = {
  id: Scalars['UUID'];
};

/** The `atBatSkip` to be created by this mutation. */
export type AtBatSkipBatterIdFkeyAtBatSkipCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** Input for the nested mutation of `player` in the `AtBatSkipInput` mutation. */
export type AtBatSkipBatterIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnAtBatSkipForAtBatSkipBatterIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnAtBatSkipForAtBatSkipBatterIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<AtBatSkipOnAtBatSkipForAtBatSkipBatterIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<AtBatSkipBatterIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `atBatSkip` in the `PlayerInput` mutation. */
export type AtBatSkipBatterIdFkeyInverseInput = {
  /** Flag indicating whether all other `atBatSkip` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  connectById?: Maybe<Array<AtBatSkipAtBatSkipPkeyConnect>>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<AtBatSkipNodeIdConnect>>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  deleteById?: Maybe<Array<AtBatSkipAtBatSkipPkeyDelete>>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<AtBatSkipNodeIdDelete>>;
  /** The primary key(s) and patch data for `atBatSkip` for the far side of the relationship. */
  updateById?: Maybe<Array<AtBatSkipOnAtBatSkipForAtBatSkipBatterIdFkeyUsingAtBatSkipPkeyUpdate>>;
  /** The primary key(s) and patch data for `atBatSkip` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnAtBatSkipForAtBatSkipBatterIdFkeyNodeIdUpdate>>;
  /** A `AtBatSkipInput` object that will be created and connected to this object. */
  create?: Maybe<Array<AtBatSkipBatterIdFkeyAtBatSkipCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type AtBatSkipBatterIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/**
 * A condition to be used against `AtBatSkip` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AtBatSkipCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `batterId` field. */
  batterId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `AtBatSkip` object types. All fields are combined with a logical ‘and.’ */
export type AtBatSkipFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `batterId` field. */
  batterId?: Maybe<UuidFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AtBatSkipFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AtBatSkipFilter>>;
  /** Negates the expression. */
  not?: Maybe<AtBatSkipFilter>;
};

/** The `atBatSkip` to be created by this mutation. */
export type AtBatSkipGameIdFkeyAtBatSkipCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** The `game` to be created by this mutation. */
export type AtBatSkipGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `AtBatSkipInput` mutation. */
export type AtBatSkipGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnAtBatSkipForAtBatSkipGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnAtBatSkipForAtBatSkipGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<AtBatSkipOnAtBatSkipForAtBatSkipGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<AtBatSkipGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `atBatSkip` in the `GameInput` mutation. */
export type AtBatSkipGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `atBatSkip` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  connectById?: Maybe<Array<AtBatSkipAtBatSkipPkeyConnect>>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<AtBatSkipNodeIdConnect>>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  deleteById?: Maybe<Array<AtBatSkipAtBatSkipPkeyDelete>>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<AtBatSkipNodeIdDelete>>;
  /** The primary key(s) and patch data for `atBatSkip` for the far side of the relationship. */
  updateById?: Maybe<Array<AtBatSkipOnAtBatSkipForAtBatSkipGameIdFkeyUsingAtBatSkipPkeyUpdate>>;
  /** The primary key(s) and patch data for `atBatSkip` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnAtBatSkipForAtBatSkipGameIdFkeyNodeIdUpdate>>;
  /** A `AtBatSkipInput` object that will be created and connected to this object. */
  create?: Maybe<Array<AtBatSkipGameIdFkeyAtBatSkipCreateInput>>;
};

/** An input for mutations affecting `AtBatSkip` */
export type AtBatSkipInput = {
  id?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type AtBatSkipNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `atBatSkip` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type AtBatSkipNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `atBatSkip` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type AtBatSkipOnAtBatSkipForAtBatSkipBatterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `atBatSkip` to look up the row to update. */
export type AtBatSkipOnAtBatSkipForAtBatSkipBatterIdFkeyUsingAtBatSkipPkeyUpdate = {
  /** An object where the defined keys will be set on the `atBatSkip` being updated. */
  patch: UpdateAtBatSkipOnAtBatSkipForAtBatSkipBatterIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type AtBatSkipOnAtBatSkipForAtBatSkipGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `atBatSkip` to look up the row to update. */
export type AtBatSkipOnAtBatSkipForAtBatSkipGameIdFkeyUsingAtBatSkipPkeyUpdate = {
  /** An object where the defined keys will be set on the `atBatSkip` being updated. */
  patch: UpdateAtBatSkipOnAtBatSkipForAtBatSkipGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type AtBatSkipOnGameEventForGameEventAtBatSkipIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `atBatSkip` to look up the row to update. */
export type AtBatSkipOnGameEventForGameEventAtBatSkipIdFkeyUsingAtBatSkipPkeyUpdate = {
  /** An object where the defined keys will be set on the `atBatSkip` being updated. */
  patch: UpdateAtBatSkipOnGameEventForGameEventAtBatSkipIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `AtBatSkip`. Fields that are set will be updated. */
export type AtBatSkipPatch = {
  id?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** Methods to use when ordering `AtBatSkip`. */
export enum AtBatSkipsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  BATTER_ID_ASC = 'BATTER_ID_ASC',
  BATTER_ID_DESC = 'BATTER_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type BaseRunner = Node & {
  __typename?: 'BaseRunner';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
  base: BaseType;
  gameId: Scalars['UUID'];
  /** Reads a single `GameState` that is related to this `BaseRunner`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Player` that is related to this `BaseRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BaseRunner`. */
  game: Maybe<Game>;
};

/** The fields on `baseRunner` to look up the row to connect. */
export type BaseRunnerBaseRunnerPkeyConnect = {
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The fields on `baseRunner` to look up the row to delete. */
export type BaseRunnerBaseRunnerPkeyDelete = {
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/**
 * A condition to be used against `BaseRunner` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type BaseRunnerCondition = {
  /** Checks for equality with the object’s `gameStateId` field. */
  gameStateId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runnerId` field. */
  runnerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `base` field. */
  base?: Maybe<BaseType>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `BaseRunner` object types. All fields are combined with a logical ‘and.’ */
export type BaseRunnerFilter = {
  /** Filter by the object’s `gameStateId` field. */
  gameStateId?: Maybe<UuidFilter>;
  /** Filter by the object’s `runnerId` field. */
  runnerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `base` field. */
  base?: Maybe<BaseTypeFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<BaseRunnerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<BaseRunnerFilter>>;
  /** Negates the expression. */
  not?: Maybe<BaseRunnerFilter>;
};

/** The `baseRunner` to be created by this mutation. */
export type BaseRunnerGameIdFkeyBaseRunnerCreateInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  base: BaseType;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** The `game` to be created by this mutation. */
export type BaseRunnerGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `BaseRunnerInput` mutation. */
export type BaseRunnerGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnBaseRunnerForBaseRunnerGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnBaseRunnerForBaseRunnerGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<BaseRunnerOnBaseRunnerForBaseRunnerGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<BaseRunnerGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `baseRunner` in the `GameInput` mutation. */
export type BaseRunnerGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `baseRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BaseRunnerNodeIdConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyDelete>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BaseRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerOnBaseRunnerForBaseRunnerGameIdFkeyUsingBaseRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnBaseRunnerForBaseRunnerGameIdFkeyNodeIdUpdate>>;
  /** A `BaseRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BaseRunnerGameIdFkeyBaseRunnerCreateInput>>;
};

/** The `baseRunner` to be created by this mutation. */
export type BaseRunnerGameStateIdFkeyBaseRunnerCreateInput = {
  runnerId?: Maybe<Scalars['UUID']>;
  base: BaseType;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** The `gameState` to be created by this mutation. */
export type BaseRunnerGameStateIdFkeyGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `gameState` in the `BaseRunnerInput` mutation. */
export type BaseRunnerGameStateIdFkeyInput = {
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<GameStateGameStatePkeyConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameStateNodeIdConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<GameStateGameStatePkeyDelete>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameStateNodeIdDelete>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingGameStatePkeyUpdate>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<BaseRunnerGameStateIdFkeyGameStateCreateInput>;
};

/** Input for the nested mutation of `baseRunner` in the `GameStateInput` mutation. */
export type BaseRunnerGameStateIdFkeyInverseInput = {
  /** Flag indicating whether all other `baseRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BaseRunnerNodeIdConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyDelete>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BaseRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingBaseRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate>>;
  /** A `BaseRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BaseRunnerGameStateIdFkeyBaseRunnerCreateInput>>;
};

/** An input for mutations affecting `BaseRunner` */
export type BaseRunnerInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  base: BaseType;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type BaseRunnerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `baseRunner` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type BaseRunnerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `baseRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `baseRunner` to look up the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerGameIdFkeyUsingBaseRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: UpdateBaseRunnerOnBaseRunnerForBaseRunnerGameIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `baseRunner` to look up the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingBaseRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: UpdateBaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `baseRunner` to look up the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingBaseRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: UpdateBaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** Represents an update to a `BaseRunner`. Fields that are set will be updated. */
export type BaseRunnerPatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  base?: Maybe<BaseType>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** The `baseRunner` to be created by this mutation. */
export type BaseRunnerRunnerIdFkeyBaseRunnerCreateInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  base: BaseType;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** Input for the nested mutation of `player` in the `BaseRunnerInput` mutation. */
export type BaseRunnerRunnerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<BaseRunnerRunnerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `baseRunner` in the `PlayerInput` mutation. */
export type BaseRunnerRunnerIdFkeyInverseInput = {
  /** Flag indicating whether all other `baseRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BaseRunnerNodeIdConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyDelete>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BaseRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingBaseRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate>>;
  /** A `BaseRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BaseRunnerRunnerIdFkeyBaseRunnerCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type BaseRunnerRunnerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** Methods to use when ordering `BaseRunner`. */
export enum BaseRunnersOrderBy {
  NATURAL = 'NATURAL',
  GAME_STATE_ID_ASC = 'GAME_STATE_ID_ASC',
  GAME_STATE_ID_DESC = 'GAME_STATE_ID_DESC',
  RUNNER_ID_ASC = 'RUNNER_ID_ASC',
  RUNNER_ID_DESC = 'RUNNER_ID_DESC',
  BASE_ASC = 'BASE_ASC',
  BASE_DESC = 'BASE_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export enum BaseType {
  FIRST = 'FIRST',
  SECOND = 'SECOND',
  THIRD = 'THIRD'
}

/** A filter to be used against BaseType fields. All fields are combined with a logical ‘and.’ */
export type BaseTypeFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<BaseType>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<BaseType>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<BaseType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<BaseType>;
  /** Included in the specified list. */
  in?: Maybe<Array<BaseType>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<BaseType>>;
  /** Less than the specified value. */
  lessThan?: Maybe<BaseType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<BaseType>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<BaseType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<BaseType>;
};

export type BasepathMovement = Node & {
  __typename?: 'BasepathMovement';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
  endBase: Maybe<BaseType>;
  wasSafe: Scalars['Boolean'];
  gameId: Scalars['UUID'];
  /** Reads a single `PlateAppearance` that is related to this `BasepathMovement`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `BasepathMovement`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BasepathMovement`. */
  game: Maybe<Game>;
};

/** The fields on `basepathMovement` to look up the row to connect. */
export type BasepathMovementBasepathMovementPkeyConnect = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The fields on `basepathMovement` to look up the row to delete. */
export type BasepathMovementBasepathMovementPkeyDelete = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/**
 * A condition to be used against `BasepathMovement` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type BasepathMovementCondition = {
  /** Checks for equality with the object’s `plateAppearanceId` field. */
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runnerId` field. */
  runnerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `endBase` field. */
  endBase?: Maybe<BaseType>;
  /** Checks for equality with the object’s `wasSafe` field. */
  wasSafe?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `BasepathMovement` object types. All fields are combined with a logical ‘and.’ */
export type BasepathMovementFilter = {
  /** Filter by the object’s `plateAppearanceId` field. */
  plateAppearanceId?: Maybe<UuidFilter>;
  /** Filter by the object’s `runnerId` field. */
  runnerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `endBase` field. */
  endBase?: Maybe<BaseTypeFilter>;
  /** Filter by the object’s `wasSafe` field. */
  wasSafe?: Maybe<BooleanFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<BasepathMovementFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<BasepathMovementFilter>>;
  /** Negates the expression. */
  not?: Maybe<BasepathMovementFilter>;
};

/** The `basepathMovement` to be created by this mutation. */
export type BasepathMovementGameIdFkeyBasepathMovementCreateInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe: Scalars['Boolean'];
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** The `game` to be created by this mutation. */
export type BasepathMovementGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `BasepathMovementInput` mutation. */
export type BasepathMovementGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnBasepathMovementForBasepathMovementGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnBasepathMovementForBasepathMovementGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<BasepathMovementOnBasepathMovementForBasepathMovementGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<BasepathMovementGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `basepathMovement` in the `GameInput` mutation. */
export type BasepathMovementGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `basepathMovement` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BasepathMovementNodeIdConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyDelete>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BasepathMovementNodeIdDelete>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementOnBasepathMovementForBasepathMovementGameIdFkeyUsingBasepathMovementPkeyUpdate>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnBasepathMovementForBasepathMovementGameIdFkeyNodeIdUpdate>>;
  /** A `BasepathMovementInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BasepathMovementGameIdFkeyBasepathMovementCreateInput>>;
};

/** An input for mutations affecting `BasepathMovement` */
export type BasepathMovementInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type BasepathMovementNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `basepathMovement` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type BasepathMovementNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `basepathMovement` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `basepathMovement` to look up the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementGameIdFkeyUsingBasepathMovementPkeyUpdate = {
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: UpdateBasepathMovementOnBasepathMovementForBasepathMovementGameIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** The fields on `basepathMovement` to look up the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingBasepathMovementPkeyUpdate = {
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: UpdateBasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `basepathMovement` to look up the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingBasepathMovementPkeyUpdate = {
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: UpdateBasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** Represents an update to a `BasepathMovement`. Fields that are set will be updated. */
export type BasepathMovementPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** The `basepathMovement` to be created by this mutation. */
export type BasepathMovementPlateAppearanceIdFkeyBasepathMovementCreateInput = {
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** Input for the nested mutation of `plateAppearance` in the `BasepathMovementInput` mutation. */
export type BasepathMovementPlateAppearanceIdFkeyInput = {
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectById?: Maybe<PlateAppearancePlateAppearancePkeyConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlateAppearanceNodeIdConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteById?: Maybe<PlateAppearancePlateAppearancePkeyDelete>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlateAppearanceNodeIdDelete>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateById?: Maybe<PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateByNodeId?: Maybe<BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate>;
  /** A `PlateAppearanceInput` object that will be created and connected to this object. */
  create?: Maybe<BasepathMovementPlateAppearanceIdFkeyPlateAppearanceCreateInput>;
};

/** Input for the nested mutation of `basepathMovement` in the `PlateAppearanceInput` mutation. */
export type BasepathMovementPlateAppearanceIdFkeyInverseInput = {
  /** Flag indicating whether all other `basepathMovement` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BasepathMovementNodeIdConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyDelete>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BasepathMovementNodeIdDelete>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingBasepathMovementPkeyUpdate>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate>>;
  /** A `BasepathMovementInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BasepathMovementPlateAppearanceIdFkeyBasepathMovementCreateInput>>;
};

/** The `plateAppearance` to be created by this mutation. */
export type BasepathMovementPlateAppearanceIdFkeyPlateAppearanceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** The `basepathMovement` to be created by this mutation. */
export type BasepathMovementRunnerIdFkeyBasepathMovementCreateInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** Input for the nested mutation of `player` in the `BasepathMovementInput` mutation. */
export type BasepathMovementRunnerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<BasepathMovementRunnerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `basepathMovement` in the `PlayerInput` mutation. */
export type BasepathMovementRunnerIdFkeyInverseInput = {
  /** Flag indicating whether all other `basepathMovement` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BasepathMovementNodeIdConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyDelete>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BasepathMovementNodeIdDelete>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingBasepathMovementPkeyUpdate>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate>>;
  /** A `BasepathMovementInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BasepathMovementRunnerIdFkeyBasepathMovementCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type BasepathMovementRunnerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** Methods to use when ordering `BasepathMovement`. */
export enum BasepathMovementsOrderBy {
  NATURAL = 'NATURAL',
  PLATE_APPEARANCE_ID_ASC = 'PLATE_APPEARANCE_ID_ASC',
  PLATE_APPEARANCE_ID_DESC = 'PLATE_APPEARANCE_ID_DESC',
  RUNNER_ID_ASC = 'RUNNER_ID_ASC',
  RUNNER_ID_DESC = 'RUNNER_ID_DESC',
  END_BASE_ASC = 'END_BASE_ASC',
  END_BASE_DESC = 'END_BASE_DESC',
  WAS_SAFE_ASC = 'WAS_SAFE_ASC',
  WAS_SAFE_DESC = 'WAS_SAFE_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Boolean']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Boolean']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Boolean']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Boolean']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Boolean']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Boolean']>;
};

export type CareerBattingStat = Node & {
  __typename?: 'CareerBattingStat';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  groupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
  seasons: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['Int']>;
  plateAppearances: Scalars['Int'];
  atBats: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  gidp: Scalars['Int'];
  runs: Scalars['Int'];
  rbi: Scalars['Int'];
  stolenBases: Scalars['Int'];
  avg: Scalars['Float'];
  obp: Scalars['Float'];
  slg: Scalars['Float'];
  ops: Scalars['Float'];
  /** Reads a single `Group` that is related to this `CareerBattingStat`. */
  group: Maybe<Group>;
  /** Reads a single `Player` that is related to this `CareerBattingStat`. */
  player: Maybe<Player>;
};

/**
 * A condition to be used against `CareerBattingStat` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type CareerBattingStatCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `seasons` field. */
  seasons?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stolenBases` field. */
  stolenBases?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `avg` field. */
  avg?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `obp` field. */
  obp?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `slg` field. */
  slg?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The fields on `careerBattingStat` to look up the row to connect. */
export type CareerBattingStatFakePublicCareerBattingStatsPrimaryKeyConnect = {
  groupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The fields on `careerBattingStat` to look up the row to delete. */
export type CareerBattingStatFakePublicCareerBattingStatsPrimaryKeyDelete = {
  groupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** A filter to be used against `CareerBattingStat` object types. All fields are combined with a logical ‘and.’ */
export type CareerBattingStatFilter = {
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<UuidFilter>;
  /** Filter by the object’s `playerId` field. */
  playerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `seasons` field. */
  seasons?: Maybe<IntFilter>;
  /** Filter by the object’s `games` field. */
  games?: Maybe<IntFilter>;
  /** Filter by the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<IntFilter>;
  /** Filter by the object’s `atBats` field. */
  atBats?: Maybe<IntFilter>;
  /** Filter by the object’s `hits` field. */
  hits?: Maybe<IntFilter>;
  /** Filter by the object’s `singles` field. */
  singles?: Maybe<IntFilter>;
  /** Filter by the object’s `doubles` field. */
  doubles?: Maybe<IntFilter>;
  /** Filter by the object’s `triples` field. */
  triples?: Maybe<IntFilter>;
  /** Filter by the object’s `homeruns` field. */
  homeruns?: Maybe<IntFilter>;
  /** Filter by the object’s `walks` field. */
  walks?: Maybe<IntFilter>;
  /** Filter by the object’s `strikeouts` field. */
  strikeouts?: Maybe<IntFilter>;
  /** Filter by the object’s `sacFlies` field. */
  sacFlies?: Maybe<IntFilter>;
  /** Filter by the object’s `gidp` field. */
  gidp?: Maybe<IntFilter>;
  /** Filter by the object’s `runs` field. */
  runs?: Maybe<IntFilter>;
  /** Filter by the object’s `rbi` field. */
  rbi?: Maybe<IntFilter>;
  /** Filter by the object’s `stolenBases` field. */
  stolenBases?: Maybe<IntFilter>;
  /** Filter by the object’s `avg` field. */
  avg?: Maybe<FloatFilter>;
  /** Filter by the object’s `obp` field. */
  obp?: Maybe<FloatFilter>;
  /** Filter by the object’s `slg` field. */
  slg?: Maybe<FloatFilter>;
  /** Filter by the object’s `ops` field. */
  ops?: Maybe<FloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<CareerBattingStatFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<CareerBattingStatFilter>>;
  /** Negates the expression. */
  not?: Maybe<CareerBattingStatFilter>;
};

/** The globally unique `ID` look up for the row to connect. */
export type CareerBattingStatNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `careerBattingStat` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type CareerBattingStatNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `careerBattingStat` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CareerBattingStatOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** The fields on `careerBattingStat` to look up the row to update. */
export type CareerBattingStatOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0UsingFakePublicCareerBattingStatsPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `careerBattingStat` being updated. */
  patch: UpdateCareerBattingStatOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0Patch;
  groupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type CareerBattingStatOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `careerBattingStat` to look up the row to update. */
export type CareerBattingStatOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey1UsingFakePublicCareerBattingStatsPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `careerBattingStat` being updated. */
  patch: UpdateCareerBattingStatOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey1Patch;
  groupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** Represents an update to a `CareerBattingStat`. Fields that are set will be updated. */
export type CareerBattingStatPatch = {
  groupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  avg?: Maybe<Scalars['Float']>;
  obp?: Maybe<Scalars['Float']>;
  slg?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  group?: Maybe<FakePublicCareerBattingStatsForeignKey0Input>;
  player?: Maybe<FakePublicCareerBattingStatsForeignKey1Input>;
};

/** Methods to use when ordering `CareerBattingStat`. */
export enum CareerBattingStatsOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  SEASONS_ASC = 'SEASONS_ASC',
  SEASONS_DESC = 'SEASONS_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  STOLEN_BASES_ASC = 'STOLEN_BASES_ASC',
  STOLEN_BASES_DESC = 'STOLEN_BASES_DESC',
  AVG_ASC = 'AVG_ASC',
  AVG_DESC = 'AVG_DESC',
  OBP_ASC = 'OBP_ASC',
  OBP_DESC = 'OBP_DESC',
  SLG_ASC = 'SLG_ASC',
  SLG_DESC = 'SLG_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export enum ContactQuality {
  NONE = 'NONE',
  GROUNDER = 'GROUNDER',
  LINE_DRIVE = 'LINE_DRIVE',
  POPUP = 'POPUP',
  LAZY_FLY = 'LAZY_FLY',
  LONG_FLY = 'LONG_FLY',
  FOUL = 'FOUL',
  DEAD_BALL = 'DEAD_BALL',
  INNING_ENDING_DEAD_BALL = 'INNING_ENDING_DEAD_BALL'
}

/** A filter to be used against ContactQuality fields. All fields are combined with a logical ‘and.’ */
export type ContactQualityFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<ContactQuality>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<ContactQuality>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<ContactQuality>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<ContactQuality>;
  /** Included in the specified list. */
  in?: Maybe<Array<ContactQuality>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<ContactQuality>>;
  /** Less than the specified value. */
  lessThan?: Maybe<ContactQuality>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<ContactQuality>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<ContactQuality>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<ContactQuality>;
};

/** All input for the create `AtBatSkip` mutation. */
export type CreateAtBatSkipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AtBatSkip` to be created by this mutation. */
  atBatSkip: AtBatSkipInput;
};

/** The output of our create `AtBatSkip` mutation. */
export type CreateAtBatSkipPayload = {
  __typename?: 'CreateAtBatSkipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `AtBatSkip` that was created by this mutation. */
  atBatSkip: Maybe<AtBatSkip>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `AtBatSkip`. */
  batter: Maybe<Player>;
  /** Reads a single `Game` that is related to this `AtBatSkip`. */
  game: Maybe<Game>;
};

/** All input for the create `BaseRunner` mutation. */
export type CreateBaseRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `BaseRunner` to be created by this mutation. */
  baseRunner: BaseRunnerInput;
};

/** The output of our create `BaseRunner` mutation. */
export type CreateBaseRunnerPayload = {
  __typename?: 'CreateBaseRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BaseRunner` that was created by this mutation. */
  baseRunner: Maybe<BaseRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `BaseRunner`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Player` that is related to this `BaseRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BaseRunner`. */
  game: Maybe<Game>;
};

/** All input for the create `BasepathMovement` mutation. */
export type CreateBasepathMovementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `BasepathMovement` to be created by this mutation. */
  basepathMovement: BasepathMovementInput;
};

/** The output of our create `BasepathMovement` mutation. */
export type CreateBasepathMovementPayload = {
  __typename?: 'CreateBasepathMovementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BasepathMovement` that was created by this mutation. */
  basepathMovement: Maybe<BasepathMovement>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `BasepathMovement`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `BasepathMovement`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BasepathMovement`. */
  game: Maybe<Game>;
};

/** All input for the create `EarlyGameEnd` mutation. */
export type CreateEarlyGameEndInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EarlyGameEnd` to be created by this mutation. */
  earlyGameEnd: EarlyGameEndInput;
};

/** The output of our create `EarlyGameEnd` mutation. */
export type CreateEarlyGameEndPayload = {
  __typename?: 'CreateEarlyGameEndPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EarlyGameEnd` that was created by this mutation. */
  earlyGameEnd: Maybe<EarlyGameEnd>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `EarlyGameEnd`. */
  game: Maybe<Game>;
};

/** All input for the create `Field` mutation. */
export type CreateFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Field` to be created by this mutation. */
  field: FieldInput;
};

/** The output of our create `Field` mutation. */
export type CreateFieldPayload = {
  __typename?: 'CreateFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Field` that was created by this mutation. */
  field: Maybe<Field>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `GameAuxMeetupInfo` mutation. */
export type CreateGameAuxMeetupInfoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GameAuxMeetupInfo` to be created by this mutation. */
  gameAuxMeetupInfo: GameAuxMeetupInfoInput;
};

/** The output of our create `GameAuxMeetupInfo` mutation. */
export type CreateGameAuxMeetupInfoPayload = {
  __typename?: 'CreateGameAuxMeetupInfoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameAuxMeetupInfo` that was created by this mutation. */
  gameAuxMeetupInfo: Maybe<GameAuxMeetupInfo>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `GameAuxMeetupInfo`. */
  game: Maybe<Player>;
};

/** All input for the create `GameEvent` mutation. */
export type CreateGameEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GameEvent` to be created by this mutation. */
  gameEvent: GameEventInput;
};

/** The output of our create `GameEvent` mutation. */
export type CreateGameEventPayload = {
  __typename?: 'CreateGameEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEvent` that was created by this mutation. */
  gameEvent: Maybe<GameEvent>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `GameEvent`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `StolenBaseAttempt` that is related to this `GameEvent`. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Reads a single `LineupChange` that is related to this `GameEvent`. */
  lineupChange: Maybe<LineupChange>;
  /** Reads a single `SoloModeOpponentInning` that is related to this `GameEvent`. */
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  /** Reads a single `AtBatSkip` that is related to this `GameEvent`. */
  atBatSkip: Maybe<AtBatSkip>;
  /** Reads a single `Game` that is related to this `GameEvent`. */
  game: Maybe<Game>;
  /** Reads a single `EarlyGameEnd` that is related to this `GameEvent`. */
  earlyGameEnd: Maybe<EarlyGameEnd>;
};

/** All input for the create `GameEventRecord` mutation. */
export type CreateGameEventRecordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GameEventRecord` to be created by this mutation. */
  gameEventRecord: GameEventRecordInput;
};

/** The output of our create `GameEventRecord` mutation. */
export type CreateGameEventRecordPayload = {
  __typename?: 'CreateGameEventRecordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEventRecord` that was created by this mutation. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameEventRecord`. */
  game: Maybe<Game>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateBefore: Maybe<GameState>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateAfter: Maybe<GameState>;
  /** Reads a single `GameEvent` that is related to this `GameEventRecord`. */
  gameEvent: Maybe<GameEvent>;
};

/** All input for the create `Game` mutation. */
export type CreateGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Game` to be created by this mutation. */
  game: GameInput;
};

/** The output of our create `Game` mutation. */
export type CreateGamePayload = {
  __typename?: 'CreateGamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Game` that was created by this mutation. */
  game: Maybe<Game>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Group` that is related to this `Game`. */
  group: Maybe<Group>;
  /** Reads a single `Field` that is related to this `Game`. */
  field: Maybe<Field>;
};

/** All input for the create `GameState` mutation. */
export type CreateGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GameState` to be created by this mutation. */
  gameState: GameStateInput;
};

/** The output of our create `GameState` mutation. */
export type CreateGameStatePayload = {
  __typename?: 'CreateGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameState` that was created by this mutation. */
  gameState: Maybe<GameState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameState`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `GameState`. */
  playerByPlayerAtBat: Maybe<Player>;
};

/** All input for the create `Group` mutation. */
export type CreateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Group` to be created by this mutation. */
  group: GroupInput;
};

/** The output of our create `Group` mutation. */
export type CreateGroupPayload = {
  __typename?: 'CreateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Group` that was created by this mutation. */
  group: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `LineupChange` mutation. */
export type CreateLineupChangeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LineupChange` to be created by this mutation. */
  lineupChange: LineupChangeInput;
};

/** The output of our create `LineupChange` mutation. */
export type CreateLineupChangePayload = {
  __typename?: 'CreateLineupChangePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupChange` that was created by this mutation. */
  lineupChange: Maybe<LineupChange>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupBefore: Maybe<Lineup>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupAfter: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupChange`. */
  game: Maybe<Game>;
};

/** All input for the create `LineupForGameState` mutation. */
export type CreateLineupForGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LineupForGameState` to be created by this mutation. */
  lineupForGameState: LineupForGameStateInput;
};

/** The output of our create `LineupForGameState` mutation. */
export type CreateLineupForGameStatePayload = {
  __typename?: 'CreateLineupForGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupForGameState` that was created by this mutation. */
  lineupForGameState: Maybe<LineupForGameState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `LineupForGameState`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Lineup` that is related to this `LineupForGameState`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupForGameState`. */
  game: Maybe<Game>;
};

/** All input for the create `Lineup` mutation. */
export type CreateLineupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Lineup` to be created by this mutation. */
  lineup: LineupInput;
};

/** The output of our create `Lineup` mutation. */
export type CreateLineupPayload = {
  __typename?: 'CreateLineupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Lineup` that was created by this mutation. */
  lineup: Maybe<Lineup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Team` that is related to this `Lineup`. */
  team: Maybe<Team>;
  /** Reads a single `Game` that is related to this `Lineup`. */
  game: Maybe<Game>;
};

/** All input for the create `LineupSpot` mutation. */
export type CreateLineupSpotInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LineupSpot` to be created by this mutation. */
  lineupSpot: LineupSpotInput;
};

/** The output of our create `LineupSpot` mutation. */
export type CreateLineupSpotPayload = {
  __typename?: 'CreateLineupSpotPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupSpot` that was created by this mutation. */
  lineupSpot: Maybe<LineupSpot>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupSpot`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Player` that is related to this `LineupSpot`. */
  player: Maybe<Player>;
  /** Reads a single `Game` that is related to this `LineupSpot`. */
  game: Maybe<Game>;
};

/** All input for the create `ManualEntryBattingLine` mutation. */
export type CreateManualEntryBattingLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ManualEntryBattingLine` to be created by this mutation. */
  manualEntryBattingLine: ManualEntryBattingLineInput;
};

/** The output of our create `ManualEntryBattingLine` mutation. */
export type CreateManualEntryBattingLinePayload = {
  __typename?: 'CreateManualEntryBattingLinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ManualEntryBattingLine` that was created by this mutation. */
  manualEntryBattingLine: Maybe<ManualEntryBattingLine>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `ManualEntryBattingLine`. */
  game: Maybe<Game>;
  /** Reads a single `Team` that is related to this `ManualEntryBattingLine`. */
  team: Maybe<Team>;
  /** Reads a single `Player` that is related to this `ManualEntryBattingLine`. */
  player: Maybe<Player>;
};

/** All input for the create `ManualEntryLineScoreCell` mutation. */
export type CreateManualEntryLineScoreCellInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ManualEntryLineScoreCell` to be created by this mutation. */
  manualEntryLineScoreCell: ManualEntryLineScoreCellInput;
};

/** The output of our create `ManualEntryLineScoreCell` mutation. */
export type CreateManualEntryLineScoreCellPayload = {
  __typename?: 'CreateManualEntryLineScoreCellPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ManualEntryLineScoreCell` that was created by this mutation. */
  manualEntryLineScoreCell: Maybe<ManualEntryLineScoreCell>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `ManualEntryLineScoreCell`. */
  game: Maybe<Game>;
};

/** All input for the create `ManualEntryPitchingLine` mutation. */
export type CreateManualEntryPitchingLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ManualEntryPitchingLine` to be created by this mutation. */
  manualEntryPitchingLine: ManualEntryPitchingLineInput;
};

/** The output of our create `ManualEntryPitchingLine` mutation. */
export type CreateManualEntryPitchingLinePayload = {
  __typename?: 'CreateManualEntryPitchingLinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ManualEntryPitchingLine` that was created by this mutation. */
  manualEntryPitchingLine: Maybe<ManualEntryPitchingLine>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `ManualEntryPitchingLine`. */
  game: Maybe<Game>;
  /** Reads a single `Team` that is related to this `ManualEntryPitchingLine`. */
  team: Maybe<Team>;
  /** Reads a single `Player` that is related to this `ManualEntryPitchingLine`. */
  player: Maybe<Player>;
};

/** All input for the create `OutOnPlayRunner` mutation. */
export type CreateOutOnPlayRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OutOnPlayRunner` to be created by this mutation. */
  outOnPlayRunner: OutOnPlayRunnerInput;
};

/** The output of our create `OutOnPlayRunner` mutation. */
export type CreateOutOnPlayRunnerPayload = {
  __typename?: 'CreateOutOnPlayRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `OutOnPlayRunner` that was created by this mutation. */
  outOnPlayRunner: Maybe<OutOnPlayRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `OutOnPlayRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `OutOnPlayRunner`. */
  game: Maybe<Game>;
};

/** All input for the create `PlateAppearance` mutation. */
export type CreatePlateAppearanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PlateAppearance` to be created by this mutation. */
  plateAppearance: PlateAppearanceInput;
};

/** The output of our create `PlateAppearance` mutation. */
export type CreatePlateAppearancePayload = {
  __typename?: 'CreatePlateAppearancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlateAppearance` that was created by this mutation. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `PlateAppearance`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `PlateAppearance`. */
  batter: Maybe<Player>;
};

/** All input for the create `PlayerAuxMeetupInfo` mutation. */
export type CreatePlayerAuxMeetupInfoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PlayerAuxMeetupInfo` to be created by this mutation. */
  playerAuxMeetupInfo: PlayerAuxMeetupInfoInput;
};

/** The output of our create `PlayerAuxMeetupInfo` mutation. */
export type CreatePlayerAuxMeetupInfoPayload = {
  __typename?: 'CreatePlayerAuxMeetupInfoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlayerAuxMeetupInfo` that was created by this mutation. */
  playerAuxMeetupInfo: Maybe<PlayerAuxMeetupInfo>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `PlayerAuxMeetupInfo`. */
  player: Maybe<Player>;
};

/** All input for the create `PlayerGroupMembership` mutation. */
export type CreatePlayerGroupMembershipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PlayerGroupMembership` to be created by this mutation. */
  playerGroupMembership: PlayerGroupMembershipInput;
};

/** The output of our create `PlayerGroupMembership` mutation. */
export type CreatePlayerGroupMembershipPayload = {
  __typename?: 'CreatePlayerGroupMembershipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlayerGroupMembership` that was created by this mutation. */
  playerGroupMembership: Maybe<PlayerGroupMembership>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `PlayerGroupMembership`. */
  player: Maybe<Player>;
  /** Reads a single `Group` that is related to this `PlayerGroupMembership`. */
  group: Maybe<Group>;
};

/** All input for the create `Player` mutation. */
export type CreatePlayerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Player` to be created by this mutation. */
  player: PlayerInput;
};

/** The output of our create `Player` mutation. */
export type CreatePlayerPayload = {
  __typename?: 'CreatePlayerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Player` that was created by this mutation. */
  player: Maybe<Player>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `ReduxDump` mutation. */
export type CreateReduxDumpInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReduxDump` to be created by this mutation. */
  reduxDump: ReduxDumpInput;
};

/** The output of our create `ReduxDump` mutation. */
export type CreateReduxDumpPayload = {
  __typename?: 'CreateReduxDumpPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ReduxDump` that was created by this mutation. */
  reduxDump: Maybe<ReduxDump>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `ScoredRunner` mutation. */
export type CreateScoredRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ScoredRunner` to be created by this mutation. */
  scoredRunner: ScoredRunnerInput;
};

/** The output of our create `ScoredRunner` mutation. */
export type CreateScoredRunnerPayload = {
  __typename?: 'CreateScoredRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ScoredRunner` that was created by this mutation. */
  scoredRunner: Maybe<ScoredRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameEventRecord` that is related to this `ScoredRunner`. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Reads a single `Player` that is related to this `ScoredRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `ScoredRunner`. */
  game: Maybe<Game>;
};

/** All input for the create `SoloModeOpponentInning` mutation. */
export type CreateSoloModeOpponentInningInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SoloModeOpponentInning` to be created by this mutation. */
  soloModeOpponentInning: SoloModeOpponentInningInput;
};

/** The output of our create `SoloModeOpponentInning` mutation. */
export type CreateSoloModeOpponentInningPayload = {
  __typename?: 'CreateSoloModeOpponentInningPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `SoloModeOpponentInning` that was created by this mutation. */
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `SoloModeOpponentInning`. */
  game: Maybe<Game>;
};

/** All input for the create `StolenBaseAttempt` mutation. */
export type CreateStolenBaseAttemptInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StolenBaseAttempt` to be created by this mutation. */
  stolenBaseAttempt: StolenBaseAttemptInput;
};

/** The output of our create `StolenBaseAttempt` mutation. */
export type CreateStolenBaseAttemptPayload = {
  __typename?: 'CreateStolenBaseAttemptPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `StolenBaseAttempt` that was created by this mutation. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `StolenBaseAttempt`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `StolenBaseAttempt`. */
  game: Maybe<Game>;
};

/** All input for the create `Team` mutation. */
export type CreateTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Team` to be created by this mutation. */
  team: TeamInput;
};

/** The output of our create `Team` mutation. */
export type CreateTeamPayload = {
  __typename?: 'CreateTeamPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Team` that was created by this mutation. */
  team: Maybe<Team>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `Team`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `Team`. */
  captain: Maybe<Player>;
};


/** A filter to be used against Date fields. All fields are combined with a logical ‘and.’ */
export type DateFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Date']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Date']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Date']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Date']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Date']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Date']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Date']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Date']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Date']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Date']>;
};


/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Datetime']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Datetime']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Datetime']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Datetime']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Datetime']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Datetime']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Datetime']>;
};

/** All input for the `deleteAtBatSkipByNodeId` mutation. */
export type DeleteAtBatSkipByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AtBatSkip` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAtBatSkip` mutation. */
export type DeleteAtBatSkipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `AtBatSkip` mutation. */
export type DeleteAtBatSkipPayload = {
  __typename?: 'DeleteAtBatSkipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `AtBatSkip` that was deleted by this mutation. */
  atBatSkip: Maybe<AtBatSkip>;
  deletedAtBatSkipNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `AtBatSkip`. */
  batter: Maybe<Player>;
  /** Reads a single `Game` that is related to this `AtBatSkip`. */
  game: Maybe<Game>;
};

/** All input for the `deleteBaseRunnerByNodeId` mutation. */
export type DeleteBaseRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `BaseRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteBaseRunner` mutation. */
export type DeleteBaseRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our delete `BaseRunner` mutation. */
export type DeleteBaseRunnerPayload = {
  __typename?: 'DeleteBaseRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BaseRunner` that was deleted by this mutation. */
  baseRunner: Maybe<BaseRunner>;
  deletedBaseRunnerNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `BaseRunner`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Player` that is related to this `BaseRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BaseRunner`. */
  game: Maybe<Game>;
};

/** All input for the `deleteBasepathMovementByNodeId` mutation. */
export type DeleteBasepathMovementByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `BasepathMovement` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteBasepathMovement` mutation. */
export type DeleteBasepathMovementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our delete `BasepathMovement` mutation. */
export type DeleteBasepathMovementPayload = {
  __typename?: 'DeleteBasepathMovementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BasepathMovement` that was deleted by this mutation. */
  basepathMovement: Maybe<BasepathMovement>;
  deletedBasepathMovementNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `BasepathMovement`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `BasepathMovement`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BasepathMovement`. */
  game: Maybe<Game>;
};

/** All input for the `deleteEarlyGameEndByNodeId` mutation. */
export type DeleteEarlyGameEndByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `EarlyGameEnd` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteEarlyGameEnd` mutation. */
export type DeleteEarlyGameEndInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `EarlyGameEnd` mutation. */
export type DeleteEarlyGameEndPayload = {
  __typename?: 'DeleteEarlyGameEndPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EarlyGameEnd` that was deleted by this mutation. */
  earlyGameEnd: Maybe<EarlyGameEnd>;
  deletedEarlyGameEndNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `EarlyGameEnd`. */
  game: Maybe<Game>;
};

/** All input for the `deleteFieldByNodeId` mutation. */
export type DeleteFieldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Field` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteField` mutation. */
export type DeleteFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Field` mutation. */
export type DeleteFieldPayload = {
  __typename?: 'DeleteFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Field` that was deleted by this mutation. */
  field: Maybe<Field>;
  deletedFieldNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteGameAuxMeetupInfoByNodeId` mutation. */
export type DeleteGameAuxMeetupInfoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameAuxMeetupInfo` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGameAuxMeetupInfo` mutation. */
export type DeleteGameAuxMeetupInfoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameId: Scalars['UUID'];
};

/** The output of our delete `GameAuxMeetupInfo` mutation. */
export type DeleteGameAuxMeetupInfoPayload = {
  __typename?: 'DeleteGameAuxMeetupInfoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameAuxMeetupInfo` that was deleted by this mutation. */
  gameAuxMeetupInfo: Maybe<GameAuxMeetupInfo>;
  deletedGameAuxMeetupInfoNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `GameAuxMeetupInfo`. */
  game: Maybe<Player>;
};

/** All input for the `deleteGameByGroupIdAndName` mutation. */
export type DeleteGameByGroupIdAndNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** All input for the `deleteGameByNodeId` mutation. */
export type DeleteGameByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Game` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGameEventByNodeId` mutation. */
export type DeleteGameEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameEvent` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGameEvent` mutation. */
export type DeleteGameEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `GameEvent` mutation. */
export type DeleteGameEventPayload = {
  __typename?: 'DeleteGameEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEvent` that was deleted by this mutation. */
  gameEvent: Maybe<GameEvent>;
  deletedGameEventNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `GameEvent`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `StolenBaseAttempt` that is related to this `GameEvent`. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Reads a single `LineupChange` that is related to this `GameEvent`. */
  lineupChange: Maybe<LineupChange>;
  /** Reads a single `SoloModeOpponentInning` that is related to this `GameEvent`. */
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  /** Reads a single `AtBatSkip` that is related to this `GameEvent`. */
  atBatSkip: Maybe<AtBatSkip>;
  /** Reads a single `Game` that is related to this `GameEvent`. */
  game: Maybe<Game>;
  /** Reads a single `EarlyGameEnd` that is related to this `GameEvent`. */
  earlyGameEnd: Maybe<EarlyGameEnd>;
};

/** All input for the `deleteGameEventRecordByGameIdAndEventIndex` mutation. */
export type DeleteGameEventRecordByGameIdAndEventIndexInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** All input for the `deleteGameEventRecordByNodeId` mutation. */
export type DeleteGameEventRecordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameEventRecord` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGameEventRecord` mutation. */
export type DeleteGameEventRecordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `GameEventRecord` mutation. */
export type DeleteGameEventRecordPayload = {
  __typename?: 'DeleteGameEventRecordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEventRecord` that was deleted by this mutation. */
  gameEventRecord: Maybe<GameEventRecord>;
  deletedGameEventRecordNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameEventRecord`. */
  game: Maybe<Game>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateBefore: Maybe<GameState>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateAfter: Maybe<GameState>;
  /** Reads a single `GameEvent` that is related to this `GameEventRecord`. */
  gameEvent: Maybe<GameEvent>;
};

/** All input for the `deleteGame` mutation. */
export type DeleteGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Game` mutation. */
export type DeleteGamePayload = {
  __typename?: 'DeleteGamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Game` that was deleted by this mutation. */
  game: Maybe<Game>;
  deletedGameNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Group` that is related to this `Game`. */
  group: Maybe<Group>;
  /** Reads a single `Field` that is related to this `Game`. */
  field: Maybe<Field>;
};

/** All input for the `deleteGameStateByNodeId` mutation. */
export type DeleteGameStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameState` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGameState` mutation. */
export type DeleteGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `GameState` mutation. */
export type DeleteGameStatePayload = {
  __typename?: 'DeleteGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameState` that was deleted by this mutation. */
  gameState: Maybe<GameState>;
  deletedGameStateNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameState`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `GameState`. */
  playerByPlayerAtBat: Maybe<Player>;
};

/** All input for the `deleteGroupByName` mutation. */
export type DeleteGroupByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** All input for the `deleteGroupByNodeId` mutation. */
export type DeleteGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Group` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGroupByUrlSlug` mutation. */
export type DeleteGroupByUrlSlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  urlSlug: Scalars['String'];
};

/** All input for the `deleteGroup` mutation. */
export type DeleteGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Group` mutation. */
export type DeleteGroupPayload = {
  __typename?: 'DeleteGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Group` that was deleted by this mutation. */
  group: Maybe<Group>;
  deletedGroupNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteLineupByNodeId` mutation. */
export type DeleteLineupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Lineup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLineupChangeByNodeId` mutation. */
export type DeleteLineupChangeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupChange` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLineupChange` mutation. */
export type DeleteLineupChangeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `LineupChange` mutation. */
export type DeleteLineupChangePayload = {
  __typename?: 'DeleteLineupChangePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupChange` that was deleted by this mutation. */
  lineupChange: Maybe<LineupChange>;
  deletedLineupChangeNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupBefore: Maybe<Lineup>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupAfter: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupChange`. */
  game: Maybe<Game>;
};

/** All input for the `deleteLineupForGameStateByNodeId` mutation. */
export type DeleteLineupForGameStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupForGameState` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLineupForGameState` mutation. */
export type DeleteLineupForGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** The output of our delete `LineupForGameState` mutation. */
export type DeleteLineupForGameStatePayload = {
  __typename?: 'DeleteLineupForGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupForGameState` that was deleted by this mutation. */
  lineupForGameState: Maybe<LineupForGameState>;
  deletedLineupForGameStateNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `LineupForGameState`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Lineup` that is related to this `LineupForGameState`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupForGameState`. */
  game: Maybe<Game>;
};

/** All input for the `deleteLineup` mutation. */
export type DeleteLineupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Lineup` mutation. */
export type DeleteLineupPayload = {
  __typename?: 'DeleteLineupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Lineup` that was deleted by this mutation. */
  lineup: Maybe<Lineup>;
  deletedLineupNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Team` that is related to this `Lineup`. */
  team: Maybe<Team>;
  /** Reads a single `Game` that is related to this `Lineup`. */
  game: Maybe<Game>;
};

/** All input for the `deleteLineupSpotByLineupIdAndBattingOrder` mutation. */
export type DeleteLineupSpotByLineupIdAndBattingOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** All input for the `deleteLineupSpotByLineupIdAndPosition` mutation. */
export type DeleteLineupSpotByLineupIdAndPositionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** All input for the `deleteLineupSpotByNodeId` mutation. */
export type DeleteLineupSpotByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupSpot` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLineupSpot` mutation. */
export type DeleteLineupSpotInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The output of our delete `LineupSpot` mutation. */
export type DeleteLineupSpotPayload = {
  __typename?: 'DeleteLineupSpotPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupSpot` that was deleted by this mutation. */
  lineupSpot: Maybe<LineupSpot>;
  deletedLineupSpotNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupSpot`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Player` that is related to this `LineupSpot`. */
  player: Maybe<Player>;
  /** Reads a single `Game` that is related to this `LineupSpot`. */
  game: Maybe<Game>;
};

/** All input for the `deleteManualEntryBattingLineByNodeId` mutation. */
export type DeleteManualEntryBattingLineByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ManualEntryBattingLine` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteManualEntryBattingLine` mutation. */
export type DeleteManualEntryBattingLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The output of our delete `ManualEntryBattingLine` mutation. */
export type DeleteManualEntryBattingLinePayload = {
  __typename?: 'DeleteManualEntryBattingLinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ManualEntryBattingLine` that was deleted by this mutation. */
  manualEntryBattingLine: Maybe<ManualEntryBattingLine>;
  deletedManualEntryBattingLineNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `ManualEntryBattingLine`. */
  game: Maybe<Game>;
  /** Reads a single `Team` that is related to this `ManualEntryBattingLine`. */
  team: Maybe<Team>;
  /** Reads a single `Player` that is related to this `ManualEntryBattingLine`. */
  player: Maybe<Player>;
};

/** All input for the `deleteManualEntryLineScoreCellByNodeId` mutation. */
export type DeleteManualEntryLineScoreCellByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ManualEntryLineScoreCell` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteManualEntryLineScoreCell` mutation. */
export type DeleteManualEntryLineScoreCellInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameId: Scalars['UUID'];
  inning: Scalars['Int'];
  halfInning: HalfInning;
};

/** The output of our delete `ManualEntryLineScoreCell` mutation. */
export type DeleteManualEntryLineScoreCellPayload = {
  __typename?: 'DeleteManualEntryLineScoreCellPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ManualEntryLineScoreCell` that was deleted by this mutation. */
  manualEntryLineScoreCell: Maybe<ManualEntryLineScoreCell>;
  deletedManualEntryLineScoreCellNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `ManualEntryLineScoreCell`. */
  game: Maybe<Game>;
};

/** All input for the `deleteManualEntryPitchingLineByNodeId` mutation. */
export type DeleteManualEntryPitchingLineByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ManualEntryPitchingLine` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteManualEntryPitchingLine` mutation. */
export type DeleteManualEntryPitchingLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The output of our delete `ManualEntryPitchingLine` mutation. */
export type DeleteManualEntryPitchingLinePayload = {
  __typename?: 'DeleteManualEntryPitchingLinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ManualEntryPitchingLine` that was deleted by this mutation. */
  manualEntryPitchingLine: Maybe<ManualEntryPitchingLine>;
  deletedManualEntryPitchingLineNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `ManualEntryPitchingLine`. */
  game: Maybe<Game>;
  /** Reads a single `Team` that is related to this `ManualEntryPitchingLine`. */
  team: Maybe<Team>;
  /** Reads a single `Player` that is related to this `ManualEntryPitchingLine`. */
  player: Maybe<Player>;
};

/** All input for the `deleteOutOnPlayRunnerByNodeId` mutation. */
export type DeleteOutOnPlayRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OutOnPlayRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOutOnPlayRunner` mutation. */
export type DeleteOutOnPlayRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our delete `OutOnPlayRunner` mutation. */
export type DeleteOutOnPlayRunnerPayload = {
  __typename?: 'DeleteOutOnPlayRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `OutOnPlayRunner` that was deleted by this mutation. */
  outOnPlayRunner: Maybe<OutOnPlayRunner>;
  deletedOutOnPlayRunnerNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `OutOnPlayRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `OutOnPlayRunner`. */
  game: Maybe<Game>;
};

/** All input for the `deletePlateAppearanceByNodeId` mutation. */
export type DeletePlateAppearanceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlateAppearance` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlateAppearance` mutation. */
export type DeletePlateAppearanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `PlateAppearance` mutation. */
export type DeletePlateAppearancePayload = {
  __typename?: 'DeletePlateAppearancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlateAppearance` that was deleted by this mutation. */
  plateAppearance: Maybe<PlateAppearance>;
  deletedPlateAppearanceNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `PlateAppearance`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `PlateAppearance`. */
  batter: Maybe<Player>;
};

/** All input for the `deletePlayerAuxMeetupInfoByNodeId` mutation. */
export type DeletePlayerAuxMeetupInfoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlayerAuxMeetupInfo` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlayerAuxMeetupInfo` mutation. */
export type DeletePlayerAuxMeetupInfoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  playerId: Scalars['UUID'];
};

/** The output of our delete `PlayerAuxMeetupInfo` mutation. */
export type DeletePlayerAuxMeetupInfoPayload = {
  __typename?: 'DeletePlayerAuxMeetupInfoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlayerAuxMeetupInfo` that was deleted by this mutation. */
  playerAuxMeetupInfo: Maybe<PlayerAuxMeetupInfo>;
  deletedPlayerAuxMeetupInfoNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `PlayerAuxMeetupInfo`. */
  player: Maybe<Player>;
};

/** All input for the `deletePlayerByFirstNameAndLastName` mutation. */
export type DeletePlayerByFirstNameAndLastNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** All input for the `deletePlayerByNodeId` mutation. */
export type DeletePlayerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Player` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlayerGroupMembershipByNodeId` mutation. */
export type DeletePlayerGroupMembershipByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlayerGroupMembership` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlayerGroupMembership` mutation. */
export type DeletePlayerGroupMembershipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
};

/** The output of our delete `PlayerGroupMembership` mutation. */
export type DeletePlayerGroupMembershipPayload = {
  __typename?: 'DeletePlayerGroupMembershipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlayerGroupMembership` that was deleted by this mutation. */
  playerGroupMembership: Maybe<PlayerGroupMembership>;
  deletedPlayerGroupMembershipNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `PlayerGroupMembership`. */
  player: Maybe<Player>;
  /** Reads a single `Group` that is related to this `PlayerGroupMembership`. */
  group: Maybe<Group>;
};

/** All input for the `deletePlayer` mutation. */
export type DeletePlayerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Player` mutation. */
export type DeletePlayerPayload = {
  __typename?: 'DeletePlayerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Player` that was deleted by this mutation. */
  player: Maybe<Player>;
  deletedPlayerNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteReduxDumpByNodeId` mutation. */
export type DeleteReduxDumpByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ReduxDump` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteReduxDump` mutation. */
export type DeleteReduxDumpInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `ReduxDump` mutation. */
export type DeleteReduxDumpPayload = {
  __typename?: 'DeleteReduxDumpPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ReduxDump` that was deleted by this mutation. */
  reduxDump: Maybe<ReduxDump>;
  deletedReduxDumpNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteScoredRunnerByNodeId` mutation. */
export type DeleteScoredRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ScoredRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteScoredRunner` mutation. */
export type DeleteScoredRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our delete `ScoredRunner` mutation. */
export type DeleteScoredRunnerPayload = {
  __typename?: 'DeleteScoredRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ScoredRunner` that was deleted by this mutation. */
  scoredRunner: Maybe<ScoredRunner>;
  deletedScoredRunnerNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameEventRecord` that is related to this `ScoredRunner`. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Reads a single `Player` that is related to this `ScoredRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `ScoredRunner`. */
  game: Maybe<Game>;
};

/** All input for the `deleteSoloModeOpponentInningByNodeId` mutation. */
export type DeleteSoloModeOpponentInningByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SoloModeOpponentInning` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSoloModeOpponentInning` mutation. */
export type DeleteSoloModeOpponentInningInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `SoloModeOpponentInning` mutation. */
export type DeleteSoloModeOpponentInningPayload = {
  __typename?: 'DeleteSoloModeOpponentInningPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `SoloModeOpponentInning` that was deleted by this mutation. */
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  deletedSoloModeOpponentInningNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `SoloModeOpponentInning`. */
  game: Maybe<Game>;
};

/** All input for the `deleteStolenBaseAttemptByNodeId` mutation. */
export type DeleteStolenBaseAttemptByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StolenBaseAttempt` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStolenBaseAttempt` mutation. */
export type DeleteStolenBaseAttemptInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `StolenBaseAttempt` mutation. */
export type DeleteStolenBaseAttemptPayload = {
  __typename?: 'DeleteStolenBaseAttemptPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `StolenBaseAttempt` that was deleted by this mutation. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  deletedStolenBaseAttemptNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `StolenBaseAttempt`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `StolenBaseAttempt`. */
  game: Maybe<Game>;
};

/** All input for the `deleteTeamByGameIdAndRole` mutation. */
export type DeleteTeamByGameIdAndRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** All input for the `deleteTeamByNodeId` mutation. */
export type DeleteTeamByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Team` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTeam` mutation. */
export type DeleteTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Team` mutation. */
export type DeleteTeamPayload = {
  __typename?: 'DeleteTeamPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Team` that was deleted by this mutation. */
  team: Maybe<Team>;
  deletedTeamNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `Team`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `Team`. */
  captain: Maybe<Player>;
};

export type EarlyGameEnd = Node & {
  __typename?: 'EarlyGameEnd';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  reason: EarlyGameEndReason;
  gameId: Scalars['UUID'];
  /** Reads a single `Game` that is related to this `EarlyGameEnd`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `EarlyGameEnd` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EarlyGameEndCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `reason` field. */
  reason?: Maybe<EarlyGameEndReason>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** The fields on `earlyGameEnd` to look up the row to connect. */
export type EarlyGameEndEarlyGameEndPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `earlyGameEnd` to look up the row to delete. */
export type EarlyGameEndEarlyGameEndPkeyDelete = {
  id: Scalars['UUID'];
};

/** A filter to be used against `EarlyGameEnd` object types. All fields are combined with a logical ‘and.’ */
export type EarlyGameEndFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `reason` field. */
  reason?: Maybe<EarlyGameEndReasonFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<EarlyGameEndFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<EarlyGameEndFilter>>;
  /** Negates the expression. */
  not?: Maybe<EarlyGameEndFilter>;
};

/** The `earlyGameEnd` to be created by this mutation. */
export type EarlyGameEndGameIdFkeyEarlyGameEndCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  reason: EarlyGameEndReason;
  game?: Maybe<EarlyGameEndGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventEarlyGameEndIdFkeyInverseInput>;
};

/** The `game` to be created by this mutation. */
export type EarlyGameEndGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `EarlyGameEndInput` mutation. */
export type EarlyGameEndGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnEarlyGameEndForEarlyGameEndGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnEarlyGameEndForEarlyGameEndGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<EarlyGameEndOnEarlyGameEndForEarlyGameEndGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<EarlyGameEndGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `earlyGameEnd` in the `GameInput` mutation. */
export type EarlyGameEndGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `earlyGameEnd` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  connectById?: Maybe<Array<EarlyGameEndEarlyGameEndPkeyConnect>>;
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<EarlyGameEndNodeIdConnect>>;
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  deleteById?: Maybe<Array<EarlyGameEndEarlyGameEndPkeyDelete>>;
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<EarlyGameEndNodeIdDelete>>;
  /** The primary key(s) and patch data for `earlyGameEnd` for the far side of the relationship. */
  updateById?: Maybe<Array<EarlyGameEndOnEarlyGameEndForEarlyGameEndGameIdFkeyUsingEarlyGameEndPkeyUpdate>>;
  /** The primary key(s) and patch data for `earlyGameEnd` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnEarlyGameEndForEarlyGameEndGameIdFkeyNodeIdUpdate>>;
  /** A `EarlyGameEndInput` object that will be created and connected to this object. */
  create?: Maybe<Array<EarlyGameEndGameIdFkeyEarlyGameEndCreateInput>>;
};

/** An input for mutations affecting `EarlyGameEnd` */
export type EarlyGameEndInput = {
  id?: Maybe<Scalars['UUID']>;
  reason: EarlyGameEndReason;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<EarlyGameEndGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventEarlyGameEndIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type EarlyGameEndNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `earlyGameEnd` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type EarlyGameEndNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `earlyGameEnd` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type EarlyGameEndOnEarlyGameEndForEarlyGameEndGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `earlyGameEnd` to look up the row to update. */
export type EarlyGameEndOnEarlyGameEndForEarlyGameEndGameIdFkeyUsingEarlyGameEndPkeyUpdate = {
  /** An object where the defined keys will be set on the `earlyGameEnd` being updated. */
  patch: UpdateEarlyGameEndOnEarlyGameEndForEarlyGameEndGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type EarlyGameEndOnGameEventForGameEventEarlyGameEndIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `earlyGameEnd` to look up the row to update. */
export type EarlyGameEndOnGameEventForGameEventEarlyGameEndIdFkeyUsingEarlyGameEndPkeyUpdate = {
  /** An object where the defined keys will be set on the `earlyGameEnd` being updated. */
  patch: UpdateEarlyGameEndOnGameEventForGameEventEarlyGameEndIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `EarlyGameEnd`. Fields that are set will be updated. */
export type EarlyGameEndPatch = {
  id?: Maybe<Scalars['UUID']>;
  reason?: Maybe<EarlyGameEndReason>;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<EarlyGameEndGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventEarlyGameEndIdFkeyInverseInput>;
};

export enum EarlyGameEndReason {
  MERCY_RULE = 'MERCY_RULE',
  TIME_EXPIRED = 'TIME_EXPIRED',
  OTHER = 'OTHER'
}

/** A filter to be used against EarlyGameEndReason fields. All fields are combined with a logical ‘and.’ */
export type EarlyGameEndReasonFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<EarlyGameEndReason>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<EarlyGameEndReason>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<EarlyGameEndReason>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<EarlyGameEndReason>;
  /** Included in the specified list. */
  in?: Maybe<Array<EarlyGameEndReason>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<EarlyGameEndReason>>;
  /** Less than the specified value. */
  lessThan?: Maybe<EarlyGameEndReason>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<EarlyGameEndReason>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<EarlyGameEndReason>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<EarlyGameEndReason>;
};

/** Methods to use when ordering `EarlyGameEnd`. */
export enum EarlyGameEndsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  REASON_ASC = 'REASON_ASC',
  REASON_DESC = 'REASON_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** The `careerBattingStat` to be created by this mutation. */
export type FakePublicCareerBattingStatsForeignKey0CareerBattingStatsCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances: Scalars['Int'];
  atBats: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  gidp: Scalars['Int'];
  runs: Scalars['Int'];
  rbi: Scalars['Int'];
  stolenBases: Scalars['Int'];
  avg: Scalars['Float'];
  obp: Scalars['Float'];
  slg: Scalars['Float'];
  ops: Scalars['Float'];
  group?: Maybe<FakePublicCareerBattingStatsForeignKey0Input>;
  player?: Maybe<FakePublicCareerBattingStatsForeignKey1Input>;
};

/** The `group` to be created by this mutation. */
export type FakePublicCareerBattingStatsForeignKey0GroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey0InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `group` in the `CareerBattingStatInput` mutation. */
export type FakePublicCareerBattingStatsForeignKey0Input = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByUrlSlug?: Maybe<GroupGroupUrlSlugKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByUrlSlug?: Maybe<GroupGroupUrlSlugKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0UsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0UsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByUrlSlug?: Maybe<GroupOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0UsingGroupUrlSlugKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<CareerBattingStatOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0NodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicCareerBattingStatsForeignKey0GroupCreateInput>;
};

/** Input for the nested mutation of `careerBattingStat` in the `GroupInput` mutation. */
export type FakePublicCareerBattingStatsForeignKey0InverseInput = {
  /** Flag indicating whether all other `careerBattingStat` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `careerBattingStat` for the far side of the relationship. */
  connectByGroupIdAndPlayerId?: Maybe<Array<CareerBattingStatFakePublicCareerBattingStatsPrimaryKeyConnect>>;
  /** The primary key(s) for `careerBattingStat` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CareerBattingStatNodeIdConnect>>;
  /** The primary key(s) for `careerBattingStat` for the far side of the relationship. */
  deleteByGroupIdAndPlayerId?: Maybe<Array<CareerBattingStatFakePublicCareerBattingStatsPrimaryKeyDelete>>;
  /** The primary key(s) for `careerBattingStat` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CareerBattingStatNodeIdDelete>>;
  /** The primary key(s) and patch data for `careerBattingStat` for the far side of the relationship. */
  updateByGroupIdAndPlayerId?: Maybe<Array<CareerBattingStatOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0UsingFakePublicCareerBattingStatsPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `careerBattingStat` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GroupOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0NodeIdUpdate>>;
  /** A `CareerBattingStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicCareerBattingStatsForeignKey0CareerBattingStatsCreateInput>>;
};

/** The `careerBattingStat` to be created by this mutation. */
export type FakePublicCareerBattingStatsForeignKey1CareerBattingStatsCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances: Scalars['Int'];
  atBats: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  gidp: Scalars['Int'];
  runs: Scalars['Int'];
  rbi: Scalars['Int'];
  stolenBases: Scalars['Int'];
  avg: Scalars['Float'];
  obp: Scalars['Float'];
  slg: Scalars['Float'];
  ops: Scalars['Float'];
  group?: Maybe<FakePublicCareerBattingStatsForeignKey0Input>;
  player?: Maybe<FakePublicCareerBattingStatsForeignKey1Input>;
};

/** Input for the nested mutation of `player` in the `CareerBattingStatInput` mutation. */
export type FakePublicCareerBattingStatsForeignKey1Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey1UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey1UsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<CareerBattingStatOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey1NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicCareerBattingStatsForeignKey1PlayerCreateInput>;
};

/** Input for the nested mutation of `careerBattingStat` in the `PlayerInput` mutation. */
export type FakePublicCareerBattingStatsForeignKey1InverseInput = {
  /** Flag indicating whether all other `careerBattingStat` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `careerBattingStat` for the far side of the relationship. */
  connectByGroupIdAndPlayerId?: Maybe<Array<CareerBattingStatFakePublicCareerBattingStatsPrimaryKeyConnect>>;
  /** The primary key(s) for `careerBattingStat` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<CareerBattingStatNodeIdConnect>>;
  /** The primary key(s) for `careerBattingStat` for the far side of the relationship. */
  deleteByGroupIdAndPlayerId?: Maybe<Array<CareerBattingStatFakePublicCareerBattingStatsPrimaryKeyDelete>>;
  /** The primary key(s) for `careerBattingStat` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<CareerBattingStatNodeIdDelete>>;
  /** The primary key(s) and patch data for `careerBattingStat` for the far side of the relationship. */
  updateByGroupIdAndPlayerId?: Maybe<Array<CareerBattingStatOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey1UsingFakePublicCareerBattingStatsPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `careerBattingStat` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey1NodeIdUpdate>>;
  /** A `CareerBattingStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicCareerBattingStatsForeignKey1CareerBattingStatsCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type FakePublicCareerBattingStatsForeignKey1PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** The `gameBattingStat` to be created by this mutation. */
export type FakePublicGameBattingStatsForeignKey0GameBattingStatsCreateInput = {
  teamId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  plateAppearances: Scalars['Int'];
  atBats: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  gidp: Scalars['Int'];
  runs: Scalars['Int'];
  rbi: Scalars['Int'];
  stolenBases: Scalars['Int'];
  game?: Maybe<FakePublicGameBattingStatsForeignKey0Input>;
  team?: Maybe<FakePublicGameBattingStatsForeignKey1Input>;
  player?: Maybe<FakePublicGameBattingStatsForeignKey2Input>;
};

/** The `game` to be created by this mutation. */
export type FakePublicGameBattingStatsForeignKey0GameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `GameBattingStatInput` mutation. */
export type FakePublicGameBattingStatsForeignKey0Input = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnGameBattingStatForFakePublicGameBattingStatsForeignKey0UsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnGameBattingStatForFakePublicGameBattingStatsForeignKey0UsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey0NodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicGameBattingStatsForeignKey0GameCreateInput>;
};

/** Input for the nested mutation of `gameBattingStat` in the `GameInput` mutation. */
export type FakePublicGameBattingStatsForeignKey0InverseInput = {
  /** Flag indicating whether all other `gameBattingStat` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameBattingStat` for the far side of the relationship. */
  connectByGameIdAndTeamIdAndPlayerId?: Maybe<Array<GameBattingStatFakePublicGameBattingStatsPrimaryKeyConnect>>;
  /** The primary key(s) for `gameBattingStat` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameBattingStatNodeIdConnect>>;
  /** The primary key(s) for `gameBattingStat` for the far side of the relationship. */
  deleteByGameIdAndTeamIdAndPlayerId?: Maybe<Array<GameBattingStatFakePublicGameBattingStatsPrimaryKeyDelete>>;
  /** The primary key(s) for `gameBattingStat` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameBattingStatNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameBattingStat` for the far side of the relationship. */
  updateByGameIdAndTeamIdAndPlayerId?: Maybe<Array<GameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey0UsingFakePublicGameBattingStatsPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `gameBattingStat` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnGameBattingStatForFakePublicGameBattingStatsForeignKey0NodeIdUpdate>>;
  /** A `GameBattingStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicGameBattingStatsForeignKey0GameBattingStatsCreateInput>>;
};

/** The `gameBattingStat` to be created by this mutation. */
export type FakePublicGameBattingStatsForeignKey1GameBattingStatsCreateInput = {
  gameId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  plateAppearances: Scalars['Int'];
  atBats: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  gidp: Scalars['Int'];
  runs: Scalars['Int'];
  rbi: Scalars['Int'];
  stolenBases: Scalars['Int'];
  game?: Maybe<FakePublicGameBattingStatsForeignKey0Input>;
  team?: Maybe<FakePublicGameBattingStatsForeignKey1Input>;
  player?: Maybe<FakePublicGameBattingStatsForeignKey2Input>;
};

/** Input for the nested mutation of `team` in the `GameBattingStatInput` mutation. */
export type FakePublicGameBattingStatsForeignKey1Input = {
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectById?: Maybe<TeamTeamPkeyConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByGameIdAndRole?: Maybe<TeamTeamGameIdRoleKeyConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByNodeId?: Maybe<TeamNodeIdConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteById?: Maybe<TeamTeamPkeyDelete>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByGameIdAndRole?: Maybe<TeamTeamGameIdRoleKeyDelete>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TeamNodeIdDelete>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateById?: Maybe<TeamOnGameBattingStatForFakePublicGameBattingStatsForeignKey1UsingTeamPkeyUpdate>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByGameIdAndRole?: Maybe<TeamOnGameBattingStatForFakePublicGameBattingStatsForeignKey1UsingTeamGameIdRoleKeyUpdate>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey1NodeIdUpdate>;
  /** A `TeamInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicGameBattingStatsForeignKey1TeamCreateInput>;
};

/** Input for the nested mutation of `gameBattingStat` in the `TeamInput` mutation. */
export type FakePublicGameBattingStatsForeignKey1InverseInput = {
  /** Flag indicating whether all other `gameBattingStat` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameBattingStat` for the far side of the relationship. */
  connectByGameIdAndTeamIdAndPlayerId?: Maybe<Array<GameBattingStatFakePublicGameBattingStatsPrimaryKeyConnect>>;
  /** The primary key(s) for `gameBattingStat` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameBattingStatNodeIdConnect>>;
  /** The primary key(s) for `gameBattingStat` for the far side of the relationship. */
  deleteByGameIdAndTeamIdAndPlayerId?: Maybe<Array<GameBattingStatFakePublicGameBattingStatsPrimaryKeyDelete>>;
  /** The primary key(s) for `gameBattingStat` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameBattingStatNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameBattingStat` for the far side of the relationship. */
  updateByGameIdAndTeamIdAndPlayerId?: Maybe<Array<GameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey1UsingFakePublicGameBattingStatsPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `gameBattingStat` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TeamOnGameBattingStatForFakePublicGameBattingStatsForeignKey1NodeIdUpdate>>;
  /** A `GameBattingStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicGameBattingStatsForeignKey1GameBattingStatsCreateInput>>;
};

/** The `team` to be created by this mutation. */
export type FakePublicGameBattingStatsForeignKey1TeamCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role: TeamRole;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineTeamIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineTeamIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey1InverseInput>;
};

/** The `gameBattingStat` to be created by this mutation. */
export type FakePublicGameBattingStatsForeignKey2GameBattingStatsCreateInput = {
  gameId?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  plateAppearances: Scalars['Int'];
  atBats: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  gidp: Scalars['Int'];
  runs: Scalars['Int'];
  rbi: Scalars['Int'];
  stolenBases: Scalars['Int'];
  game?: Maybe<FakePublicGameBattingStatsForeignKey0Input>;
  team?: Maybe<FakePublicGameBattingStatsForeignKey1Input>;
  player?: Maybe<FakePublicGameBattingStatsForeignKey2Input>;
};

/** Input for the nested mutation of `player` in the `GameBattingStatInput` mutation. */
export type FakePublicGameBattingStatsForeignKey2Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnGameBattingStatForFakePublicGameBattingStatsForeignKey2UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnGameBattingStatForFakePublicGameBattingStatsForeignKey2UsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey2NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicGameBattingStatsForeignKey2PlayerCreateInput>;
};

/** Input for the nested mutation of `gameBattingStat` in the `PlayerInput` mutation. */
export type FakePublicGameBattingStatsForeignKey2InverseInput = {
  /** Flag indicating whether all other `gameBattingStat` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameBattingStat` for the far side of the relationship. */
  connectByGameIdAndTeamIdAndPlayerId?: Maybe<Array<GameBattingStatFakePublicGameBattingStatsPrimaryKeyConnect>>;
  /** The primary key(s) for `gameBattingStat` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameBattingStatNodeIdConnect>>;
  /** The primary key(s) for `gameBattingStat` for the far side of the relationship. */
  deleteByGameIdAndTeamIdAndPlayerId?: Maybe<Array<GameBattingStatFakePublicGameBattingStatsPrimaryKeyDelete>>;
  /** The primary key(s) for `gameBattingStat` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameBattingStatNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameBattingStat` for the far side of the relationship. */
  updateByGameIdAndTeamIdAndPlayerId?: Maybe<Array<GameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey2UsingFakePublicGameBattingStatsPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `gameBattingStat` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnGameBattingStatForFakePublicGameBattingStatsForeignKey2NodeIdUpdate>>;
  /** A `GameBattingStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicGameBattingStatsForeignKey2GameBattingStatsCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type FakePublicGameBattingStatsForeignKey2PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** The `group` to be created by this mutation. */
export type FakePublicSeasonBattingStatsForeignKey0GroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey0InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `group` in the `SeasonBattingStatInput` mutation. */
export type FakePublicSeasonBattingStatsForeignKey0Input = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByUrlSlug?: Maybe<GroupGroupUrlSlugKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByUrlSlug?: Maybe<GroupGroupUrlSlugKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0UsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0UsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByUrlSlug?: Maybe<GroupOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0UsingGroupUrlSlugKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonBattingStatOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0NodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonBattingStatsForeignKey0GroupCreateInput>;
};

/** Input for the nested mutation of `seasonBattingStat` in the `GroupInput` mutation. */
export type FakePublicSeasonBattingStatsForeignKey0InverseInput = {
  /** Flag indicating whether all other `seasonBattingStat` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `seasonBattingStat` for the far side of the relationship. */
  connectByGroupIdAndPlayerId?: Maybe<Array<SeasonBattingStatFakePublicSeasonBattingStatsPrimaryKeyConnect>>;
  /** The primary key(s) for `seasonBattingStat` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<SeasonBattingStatNodeIdConnect>>;
  /** The primary key(s) for `seasonBattingStat` for the far side of the relationship. */
  deleteByGroupIdAndPlayerId?: Maybe<Array<SeasonBattingStatFakePublicSeasonBattingStatsPrimaryKeyDelete>>;
  /** The primary key(s) for `seasonBattingStat` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<SeasonBattingStatNodeIdDelete>>;
  /** The primary key(s) and patch data for `seasonBattingStat` for the far side of the relationship. */
  updateByGroupIdAndPlayerId?: Maybe<Array<SeasonBattingStatOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0UsingFakePublicSeasonBattingStatsPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `seasonBattingStat` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GroupOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0NodeIdUpdate>>;
  /** A `SeasonBattingStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonBattingStatsForeignKey0SeasonBattingStatsCreateInput>>;
};

/** The `seasonBattingStat` to be created by this mutation. */
export type FakePublicSeasonBattingStatsForeignKey0SeasonBattingStatsCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances: Scalars['Int'];
  atBats: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  gidp: Scalars['Int'];
  runs: Scalars['Int'];
  rbi: Scalars['Int'];
  stolenBases: Scalars['Int'];
  avg: Scalars['Float'];
  obp: Scalars['Float'];
  slg: Scalars['Float'];
  ops: Scalars['Float'];
  group?: Maybe<FakePublicSeasonBattingStatsForeignKey0Input>;
  player?: Maybe<FakePublicSeasonBattingStatsForeignKey1Input>;
};

/** Input for the nested mutation of `player` in the `SeasonBattingStatInput` mutation. */
export type FakePublicSeasonBattingStatsForeignKey1Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey1UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey1UsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonBattingStatOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey1NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonBattingStatsForeignKey1PlayerCreateInput>;
};

/** Input for the nested mutation of `seasonBattingStat` in the `PlayerInput` mutation. */
export type FakePublicSeasonBattingStatsForeignKey1InverseInput = {
  /** Flag indicating whether all other `seasonBattingStat` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `seasonBattingStat` for the far side of the relationship. */
  connectByGroupIdAndPlayerId?: Maybe<Array<SeasonBattingStatFakePublicSeasonBattingStatsPrimaryKeyConnect>>;
  /** The primary key(s) for `seasonBattingStat` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<SeasonBattingStatNodeIdConnect>>;
  /** The primary key(s) for `seasonBattingStat` for the far side of the relationship. */
  deleteByGroupIdAndPlayerId?: Maybe<Array<SeasonBattingStatFakePublicSeasonBattingStatsPrimaryKeyDelete>>;
  /** The primary key(s) for `seasonBattingStat` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<SeasonBattingStatNodeIdDelete>>;
  /** The primary key(s) and patch data for `seasonBattingStat` for the far side of the relationship. */
  updateByGroupIdAndPlayerId?: Maybe<Array<SeasonBattingStatOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey1UsingFakePublicSeasonBattingStatsPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `seasonBattingStat` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey1NodeIdUpdate>>;
  /** A `SeasonBattingStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonBattingStatsForeignKey1SeasonBattingStatsCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type FakePublicSeasonBattingStatsForeignKey1PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** The `seasonBattingStat` to be created by this mutation. */
export type FakePublicSeasonBattingStatsForeignKey1SeasonBattingStatsCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances: Scalars['Int'];
  atBats: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  gidp: Scalars['Int'];
  runs: Scalars['Int'];
  rbi: Scalars['Int'];
  stolenBases: Scalars['Int'];
  avg: Scalars['Float'];
  obp: Scalars['Float'];
  slg: Scalars['Float'];
  ops: Scalars['Float'];
  group?: Maybe<FakePublicSeasonBattingStatsForeignKey0Input>;
  player?: Maybe<FakePublicSeasonBattingStatsForeignKey1Input>;
};

export type Field = Node & {
  __typename?: 'Field';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  name: Scalars['String'];
  notes: Maybe<Scalars['String']>;
  address: Scalars['String'];
  /** Reads and enables pagination through a set of `Game`. */
  games: Array<Game>;
};


export type FieldGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GamesOrderBy>>;
  condition?: Maybe<GameCondition>;
  filter?: Maybe<GameFilter>;
};

/** A condition to be used against `Field` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FieldCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address` field. */
  address?: Maybe<Scalars['String']>;
};

/** The fields on `field` to look up the row to connect. */
export type FieldFieldPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `field` to look up the row to delete. */
export type FieldFieldPkeyDelete = {
  id: Scalars['UUID'];
};

/** A filter to be used against `Field` object types. All fields are combined with a logical ‘and.’ */
export type FieldFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `address` field. */
  address?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<FieldFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<FieldFilter>>;
  /** Negates the expression. */
  not?: Maybe<FieldFilter>;
};

/** An input for mutations affecting `Field` */
export type FieldInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  address: Scalars['String'];
  games?: Maybe<GameFieldIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type FieldNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `field` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type FieldNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `field` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type FieldOnGameForGameFieldIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `field` to look up the row to update. */
export type FieldOnGameForGameFieldIdFkeyUsingFieldPkeyUpdate = {
  /** An object where the defined keys will be set on the `field` being updated. */
  patch: UpdateFieldOnGameForGameFieldIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Field`. Fields that are set will be updated. */
export type FieldPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  games?: Maybe<GameFieldIdFkeyInverseInput>;
};

export enum FieldingPosition {
  PITCHER = 'PITCHER',
  CATCHER = 'CATCHER',
  FIRST_BASE = 'FIRST_BASE',
  SECOND_BASE = 'SECOND_BASE',
  THIRD_BASE = 'THIRD_BASE',
  SHORTSTOP = 'SHORTSTOP',
  LEFT_FIELD = 'LEFT_FIELD',
  CENTER_FIELD = 'CENTER_FIELD',
  LEFT_CENTER = 'LEFT_CENTER',
  RIGHT_CENTER = 'RIGHT_CENTER',
  RIGHT_FIELD = 'RIGHT_FIELD',
  MIDDLE_INFIELD = 'MIDDLE_INFIELD'
}

/** A filter to be used against FieldingPosition fields. All fields are combined with a logical ‘and.’ */
export type FieldingPositionFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<FieldingPosition>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<FieldingPosition>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<FieldingPosition>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<FieldingPosition>;
  /** Included in the specified list. */
  in?: Maybe<Array<FieldingPosition>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<FieldingPosition>>;
  /** Less than the specified value. */
  lessThan?: Maybe<FieldingPosition>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<FieldingPosition>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<FieldingPosition>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<FieldingPosition>;
};

/** Methods to use when ordering `Field`. */
export enum FieldsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  NOTES_ASC = 'NOTES_ASC',
  NOTES_DESC = 'NOTES_DESC',
  ADDRESS_ASC = 'ADDRESS_ASC',
  ADDRESS_DESC = 'ADDRESS_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against Float fields. All fields are combined with a logical ‘and.’ */
export type FloatFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Float']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Float']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Float']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Float']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Float']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Float']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Float']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Float']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Float']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Float']>;
};

export type Game = Node & {
  __typename?: 'Game';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  groupId: Scalars['UUID'];
  name: Maybe<Scalars['String']>;
  fieldId: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength: Scalars['Int'];
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved: Scalars['Datetime'];
  soloMode: Scalars['Boolean'];
  manualEntry: Scalars['Boolean'];
  legacyMeetup: Scalars['Boolean'];
  /** Reads a single `Group` that is related to this `Game`. */
  group: Maybe<Group>;
  /** Reads a single `Field` that is related to this `Game`. */
  field: Maybe<Field>;
  /** Reads and enables pagination through a set of `Team`. */
  teams: Array<Team>;
  /** Reads and enables pagination through a set of `Lineup`. */
  lineups: Array<Lineup>;
  /** Reads and enables pagination through a set of `LineupSpot`. */
  lineupSpots: Array<LineupSpot>;
  /** Reads and enables pagination through a set of `PlateAppearance`. */
  plateAppearances: Array<PlateAppearance>;
  /** Reads and enables pagination through a set of `BasepathMovement`. */
  basepathMovements: Array<BasepathMovement>;
  /** Reads and enables pagination through a set of `OutOnPlayRunner`. */
  outOnPlayRunners: Array<OutOnPlayRunner>;
  /** Reads and enables pagination through a set of `StolenBaseAttempt`. */
  stolenBaseAttempts: Array<StolenBaseAttempt>;
  /** Reads and enables pagination through a set of `LineupChange`. */
  lineupChanges: Array<LineupChange>;
  /** Reads and enables pagination through a set of `GameState`. */
  gameStates: Array<GameState>;
  /** Reads and enables pagination through a set of `BaseRunner`. */
  baseRunners: Array<BaseRunner>;
  /** Reads and enables pagination through a set of `LineupForGameState`. */
  lineupForGameStates: Array<LineupForGameState>;
  /** Reads and enables pagination through a set of `GameEventRecord`. */
  gameEventRecords: Array<GameEventRecord>;
  /** Reads and enables pagination through a set of `ScoredRunner`. */
  scoredRunners: Array<ScoredRunner>;
  /** Reads and enables pagination through a set of `SoloModeOpponentInning`. */
  soloModeOpponentInnings: Array<SoloModeOpponentInning>;
  /** Reads and enables pagination through a set of `AtBatSkip`. */
  atBatSkips: Array<AtBatSkip>;
  /** Reads and enables pagination through a set of `EarlyGameEnd`. */
  earlyGameEnds: Array<EarlyGameEnd>;
  /** Reads and enables pagination through a set of `ManualEntryBattingLine`. */
  manualEntryBattingLines: Array<ManualEntryBattingLine>;
  /** Reads and enables pagination through a set of `ManualEntryPitchingLine`. */
  manualEntryPitchingLines: Array<ManualEntryPitchingLine>;
  /** Reads and enables pagination through a set of `ManualEntryLineScoreCell`. */
  manualEntryLineScoreCells: Array<ManualEntryLineScoreCell>;
  /** Reads and enables pagination through a set of `GameBattingStat`. */
  gameBattingStats: Array<GameBattingStat>;
  /** Reads and enables pagination through a set of `TraditionalStatLine`. */
  boxScore: Maybe<Array<Maybe<TraditionalStatLine>>>;
  /** Reads and enables pagination through a set of `LineScoreCell`. */
  lineScore: Maybe<Array<Maybe<LineScoreCell>>>;
  season: Maybe<Scalars['Int']>;
};


export type GameTeamsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<TeamsOrderBy>>;
  condition?: Maybe<TeamCondition>;
  filter?: Maybe<TeamFilter>;
};


export type GameLineupsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupsOrderBy>>;
  condition?: Maybe<LineupCondition>;
  filter?: Maybe<LineupFilter>;
};


export type GameLineupSpotsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupSpotsOrderBy>>;
  condition?: Maybe<LineupSpotCondition>;
  filter?: Maybe<LineupSpotFilter>;
};


export type GamePlateAppearancesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlateAppearancesOrderBy>>;
  condition?: Maybe<PlateAppearanceCondition>;
  filter?: Maybe<PlateAppearanceFilter>;
};


export type GameBasepathMovementsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BasepathMovementsOrderBy>>;
  condition?: Maybe<BasepathMovementCondition>;
  filter?: Maybe<BasepathMovementFilter>;
};


export type GameOutOnPlayRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<OutOnPlayRunnersOrderBy>>;
  condition?: Maybe<OutOnPlayRunnerCondition>;
  filter?: Maybe<OutOnPlayRunnerFilter>;
};


export type GameStolenBaseAttemptsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<StolenBaseAttemptsOrderBy>>;
  condition?: Maybe<StolenBaseAttemptCondition>;
  filter?: Maybe<StolenBaseAttemptFilter>;
};


export type GameLineupChangesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupChangesOrderBy>>;
  condition?: Maybe<LineupChangeCondition>;
  filter?: Maybe<LineupChangeFilter>;
};


export type GameGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameStatesOrderBy>>;
  condition?: Maybe<GameStateCondition>;
  filter?: Maybe<GameStateFilter>;
};


export type GameBaseRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BaseRunnersOrderBy>>;
  condition?: Maybe<BaseRunnerCondition>;
  filter?: Maybe<BaseRunnerFilter>;
};


export type GameLineupForGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupForGameStatesOrderBy>>;
  condition?: Maybe<LineupForGameStateCondition>;
  filter?: Maybe<LineupForGameStateFilter>;
};


export type GameGameEventRecordsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventRecordsOrderBy>>;
  condition?: Maybe<GameEventRecordCondition>;
  filter?: Maybe<GameEventRecordFilter>;
};


export type GameScoredRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ScoredRunnersOrderBy>>;
  condition?: Maybe<ScoredRunnerCondition>;
  filter?: Maybe<ScoredRunnerFilter>;
};


export type GameSoloModeOpponentInningsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SoloModeOpponentInningsOrderBy>>;
  condition?: Maybe<SoloModeOpponentInningCondition>;
  filter?: Maybe<SoloModeOpponentInningFilter>;
};


export type GameAtBatSkipsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<AtBatSkipsOrderBy>>;
  condition?: Maybe<AtBatSkipCondition>;
  filter?: Maybe<AtBatSkipFilter>;
};


export type GameEarlyGameEndsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EarlyGameEndsOrderBy>>;
  condition?: Maybe<EarlyGameEndCondition>;
  filter?: Maybe<EarlyGameEndFilter>;
};


export type GameManualEntryBattingLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ManualEntryBattingLinesOrderBy>>;
  condition?: Maybe<ManualEntryBattingLineCondition>;
  filter?: Maybe<ManualEntryBattingLineFilter>;
};


export type GameManualEntryPitchingLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ManualEntryPitchingLinesOrderBy>>;
  condition?: Maybe<ManualEntryPitchingLineCondition>;
  filter?: Maybe<ManualEntryPitchingLineFilter>;
};


export type GameManualEntryLineScoreCellsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ManualEntryLineScoreCellsOrderBy>>;
  condition?: Maybe<ManualEntryLineScoreCellCondition>;
  filter?: Maybe<ManualEntryLineScoreCellFilter>;
};


export type GameGameBattingStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameBattingStatsOrderBy>>;
  condition?: Maybe<GameBattingStatCondition>;
  filter?: Maybe<GameBattingStatFilter>;
};


export type GameBoxScoreArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  filter?: Maybe<TraditionalStatLineFilter>;
};


export type GameLineScoreArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  filter?: Maybe<LineScoreCellFilter>;
};

export type GameAuxMeetupInfo = Node & {
  __typename?: 'GameAuxMeetupInfo';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameId: Scalars['UUID'];
  imageGalleryUrl: Maybe<Scalars['String']>;
  meetupEventId: Maybe<Scalars['String']>;
  advanced: Scalars['Boolean'];
  /** Reads a single `Player` that is related to this `GameAuxMeetupInfo`. */
  game: Maybe<Player>;
};

/**
 * A condition to be used against `GameAuxMeetupInfo` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type GameAuxMeetupInfoCondition = {
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `imageGalleryUrl` field. */
  imageGalleryUrl?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `meetupEventId` field. */
  meetupEventId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `advanced` field. */
  advanced?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `GameAuxMeetupInfo` object types. All fields are combined with a logical ‘and.’ */
export type GameAuxMeetupInfoFilter = {
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Filter by the object’s `imageGalleryUrl` field. */
  imageGalleryUrl?: Maybe<StringFilter>;
  /** Filter by the object’s `meetupEventId` field. */
  meetupEventId?: Maybe<StringFilter>;
  /** Filter by the object’s `advanced` field. */
  advanced?: Maybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GameAuxMeetupInfoFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GameAuxMeetupInfoFilter>>;
  /** Negates the expression. */
  not?: Maybe<GameAuxMeetupInfoFilter>;
};

/** The fields on `gameAuxMeetupInfo` to look up the row to connect. */
export type GameAuxMeetupInfoGameAuxMeetupInfoPkeyConnect = {
  gameId: Scalars['UUID'];
};

/** The fields on `gameAuxMeetupInfo` to look up the row to delete. */
export type GameAuxMeetupInfoGameAuxMeetupInfoPkeyDelete = {
  gameId: Scalars['UUID'];
};

/** The `gameAuxMeetupInfo` to be created by this mutation. */
export type GameAuxMeetupInfoGameIdFkeyGameAuxMeetupInfoCreateInput = {
  imageGalleryUrl?: Maybe<Scalars['String']>;
  meetupEventId?: Maybe<Scalars['String']>;
  advanced?: Maybe<Scalars['Boolean']>;
  player?: Maybe<GameAuxMeetupInfoGameIdFkeyInput>;
};

/** Input for the nested mutation of `player` in the `GameAuxMeetupInfoInput` mutation. */
export type GameAuxMeetupInfoGameIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnGameAuxMeetupInfoForGameAuxMeetupInfoGameIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnGameAuxMeetupInfoForGameAuxMeetupInfoGameIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameAuxMeetupInfoOnGameAuxMeetupInfoForGameAuxMeetupInfoGameIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<GameAuxMeetupInfoGameIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `gameAuxMeetupInfo` in the `PlayerInput` mutation. */
export type GameAuxMeetupInfoGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameAuxMeetupInfo` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameAuxMeetupInfo` for the far side of the relationship. */
  connectByGameId?: Maybe<GameAuxMeetupInfoGameAuxMeetupInfoPkeyConnect>;
  /** The primary key(s) for `gameAuxMeetupInfo` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameAuxMeetupInfoNodeIdConnect>;
  /** The primary key(s) for `gameAuxMeetupInfo` for the far side of the relationship. */
  deleteByGameId?: Maybe<GameAuxMeetupInfoGameAuxMeetupInfoPkeyDelete>;
  /** The primary key(s) for `gameAuxMeetupInfo` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameAuxMeetupInfoNodeIdDelete>;
  /** The primary key(s) and patch data for `gameAuxMeetupInfo` for the far side of the relationship. */
  updateByGameId?: Maybe<GameAuxMeetupInfoOnGameAuxMeetupInfoForGameAuxMeetupInfoGameIdFkeyUsingGameAuxMeetupInfoPkeyUpdate>;
  /** The primary key(s) and patch data for `gameAuxMeetupInfo` for the far side of the relationship. */
  updateByNodeId?: Maybe<PlayerOnGameAuxMeetupInfoForGameAuxMeetupInfoGameIdFkeyNodeIdUpdate>;
  /** A `GameAuxMeetupInfoInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameAuxMeetupInfoGameIdFkeyGameAuxMeetupInfoCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type GameAuxMeetupInfoGameIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An input for mutations affecting `GameAuxMeetupInfo` */
export type GameAuxMeetupInfoInput = {
  gameId?: Maybe<Scalars['UUID']>;
  imageGalleryUrl?: Maybe<Scalars['String']>;
  meetupEventId?: Maybe<Scalars['String']>;
  advanced?: Maybe<Scalars['Boolean']>;
  player?: Maybe<GameAuxMeetupInfoGameIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GameAuxMeetupInfoNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `gameAuxMeetupInfo` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GameAuxMeetupInfoNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `gameAuxMeetupInfo` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameAuxMeetupInfoOnGameAuxMeetupInfoForGameAuxMeetupInfoGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `gameAuxMeetupInfo` to look up the row to update. */
export type GameAuxMeetupInfoOnGameAuxMeetupInfoForGameAuxMeetupInfoGameIdFkeyUsingGameAuxMeetupInfoPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameAuxMeetupInfo` being updated. */
  patch: UpdateGameAuxMeetupInfoOnGameAuxMeetupInfoForGameAuxMeetupInfoGameIdFkeyPatch;
  gameId: Scalars['UUID'];
};

/** Represents an update to a `GameAuxMeetupInfo`. Fields that are set will be updated. */
export type GameAuxMeetupInfoPatch = {
  gameId?: Maybe<Scalars['UUID']>;
  imageGalleryUrl?: Maybe<Scalars['String']>;
  meetupEventId?: Maybe<Scalars['String']>;
  advanced?: Maybe<Scalars['Boolean']>;
  player?: Maybe<GameAuxMeetupInfoGameIdFkeyInput>;
};

/** Methods to use when ordering `GameAuxMeetupInfo`. */
export enum GameAuxMeetupInfosOrderBy {
  NATURAL = 'NATURAL',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  IMAGE_GALLERY_URL_ASC = 'IMAGE_GALLERY_URL_ASC',
  IMAGE_GALLERY_URL_DESC = 'IMAGE_GALLERY_URL_DESC',
  MEETUP_EVENT_ID_ASC = 'MEETUP_EVENT_ID_ASC',
  MEETUP_EVENT_ID_DESC = 'MEETUP_EVENT_ID_DESC',
  ADVANCED_ASC = 'ADVANCED_ASC',
  ADVANCED_DESC = 'ADVANCED_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type GameBattingStat = Node & {
  __typename?: 'GameBattingStat';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
  plateAppearances: Scalars['Int'];
  atBats: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  gidp: Scalars['Int'];
  runs: Scalars['Int'];
  rbi: Scalars['Int'];
  stolenBases: Scalars['Int'];
  /** Reads a single `Game` that is related to this `GameBattingStat`. */
  game: Maybe<Game>;
  /** Reads a single `Team` that is related to this `GameBattingStat`. */
  team: Maybe<Team>;
  /** Reads a single `Player` that is related to this `GameBattingStat`. */
  player: Maybe<Player>;
};

/**
 * A condition to be used against `GameBattingStat` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type GameBattingStatCondition = {
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stolenBases` field. */
  stolenBases?: Maybe<Scalars['Int']>;
};

/** The fields on `gameBattingStat` to look up the row to connect. */
export type GameBattingStatFakePublicGameBattingStatsPrimaryKeyConnect = {
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The fields on `gameBattingStat` to look up the row to delete. */
export type GameBattingStatFakePublicGameBattingStatsPrimaryKeyDelete = {
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** A filter to be used against `GameBattingStat` object types. All fields are combined with a logical ‘and.’ */
export type GameBattingStatFilter = {
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Filter by the object’s `teamId` field. */
  teamId?: Maybe<UuidFilter>;
  /** Filter by the object’s `playerId` field. */
  playerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<IntFilter>;
  /** Filter by the object’s `atBats` field. */
  atBats?: Maybe<IntFilter>;
  /** Filter by the object’s `hits` field. */
  hits?: Maybe<IntFilter>;
  /** Filter by the object’s `singles` field. */
  singles?: Maybe<IntFilter>;
  /** Filter by the object’s `doubles` field. */
  doubles?: Maybe<IntFilter>;
  /** Filter by the object’s `triples` field. */
  triples?: Maybe<IntFilter>;
  /** Filter by the object’s `homeruns` field. */
  homeruns?: Maybe<IntFilter>;
  /** Filter by the object’s `walks` field. */
  walks?: Maybe<IntFilter>;
  /** Filter by the object’s `strikeouts` field. */
  strikeouts?: Maybe<IntFilter>;
  /** Filter by the object’s `sacFlies` field. */
  sacFlies?: Maybe<IntFilter>;
  /** Filter by the object’s `gidp` field. */
  gidp?: Maybe<IntFilter>;
  /** Filter by the object’s `runs` field. */
  runs?: Maybe<IntFilter>;
  /** Filter by the object’s `rbi` field. */
  rbi?: Maybe<IntFilter>;
  /** Filter by the object’s `stolenBases` field. */
  stolenBases?: Maybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GameBattingStatFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GameBattingStatFilter>>;
  /** Negates the expression. */
  not?: Maybe<GameBattingStatFilter>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GameBattingStatNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `gameBattingStat` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GameBattingStatNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `gameBattingStat` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `gameBattingStat` to look up the row to update. */
export type GameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey0UsingFakePublicGameBattingStatsPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `gameBattingStat` being updated. */
  patch: UpdateGameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey0Patch;
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `team` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: TeamPatch;
};

/** The fields on `gameBattingStat` to look up the row to update. */
export type GameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey1UsingFakePublicGameBattingStatsPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `gameBattingStat` being updated. */
  patch: UpdateGameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey1Patch;
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `gameBattingStat` to look up the row to update. */
export type GameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey2UsingFakePublicGameBattingStatsPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `gameBattingStat` being updated. */
  patch: UpdateGameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey2Patch;
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** Represents an update to a `GameBattingStat`. Fields that are set will be updated. */
export type GameBattingStatPatch = {
  gameId?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  game?: Maybe<FakePublicGameBattingStatsForeignKey0Input>;
  team?: Maybe<FakePublicGameBattingStatsForeignKey1Input>;
  player?: Maybe<FakePublicGameBattingStatsForeignKey2Input>;
};

/** Methods to use when ordering `GameBattingStat`. */
export enum GameBattingStatsOrderBy {
  NATURAL = 'NATURAL',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  TEAM_ID_ASC = 'TEAM_ID_ASC',
  TEAM_ID_DESC = 'TEAM_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  STOLEN_BASES_ASC = 'STOLEN_BASES_ASC',
  STOLEN_BASES_DESC = 'STOLEN_BASES_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `Game` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GameCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `score` field. */
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  /** Checks for equality with the object’s `gameLength` field. */
  gameLength?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `timeStarted` field. */
  timeStarted?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `timeEnded` field. */
  timeEnded?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `timeSaved` field. */
  timeSaved?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `soloMode` field. */
  soloMode?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `manualEntry` field. */
  manualEntry?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `legacyMeetup` field. */
  legacyMeetup?: Maybe<Scalars['Boolean']>;
};

export type GameEvent = Node & {
  __typename?: 'GameEvent';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  plateAppearanceId: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId: Maybe<Scalars['UUID']>;
  lineupChangeId: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId: Maybe<Scalars['UUID']>;
  atBatSkipId: Maybe<Scalars['UUID']>;
  gameId: Scalars['UUID'];
  earlyGameEndId: Maybe<Scalars['UUID']>;
  /** Reads a single `PlateAppearance` that is related to this `GameEvent`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `StolenBaseAttempt` that is related to this `GameEvent`. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Reads a single `LineupChange` that is related to this `GameEvent`. */
  lineupChange: Maybe<LineupChange>;
  /** Reads a single `SoloModeOpponentInning` that is related to this `GameEvent`. */
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  /** Reads a single `AtBatSkip` that is related to this `GameEvent`. */
  atBatSkip: Maybe<AtBatSkip>;
  /** Reads a single `Game` that is related to this `GameEvent`. */
  game: Maybe<Game>;
  /** Reads a single `EarlyGameEnd` that is related to this `GameEvent`. */
  earlyGameEnd: Maybe<EarlyGameEnd>;
  /** Reads and enables pagination through a set of `GameEventRecord`. */
  gameEventRecords: Array<GameEventRecord>;
};


export type GameEventGameEventRecordsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventRecordsOrderBy>>;
  condition?: Maybe<GameEventRecordCondition>;
  filter?: Maybe<GameEventRecordFilter>;
};

/** The `atBatSkip` to be created by this mutation. */
export type GameEventAtBatSkipIdFkeyAtBatSkipCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventAtBatSkipIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `atBatSkip` in the `GameEventInput` mutation. */
export type GameEventAtBatSkipIdFkeyInput = {
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  connectById?: Maybe<AtBatSkipAtBatSkipPkeyConnect>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  connectByNodeId?: Maybe<AtBatSkipNodeIdConnect>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  deleteById?: Maybe<AtBatSkipAtBatSkipPkeyDelete>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<AtBatSkipNodeIdDelete>;
  /** The primary key(s) and patch data for `atBatSkip` for the far side of the relationship. */
  updateById?: Maybe<AtBatSkipOnGameEventForGameEventAtBatSkipIdFkeyUsingAtBatSkipPkeyUpdate>;
  /** The primary key(s) and patch data for `atBatSkip` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventAtBatSkipIdFkeyNodeIdUpdate>;
  /** A `AtBatSkipInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventAtBatSkipIdFkeyAtBatSkipCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `AtBatSkipInput` mutation. */
export type GameEventAtBatSkipIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventAtBatSkipIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<AtBatSkipOnGameEventForGameEventAtBatSkipIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventAtBatSkipIdFkeyGameEventCreateInput>>;
};

/**
 * A condition to be used against `GameEvent` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GameEventCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `plateAppearanceId` field. */
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `stolenBaseAttemptId` field. */
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `lineupChangeId` field. */
  lineupChangeId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `soloModeOpponentInningId` field. */
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `atBatSkipId` field. */
  atBatSkipId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `earlyGameEndId` field. */
  earlyGameEndId?: Maybe<Scalars['UUID']>;
};

/** The `earlyGameEnd` to be created by this mutation. */
export type GameEventEarlyGameEndIdFkeyEarlyGameEndCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  reason: EarlyGameEndReason;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<EarlyGameEndGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventEarlyGameEndIdFkeyInverseInput>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventEarlyGameEndIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `earlyGameEnd` in the `GameEventInput` mutation. */
export type GameEventEarlyGameEndIdFkeyInput = {
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  connectById?: Maybe<EarlyGameEndEarlyGameEndPkeyConnect>;
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  connectByNodeId?: Maybe<EarlyGameEndNodeIdConnect>;
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  deleteById?: Maybe<EarlyGameEndEarlyGameEndPkeyDelete>;
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  deleteByNodeId?: Maybe<EarlyGameEndNodeIdDelete>;
  /** The primary key(s) and patch data for `earlyGameEnd` for the far side of the relationship. */
  updateById?: Maybe<EarlyGameEndOnGameEventForGameEventEarlyGameEndIdFkeyUsingEarlyGameEndPkeyUpdate>;
  /** The primary key(s) and patch data for `earlyGameEnd` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventEarlyGameEndIdFkeyNodeIdUpdate>;
  /** A `EarlyGameEndInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventEarlyGameEndIdFkeyEarlyGameEndCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `EarlyGameEndInput` mutation. */
export type GameEventEarlyGameEndIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventEarlyGameEndIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<EarlyGameEndOnGameEventForGameEventEarlyGameEndIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventEarlyGameEndIdFkeyGameEventCreateInput>>;
};

/** A filter to be used against `GameEvent` object types. All fields are combined with a logical ‘and.’ */
export type GameEventFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `plateAppearanceId` field. */
  plateAppearanceId?: Maybe<UuidFilter>;
  /** Filter by the object’s `stolenBaseAttemptId` field. */
  stolenBaseAttemptId?: Maybe<UuidFilter>;
  /** Filter by the object’s `lineupChangeId` field. */
  lineupChangeId?: Maybe<UuidFilter>;
  /** Filter by the object’s `soloModeOpponentInningId` field. */
  soloModeOpponentInningId?: Maybe<UuidFilter>;
  /** Filter by the object’s `atBatSkipId` field. */
  atBatSkipId?: Maybe<UuidFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Filter by the object’s `earlyGameEndId` field. */
  earlyGameEndId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GameEventFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GameEventFilter>>;
  /** Negates the expression. */
  not?: Maybe<GameEventFilter>;
};

/** The fields on `gameEvent` to look up the row to connect. */
export type GameEventGameEventPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `gameEvent` to look up the row to delete. */
export type GameEventGameEventPkeyDelete = {
  id: Scalars['UUID'];
};

/** The `game` to be created by this mutation. */
export type GameEventGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventGameIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `game` in the `GameEventInput` mutation. */
export type GameEventGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnGameEventForGameEventGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnGameEventForGameEventGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `GameInput` mutation. */
export type GameEventGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventGameIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnGameEventForGameEventGameIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventGameIdFkeyGameEventCreateInput>>;
};

/** An input for mutations affecting `GameEvent` */
export type GameEventInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventLineupChangeIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `lineupChange` in the `GameEventInput` mutation. */
export type GameEventLineupChangeIdFkeyInput = {
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectById?: Maybe<LineupChangeLineupChangePkeyConnect>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectByNodeId?: Maybe<LineupChangeNodeIdConnect>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteById?: Maybe<LineupChangeLineupChangePkeyDelete>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LineupChangeNodeIdDelete>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateById?: Maybe<LineupChangeOnGameEventForGameEventLineupChangeIdFkeyUsingLineupChangePkeyUpdate>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate>;
  /** A `LineupChangeInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventLineupChangeIdFkeyLineupChangeCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `LineupChangeInput` mutation. */
export type GameEventLineupChangeIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventLineupChangeIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LineupChangeOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventLineupChangeIdFkeyGameEventCreateInput>>;
};

/** The `lineupChange` to be created by this mutation. */
export type GameEventLineupChangeIdFkeyLineupChangeCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GameEventNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GameEventNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventAtBatSkipIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `atBatSkip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `atBatSkip` being updated. */
  patch: AtBatSkipPatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventAtBatSkipIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventAtBatSkipIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventEarlyGameEndIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `earlyGameEnd` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `earlyGameEnd` being updated. */
  patch: EarlyGameEndPatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventEarlyGameEndIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventEarlyGameEndIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventGameIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: LineupChangePatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventLineupChangeIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventLineupChangeIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventPlateAppearanceIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventPlateAppearanceIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventSoloModeOpponentInningIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `soloModeOpponentInning` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `soloModeOpponentInning` being updated. */
  patch: SoloModeOpponentInningPatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventSoloModeOpponentInningIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventSoloModeOpponentInningIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `stolenBaseAttempt` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: StolenBaseAttemptPatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `GameEvent`. Fields that are set will be updated. */
export type GameEventPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventPlateAppearanceIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `plateAppearance` in the `GameEventInput` mutation. */
export type GameEventPlateAppearanceIdFkeyInput = {
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectById?: Maybe<PlateAppearancePlateAppearancePkeyConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlateAppearanceNodeIdConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteById?: Maybe<PlateAppearancePlateAppearancePkeyDelete>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlateAppearanceNodeIdDelete>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateById?: Maybe<PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate>;
  /** A `PlateAppearanceInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventPlateAppearanceIdFkeyPlateAppearanceCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `PlateAppearanceInput` mutation. */
export type GameEventPlateAppearanceIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventPlateAppearanceIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventPlateAppearanceIdFkeyGameEventCreateInput>>;
};

/** The `plateAppearance` to be created by this mutation. */
export type GameEventPlateAppearanceIdFkeyPlateAppearanceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

export type GameEventRecord = Node & {
  __typename?: 'GameEventRecord';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
  gameStateBeforeId: Scalars['UUID'];
  gameStateAfterId: Scalars['UUID'];
  gameEventId: Scalars['UUID'];
  notes: Maybe<Scalars['String']>;
  /** Reads a single `Game` that is related to this `GameEventRecord`. */
  game: Maybe<Game>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateBefore: Maybe<GameState>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateAfter: Maybe<GameState>;
  /** Reads a single `GameEvent` that is related to this `GameEventRecord`. */
  gameEvent: Maybe<GameEvent>;
  /** Reads and enables pagination through a set of `ScoredRunner`. */
  scoredRunners: Array<ScoredRunner>;
};


export type GameEventRecordScoredRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ScoredRunnersOrderBy>>;
  condition?: Maybe<ScoredRunnerCondition>;
  filter?: Maybe<ScoredRunnerFilter>;
};

/**
 * A condition to be used against `GameEventRecord` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type GameEventRecordCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `eventIndex` field. */
  eventIndex?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameStateBeforeId` field. */
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameStateAfterId` field. */
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameEventId` field. */
  gameEventId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
};

/** A filter to be used against `GameEventRecord` object types. All fields are combined with a logical ‘and.’ */
export type GameEventRecordFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Filter by the object’s `eventIndex` field. */
  eventIndex?: Maybe<IntFilter>;
  /** Filter by the object’s `gameStateBeforeId` field. */
  gameStateBeforeId?: Maybe<UuidFilter>;
  /** Filter by the object’s `gameStateAfterId` field. */
  gameStateAfterId?: Maybe<UuidFilter>;
  /** Filter by the object’s `gameEventId` field. */
  gameEventId?: Maybe<UuidFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GameEventRecordFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GameEventRecordFilter>>;
  /** Negates the expression. */
  not?: Maybe<GameEventRecordFilter>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventRecordGameEventIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** The `gameEventRecord` to be created by this mutation. */
export type GameEventRecordGameEventIdFkeyGameEventRecordCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** Input for the nested mutation of `gameEvent` in the `GameEventRecordInput` mutation. */
export type GameEventRecordGameEventIdFkeyInput = {
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<GameEventGameEventPkeyConnect>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameEventNodeIdConnect>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<GameEventGameEventPkeyDelete>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameEventNodeIdDelete>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventPkeyUpdate>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventRecordGameEventIdFkeyGameEventCreateInput>;
};

/** Input for the nested mutation of `gameEventRecord` in the `GameEventInput` mutation. */
export type GameEventRecordGameEventIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventRecordGameEventRecordPkeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventRecordNodeIdConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventRecordGameEventRecordPkeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventRecordNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByGameIdAndEventIndex?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate>>;
  /** A `GameEventRecordInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventRecordGameEventIdFkeyGameEventRecordCreateInput>>;
};

/** The fields on `gameEventRecord` to look up the row to connect. */
export type GameEventRecordGameEventRecordGameIdEventIndexKeyConnect = {
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to delete. */
export type GameEventRecordGameEventRecordGameIdEventIndexKeyDelete = {
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to connect. */
export type GameEventRecordGameEventRecordPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `gameEventRecord` to look up the row to delete. */
export type GameEventRecordGameEventRecordPkeyDelete = {
  id: Scalars['UUID'];
};

/** The `game` to be created by this mutation. */
export type GameEventRecordGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** The `gameEventRecord` to be created by this mutation. */
export type GameEventRecordGameIdFkeyGameEventRecordCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** Input for the nested mutation of `game` in the `GameEventRecordInput` mutation. */
export type GameEventRecordGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventRecordGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `gameEventRecord` in the `GameInput` mutation. */
export type GameEventRecordGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventRecordGameEventRecordPkeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventRecordNodeIdConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventRecordGameEventRecordPkeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventRecordNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByGameIdAndEventIndex?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate>>;
  /** A `GameEventRecordInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventRecordGameIdFkeyGameEventRecordCreateInput>>;
};

/** The `gameEventRecord` to be created by this mutation. */
export type GameEventRecordGameStateAfterFkGameEventRecordCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** The `gameState` to be created by this mutation. */
export type GameEventRecordGameStateAfterFkGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `gameState` in the `GameEventRecordInput` mutation. */
export type GameEventRecordGameStateAfterFkInput = {
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<GameStateGameStatePkeyConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameStateNodeIdConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<GameStateGameStatePkeyDelete>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameStateNodeIdDelete>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameStatePkeyUpdate>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventRecordGameStateAfterFkGameStateCreateInput>;
};

/** Input for the nested mutation of `gameEventRecord` in the `GameStateInput` mutation. */
export type GameEventRecordGameStateAfterFkInverseInput = {
  /** Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventRecordGameEventRecordPkeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventRecordNodeIdConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventRecordGameEventRecordPkeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventRecordNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByGameIdAndEventIndex?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordGameIdEventIndexKeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate>>;
  /** A `GameEventRecordInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventRecordGameStateAfterFkGameEventRecordCreateInput>>;
};

/** The `gameEventRecord` to be created by this mutation. */
export type GameEventRecordGameStateBeforeFkGameEventRecordCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** The `gameState` to be created by this mutation. */
export type GameEventRecordGameStateBeforeFkGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `gameState` in the `GameEventRecordInput` mutation. */
export type GameEventRecordGameStateBeforeFkInput = {
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<GameStateGameStatePkeyConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameStateNodeIdConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<GameStateGameStatePkeyDelete>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameStateNodeIdDelete>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameStatePkeyUpdate>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventRecordGameStateBeforeFkGameStateCreateInput>;
};

/** Input for the nested mutation of `gameEventRecord` in the `GameStateInput` mutation. */
export type GameEventRecordGameStateBeforeFkInverseInput = {
  /** Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventRecordGameEventRecordPkeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventRecordNodeIdConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventRecordGameEventRecordPkeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventRecordNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByGameIdAndEventIndex?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordGameIdEventIndexKeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate>>;
  /** A `GameEventRecordInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventRecordGameStateBeforeFkGameEventRecordCreateInput>>;
};

/** An input for mutations affecting `GameEventRecord` */
export type GameEventRecordInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GameEventRecordNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GameEventRecordNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordGameIdEventIndexKeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordGameIdEventIndexKeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scoredRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: ScoredRunnerPatch;
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `GameEventRecord`. Fields that are set will be updated. */
export type GameEventRecordPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** Methods to use when ordering `GameEventRecord`. */
export enum GameEventRecordsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  EVENT_INDEX_ASC = 'EVENT_INDEX_ASC',
  EVENT_INDEX_DESC = 'EVENT_INDEX_DESC',
  GAME_STATE_BEFORE_ID_ASC = 'GAME_STATE_BEFORE_ID_ASC',
  GAME_STATE_BEFORE_ID_DESC = 'GAME_STATE_BEFORE_ID_DESC',
  GAME_STATE_AFTER_ID_ASC = 'GAME_STATE_AFTER_ID_ASC',
  GAME_STATE_AFTER_ID_DESC = 'GAME_STATE_AFTER_ID_DESC',
  GAME_EVENT_ID_ASC = 'GAME_EVENT_ID_ASC',
  GAME_EVENT_ID_DESC = 'GAME_EVENT_ID_DESC',
  NOTES_ASC = 'NOTES_ASC',
  NOTES_DESC = 'NOTES_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** The `gameEvent` to be created by this mutation. */
export type GameEventSoloModeOpponentInningIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `soloModeOpponentInning` in the `GameEventInput` mutation. */
export type GameEventSoloModeOpponentInningIdFkeyInput = {
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  connectById?: Maybe<SoloModeOpponentInningSoloModeOpponentInningPkeyConnect>;
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  connectByNodeId?: Maybe<SoloModeOpponentInningNodeIdConnect>;
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  deleteById?: Maybe<SoloModeOpponentInningSoloModeOpponentInningPkeyDelete>;
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  deleteByNodeId?: Maybe<SoloModeOpponentInningNodeIdDelete>;
  /** The primary key(s) and patch data for `soloModeOpponentInning` for the far side of the relationship. */
  updateById?: Maybe<SoloModeOpponentInningOnGameEventForGameEventSoloModeOpponentInningIdFkeyUsingSoloModeOpponentInningPkeyUpdate>;
  /** The primary key(s) and patch data for `soloModeOpponentInning` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventSoloModeOpponentInningIdFkeyNodeIdUpdate>;
  /** A `SoloModeOpponentInningInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventSoloModeOpponentInningIdFkeySoloModeOpponentInningCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `SoloModeOpponentInningInput` mutation. */
export type GameEventSoloModeOpponentInningIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventSoloModeOpponentInningIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<SoloModeOpponentInningOnGameEventForGameEventSoloModeOpponentInningIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventSoloModeOpponentInningIdFkeyGameEventCreateInput>>;
};

/** The `soloModeOpponentInning` to be created by this mutation. */
export type GameEventSoloModeOpponentInningIdFkeySoloModeOpponentInningCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  runsScored: Scalars['Int'];
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<SoloModeOpponentInningGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventSoloModeOpponentInningIdFkeyInverseInput>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventStolenBaseAttemptIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `stolenBaseAttempt` in the `GameEventInput` mutation. */
export type GameEventStolenBaseAttemptIdFkeyInput = {
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectById?: Maybe<StolenBaseAttemptStolenBaseAttemptPkeyConnect>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectByNodeId?: Maybe<StolenBaseAttemptNodeIdConnect>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteById?: Maybe<StolenBaseAttemptStolenBaseAttemptPkeyDelete>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteByNodeId?: Maybe<StolenBaseAttemptNodeIdDelete>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateById?: Maybe<StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingStolenBaseAttemptPkeyUpdate>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate>;
  /** A `StolenBaseAttemptInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventStolenBaseAttemptIdFkeyStolenBaseAttemptCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `StolenBaseAttemptInput` mutation. */
export type GameEventStolenBaseAttemptIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventStolenBaseAttemptIdFkeyGameEventCreateInput>>;
};

/** The `stolenBaseAttempt` to be created by this mutation. */
export type GameEventStolenBaseAttemptIdFkeyStolenBaseAttemptCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** Methods to use when ordering `GameEvent`. */
export enum GameEventsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  PLATE_APPEARANCE_ID_ASC = 'PLATE_APPEARANCE_ID_ASC',
  PLATE_APPEARANCE_ID_DESC = 'PLATE_APPEARANCE_ID_DESC',
  STOLEN_BASE_ATTEMPT_ID_ASC = 'STOLEN_BASE_ATTEMPT_ID_ASC',
  STOLEN_BASE_ATTEMPT_ID_DESC = 'STOLEN_BASE_ATTEMPT_ID_DESC',
  LINEUP_CHANGE_ID_ASC = 'LINEUP_CHANGE_ID_ASC',
  LINEUP_CHANGE_ID_DESC = 'LINEUP_CHANGE_ID_DESC',
  SOLO_MODE_OPPONENT_INNING_ID_ASC = 'SOLO_MODE_OPPONENT_INNING_ID_ASC',
  SOLO_MODE_OPPONENT_INNING_ID_DESC = 'SOLO_MODE_OPPONENT_INNING_ID_DESC',
  AT_BAT_SKIP_ID_ASC = 'AT_BAT_SKIP_ID_ASC',
  AT_BAT_SKIP_ID_DESC = 'AT_BAT_SKIP_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  EARLY_GAME_END_ID_ASC = 'EARLY_GAME_END_ID_ASC',
  EARLY_GAME_END_ID_DESC = 'EARLY_GAME_END_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** The `field` to be created by this mutation. */
export type GameFieldIdFkeyFieldCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  address: Scalars['String'];
  games?: Maybe<GameFieldIdFkeyInverseInput>;
};

/** The `game` to be created by this mutation. */
export type GameFieldIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `field` in the `GameInput` mutation. */
export type GameFieldIdFkeyInput = {
  /** The primary key(s) for `field` for the far side of the relationship. */
  connectById?: Maybe<FieldFieldPkeyConnect>;
  /** The primary key(s) for `field` for the far side of the relationship. */
  connectByNodeId?: Maybe<FieldNodeIdConnect>;
  /** The primary key(s) for `field` for the far side of the relationship. */
  deleteById?: Maybe<FieldFieldPkeyDelete>;
  /** The primary key(s) for `field` for the far side of the relationship. */
  deleteByNodeId?: Maybe<FieldNodeIdDelete>;
  /** The primary key(s) and patch data for `field` for the far side of the relationship. */
  updateById?: Maybe<FieldOnGameForGameFieldIdFkeyUsingFieldPkeyUpdate>;
  /** The primary key(s) and patch data for `field` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameOnGameForGameFieldIdFkeyNodeIdUpdate>;
  /** A `FieldInput` object that will be created and connected to this object. */
  create?: Maybe<GameFieldIdFkeyFieldCreateInput>;
};

/** Input for the nested mutation of `game` in the `FieldInput` mutation. */
export type GameFieldIdFkeyInverseInput = {
  /** Flag indicating whether all other `game` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<Array<GameGamePkeyConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<Array<GameGameNameUniqPerGroupConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameNodeIdConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameGamePkeyDelete>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<Array<GameGameNameUniqPerGroupDelete>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameNodeIdDelete>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<Array<GameOnGameForGameFieldIdFkeyUsingGamePkeyUpdate>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<Array<GameOnGameForGameFieldIdFkeyUsingGameNameUniqPerGroupUpdate>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<FieldOnGameForGameFieldIdFkeyNodeIdUpdate>>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameFieldIdFkeyGameCreateInput>>;
};

/** A filter to be used against `Game` object types. All fields are combined with a logical ‘and.’ */
export type GameFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<UuidFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `fieldId` field. */
  fieldId?: Maybe<UuidFilter>;
  /** Filter by the object’s `score` field. */
  score?: Maybe<IntListFilter>;
  /** Filter by the object’s `gameLength` field. */
  gameLength?: Maybe<IntFilter>;
  /** Filter by the object’s `timeStarted` field. */
  timeStarted?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `timeEnded` field. */
  timeEnded?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `timeSaved` field. */
  timeSaved?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `soloMode` field. */
  soloMode?: Maybe<BooleanFilter>;
  /** Filter by the object’s `manualEntry` field. */
  manualEntry?: Maybe<BooleanFilter>;
  /** Filter by the object’s `legacyMeetup` field. */
  legacyMeetup?: Maybe<BooleanFilter>;
  /** Filter by the object’s `season` field. */
  season?: Maybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GameFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GameFilter>>;
  /** Negates the expression. */
  not?: Maybe<GameFilter>;
};

/** The fields on `game` to look up the row to connect. */
export type GameGameNameUniqPerGroupConnect = {
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to delete. */
export type GameGameNameUniqPerGroupDelete = {
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to connect. */
export type GameGamePkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `game` to look up the row to delete. */
export type GameGamePkeyDelete = {
  id: Scalars['UUID'];
};

/** The `game` to be created by this mutation. */
export type GameGroupIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** The `group` to be created by this mutation. */
export type GameGroupIdFkeyGroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey0InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `group` in the `GameInput` mutation. */
export type GameGroupIdFkeyInput = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByUrlSlug?: Maybe<GroupGroupUrlSlugKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByUrlSlug?: Maybe<GroupGroupUrlSlugKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnGameForGameGroupIdFkeyUsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnGameForGameGroupIdFkeyUsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByUrlSlug?: Maybe<GroupOnGameForGameGroupIdFkeyUsingGroupUrlSlugKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameOnGameForGameGroupIdFkeyNodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<GameGroupIdFkeyGroupCreateInput>;
};

/** Input for the nested mutation of `game` in the `GroupInput` mutation. */
export type GameGroupIdFkeyInverseInput = {
  /** Flag indicating whether all other `game` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<Array<GameGamePkeyConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<Array<GameGameNameUniqPerGroupConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameNodeIdConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameGamePkeyDelete>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<Array<GameGameNameUniqPerGroupDelete>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameNodeIdDelete>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<Array<GameOnGameForGameGroupIdFkeyUsingGamePkeyUpdate>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<Array<GameOnGameForGameGroupIdFkeyUsingGameNameUniqPerGroupUpdate>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GroupOnGameForGameGroupIdFkeyNodeIdUpdate>>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameGroupIdFkeyGameCreateInput>>;
};

/** An input for mutations affecting `Game` */
export type GameInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GameNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GameNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `game` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnAtBatSkipForAtBatSkipGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `atBatSkip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `atBatSkip` being updated. */
  patch: AtBatSkipPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnAtBatSkipForAtBatSkipGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnAtBatSkipForAtBatSkipGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnAtBatSkipForAtBatSkipGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnAtBatSkipForAtBatSkipGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnBaseRunnerForBaseRunnerGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `baseRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: BaseRunnerPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnBaseRunnerForBaseRunnerGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnBaseRunnerForBaseRunnerGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnBaseRunnerForBaseRunnerGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnBaseRunnerForBaseRunnerGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnBasepathMovementForBasepathMovementGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `basepathMovement` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: BasepathMovementPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnBasepathMovementForBasepathMovementGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnBasepathMovementForBasepathMovementGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnBasepathMovementForBasepathMovementGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnBasepathMovementForBasepathMovementGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnEarlyGameEndForEarlyGameEndGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `earlyGameEnd` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `earlyGameEnd` being updated. */
  patch: EarlyGameEndPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnEarlyGameEndForEarlyGameEndGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnEarlyGameEndForEarlyGameEndGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnEarlyGameEndForEarlyGameEndGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnEarlyGameEndForEarlyGameEndGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameBattingStatForFakePublicGameBattingStatsForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameBattingStat` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameBattingStat` being updated. */
  patch: GameBattingStatPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameBattingStatForFakePublicGameBattingStatsForeignKey0UsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameBattingStatForFakePublicGameBattingStatsForeignKey0Patch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameBattingStatForFakePublicGameBattingStatsForeignKey0UsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameBattingStatForFakePublicGameBattingStatsForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameEventForGameEventGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameEventForGameEventGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameEventForGameEventGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameEventForGameEventGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameEventForGameEventGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameEventRecordForGameEventRecordGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameEventRecordForGameEventRecordGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameForGameFieldIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `field` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `field` being updated. */
  patch: FieldPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameForGameFieldIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameForGameFieldIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameForGameFieldIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameForGameFieldIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameForGameGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameForGameGroupIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameForGameGroupIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameForGameGroupIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameForGameGroupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameStateForGameStateGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameStateForGameStateGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameStateForGameStateGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameStateForGameStateGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameStateForGameStateGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnLineupChangeForLineupChangeGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: LineupChangePatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupChangeForLineupChangeGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupChangeForLineupChangeGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupChangeForLineupChangeGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupChangeForLineupChangeGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnLineupForGameStateForLineupForGameStateGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupForGameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: LineupForGameStatePatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupForGameStateForLineupForGameStateGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupForGameStateForLineupForGameStateGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupForGameStateForLineupForGameStateGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupForGameStateForLineupForGameStateGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnLineupForLineupGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: LineupPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupForLineupGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupForLineupGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupForLineupGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupForLineupGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnLineupSpotForLineupSpotGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupSpot` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: LineupSpotPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupSpotForLineupSpotGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupSpotForLineupSpotGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupSpotForLineupSpotGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupSpotForLineupSpotGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnManualEntryBattingLineForManualEntryBattingLineGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `manualEntryBattingLine` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `manualEntryBattingLine` being updated. */
  patch: ManualEntryBattingLinePatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnManualEntryBattingLineForManualEntryBattingLineGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnManualEntryBattingLineForManualEntryBattingLineGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnManualEntryBattingLineForManualEntryBattingLineGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnManualEntryBattingLineForManualEntryBattingLineGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnManualEntryLineScoreCellForManualEntryLineScoreCellGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `manualEntryLineScoreCell` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `manualEntryLineScoreCell` being updated. */
  patch: ManualEntryLineScoreCellPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnManualEntryLineScoreCellForManualEntryLineScoreCellGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnManualEntryLineScoreCellForManualEntryLineScoreCellGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnManualEntryLineScoreCellForManualEntryLineScoreCellGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnManualEntryLineScoreCellForManualEntryLineScoreCellGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnManualEntryPitchingLineForManualEntryPitchingLineGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `manualEntryPitchingLine` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `manualEntryPitchingLine` being updated. */
  patch: ManualEntryPitchingLinePatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnManualEntryPitchingLineForManualEntryPitchingLineGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnManualEntryPitchingLineForManualEntryPitchingLineGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnManualEntryPitchingLineForManualEntryPitchingLineGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnManualEntryPitchingLineForManualEntryPitchingLineGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `outOnPlayRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: OutOnPlayRunnerPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnPlateAppearanceForPlateAppearanceGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnPlateAppearanceForPlateAppearanceGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnPlateAppearanceForPlateAppearanceGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnPlateAppearanceForPlateAppearanceGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnPlateAppearanceForPlateAppearanceGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnScoredRunnerForScoredRunnerGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scoredRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: ScoredRunnerPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnScoredRunnerForScoredRunnerGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnScoredRunnerForScoredRunnerGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnScoredRunnerForScoredRunnerGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnScoredRunnerForScoredRunnerGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `soloModeOpponentInning` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `soloModeOpponentInning` being updated. */
  patch: SoloModeOpponentInningPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `stolenBaseAttempt` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: StolenBaseAttemptPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnTeamForTeamGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `team` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: TeamPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnTeamForTeamGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnTeamForTeamGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnTeamForTeamGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnTeamForTeamGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Game`. Fields that are set will be updated. */
export type GamePatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

export type GameState = Node & {
  __typename?: 'GameState';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  gameId: Scalars['UUID'];
  gameStateIndex: Scalars['Int'];
  playerAtBat: Scalars['UUID'];
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  /** Reads a single `Game` that is related to this `GameState`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `GameState`. */
  playerByPlayerAtBat: Maybe<Player>;
  /** Reads and enables pagination through a set of `BaseRunner`. */
  baseRunners: Array<BaseRunner>;
  /** Reads and enables pagination through a set of `LineupForGameState`. */
  lineupForGameStates: Array<LineupForGameState>;
  /** Reads and enables pagination through a set of `GameEventRecord`. */
  gameEventRecordsByGameStateBeforeId: Array<GameEventRecord>;
  /** Reads and enables pagination through a set of `GameEventRecord`. */
  gameEventRecordsByGameStateAfterId: Array<GameEventRecord>;
  /** Reads and enables pagination through a set of `Lineup`. */
  lineups: Maybe<Array<Maybe<Lineup>>>;
};


export type GameStateBaseRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BaseRunnersOrderBy>>;
  condition?: Maybe<BaseRunnerCondition>;
  filter?: Maybe<BaseRunnerFilter>;
};


export type GameStateLineupForGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupForGameStatesOrderBy>>;
  condition?: Maybe<LineupForGameStateCondition>;
  filter?: Maybe<LineupForGameStateFilter>;
};


export type GameStateGameEventRecordsByGameStateBeforeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventRecordsOrderBy>>;
  condition?: Maybe<GameEventRecordCondition>;
  filter?: Maybe<GameEventRecordFilter>;
};


export type GameStateGameEventRecordsByGameStateAfterIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventRecordsOrderBy>>;
  condition?: Maybe<GameEventRecordCondition>;
  filter?: Maybe<GameEventRecordFilter>;
};


export type GameStateLineupsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  filter?: Maybe<LineupFilter>;
};

/**
 * A condition to be used against `GameState` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GameStateCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameStateIndex` field. */
  gameStateIndex?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerAtBat` field. */
  playerAtBat?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `inning` field. */
  inning?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `halfInning` field. */
  halfInning?: Maybe<HalfInning>;
  /** Checks for equality with the object’s `outs` field. */
  outs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `score` field. */
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
};

/** A filter to be used against `GameState` object types. All fields are combined with a logical ‘and.’ */
export type GameStateFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Filter by the object’s `gameStateIndex` field. */
  gameStateIndex?: Maybe<IntFilter>;
  /** Filter by the object’s `playerAtBat` field. */
  playerAtBat?: Maybe<UuidFilter>;
  /** Filter by the object’s `inning` field. */
  inning?: Maybe<IntFilter>;
  /** Filter by the object’s `halfInning` field. */
  halfInning?: Maybe<HalfInningFilter>;
  /** Filter by the object’s `outs` field. */
  outs?: Maybe<IntFilter>;
  /** Filter by the object’s `score` field. */
  score?: Maybe<IntListFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GameStateFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GameStateFilter>>;
  /** Negates the expression. */
  not?: Maybe<GameStateFilter>;
};

/** The `game` to be created by this mutation. */
export type GameStateGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** The `gameState` to be created by this mutation. */
export type GameStateGameIdFkeyGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `game` in the `GameStateInput` mutation. */
export type GameStateGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnGameStateForGameStateGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnGameStateForGameStateGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameStateOnGameStateForGameStateGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<GameStateGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `gameState` in the `GameInput` mutation. */
export type GameStateGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameState` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<Array<GameStateGameStatePkeyConnect>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameStateNodeIdConnect>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameStateGameStatePkeyDelete>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameStateNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<Array<GameStateOnGameStateForGameStateGameIdFkeyUsingGameStatePkeyUpdate>>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnGameStateForGameStateGameIdFkeyNodeIdUpdate>>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameStateGameIdFkeyGameStateCreateInput>>;
};

/** The fields on `gameState` to look up the row to connect. */
export type GameStateGameStatePkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `gameState` to look up the row to delete. */
export type GameStateGameStatePkeyDelete = {
  id: Scalars['UUID'];
};

/** An input for mutations affecting `GameState` */
export type GameStateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GameStateNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GameStateNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `gameState` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `baseRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: BaseRunnerPatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnGameEventRecordForGameEventRecordGameStateAfterFkPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnGameStateForGameStateGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnGameStateForGameStateGameIdFkeyUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnGameStateForGameStateGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnGameStateForGameStatePlayerAtBatFkeyUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnGameStateForGameStatePlayerAtBatFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupForGameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: LineupForGameStatePatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `GameState`. Fields that are set will be updated. */
export type GameStatePatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** The `gameState` to be created by this mutation. */
export type GameStatePlayerAtBatFkeyGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `player` in the `GameStateInput` mutation. */
export type GameStatePlayerAtBatFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameStateOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<GameStatePlayerAtBatFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `gameState` in the `PlayerInput` mutation. */
export type GameStatePlayerAtBatFkeyInverseInput = {
  /** Flag indicating whether all other `gameState` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<Array<GameStateGameStatePkeyConnect>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameStateNodeIdConnect>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameStateGameStatePkeyDelete>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameStateNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<Array<GameStateOnGameStateForGameStatePlayerAtBatFkeyUsingGameStatePkeyUpdate>>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate>>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameStatePlayerAtBatFkeyGameStateCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type GameStatePlayerAtBatFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** Methods to use when ordering `GameState`. */
export enum GameStatesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  GAME_STATE_INDEX_ASC = 'GAME_STATE_INDEX_ASC',
  GAME_STATE_INDEX_DESC = 'GAME_STATE_INDEX_DESC',
  PLAYER_AT_BAT_ASC = 'PLAYER_AT_BAT_ASC',
  PLAYER_AT_BAT_DESC = 'PLAYER_AT_BAT_DESC',
  INNING_ASC = 'INNING_ASC',
  INNING_DESC = 'INNING_DESC',
  HALF_INNING_ASC = 'HALF_INNING_ASC',
  HALF_INNING_DESC = 'HALF_INNING_DESC',
  OUTS_ASC = 'OUTS_ASC',
  OUTS_DESC = 'OUTS_DESC',
  SCORE_ASC = 'SCORE_ASC',
  SCORE_DESC = 'SCORE_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** Methods to use when ordering `Game`. */
export enum GamesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  FIELD_ID_ASC = 'FIELD_ID_ASC',
  FIELD_ID_DESC = 'FIELD_ID_DESC',
  SCORE_ASC = 'SCORE_ASC',
  SCORE_DESC = 'SCORE_DESC',
  GAME_LENGTH_ASC = 'GAME_LENGTH_ASC',
  GAME_LENGTH_DESC = 'GAME_LENGTH_DESC',
  TIME_STARTED_ASC = 'TIME_STARTED_ASC',
  TIME_STARTED_DESC = 'TIME_STARTED_DESC',
  TIME_ENDED_ASC = 'TIME_ENDED_ASC',
  TIME_ENDED_DESC = 'TIME_ENDED_DESC',
  TIME_SAVED_ASC = 'TIME_SAVED_ASC',
  TIME_SAVED_DESC = 'TIME_SAVED_DESC',
  SOLO_MODE_ASC = 'SOLO_MODE_ASC',
  SOLO_MODE_DESC = 'SOLO_MODE_DESC',
  MANUAL_ENTRY_ASC = 'MANUAL_ENTRY_ASC',
  MANUAL_ENTRY_DESC = 'MANUAL_ENTRY_DESC',
  LEGACY_MEETUP_ASC = 'LEGACY_MEETUP_ASC',
  LEGACY_MEETUP_DESC = 'LEGACY_MEETUP_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export enum Gender {
  MALE = 'MALE',
  FEMALE = 'FEMALE'
}

/** A filter to be used against Gender fields. All fields are combined with a logical ‘and.’ */
export type GenderFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Gender>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Gender>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Gender>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Gender>;
  /** Included in the specified list. */
  in?: Maybe<Array<Gender>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Gender>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Gender>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Gender>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Gender>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Gender>;
};

/** The return type of our `getPlateAppearancesConnection` query. */
export type GetPlateAppearancesRecord = {
  __typename?: 'GetPlateAppearancesRecord';
  gameId: Maybe<Scalars['UUID']>;
  gameStartTime: Maybe<Scalars['Datetime']>;
  playerId: Maybe<Scalars['UUID']>;
  type: Maybe<PlateAppearanceType>;
  contact: Maybe<ContactQuality>;
  hitTo: Maybe<FieldingPosition>;
  runsScored: Maybe<Scalars['Int']>;
  inning: Maybe<Scalars['Int']>;
  halfInning: Maybe<HalfInning>;
  gameStateBeforeId: Maybe<Scalars['UUID']>;
  gameEventRecordId: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `GetPlateAppearancesRecord` object types. All fields are combined with a logical ‘and.’ */
export type GetPlateAppearancesRecordFilter = {
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Filter by the object’s `gameStartTime` field. */
  gameStartTime?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `playerId` field. */
  playerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<PlateAppearanceTypeFilter>;
  /** Filter by the object’s `contact` field. */
  contact?: Maybe<ContactQualityFilter>;
  /** Filter by the object’s `hitTo` field. */
  hitTo?: Maybe<FieldingPositionFilter>;
  /** Filter by the object’s `runsScored` field. */
  runsScored?: Maybe<IntFilter>;
  /** Filter by the object’s `inning` field. */
  inning?: Maybe<IntFilter>;
  /** Filter by the object’s `halfInning` field. */
  halfInning?: Maybe<HalfInningFilter>;
  /** Filter by the object’s `gameStateBeforeId` field. */
  gameStateBeforeId?: Maybe<UuidFilter>;
  /** Filter by the object’s `gameEventRecordId` field. */
  gameEventRecordId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GetPlateAppearancesRecordFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GetPlateAppearancesRecordFilter>>;
  /** Negates the expression. */
  not?: Maybe<GetPlateAppearancesRecordFilter>;
};

/** The return type of our `getRunsScoredConnection` query. */
export type GetRunsScoredRecord = {
  __typename?: 'GetRunsScoredRecord';
  batterId: Maybe<Scalars['UUID']>;
  runnerId: Maybe<Scalars['UUID']>;
  battedIn: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `GetRunsScoredRecord` object types. All fields are combined with a logical ‘and.’ */
export type GetRunsScoredRecordFilter = {
  /** Filter by the object’s `batterId` field. */
  batterId?: Maybe<UuidFilter>;
  /** Filter by the object’s `runnerId` field. */
  runnerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `battedIn` field. */
  battedIn?: Maybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GetRunsScoredRecordFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GetRunsScoredRecordFilter>>;
  /** Negates the expression. */
  not?: Maybe<GetRunsScoredRecordFilter>;
};

export type Group = Node & {
  __typename?: 'Group';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  name: Scalars['String'];
  notes: Maybe<Scalars['String']>;
  soloMode: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats: Maybe<Scalars['Boolean']>;
  allowSteals: Maybe<Scalars['Boolean']>;
  /** Reads and enables pagination through a set of `Game`. */
  games: Array<Game>;
  /** Reads and enables pagination through a set of `PlayerGroupMembership`. */
  playerGroupMemberships: Array<PlayerGroupMembership>;
  /** Reads and enables pagination through a set of `CareerBattingStat`. */
  careerBattingStats: Array<CareerBattingStat>;
  /** Reads and enables pagination through a set of `SeasonBattingStat`. */
  seasonBattingStats: Array<SeasonBattingStat>;
  allSeasons: Maybe<Array<Maybe<Scalars['Int']>>>;
  gamesInSeason: Maybe<Scalars['Int']>;
  /** Reads and enables pagination through a set of `Player`. */
  players: Maybe<Array<Maybe<Player>>>;
};


export type GroupGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GamesOrderBy>>;
  condition?: Maybe<GameCondition>;
  filter?: Maybe<GameFilter>;
};


export type GroupPlayerGroupMembershipsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlayerGroupMembershipsOrderBy>>;
  condition?: Maybe<PlayerGroupMembershipCondition>;
  filter?: Maybe<PlayerGroupMembershipFilter>;
};


export type GroupCareerBattingStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerBattingStatsOrderBy>>;
  condition?: Maybe<CareerBattingStatCondition>;
  filter?: Maybe<CareerBattingStatFilter>;
};


export type GroupSeasonBattingStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonBattingStatsOrderBy>>;
  condition?: Maybe<SeasonBattingStatCondition>;
  filter?: Maybe<SeasonBattingStatFilter>;
};


export type GroupAllSeasonsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  filter?: Maybe<IntFilter>;
};


export type GroupGamesInSeasonArgs = {
  season?: Maybe<Scalars['Int']>;
};


export type GroupPlayersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  filter?: Maybe<PlayerFilter>;
};

/** A condition to be used against `Group` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GroupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `soloMode` field. */
  soloMode?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `urlSlug` field. */
  urlSlug?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `allowSkippingAtBats` field. */
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `allowSteals` field. */
  allowSteals?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `Group` object types. All fields are combined with a logical ‘and.’ */
export type GroupFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `notes` field. */
  notes?: Maybe<StringFilter>;
  /** Filter by the object’s `soloMode` field. */
  soloMode?: Maybe<BooleanFilter>;
  /** Filter by the object’s `urlSlug` field. */
  urlSlug?: Maybe<StringFilter>;
  /** Filter by the object’s `allowSkippingAtBats` field. */
  allowSkippingAtBats?: Maybe<BooleanFilter>;
  /** Filter by the object’s `allowSteals` field. */
  allowSteals?: Maybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<GroupFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<GroupFilter>>;
  /** Negates the expression. */
  not?: Maybe<GroupFilter>;
};

/** The fields on `group` to look up the row to connect. */
export type GroupGroupNameKeyConnect = {
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to delete. */
export type GroupGroupNameKeyDelete = {
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to connect. */
export type GroupGroupPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to delete. */
export type GroupGroupPkeyDelete = {
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to connect. */
export type GroupGroupUrlSlugKeyConnect = {
  urlSlug: Scalars['String'];
};

/** The fields on `group` to look up the row to delete. */
export type GroupGroupUrlSlugKeyDelete = {
  urlSlug: Scalars['String'];
};

/** An input for mutations affecting `Group` */
export type GroupInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey0InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GroupNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GroupNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `group` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GroupOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `careerBattingStat` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `careerBattingStat` being updated. */
  patch: CareerBattingStatPatch;
};

/** The fields on `group` to look up the row to update. */
export type GroupOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0UsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0Patch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0UsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0UsingGroupUrlSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0Patch;
  urlSlug: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type GroupOnGameForGameGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `group` to look up the row to update. */
export type GroupOnGameForGameGroupIdFkeyUsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnGameForGameGroupIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnGameForGameGroupIdFkeyUsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnGameForGameGroupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnGameForGameGroupIdFkeyUsingGroupUrlSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnGameForGameGroupIdFkeyPatch;
  urlSlug: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `playerGroupMembership` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `playerGroupMembership` being updated. */
  patch: PlayerGroupMembershipPatch;
};

/** The fields on `group` to look up the row to update. */
export type GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingGroupUrlSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyPatch;
  urlSlug: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type GroupOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `seasonBattingStat` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `seasonBattingStat` being updated. */
  patch: SeasonBattingStatPatch;
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0UsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0Patch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0UsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0UsingGroupUrlSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0Patch;
  urlSlug: Scalars['String'];
};

/** Represents an update to a `Group`. Fields that are set will be updated. */
export type GroupPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey0InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey0InverseInput>;
};

export enum GroupPermissionType {
  SAVE_GAMES = 'SAVE_GAMES',
  DRAFT_TEAMS = 'DRAFT_TEAMS',
  ADD_PLAYERS_TO_GROUP = 'ADD_PLAYERS_TO_GROUP'
}

/** A filter to be used against GroupPermissionType fields. All fields are combined with a logical ‘and.’ */
export type GroupPermissionTypeFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<GroupPermissionType>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<GroupPermissionType>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<GroupPermissionType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<GroupPermissionType>;
  /** Included in the specified list. */
  in?: Maybe<Array<GroupPermissionType>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<GroupPermissionType>>;
  /** Less than the specified value. */
  lessThan?: Maybe<GroupPermissionType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<GroupPermissionType>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<GroupPermissionType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<GroupPermissionType>;
};

/** Methods to use when ordering `Group`. */
export enum GroupsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  NOTES_ASC = 'NOTES_ASC',
  NOTES_DESC = 'NOTES_DESC',
  SOLO_MODE_ASC = 'SOLO_MODE_ASC',
  SOLO_MODE_DESC = 'SOLO_MODE_DESC',
  URL_SLUG_ASC = 'URL_SLUG_ASC',
  URL_SLUG_DESC = 'URL_SLUG_DESC',
  ALLOW_SKIPPING_AT_BATS_ASC = 'ALLOW_SKIPPING_AT_BATS_ASC',
  ALLOW_SKIPPING_AT_BATS_DESC = 'ALLOW_SKIPPING_AT_BATS_DESC',
  ALLOW_STEALS_ASC = 'ALLOW_STEALS_ASC',
  ALLOW_STEALS_DESC = 'ALLOW_STEALS_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export enum HalfInning {
  TOP = 'TOP',
  BOTTOM = 'BOTTOM'
}

/** A filter to be used against HalfInning fields. All fields are combined with a logical ‘and.’ */
export type HalfInningFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<HalfInning>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<HalfInning>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<HalfInning>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<HalfInning>;
  /** Included in the specified list. */
  in?: Maybe<Array<HalfInning>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<HalfInning>>;
  /** Less than the specified value. */
  lessThan?: Maybe<HalfInning>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<HalfInning>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<HalfInning>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<HalfInning>;
};

export enum Handedness {
  LEFT = 'LEFT',
  RIGHT = 'RIGHT',
  BOTH = 'BOTH'
}

/** A filter to be used against Handedness fields. All fields are combined with a logical ‘and.’ */
export type HandednessFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Handedness>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Handedness>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Handedness>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Handedness>;
  /** Included in the specified list. */
  in?: Maybe<Array<Handedness>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Handedness>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Handedness>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Handedness>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Handedness>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Handedness>;
};

/** All input for the `initiatePasswordReset` mutation. */
export type InitiatePasswordResetInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  email: Scalars['String'];
};

/** The output of our `initiatePasswordReset` mutation. */
export type InitiatePasswordResetPayload = {
  __typename?: 'InitiatePasswordResetPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `initiatePlayerClaim` mutation. */
export type InitiatePlayerClaimInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  playerId: Scalars['UUID'];
  email: Scalars['String'];
};

/** The output of our `initiatePlayerClaim` mutation. */
export type InitiatePlayerClaimPayload = {
  __typename?: 'InitiatePlayerClaimPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  boolean: Maybe<Scalars['Boolean']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Int']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Int']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Int']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Int']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Int']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Int']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Int']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Int']>;
};

/** A filter to be used against Int List fields. All fields are combined with a logical ‘and.’ */
export type IntListFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Array<Maybe<Scalars['Int']>>>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Array<Maybe<Scalars['Int']>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Array<Maybe<Scalars['Int']>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Array<Maybe<Scalars['Int']>>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Array<Maybe<Scalars['Int']>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Array<Maybe<Scalars['Int']>>>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Array<Maybe<Scalars['Int']>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Array<Maybe<Scalars['Int']>>>;
  /** Contains the specified list of values. */
  contains?: Maybe<Array<Maybe<Scalars['Int']>>>;
  /** Contained by the specified list of values. */
  containedBy?: Maybe<Array<Maybe<Scalars['Int']>>>;
  /** Overlaps the specified list of values. */
  overlaps?: Maybe<Array<Maybe<Scalars['Int']>>>;
  /** Any array item is equal to the specified value. */
  anyEqualTo?: Maybe<Scalars['Int']>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: Maybe<Scalars['Int']>;
  /** Any array item is less than the specified value. */
  anyLessThan?: Maybe<Scalars['Int']>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: Maybe<Scalars['Int']>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: Maybe<Scalars['Int']>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: Maybe<Scalars['Int']>;
};


/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JsonFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['JSON']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['JSON']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['JSON']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['JSON']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['JSON']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['JSON']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['JSON']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['JSON']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['JSON']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['JSON']>;
  /** Contains the specified JSON. */
  contains?: Maybe<Scalars['JSON']>;
  /** Contains the specified key. */
  containsKey?: Maybe<Scalars['String']>;
  /** Contains all of the specified keys. */
  containsAllKeys?: Maybe<Array<Scalars['String']>>;
  /** Contains any of the specified keys. */
  containsAnyKeys?: Maybe<Array<Scalars['String']>>;
  /** Contained by the specified JSON. */
  containedBy?: Maybe<Scalars['JSON']>;
};


export type LineScoreCell = {
  __typename?: 'LineScoreCell';
  inning: Maybe<Scalars['Int']>;
  halfInning: Maybe<HalfInning>;
  runs: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
};

/** A filter to be used against `LineScoreCell` object types. All fields are combined with a logical ‘and.’ */
export type LineScoreCellFilter = {
  /** Filter by the object’s `inning` field. */
  inning?: Maybe<IntFilter>;
  /** Filter by the object’s `halfInning` field. */
  halfInning?: Maybe<HalfInningFilter>;
  /** Filter by the object’s `runs` field. */
  runs?: Maybe<IntFilter>;
  /** Filter by the object’s `hits` field. */
  hits?: Maybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<LineScoreCellFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<LineScoreCellFilter>>;
  /** Negates the expression. */
  not?: Maybe<LineScoreCellFilter>;
};

export type Lineup = Node & {
  __typename?: 'Lineup';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  teamId: Scalars['UUID'];
  gameId: Scalars['UUID'];
  /** Reads a single `Team` that is related to this `Lineup`. */
  team: Maybe<Team>;
  /** Reads a single `Game` that is related to this `Lineup`. */
  game: Maybe<Game>;
  /** Reads and enables pagination through a set of `LineupSpot`. */
  lineupSpots: Array<LineupSpot>;
  /** Reads and enables pagination through a set of `LineupChange`. */
  lineupChangesByLineupBeforeId: Array<LineupChange>;
  /** Reads and enables pagination through a set of `LineupChange`. */
  lineupChangesByLineupAfterId: Array<LineupChange>;
  /** Reads and enables pagination through a set of `LineupForGameState`. */
  lineupForGameStates: Array<LineupForGameState>;
};


export type LineupLineupSpotsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupSpotsOrderBy>>;
  condition?: Maybe<LineupSpotCondition>;
  filter?: Maybe<LineupSpotFilter>;
};


export type LineupLineupChangesByLineupBeforeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupChangesOrderBy>>;
  condition?: Maybe<LineupChangeCondition>;
  filter?: Maybe<LineupChangeFilter>;
};


export type LineupLineupChangesByLineupAfterIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupChangesOrderBy>>;
  condition?: Maybe<LineupChangeCondition>;
  filter?: Maybe<LineupChangeFilter>;
};


export type LineupLineupForGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupForGameStatesOrderBy>>;
  condition?: Maybe<LineupForGameStateCondition>;
  filter?: Maybe<LineupForGameStateFilter>;
};

export type LineupChange = Node & {
  __typename?: 'LineupChange';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  lineupBeforeId: Scalars['UUID'];
  lineupAfterId: Scalars['UUID'];
  gameId: Scalars['UUID'];
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupBefore: Maybe<Lineup>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupAfter: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupChange`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `LineupChange` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LineupChangeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `lineupBeforeId` field. */
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `lineupAfterId` field. */
  lineupAfterId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `LineupChange` object types. All fields are combined with a logical ‘and.’ */
export type LineupChangeFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `lineupBeforeId` field. */
  lineupBeforeId?: Maybe<UuidFilter>;
  /** Filter by the object’s `lineupAfterId` field. */
  lineupAfterId?: Maybe<UuidFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<LineupChangeFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<LineupChangeFilter>>;
  /** Negates the expression. */
  not?: Maybe<LineupChangeFilter>;
};

/** The `game` to be created by this mutation. */
export type LineupChangeGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `LineupChangeInput` mutation. */
export type LineupChangeGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnLineupChangeForLineupChangeGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnLineupChangeForLineupChangeGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupChangeOnLineupChangeForLineupChangeGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<LineupChangeGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `lineupChange` in the `GameInput` mutation. */
export type LineupChangeGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupChange` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectById?: Maybe<Array<LineupChangeLineupChangePkeyConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupChangeNodeIdConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteById?: Maybe<Array<LineupChangeLineupChangePkeyDelete>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupChangeNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateById?: Maybe<Array<LineupChangeOnLineupChangeForLineupChangeGameIdFkeyUsingLineupChangePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnLineupChangeForLineupChangeGameIdFkeyNodeIdUpdate>>;
  /** A `LineupChangeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupChangeGameIdFkeyLineupChangeCreateInput>>;
};

/** The `lineupChange` to be created by this mutation. */
export type LineupChangeGameIdFkeyLineupChangeCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** An input for mutations affecting `LineupChange` */
export type LineupChangeInput = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** Input for the nested mutation of `lineup` in the `LineupChangeInput` mutation. */
export type LineupChangeLineupAfterIdFkeyInput = {
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectById?: Maybe<LineupLineupPkeyConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectByNodeId?: Maybe<LineupNodeIdConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteById?: Maybe<LineupLineupPkeyDelete>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LineupNodeIdDelete>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateById?: Maybe<LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupPkeyUpdate>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate>;
  /** A `LineupInput` object that will be created and connected to this object. */
  create?: Maybe<LineupChangeLineupAfterIdFkeyLineupCreateInput>;
};

/** Input for the nested mutation of `lineupChange` in the `LineupInput` mutation. */
export type LineupChangeLineupAfterIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupChange` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectById?: Maybe<Array<LineupChangeLineupChangePkeyConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupChangeNodeIdConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteById?: Maybe<Array<LineupChangeLineupChangePkeyDelete>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupChangeNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateById?: Maybe<Array<LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupChangePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate>>;
  /** A `LineupChangeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupChangeLineupAfterIdFkeyLineupChangeCreateInput>>;
};

/** The `lineupChange` to be created by this mutation. */
export type LineupChangeLineupAfterIdFkeyLineupChangeCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** The `lineup` to be created by this mutation. */
export type LineupChangeLineupAfterIdFkeyLineupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** Input for the nested mutation of `lineupChange` in the `LineupInput` mutation. */
export type LineupChangeLineupBeforeIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupChange` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectById?: Maybe<Array<LineupChangeLineupChangePkeyConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupChangeNodeIdConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteById?: Maybe<Array<LineupChangeLineupChangePkeyDelete>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupChangeNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateById?: Maybe<Array<LineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyUsingLineupChangePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LineupOnLineupChangeForLineupChangeLineupBeforeIdFkeyNodeIdUpdate>>;
  /** A `LineupChangeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupChangeLineupBeforeIdFkeyLineupChangeCreateInput>>;
};

/** The `lineupChange` to be created by this mutation. */
export type LineupChangeLineupBeforeIdFkeyLineupChangeCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** The fields on `lineupChange` to look up the row to connect. */
export type LineupChangeLineupChangePkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `lineupChange` to look up the row to delete. */
export type LineupChangeLineupChangePkeyDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LineupChangeNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LineupChangeNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupChangeOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `lineupChange` to look up the row to update. */
export type LineupChangeOnGameEventForGameEventLineupChangeIdFkeyUsingLineupChangePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: UpdateLineupChangeOnGameEventForGameEventLineupChangeIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupChangeOnLineupChangeForLineupChangeGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `lineupChange` to look up the row to update. */
export type LineupChangeOnLineupChangeForLineupChangeGameIdFkeyUsingLineupChangePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: UpdateLineupChangeOnLineupChangeForLineupChangeGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: LineupPatch;
};

/** The fields on `lineupChange` to look up the row to update. */
export type LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupChangePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: UpdateLineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `lineupChange` to look up the row to update. */
export type LineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyUsingLineupChangePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: UpdateLineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `LineupChange`. Fields that are set will be updated. */
export type LineupChangePatch = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** Methods to use when ordering `LineupChange`. */
export enum LineupChangesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  LINEUP_BEFORE_ID_ASC = 'LINEUP_BEFORE_ID_ASC',
  LINEUP_BEFORE_ID_DESC = 'LINEUP_BEFORE_ID_DESC',
  LINEUP_AFTER_ID_ASC = 'LINEUP_AFTER_ID_ASC',
  LINEUP_AFTER_ID_DESC = 'LINEUP_AFTER_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `Lineup` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type LineupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `Lineup` object types. All fields are combined with a logical ‘and.’ */
export type LineupFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `teamId` field. */
  teamId?: Maybe<UuidFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<LineupFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<LineupFilter>>;
  /** Negates the expression. */
  not?: Maybe<LineupFilter>;
};

export type LineupForGameState = Node & {
  __typename?: 'LineupForGameState';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
  gameId: Scalars['UUID'];
  /** Reads a single `GameState` that is related to this `LineupForGameState`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Lineup` that is related to this `LineupForGameState`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupForGameState`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `LineupForGameState` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LineupForGameStateCondition = {
  /** Checks for equality with the object’s `gameStateId` field. */
  gameStateId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `lineupId` field. */
  lineupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `LineupForGameState` object types. All fields are combined with a logical ‘and.’ */
export type LineupForGameStateFilter = {
  /** Filter by the object’s `gameStateId` field. */
  gameStateId?: Maybe<UuidFilter>;
  /** Filter by the object’s `lineupId` field. */
  lineupId?: Maybe<UuidFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<LineupForGameStateFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<LineupForGameStateFilter>>;
  /** Negates the expression. */
  not?: Maybe<LineupForGameStateFilter>;
};

/** The `game` to be created by this mutation. */
export type LineupForGameStateGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `LineupForGameStateInput` mutation. */
export type LineupForGameStateGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnLineupForGameStateForLineupForGameStateGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnLineupForGameStateForLineupForGameStateGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupForGameStateOnLineupForGameStateForLineupForGameStateGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<LineupForGameStateGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `lineupForGameState` in the `GameInput` mutation. */
export type LineupForGameStateGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupForGameState` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupForGameStateNodeIdConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyDelete>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupForGameStateNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateOnLineupForGameStateForLineupForGameStateGameIdFkeyUsingLineupForGameStatePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnLineupForGameStateForLineupForGameStateGameIdFkeyNodeIdUpdate>>;
  /** A `LineupForGameStateInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupForGameStateGameIdFkeyLineupForGameStateCreateInput>>;
};

/** The `lineupForGameState` to be created by this mutation. */
export type LineupForGameStateGameIdFkeyLineupForGameStateCreateInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  lineupId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** The `gameState` to be created by this mutation. */
export type LineupForGameStateGameStateIdFkeyGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `gameState` in the `LineupForGameStateInput` mutation. */
export type LineupForGameStateGameStateIdFkeyInput = {
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<GameStateGameStatePkeyConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameStateNodeIdConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<GameStateGameStatePkeyDelete>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameStateNodeIdDelete>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingGameStatePkeyUpdate>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<LineupForGameStateGameStateIdFkeyGameStateCreateInput>;
};

/** Input for the nested mutation of `lineupForGameState` in the `GameStateInput` mutation. */
export type LineupForGameStateGameStateIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupForGameState` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupForGameStateNodeIdConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyDelete>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupForGameStateNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingLineupForGameStatePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate>>;
  /** A `LineupForGameStateInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupForGameStateGameStateIdFkeyLineupForGameStateCreateInput>>;
};

/** The `lineupForGameState` to be created by this mutation. */
export type LineupForGameStateGameStateIdFkeyLineupForGameStateCreateInput = {
  lineupId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** An input for mutations affecting `LineupForGameState` */
export type LineupForGameStateInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  lineupId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** The fields on `lineupForGameState` to look up the row to connect. */
export type LineupForGameStateLineupForGameStatePkeyConnect = {
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** The fields on `lineupForGameState` to look up the row to delete. */
export type LineupForGameStateLineupForGameStatePkeyDelete = {
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** Input for the nested mutation of `lineup` in the `LineupForGameStateInput` mutation. */
export type LineupForGameStateLineupIdFkeyInput = {
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectById?: Maybe<LineupLineupPkeyConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectByNodeId?: Maybe<LineupNodeIdConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteById?: Maybe<LineupLineupPkeyDelete>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LineupNodeIdDelete>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateById?: Maybe<LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupPkeyUpdate>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate>;
  /** A `LineupInput` object that will be created and connected to this object. */
  create?: Maybe<LineupForGameStateLineupIdFkeyLineupCreateInput>;
};

/** Input for the nested mutation of `lineupForGameState` in the `LineupInput` mutation. */
export type LineupForGameStateLineupIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupForGameState` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupForGameStateNodeIdConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyDelete>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupForGameStateNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupForGameStatePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate>>;
  /** A `LineupForGameStateInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupForGameStateLineupIdFkeyLineupForGameStateCreateInput>>;
};

/** The `lineup` to be created by this mutation. */
export type LineupForGameStateLineupIdFkeyLineupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** The `lineupForGameState` to be created by this mutation. */
export type LineupForGameStateLineupIdFkeyLineupForGameStateCreateInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type LineupForGameStateNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `lineupForGameState` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LineupForGameStateNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `lineupForGameState` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `lineupForGameState` to look up the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateGameIdFkeyUsingLineupForGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateGameIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `lineupForGameState` to look up the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingLineupForGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: LineupPatch;
};

/** The fields on `lineupForGameState` to look up the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupForGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** Represents an update to a `LineupForGameState`. Fields that are set will be updated. */
export type LineupForGameStatePatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  lineupId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** Methods to use when ordering `LineupForGameState`. */
export enum LineupForGameStatesOrderBy {
  NATURAL = 'NATURAL',
  GAME_STATE_ID_ASC = 'GAME_STATE_ID_ASC',
  GAME_STATE_ID_DESC = 'GAME_STATE_ID_DESC',
  LINEUP_ID_ASC = 'LINEUP_ID_ASC',
  LINEUP_ID_DESC = 'LINEUP_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** The `game` to be created by this mutation. */
export type LineupGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `LineupInput` mutation. */
export type LineupGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnLineupForLineupGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnLineupForLineupGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupOnLineupForLineupGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<LineupGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `lineup` in the `GameInput` mutation. */
export type LineupGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineup` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectById?: Maybe<Array<LineupLineupPkeyConnect>>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupNodeIdConnect>>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteById?: Maybe<Array<LineupLineupPkeyDelete>>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateById?: Maybe<Array<LineupOnLineupForLineupGameIdFkeyUsingLineupPkeyUpdate>>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnLineupForLineupGameIdFkeyNodeIdUpdate>>;
  /** A `LineupInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupGameIdFkeyLineupCreateInput>>;
};

/** The `lineup` to be created by this mutation. */
export type LineupGameIdFkeyLineupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An input for mutations affecting `Lineup` */
export type LineupInput = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** The fields on `lineup` to look up the row to connect. */
export type LineupLineupPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `lineup` to look up the row to delete. */
export type LineupLineupPkeyDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LineupNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LineupNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `lineup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: LineupChangePatch;
};

/** The fields on `lineup` to look up the row to update. */
export type LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: UpdateLineupOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupChangeForLineupChangeLineupBeforeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: LineupChangePatch;
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupForGameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: LineupForGameStatePatch;
};

/** The fields on `lineup` to look up the row to update. */
export type LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: UpdateLineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupForLineupGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `lineup` to look up the row to update. */
export type LineupOnLineupForLineupGameIdFkeyUsingLineupPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: UpdateLineupOnLineupForLineupGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupForLineupTeamIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `team` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: TeamPatch;
};

/** The fields on `lineup` to look up the row to update. */
export type LineupOnLineupForLineupTeamIdFkeyUsingLineupPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: UpdateLineupOnLineupForLineupTeamIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupSpot` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: LineupSpotPatch;
};

/** The fields on `lineup` to look up the row to update. */
export type LineupOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: UpdateLineupOnLineupSpotForLineupSpotLineupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Lineup`. Fields that are set will be updated. */
export type LineupPatch = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

export type LineupSpot = Node & {
  __typename?: 'LineupSpot';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
  position: Maybe<FieldingPosition>;
  gameId: Scalars['UUID'];
  /** Reads a single `Lineup` that is related to this `LineupSpot`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Player` that is related to this `LineupSpot`. */
  player: Maybe<Player>;
  /** Reads a single `Game` that is related to this `LineupSpot`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `LineupSpot` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LineupSpotCondition = {
  /** Checks for equality with the object’s `lineupId` field. */
  lineupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `battingOrder` field. */
  battingOrder?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `position` field. */
  position?: Maybe<FieldingPosition>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `LineupSpot` object types. All fields are combined with a logical ‘and.’ */
export type LineupSpotFilter = {
  /** Filter by the object’s `lineupId` field. */
  lineupId?: Maybe<UuidFilter>;
  /** Filter by the object’s `playerId` field. */
  playerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `battingOrder` field. */
  battingOrder?: Maybe<IntFilter>;
  /** Filter by the object’s `position` field. */
  position?: Maybe<FieldingPositionFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<LineupSpotFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<LineupSpotFilter>>;
  /** Negates the expression. */
  not?: Maybe<LineupSpotFilter>;
};

/** The `game` to be created by this mutation. */
export type LineupSpotGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `LineupSpotInput` mutation. */
export type LineupSpotGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnLineupSpotForLineupSpotGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnLineupSpotForLineupSpotGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupSpotOnLineupSpotForLineupSpotGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<LineupSpotGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `lineupSpot` in the `GameInput` mutation. */
export type LineupSpotGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupSpot` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupSpotNodeIdConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupSpotNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPlayerId?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotGameIdFkeyUsingLineupSpotPkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotGameIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPosition?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotGameIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnLineupSpotForLineupSpotGameIdFkeyNodeIdUpdate>>;
  /** A `LineupSpotInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupSpotGameIdFkeyLineupSpotCreateInput>>;
};

/** The `lineupSpot` to be created by this mutation. */
export type LineupSpotGameIdFkeyLineupSpotCreateInput = {
  lineupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder: Scalars['Int'];
  position?: Maybe<FieldingPosition>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** An input for mutations affecting `LineupSpot` */
export type LineupSpotInput = {
  lineupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder: Scalars['Int'];
  position?: Maybe<FieldingPosition>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** Input for the nested mutation of `lineup` in the `LineupSpotInput` mutation. */
export type LineupSpotLineupIdFkeyInput = {
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectById?: Maybe<LineupLineupPkeyConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectByNodeId?: Maybe<LineupNodeIdConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteById?: Maybe<LineupLineupPkeyDelete>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LineupNodeIdDelete>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateById?: Maybe<LineupOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupPkeyUpdate>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate>;
  /** A `LineupInput` object that will be created and connected to this object. */
  create?: Maybe<LineupSpotLineupIdFkeyLineupCreateInput>;
};

/** Input for the nested mutation of `lineupSpot` in the `LineupInput` mutation. */
export type LineupSpotLineupIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupSpot` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupSpotNodeIdConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupSpotNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPlayerId?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotPkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPosition?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LineupOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate>>;
  /** A `LineupSpotInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupSpotLineupIdFkeyLineupSpotCreateInput>>;
};

/** The `lineup` to be created by this mutation. */
export type LineupSpotLineupIdFkeyLineupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** The `lineupSpot` to be created by this mutation. */
export type LineupSpotLineupIdFkeyLineupSpotCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder: Scalars['Int'];
  position?: Maybe<FieldingPosition>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** The fields on `lineupSpot` to look up the row to connect. */
export type LineupSpotLineupSpotLineupIdBattingOrderKeyConnect = {
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** The fields on `lineupSpot` to look up the row to delete. */
export type LineupSpotLineupSpotLineupIdBattingOrderKeyDelete = {
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** The fields on `lineupSpot` to look up the row to connect. */
export type LineupSpotLineupSpotLineupIdPositionKeyConnect = {
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** The fields on `lineupSpot` to look up the row to delete. */
export type LineupSpotLineupSpotLineupIdPositionKeyDelete = {
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** The fields on `lineupSpot` to look up the row to connect. */
export type LineupSpotLineupSpotPkeyConnect = {
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The fields on `lineupSpot` to look up the row to delete. */
export type LineupSpotLineupSpotPkeyDelete = {
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LineupSpotNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `lineupSpot` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LineupSpotNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `lineupSpot` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotGameIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotGameIdFkeyPatch;
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotGameIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotGameIdFkeyPatch;
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotGameIdFkeyUsingLineupSpotPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotGameIdFkeyPatch;
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: LineupPatch;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch;
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch;
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch;
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch;
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch;
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch;
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** Represents an update to a `LineupSpot`. Fields that are set will be updated. */
export type LineupSpotPatch = {
  lineupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder?: Maybe<Scalars['Int']>;
  position?: Maybe<FieldingPosition>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** Input for the nested mutation of `player` in the `LineupSpotInput` mutation. */
export type LineupSpotPlayerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<LineupSpotPlayerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `lineupSpot` in the `PlayerInput` mutation. */
export type LineupSpotPlayerIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupSpot` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupSpotNodeIdConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupSpotNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPlayerId?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotPkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPosition?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate>>;
  /** A `LineupSpotInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupSpotPlayerIdFkeyLineupSpotCreateInput>>;
};

/** The `lineupSpot` to be created by this mutation. */
export type LineupSpotPlayerIdFkeyLineupSpotCreateInput = {
  lineupId?: Maybe<Scalars['UUID']>;
  battingOrder: Scalars['Int'];
  position?: Maybe<FieldingPosition>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** The `player` to be created by this mutation. */
export type LineupSpotPlayerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** Methods to use when ordering `LineupSpot`. */
export enum LineupSpotsOrderBy {
  NATURAL = 'NATURAL',
  LINEUP_ID_ASC = 'LINEUP_ID_ASC',
  LINEUP_ID_DESC = 'LINEUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  BATTING_ORDER_ASC = 'BATTING_ORDER_ASC',
  BATTING_ORDER_DESC = 'BATTING_ORDER_DESC',
  POSITION_ASC = 'POSITION_ASC',
  POSITION_DESC = 'POSITION_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** Input for the nested mutation of `team` in the `LineupInput` mutation. */
export type LineupTeamIdFkeyInput = {
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectById?: Maybe<TeamTeamPkeyConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByGameIdAndRole?: Maybe<TeamTeamGameIdRoleKeyConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByNodeId?: Maybe<TeamNodeIdConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteById?: Maybe<TeamTeamPkeyDelete>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByGameIdAndRole?: Maybe<TeamTeamGameIdRoleKeyDelete>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TeamNodeIdDelete>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateById?: Maybe<TeamOnLineupForLineupTeamIdFkeyUsingTeamPkeyUpdate>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByGameIdAndRole?: Maybe<TeamOnLineupForLineupTeamIdFkeyUsingTeamGameIdRoleKeyUpdate>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupOnLineupForLineupTeamIdFkeyNodeIdUpdate>;
  /** A `TeamInput` object that will be created and connected to this object. */
  create?: Maybe<LineupTeamIdFkeyTeamCreateInput>;
};

/** Input for the nested mutation of `lineup` in the `TeamInput` mutation. */
export type LineupTeamIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineup` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectById?: Maybe<Array<LineupLineupPkeyConnect>>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupNodeIdConnect>>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteById?: Maybe<Array<LineupLineupPkeyDelete>>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateById?: Maybe<Array<LineupOnLineupForLineupTeamIdFkeyUsingLineupPkeyUpdate>>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TeamOnLineupForLineupTeamIdFkeyNodeIdUpdate>>;
  /** A `LineupInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupTeamIdFkeyLineupCreateInput>>;
};

/** The `lineup` to be created by this mutation. */
export type LineupTeamIdFkeyLineupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** The `team` to be created by this mutation. */
export type LineupTeamIdFkeyTeamCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role: TeamRole;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineTeamIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineTeamIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey1InverseInput>;
};

/** Methods to use when ordering `Lineup`. */
export enum LineupsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  TEAM_ID_ASC = 'TEAM_ID_ASC',
  TEAM_ID_DESC = 'TEAM_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** All input for the `login` mutation. */
export type LoginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  email: Scalars['String'];
  password: Scalars['String'];
};

/** The output of our `login` mutation. */
export type LoginPayload = {
  __typename?: 'LoginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  jwt: Maybe<Scalars['Jwt']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type ManualEntryBattingLine = Node & {
  __typename?: 'ManualEntryBattingLine';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
  plateAppearances: Scalars['Int'];
  atBats: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  gidp: Scalars['Int'];
  runs: Scalars['Int'];
  rbi: Scalars['Int'];
  stolenBases: Scalars['Int'];
  /** Reads a single `Game` that is related to this `ManualEntryBattingLine`. */
  game: Maybe<Game>;
  /** Reads a single `Team` that is related to this `ManualEntryBattingLine`. */
  team: Maybe<Team>;
  /** Reads a single `Player` that is related to this `ManualEntryBattingLine`. */
  player: Maybe<Player>;
};

/**
 * A condition to be used against `ManualEntryBattingLine` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ManualEntryBattingLineCondition = {
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stolenBases` field. */
  stolenBases?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `ManualEntryBattingLine` object types. All fields are combined with a logical ‘and.’ */
export type ManualEntryBattingLineFilter = {
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Filter by the object’s `teamId` field. */
  teamId?: Maybe<UuidFilter>;
  /** Filter by the object’s `playerId` field. */
  playerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<IntFilter>;
  /** Filter by the object’s `atBats` field. */
  atBats?: Maybe<IntFilter>;
  /** Filter by the object’s `hits` field. */
  hits?: Maybe<IntFilter>;
  /** Filter by the object’s `singles` field. */
  singles?: Maybe<IntFilter>;
  /** Filter by the object’s `doubles` field. */
  doubles?: Maybe<IntFilter>;
  /** Filter by the object’s `triples` field. */
  triples?: Maybe<IntFilter>;
  /** Filter by the object’s `homeruns` field. */
  homeruns?: Maybe<IntFilter>;
  /** Filter by the object’s `walks` field. */
  walks?: Maybe<IntFilter>;
  /** Filter by the object’s `strikeouts` field. */
  strikeouts?: Maybe<IntFilter>;
  /** Filter by the object’s `sacFlies` field. */
  sacFlies?: Maybe<IntFilter>;
  /** Filter by the object’s `gidp` field. */
  gidp?: Maybe<IntFilter>;
  /** Filter by the object’s `runs` field. */
  runs?: Maybe<IntFilter>;
  /** Filter by the object’s `rbi` field. */
  rbi?: Maybe<IntFilter>;
  /** Filter by the object’s `stolenBases` field. */
  stolenBases?: Maybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ManualEntryBattingLineFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ManualEntryBattingLineFilter>>;
  /** Negates the expression. */
  not?: Maybe<ManualEntryBattingLineFilter>;
};

/** The `game` to be created by this mutation. */
export type ManualEntryBattingLineGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `ManualEntryBattingLineInput` mutation. */
export type ManualEntryBattingLineGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnManualEntryBattingLineForManualEntryBattingLineGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnManualEntryBattingLineForManualEntryBattingLineGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<ManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLineGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<ManualEntryBattingLineGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `manualEntryBattingLine` in the `GameInput` mutation. */
export type ManualEntryBattingLineGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `manualEntryBattingLine` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `manualEntryBattingLine` for the far side of the relationship. */
  connectByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryBattingLineManualEntryBattingLinePkeyConnect>>;
  /** The primary key(s) for `manualEntryBattingLine` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ManualEntryBattingLineNodeIdConnect>>;
  /** The primary key(s) for `manualEntryBattingLine` for the far side of the relationship. */
  deleteByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryBattingLineManualEntryBattingLinePkeyDelete>>;
  /** The primary key(s) for `manualEntryBattingLine` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ManualEntryBattingLineNodeIdDelete>>;
  /** The primary key(s) and patch data for `manualEntryBattingLine` for the far side of the relationship. */
  updateByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLineGameIdFkeyUsingManualEntryBattingLinePkeyUpdate>>;
  /** The primary key(s) and patch data for `manualEntryBattingLine` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnManualEntryBattingLineForManualEntryBattingLineGameIdFkeyNodeIdUpdate>>;
  /** A `ManualEntryBattingLineInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ManualEntryBattingLineGameIdFkeyManualEntryBattingLineCreateInput>>;
};

/** The `manualEntryBattingLine` to be created by this mutation. */
export type ManualEntryBattingLineGameIdFkeyManualEntryBattingLineCreateInput = {
  teamId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  plateAppearances: Scalars['Int'];
  atBats: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  gidp: Scalars['Int'];
  runs: Scalars['Int'];
  rbi: Scalars['Int'];
  stolenBases: Scalars['Int'];
  game?: Maybe<ManualEntryBattingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryBattingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryBattingLinePlayerIdFkeyInput>;
};

/** An input for mutations affecting `ManualEntryBattingLine` */
export type ManualEntryBattingLineInput = {
  gameId?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  plateAppearances: Scalars['Int'];
  atBats: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  gidp: Scalars['Int'];
  runs: Scalars['Int'];
  rbi: Scalars['Int'];
  stolenBases: Scalars['Int'];
  game?: Maybe<ManualEntryBattingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryBattingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryBattingLinePlayerIdFkeyInput>;
};

/** The fields on `manualEntryBattingLine` to look up the row to connect. */
export type ManualEntryBattingLineManualEntryBattingLinePkeyConnect = {
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The fields on `manualEntryBattingLine` to look up the row to delete. */
export type ManualEntryBattingLineManualEntryBattingLinePkeyDelete = {
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ManualEntryBattingLineNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `manualEntryBattingLine` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ManualEntryBattingLineNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `manualEntryBattingLine` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLineGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `manualEntryBattingLine` to look up the row to update. */
export type ManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLineGameIdFkeyUsingManualEntryBattingLinePkeyUpdate = {
  /** An object where the defined keys will be set on the `manualEntryBattingLine` being updated. */
  patch: UpdateManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLineGameIdFkeyPatch;
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLinePlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `manualEntryBattingLine` to look up the row to update. */
export type ManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLinePlayerIdFkeyUsingManualEntryBattingLinePkeyUpdate = {
  /** An object where the defined keys will be set on the `manualEntryBattingLine` being updated. */
  patch: UpdateManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLinePlayerIdFkeyPatch;
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLineTeamIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `team` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: TeamPatch;
};

/** The fields on `manualEntryBattingLine` to look up the row to update. */
export type ManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLineTeamIdFkeyUsingManualEntryBattingLinePkeyUpdate = {
  /** An object where the defined keys will be set on the `manualEntryBattingLine` being updated. */
  patch: UpdateManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLineTeamIdFkeyPatch;
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** Represents an update to a `ManualEntryBattingLine`. Fields that are set will be updated. */
export type ManualEntryBattingLinePatch = {
  gameId?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  game?: Maybe<ManualEntryBattingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryBattingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryBattingLinePlayerIdFkeyInput>;
};

/** Input for the nested mutation of `player` in the `ManualEntryBattingLineInput` mutation. */
export type ManualEntryBattingLinePlayerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnManualEntryBattingLineForManualEntryBattingLinePlayerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnManualEntryBattingLineForManualEntryBattingLinePlayerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<ManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLinePlayerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<ManualEntryBattingLinePlayerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `manualEntryBattingLine` in the `PlayerInput` mutation. */
export type ManualEntryBattingLinePlayerIdFkeyInverseInput = {
  /** Flag indicating whether all other `manualEntryBattingLine` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `manualEntryBattingLine` for the far side of the relationship. */
  connectByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryBattingLineManualEntryBattingLinePkeyConnect>>;
  /** The primary key(s) for `manualEntryBattingLine` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ManualEntryBattingLineNodeIdConnect>>;
  /** The primary key(s) for `manualEntryBattingLine` for the far side of the relationship. */
  deleteByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryBattingLineManualEntryBattingLinePkeyDelete>>;
  /** The primary key(s) for `manualEntryBattingLine` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ManualEntryBattingLineNodeIdDelete>>;
  /** The primary key(s) and patch data for `manualEntryBattingLine` for the far side of the relationship. */
  updateByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLinePlayerIdFkeyUsingManualEntryBattingLinePkeyUpdate>>;
  /** The primary key(s) and patch data for `manualEntryBattingLine` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnManualEntryBattingLineForManualEntryBattingLinePlayerIdFkeyNodeIdUpdate>>;
  /** A `ManualEntryBattingLineInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ManualEntryBattingLinePlayerIdFkeyManualEntryBattingLineCreateInput>>;
};

/** The `manualEntryBattingLine` to be created by this mutation. */
export type ManualEntryBattingLinePlayerIdFkeyManualEntryBattingLineCreateInput = {
  gameId?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  plateAppearances: Scalars['Int'];
  atBats: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  gidp: Scalars['Int'];
  runs: Scalars['Int'];
  rbi: Scalars['Int'];
  stolenBases: Scalars['Int'];
  game?: Maybe<ManualEntryBattingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryBattingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryBattingLinePlayerIdFkeyInput>;
};

/** The `player` to be created by this mutation. */
export type ManualEntryBattingLinePlayerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** Input for the nested mutation of `team` in the `ManualEntryBattingLineInput` mutation. */
export type ManualEntryBattingLineTeamIdFkeyInput = {
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectById?: Maybe<TeamTeamPkeyConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByGameIdAndRole?: Maybe<TeamTeamGameIdRoleKeyConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByNodeId?: Maybe<TeamNodeIdConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteById?: Maybe<TeamTeamPkeyDelete>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByGameIdAndRole?: Maybe<TeamTeamGameIdRoleKeyDelete>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TeamNodeIdDelete>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateById?: Maybe<TeamOnManualEntryBattingLineForManualEntryBattingLineTeamIdFkeyUsingTeamPkeyUpdate>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByGameIdAndRole?: Maybe<TeamOnManualEntryBattingLineForManualEntryBattingLineTeamIdFkeyUsingTeamGameIdRoleKeyUpdate>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByNodeId?: Maybe<ManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLineTeamIdFkeyNodeIdUpdate>;
  /** A `TeamInput` object that will be created and connected to this object. */
  create?: Maybe<ManualEntryBattingLineTeamIdFkeyTeamCreateInput>;
};

/** Input for the nested mutation of `manualEntryBattingLine` in the `TeamInput` mutation. */
export type ManualEntryBattingLineTeamIdFkeyInverseInput = {
  /** Flag indicating whether all other `manualEntryBattingLine` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `manualEntryBattingLine` for the far side of the relationship. */
  connectByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryBattingLineManualEntryBattingLinePkeyConnect>>;
  /** The primary key(s) for `manualEntryBattingLine` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ManualEntryBattingLineNodeIdConnect>>;
  /** The primary key(s) for `manualEntryBattingLine` for the far side of the relationship. */
  deleteByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryBattingLineManualEntryBattingLinePkeyDelete>>;
  /** The primary key(s) for `manualEntryBattingLine` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ManualEntryBattingLineNodeIdDelete>>;
  /** The primary key(s) and patch data for `manualEntryBattingLine` for the far side of the relationship. */
  updateByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLineTeamIdFkeyUsingManualEntryBattingLinePkeyUpdate>>;
  /** The primary key(s) and patch data for `manualEntryBattingLine` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TeamOnManualEntryBattingLineForManualEntryBattingLineTeamIdFkeyNodeIdUpdate>>;
  /** A `ManualEntryBattingLineInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ManualEntryBattingLineTeamIdFkeyManualEntryBattingLineCreateInput>>;
};

/** The `manualEntryBattingLine` to be created by this mutation. */
export type ManualEntryBattingLineTeamIdFkeyManualEntryBattingLineCreateInput = {
  gameId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  plateAppearances: Scalars['Int'];
  atBats: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  gidp: Scalars['Int'];
  runs: Scalars['Int'];
  rbi: Scalars['Int'];
  stolenBases: Scalars['Int'];
  game?: Maybe<ManualEntryBattingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryBattingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryBattingLinePlayerIdFkeyInput>;
};

/** The `team` to be created by this mutation. */
export type ManualEntryBattingLineTeamIdFkeyTeamCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role: TeamRole;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineTeamIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineTeamIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey1InverseInput>;
};

/** Methods to use when ordering `ManualEntryBattingLine`. */
export enum ManualEntryBattingLinesOrderBy {
  NATURAL = 'NATURAL',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  TEAM_ID_ASC = 'TEAM_ID_ASC',
  TEAM_ID_DESC = 'TEAM_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  STOLEN_BASES_ASC = 'STOLEN_BASES_ASC',
  STOLEN_BASES_DESC = 'STOLEN_BASES_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type ManualEntryLineScoreCell = Node & {
  __typename?: 'ManualEntryLineScoreCell';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameId: Scalars['UUID'];
  inning: Scalars['Int'];
  halfInning: HalfInning;
  runs: Scalars['Int'];
  /** Reads a single `Game` that is related to this `ManualEntryLineScoreCell`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `ManualEntryLineScoreCell` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ManualEntryLineScoreCellCondition = {
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `inning` field. */
  inning?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `halfInning` field. */
  halfInning?: Maybe<HalfInning>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `ManualEntryLineScoreCell` object types. All fields are combined with a logical ‘and.’ */
export type ManualEntryLineScoreCellFilter = {
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Filter by the object’s `inning` field. */
  inning?: Maybe<IntFilter>;
  /** Filter by the object’s `halfInning` field. */
  halfInning?: Maybe<HalfInningFilter>;
  /** Filter by the object’s `runs` field. */
  runs?: Maybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ManualEntryLineScoreCellFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ManualEntryLineScoreCellFilter>>;
  /** Negates the expression. */
  not?: Maybe<ManualEntryLineScoreCellFilter>;
};

/** The `game` to be created by this mutation. */
export type ManualEntryLineScoreCellGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `ManualEntryLineScoreCellInput` mutation. */
export type ManualEntryLineScoreCellGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnManualEntryLineScoreCellForManualEntryLineScoreCellGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnManualEntryLineScoreCellForManualEntryLineScoreCellGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<ManualEntryLineScoreCellOnManualEntryLineScoreCellForManualEntryLineScoreCellGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<ManualEntryLineScoreCellGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `manualEntryLineScoreCell` in the `GameInput` mutation. */
export type ManualEntryLineScoreCellGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `manualEntryLineScoreCell` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `manualEntryLineScoreCell` for the far side of the relationship. */
  connectByGameIdAndInningAndHalfInning?: Maybe<Array<ManualEntryLineScoreCellManualEntryLineScoreCellPkeyConnect>>;
  /** The primary key(s) for `manualEntryLineScoreCell` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ManualEntryLineScoreCellNodeIdConnect>>;
  /** The primary key(s) for `manualEntryLineScoreCell` for the far side of the relationship. */
  deleteByGameIdAndInningAndHalfInning?: Maybe<Array<ManualEntryLineScoreCellManualEntryLineScoreCellPkeyDelete>>;
  /** The primary key(s) for `manualEntryLineScoreCell` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ManualEntryLineScoreCellNodeIdDelete>>;
  /** The primary key(s) and patch data for `manualEntryLineScoreCell` for the far side of the relationship. */
  updateByGameIdAndInningAndHalfInning?: Maybe<Array<ManualEntryLineScoreCellOnManualEntryLineScoreCellForManualEntryLineScoreCellGameIdFkeyUsingManualEntryLineScoreCellPkeyUpdate>>;
  /** The primary key(s) and patch data for `manualEntryLineScoreCell` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnManualEntryLineScoreCellForManualEntryLineScoreCellGameIdFkeyNodeIdUpdate>>;
  /** A `ManualEntryLineScoreCellInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ManualEntryLineScoreCellGameIdFkeyManualEntryLineScoreCellCreateInput>>;
};

/** The `manualEntryLineScoreCell` to be created by this mutation. */
export type ManualEntryLineScoreCellGameIdFkeyManualEntryLineScoreCellCreateInput = {
  inning: Scalars['Int'];
  halfInning: HalfInning;
  runs: Scalars['Int'];
  game?: Maybe<ManualEntryLineScoreCellGameIdFkeyInput>;
};

/** An input for mutations affecting `ManualEntryLineScoreCell` */
export type ManualEntryLineScoreCellInput = {
  gameId?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  runs: Scalars['Int'];
  game?: Maybe<ManualEntryLineScoreCellGameIdFkeyInput>;
};

/** The fields on `manualEntryLineScoreCell` to look up the row to connect. */
export type ManualEntryLineScoreCellManualEntryLineScoreCellPkeyConnect = {
  gameId: Scalars['UUID'];
  inning: Scalars['Int'];
  halfInning: HalfInning;
};

/** The fields on `manualEntryLineScoreCell` to look up the row to delete. */
export type ManualEntryLineScoreCellManualEntryLineScoreCellPkeyDelete = {
  gameId: Scalars['UUID'];
  inning: Scalars['Int'];
  halfInning: HalfInning;
};

/** The globally unique `ID` look up for the row to connect. */
export type ManualEntryLineScoreCellNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `manualEntryLineScoreCell` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ManualEntryLineScoreCellNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `manualEntryLineScoreCell` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ManualEntryLineScoreCellOnManualEntryLineScoreCellForManualEntryLineScoreCellGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `manualEntryLineScoreCell` to look up the row to update. */
export type ManualEntryLineScoreCellOnManualEntryLineScoreCellForManualEntryLineScoreCellGameIdFkeyUsingManualEntryLineScoreCellPkeyUpdate = {
  /** An object where the defined keys will be set on the `manualEntryLineScoreCell` being updated. */
  patch: UpdateManualEntryLineScoreCellOnManualEntryLineScoreCellForManualEntryLineScoreCellGameIdFkeyPatch;
  gameId: Scalars['UUID'];
  inning: Scalars['Int'];
  halfInning: HalfInning;
};

/** Represents an update to a `ManualEntryLineScoreCell`. Fields that are set will be updated. */
export type ManualEntryLineScoreCellPatch = {
  gameId?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  runs?: Maybe<Scalars['Int']>;
  game?: Maybe<ManualEntryLineScoreCellGameIdFkeyInput>;
};

/** Methods to use when ordering `ManualEntryLineScoreCell`. */
export enum ManualEntryLineScoreCellsOrderBy {
  NATURAL = 'NATURAL',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  INNING_ASC = 'INNING_ASC',
  INNING_DESC = 'INNING_DESC',
  HALF_INNING_ASC = 'HALF_INNING_ASC',
  HALF_INNING_DESC = 'HALF_INNING_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type ManualEntryPitchingLine = Node & {
  __typename?: 'ManualEntryPitchingLine';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
  inningsPitched: Scalars['Int'];
  won: Scalars['Boolean'];
  lost: Scalars['Boolean'];
  save: Scalars['Boolean'];
  completeGame: Scalars['Boolean'];
  qualityStart: Scalars['Boolean'];
  runsAllowed: Scalars['Int'];
  strikeouts: Scalars['Int'];
  walks: Scalars['Int'];
  /** Reads a single `Game` that is related to this `ManualEntryPitchingLine`. */
  game: Maybe<Game>;
  /** Reads a single `Team` that is related to this `ManualEntryPitchingLine`. */
  team: Maybe<Team>;
  /** Reads a single `Player` that is related to this `ManualEntryPitchingLine`. */
  player: Maybe<Player>;
};

/**
 * A condition to be used against `ManualEntryPitchingLine` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ManualEntryPitchingLineCondition = {
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `inningsPitched` field. */
  inningsPitched?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `won` field. */
  won?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `lost` field. */
  lost?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `save` field. */
  save?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `completeGame` field. */
  completeGame?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `qualityStart` field. */
  qualityStart?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `runsAllowed` field. */
  runsAllowed?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `ManualEntryPitchingLine` object types. All fields are combined with a logical ‘and.’ */
export type ManualEntryPitchingLineFilter = {
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Filter by the object’s `teamId` field. */
  teamId?: Maybe<UuidFilter>;
  /** Filter by the object’s `playerId` field. */
  playerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `inningsPitched` field. */
  inningsPitched?: Maybe<IntFilter>;
  /** Filter by the object’s `won` field. */
  won?: Maybe<BooleanFilter>;
  /** Filter by the object’s `lost` field. */
  lost?: Maybe<BooleanFilter>;
  /** Filter by the object’s `save` field. */
  save?: Maybe<BooleanFilter>;
  /** Filter by the object’s `completeGame` field. */
  completeGame?: Maybe<BooleanFilter>;
  /** Filter by the object’s `qualityStart` field. */
  qualityStart?: Maybe<BooleanFilter>;
  /** Filter by the object’s `runsAllowed` field. */
  runsAllowed?: Maybe<IntFilter>;
  /** Filter by the object’s `strikeouts` field. */
  strikeouts?: Maybe<IntFilter>;
  /** Filter by the object’s `walks` field. */
  walks?: Maybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ManualEntryPitchingLineFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ManualEntryPitchingLineFilter>>;
  /** Negates the expression. */
  not?: Maybe<ManualEntryPitchingLineFilter>;
};

/** The `game` to be created by this mutation. */
export type ManualEntryPitchingLineGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `ManualEntryPitchingLineInput` mutation. */
export type ManualEntryPitchingLineGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnManualEntryPitchingLineForManualEntryPitchingLineGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnManualEntryPitchingLineForManualEntryPitchingLineGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<ManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLineGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<ManualEntryPitchingLineGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `manualEntryPitchingLine` in the `GameInput` mutation. */
export type ManualEntryPitchingLineGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `manualEntryPitchingLine` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `manualEntryPitchingLine` for the far side of the relationship. */
  connectByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryPitchingLineManualEntryPitchingLinePkeyConnect>>;
  /** The primary key(s) for `manualEntryPitchingLine` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ManualEntryPitchingLineNodeIdConnect>>;
  /** The primary key(s) for `manualEntryPitchingLine` for the far side of the relationship. */
  deleteByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryPitchingLineManualEntryPitchingLinePkeyDelete>>;
  /** The primary key(s) for `manualEntryPitchingLine` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ManualEntryPitchingLineNodeIdDelete>>;
  /** The primary key(s) and patch data for `manualEntryPitchingLine` for the far side of the relationship. */
  updateByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLineGameIdFkeyUsingManualEntryPitchingLinePkeyUpdate>>;
  /** The primary key(s) and patch data for `manualEntryPitchingLine` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnManualEntryPitchingLineForManualEntryPitchingLineGameIdFkeyNodeIdUpdate>>;
  /** A `ManualEntryPitchingLineInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ManualEntryPitchingLineGameIdFkeyManualEntryPitchingLineCreateInput>>;
};

/** The `manualEntryPitchingLine` to be created by this mutation. */
export type ManualEntryPitchingLineGameIdFkeyManualEntryPitchingLineCreateInput = {
  teamId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  inningsPitched: Scalars['Int'];
  won: Scalars['Boolean'];
  lost: Scalars['Boolean'];
  save: Scalars['Boolean'];
  completeGame: Scalars['Boolean'];
  qualityStart: Scalars['Boolean'];
  runsAllowed: Scalars['Int'];
  strikeouts: Scalars['Int'];
  walks: Scalars['Int'];
  game?: Maybe<ManualEntryPitchingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryPitchingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInput>;
};

/** An input for mutations affecting `ManualEntryPitchingLine` */
export type ManualEntryPitchingLineInput = {
  gameId?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  inningsPitched: Scalars['Int'];
  won: Scalars['Boolean'];
  lost: Scalars['Boolean'];
  save: Scalars['Boolean'];
  completeGame: Scalars['Boolean'];
  qualityStart: Scalars['Boolean'];
  runsAllowed: Scalars['Int'];
  strikeouts: Scalars['Int'];
  walks: Scalars['Int'];
  game?: Maybe<ManualEntryPitchingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryPitchingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInput>;
};

/** The fields on `manualEntryPitchingLine` to look up the row to connect. */
export type ManualEntryPitchingLineManualEntryPitchingLinePkeyConnect = {
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The fields on `manualEntryPitchingLine` to look up the row to delete. */
export type ManualEntryPitchingLineManualEntryPitchingLinePkeyDelete = {
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ManualEntryPitchingLineNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `manualEntryPitchingLine` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ManualEntryPitchingLineNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `manualEntryPitchingLine` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLineGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `manualEntryPitchingLine` to look up the row to update. */
export type ManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLineGameIdFkeyUsingManualEntryPitchingLinePkeyUpdate = {
  /** An object where the defined keys will be set on the `manualEntryPitchingLine` being updated. */
  patch: UpdateManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLineGameIdFkeyPatch;
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLinePlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `manualEntryPitchingLine` to look up the row to update. */
export type ManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLinePlayerIdFkeyUsingManualEntryPitchingLinePkeyUpdate = {
  /** An object where the defined keys will be set on the `manualEntryPitchingLine` being updated. */
  patch: UpdateManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLinePlayerIdFkeyPatch;
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLineTeamIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `team` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: TeamPatch;
};

/** The fields on `manualEntryPitchingLine` to look up the row to update. */
export type ManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLineTeamIdFkeyUsingManualEntryPitchingLinePkeyUpdate = {
  /** An object where the defined keys will be set on the `manualEntryPitchingLine` being updated. */
  patch: UpdateManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLineTeamIdFkeyPatch;
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** Represents an update to a `ManualEntryPitchingLine`. Fields that are set will be updated. */
export type ManualEntryPitchingLinePatch = {
  gameId?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  inningsPitched?: Maybe<Scalars['Int']>;
  won?: Maybe<Scalars['Boolean']>;
  lost?: Maybe<Scalars['Boolean']>;
  save?: Maybe<Scalars['Boolean']>;
  completeGame?: Maybe<Scalars['Boolean']>;
  qualityStart?: Maybe<Scalars['Boolean']>;
  runsAllowed?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  game?: Maybe<ManualEntryPitchingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryPitchingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInput>;
};

/** Input for the nested mutation of `player` in the `ManualEntryPitchingLineInput` mutation. */
export type ManualEntryPitchingLinePlayerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnManualEntryPitchingLineForManualEntryPitchingLinePlayerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnManualEntryPitchingLineForManualEntryPitchingLinePlayerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<ManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLinePlayerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<ManualEntryPitchingLinePlayerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `manualEntryPitchingLine` in the `PlayerInput` mutation. */
export type ManualEntryPitchingLinePlayerIdFkeyInverseInput = {
  /** Flag indicating whether all other `manualEntryPitchingLine` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `manualEntryPitchingLine` for the far side of the relationship. */
  connectByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryPitchingLineManualEntryPitchingLinePkeyConnect>>;
  /** The primary key(s) for `manualEntryPitchingLine` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ManualEntryPitchingLineNodeIdConnect>>;
  /** The primary key(s) for `manualEntryPitchingLine` for the far side of the relationship. */
  deleteByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryPitchingLineManualEntryPitchingLinePkeyDelete>>;
  /** The primary key(s) for `manualEntryPitchingLine` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ManualEntryPitchingLineNodeIdDelete>>;
  /** The primary key(s) and patch data for `manualEntryPitchingLine` for the far side of the relationship. */
  updateByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLinePlayerIdFkeyUsingManualEntryPitchingLinePkeyUpdate>>;
  /** The primary key(s) and patch data for `manualEntryPitchingLine` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnManualEntryPitchingLineForManualEntryPitchingLinePlayerIdFkeyNodeIdUpdate>>;
  /** A `ManualEntryPitchingLineInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ManualEntryPitchingLinePlayerIdFkeyManualEntryPitchingLineCreateInput>>;
};

/** The `manualEntryPitchingLine` to be created by this mutation. */
export type ManualEntryPitchingLinePlayerIdFkeyManualEntryPitchingLineCreateInput = {
  gameId?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  inningsPitched: Scalars['Int'];
  won: Scalars['Boolean'];
  lost: Scalars['Boolean'];
  save: Scalars['Boolean'];
  completeGame: Scalars['Boolean'];
  qualityStart: Scalars['Boolean'];
  runsAllowed: Scalars['Int'];
  strikeouts: Scalars['Int'];
  walks: Scalars['Int'];
  game?: Maybe<ManualEntryPitchingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryPitchingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInput>;
};

/** The `player` to be created by this mutation. */
export type ManualEntryPitchingLinePlayerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** Input for the nested mutation of `team` in the `ManualEntryPitchingLineInput` mutation. */
export type ManualEntryPitchingLineTeamIdFkeyInput = {
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectById?: Maybe<TeamTeamPkeyConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByGameIdAndRole?: Maybe<TeamTeamGameIdRoleKeyConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByNodeId?: Maybe<TeamNodeIdConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteById?: Maybe<TeamTeamPkeyDelete>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByGameIdAndRole?: Maybe<TeamTeamGameIdRoleKeyDelete>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TeamNodeIdDelete>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateById?: Maybe<TeamOnManualEntryPitchingLineForManualEntryPitchingLineTeamIdFkeyUsingTeamPkeyUpdate>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByGameIdAndRole?: Maybe<TeamOnManualEntryPitchingLineForManualEntryPitchingLineTeamIdFkeyUsingTeamGameIdRoleKeyUpdate>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByNodeId?: Maybe<ManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLineTeamIdFkeyNodeIdUpdate>;
  /** A `TeamInput` object that will be created and connected to this object. */
  create?: Maybe<ManualEntryPitchingLineTeamIdFkeyTeamCreateInput>;
};

/** Input for the nested mutation of `manualEntryPitchingLine` in the `TeamInput` mutation. */
export type ManualEntryPitchingLineTeamIdFkeyInverseInput = {
  /** Flag indicating whether all other `manualEntryPitchingLine` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `manualEntryPitchingLine` for the far side of the relationship. */
  connectByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryPitchingLineManualEntryPitchingLinePkeyConnect>>;
  /** The primary key(s) for `manualEntryPitchingLine` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ManualEntryPitchingLineNodeIdConnect>>;
  /** The primary key(s) for `manualEntryPitchingLine` for the far side of the relationship. */
  deleteByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryPitchingLineManualEntryPitchingLinePkeyDelete>>;
  /** The primary key(s) for `manualEntryPitchingLine` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ManualEntryPitchingLineNodeIdDelete>>;
  /** The primary key(s) and patch data for `manualEntryPitchingLine` for the far side of the relationship. */
  updateByGameIdAndTeamIdAndPlayerId?: Maybe<Array<ManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLineTeamIdFkeyUsingManualEntryPitchingLinePkeyUpdate>>;
  /** The primary key(s) and patch data for `manualEntryPitchingLine` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TeamOnManualEntryPitchingLineForManualEntryPitchingLineTeamIdFkeyNodeIdUpdate>>;
  /** A `ManualEntryPitchingLineInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ManualEntryPitchingLineTeamIdFkeyManualEntryPitchingLineCreateInput>>;
};

/** The `manualEntryPitchingLine` to be created by this mutation. */
export type ManualEntryPitchingLineTeamIdFkeyManualEntryPitchingLineCreateInput = {
  gameId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  inningsPitched: Scalars['Int'];
  won: Scalars['Boolean'];
  lost: Scalars['Boolean'];
  save: Scalars['Boolean'];
  completeGame: Scalars['Boolean'];
  qualityStart: Scalars['Boolean'];
  runsAllowed: Scalars['Int'];
  strikeouts: Scalars['Int'];
  walks: Scalars['Int'];
  game?: Maybe<ManualEntryPitchingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryPitchingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInput>;
};

/** The `team` to be created by this mutation. */
export type ManualEntryPitchingLineTeamIdFkeyTeamCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role: TeamRole;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineTeamIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineTeamIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey1InverseInput>;
};

/** Methods to use when ordering `ManualEntryPitchingLine`. */
export enum ManualEntryPitchingLinesOrderBy {
  NATURAL = 'NATURAL',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  TEAM_ID_ASC = 'TEAM_ID_ASC',
  TEAM_ID_DESC = 'TEAM_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  INNINGS_PITCHED_ASC = 'INNINGS_PITCHED_ASC',
  INNINGS_PITCHED_DESC = 'INNINGS_PITCHED_DESC',
  WON_ASC = 'WON_ASC',
  WON_DESC = 'WON_DESC',
  LOST_ASC = 'LOST_ASC',
  LOST_DESC = 'LOST_DESC',
  SAVE_ASC = 'SAVE_ASC',
  SAVE_DESC = 'SAVE_DESC',
  COMPLETE_GAME_ASC = 'COMPLETE_GAME_ASC',
  COMPLETE_GAME_DESC = 'COMPLETE_GAME_DESC',
  QUALITY_START_ASC = 'QUALITY_START_ASC',
  QUALITY_START_DESC = 'QUALITY_START_DESC',
  RUNS_ALLOWED_ASC = 'RUNS_ALLOWED_ASC',
  RUNS_ALLOWED_DESC = 'RUNS_ALLOWED_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a single `AtBatSkip`. */
  createAtBatSkip: Maybe<CreateAtBatSkipPayload>;
  /** Creates a single `BaseRunner`. */
  createBaseRunner: Maybe<CreateBaseRunnerPayload>;
  /** Creates a single `BasepathMovement`. */
  createBasepathMovement: Maybe<CreateBasepathMovementPayload>;
  /** Creates a single `EarlyGameEnd`. */
  createEarlyGameEnd: Maybe<CreateEarlyGameEndPayload>;
  /** Creates a single `Field`. */
  createField: Maybe<CreateFieldPayload>;
  /** Creates a single `Game`. */
  createGame: Maybe<CreateGamePayload>;
  /** Creates a single `GameAuxMeetupInfo`. */
  createGameAuxMeetupInfo: Maybe<CreateGameAuxMeetupInfoPayload>;
  /** Creates a single `GameEvent`. */
  createGameEvent: Maybe<CreateGameEventPayload>;
  /** Creates a single `GameEventRecord`. */
  createGameEventRecord: Maybe<CreateGameEventRecordPayload>;
  /** Creates a single `GameState`. */
  createGameState: Maybe<CreateGameStatePayload>;
  /** Creates a single `Group`. */
  createGroup: Maybe<CreateGroupPayload>;
  /** Creates a single `Lineup`. */
  createLineup: Maybe<CreateLineupPayload>;
  /** Creates a single `LineupChange`. */
  createLineupChange: Maybe<CreateLineupChangePayload>;
  /** Creates a single `LineupForGameState`. */
  createLineupForGameState: Maybe<CreateLineupForGameStatePayload>;
  /** Creates a single `LineupSpot`. */
  createLineupSpot: Maybe<CreateLineupSpotPayload>;
  /** Creates a single `ManualEntryBattingLine`. */
  createManualEntryBattingLine: Maybe<CreateManualEntryBattingLinePayload>;
  /** Creates a single `ManualEntryLineScoreCell`. */
  createManualEntryLineScoreCell: Maybe<CreateManualEntryLineScoreCellPayload>;
  /** Creates a single `ManualEntryPitchingLine`. */
  createManualEntryPitchingLine: Maybe<CreateManualEntryPitchingLinePayload>;
  /** Creates a single `OutOnPlayRunner`. */
  createOutOnPlayRunner: Maybe<CreateOutOnPlayRunnerPayload>;
  /** Creates a single `PlateAppearance`. */
  createPlateAppearance: Maybe<CreatePlateAppearancePayload>;
  /** Creates a single `Player`. */
  createPlayer: Maybe<CreatePlayerPayload>;
  /** Creates a single `PlayerAuxMeetupInfo`. */
  createPlayerAuxMeetupInfo: Maybe<CreatePlayerAuxMeetupInfoPayload>;
  /** Creates a single `PlayerGroupMembership`. */
  createPlayerGroupMembership: Maybe<CreatePlayerGroupMembershipPayload>;
  /** Creates a single `ReduxDump`. */
  createReduxDump: Maybe<CreateReduxDumpPayload>;
  /** Creates a single `ScoredRunner`. */
  createScoredRunner: Maybe<CreateScoredRunnerPayload>;
  /** Creates a single `SoloModeOpponentInning`. */
  createSoloModeOpponentInning: Maybe<CreateSoloModeOpponentInningPayload>;
  /** Creates a single `StolenBaseAttempt`. */
  createStolenBaseAttempt: Maybe<CreateStolenBaseAttemptPayload>;
  /** Creates a single `Team`. */
  createTeam: Maybe<CreateTeamPayload>;
  /** Updates a single `AtBatSkip` using its globally unique id and a patch. */
  updateAtBatSkipByNodeId: Maybe<UpdateAtBatSkipPayload>;
  /** Updates a single `AtBatSkip` using a unique key and a patch. */
  updateAtBatSkip: Maybe<UpdateAtBatSkipPayload>;
  /** Updates a single `BaseRunner` using its globally unique id and a patch. */
  updateBaseRunnerByNodeId: Maybe<UpdateBaseRunnerPayload>;
  /** Updates a single `BaseRunner` using a unique key and a patch. */
  updateBaseRunner: Maybe<UpdateBaseRunnerPayload>;
  /** Updates a single `BasepathMovement` using its globally unique id and a patch. */
  updateBasepathMovementByNodeId: Maybe<UpdateBasepathMovementPayload>;
  /** Updates a single `BasepathMovement` using a unique key and a patch. */
  updateBasepathMovement: Maybe<UpdateBasepathMovementPayload>;
  /** Updates a single `EarlyGameEnd` using its globally unique id and a patch. */
  updateEarlyGameEndByNodeId: Maybe<UpdateEarlyGameEndPayload>;
  /** Updates a single `EarlyGameEnd` using a unique key and a patch. */
  updateEarlyGameEnd: Maybe<UpdateEarlyGameEndPayload>;
  /** Updates a single `Field` using its globally unique id and a patch. */
  updateFieldByNodeId: Maybe<UpdateFieldPayload>;
  /** Updates a single `Field` using a unique key and a patch. */
  updateField: Maybe<UpdateFieldPayload>;
  /** Updates a single `Game` using its globally unique id and a patch. */
  updateGameByNodeId: Maybe<UpdateGamePayload>;
  /** Updates a single `Game` using a unique key and a patch. */
  updateGame: Maybe<UpdateGamePayload>;
  /** Updates a single `Game` using a unique key and a patch. */
  updateGameByGroupIdAndName: Maybe<UpdateGamePayload>;
  /** Updates a single `GameAuxMeetupInfo` using its globally unique id and a patch. */
  updateGameAuxMeetupInfoByNodeId: Maybe<UpdateGameAuxMeetupInfoPayload>;
  /** Updates a single `GameAuxMeetupInfo` using a unique key and a patch. */
  updateGameAuxMeetupInfo: Maybe<UpdateGameAuxMeetupInfoPayload>;
  /** Updates a single `GameEvent` using its globally unique id and a patch. */
  updateGameEventByNodeId: Maybe<UpdateGameEventPayload>;
  /** Updates a single `GameEvent` using a unique key and a patch. */
  updateGameEvent: Maybe<UpdateGameEventPayload>;
  /** Updates a single `GameEventRecord` using its globally unique id and a patch. */
  updateGameEventRecordByNodeId: Maybe<UpdateGameEventRecordPayload>;
  /** Updates a single `GameEventRecord` using a unique key and a patch. */
  updateGameEventRecord: Maybe<UpdateGameEventRecordPayload>;
  /** Updates a single `GameEventRecord` using a unique key and a patch. */
  updateGameEventRecordByGameIdAndEventIndex: Maybe<UpdateGameEventRecordPayload>;
  /** Updates a single `GameState` using its globally unique id and a patch. */
  updateGameStateByNodeId: Maybe<UpdateGameStatePayload>;
  /** Updates a single `GameState` using a unique key and a patch. */
  updateGameState: Maybe<UpdateGameStatePayload>;
  /** Updates a single `Group` using its globally unique id and a patch. */
  updateGroupByNodeId: Maybe<UpdateGroupPayload>;
  /** Updates a single `Group` using a unique key and a patch. */
  updateGroup: Maybe<UpdateGroupPayload>;
  /** Updates a single `Group` using a unique key and a patch. */
  updateGroupByName: Maybe<UpdateGroupPayload>;
  /** Updates a single `Group` using a unique key and a patch. */
  updateGroupByUrlSlug: Maybe<UpdateGroupPayload>;
  /** Updates a single `Lineup` using its globally unique id and a patch. */
  updateLineupByNodeId: Maybe<UpdateLineupPayload>;
  /** Updates a single `Lineup` using a unique key and a patch. */
  updateLineup: Maybe<UpdateLineupPayload>;
  /** Updates a single `LineupChange` using its globally unique id and a patch. */
  updateLineupChangeByNodeId: Maybe<UpdateLineupChangePayload>;
  /** Updates a single `LineupChange` using a unique key and a patch. */
  updateLineupChange: Maybe<UpdateLineupChangePayload>;
  /** Updates a single `LineupForGameState` using its globally unique id and a patch. */
  updateLineupForGameStateByNodeId: Maybe<UpdateLineupForGameStatePayload>;
  /** Updates a single `LineupForGameState` using a unique key and a patch. */
  updateLineupForGameState: Maybe<UpdateLineupForGameStatePayload>;
  /** Updates a single `LineupSpot` using its globally unique id and a patch. */
  updateLineupSpotByNodeId: Maybe<UpdateLineupSpotPayload>;
  /** Updates a single `LineupSpot` using a unique key and a patch. */
  updateLineupSpot: Maybe<UpdateLineupSpotPayload>;
  /** Updates a single `LineupSpot` using a unique key and a patch. */
  updateLineupSpotByLineupIdAndBattingOrder: Maybe<UpdateLineupSpotPayload>;
  /** Updates a single `LineupSpot` using a unique key and a patch. */
  updateLineupSpotByLineupIdAndPosition: Maybe<UpdateLineupSpotPayload>;
  /** Updates a single `ManualEntryBattingLine` using its globally unique id and a patch. */
  updateManualEntryBattingLineByNodeId: Maybe<UpdateManualEntryBattingLinePayload>;
  /** Updates a single `ManualEntryBattingLine` using a unique key and a patch. */
  updateManualEntryBattingLine: Maybe<UpdateManualEntryBattingLinePayload>;
  /** Updates a single `ManualEntryLineScoreCell` using its globally unique id and a patch. */
  updateManualEntryLineScoreCellByNodeId: Maybe<UpdateManualEntryLineScoreCellPayload>;
  /** Updates a single `ManualEntryLineScoreCell` using a unique key and a patch. */
  updateManualEntryLineScoreCell: Maybe<UpdateManualEntryLineScoreCellPayload>;
  /** Updates a single `ManualEntryPitchingLine` using its globally unique id and a patch. */
  updateManualEntryPitchingLineByNodeId: Maybe<UpdateManualEntryPitchingLinePayload>;
  /** Updates a single `ManualEntryPitchingLine` using a unique key and a patch. */
  updateManualEntryPitchingLine: Maybe<UpdateManualEntryPitchingLinePayload>;
  /** Updates a single `OutOnPlayRunner` using its globally unique id and a patch. */
  updateOutOnPlayRunnerByNodeId: Maybe<UpdateOutOnPlayRunnerPayload>;
  /** Updates a single `OutOnPlayRunner` using a unique key and a patch. */
  updateOutOnPlayRunner: Maybe<UpdateOutOnPlayRunnerPayload>;
  /** Updates a single `PlateAppearance` using its globally unique id and a patch. */
  updatePlateAppearanceByNodeId: Maybe<UpdatePlateAppearancePayload>;
  /** Updates a single `PlateAppearance` using a unique key and a patch. */
  updatePlateAppearance: Maybe<UpdatePlateAppearancePayload>;
  /** Updates a single `Player` using its globally unique id and a patch. */
  updatePlayerByNodeId: Maybe<UpdatePlayerPayload>;
  /** Updates a single `Player` using a unique key and a patch. */
  updatePlayer: Maybe<UpdatePlayerPayload>;
  /** Updates a single `Player` using a unique key and a patch. */
  updatePlayerByFirstNameAndLastName: Maybe<UpdatePlayerPayload>;
  /** Updates a single `PlayerAuxMeetupInfo` using its globally unique id and a patch. */
  updatePlayerAuxMeetupInfoByNodeId: Maybe<UpdatePlayerAuxMeetupInfoPayload>;
  /** Updates a single `PlayerAuxMeetupInfo` using a unique key and a patch. */
  updatePlayerAuxMeetupInfo: Maybe<UpdatePlayerAuxMeetupInfoPayload>;
  /** Updates a single `PlayerGroupMembership` using its globally unique id and a patch. */
  updatePlayerGroupMembershipByNodeId: Maybe<UpdatePlayerGroupMembershipPayload>;
  /** Updates a single `PlayerGroupMembership` using a unique key and a patch. */
  updatePlayerGroupMembership: Maybe<UpdatePlayerGroupMembershipPayload>;
  /** Updates a single `ReduxDump` using its globally unique id and a patch. */
  updateReduxDumpByNodeId: Maybe<UpdateReduxDumpPayload>;
  /** Updates a single `ReduxDump` using a unique key and a patch. */
  updateReduxDump: Maybe<UpdateReduxDumpPayload>;
  /** Updates a single `ScoredRunner` using its globally unique id and a patch. */
  updateScoredRunnerByNodeId: Maybe<UpdateScoredRunnerPayload>;
  /** Updates a single `ScoredRunner` using a unique key and a patch. */
  updateScoredRunner: Maybe<UpdateScoredRunnerPayload>;
  /** Updates a single `SoloModeOpponentInning` using its globally unique id and a patch. */
  updateSoloModeOpponentInningByNodeId: Maybe<UpdateSoloModeOpponentInningPayload>;
  /** Updates a single `SoloModeOpponentInning` using a unique key and a patch. */
  updateSoloModeOpponentInning: Maybe<UpdateSoloModeOpponentInningPayload>;
  /** Updates a single `StolenBaseAttempt` using its globally unique id and a patch. */
  updateStolenBaseAttemptByNodeId: Maybe<UpdateStolenBaseAttemptPayload>;
  /** Updates a single `StolenBaseAttempt` using a unique key and a patch. */
  updateStolenBaseAttempt: Maybe<UpdateStolenBaseAttemptPayload>;
  /** Updates a single `Team` using its globally unique id and a patch. */
  updateTeamByNodeId: Maybe<UpdateTeamPayload>;
  /** Updates a single `Team` using a unique key and a patch. */
  updateTeam: Maybe<UpdateTeamPayload>;
  /** Updates a single `Team` using a unique key and a patch. */
  updateTeamByGameIdAndRole: Maybe<UpdateTeamPayload>;
  /** Deletes a single `AtBatSkip` using its globally unique id. */
  deleteAtBatSkipByNodeId: Maybe<DeleteAtBatSkipPayload>;
  /** Deletes a single `AtBatSkip` using a unique key. */
  deleteAtBatSkip: Maybe<DeleteAtBatSkipPayload>;
  /** Deletes a single `BaseRunner` using its globally unique id. */
  deleteBaseRunnerByNodeId: Maybe<DeleteBaseRunnerPayload>;
  /** Deletes a single `BaseRunner` using a unique key. */
  deleteBaseRunner: Maybe<DeleteBaseRunnerPayload>;
  /** Deletes a single `BasepathMovement` using its globally unique id. */
  deleteBasepathMovementByNodeId: Maybe<DeleteBasepathMovementPayload>;
  /** Deletes a single `BasepathMovement` using a unique key. */
  deleteBasepathMovement: Maybe<DeleteBasepathMovementPayload>;
  /** Deletes a single `EarlyGameEnd` using its globally unique id. */
  deleteEarlyGameEndByNodeId: Maybe<DeleteEarlyGameEndPayload>;
  /** Deletes a single `EarlyGameEnd` using a unique key. */
  deleteEarlyGameEnd: Maybe<DeleteEarlyGameEndPayload>;
  /** Deletes a single `Field` using its globally unique id. */
  deleteFieldByNodeId: Maybe<DeleteFieldPayload>;
  /** Deletes a single `Field` using a unique key. */
  deleteField: Maybe<DeleteFieldPayload>;
  /** Deletes a single `Game` using its globally unique id. */
  deleteGameByNodeId: Maybe<DeleteGamePayload>;
  /** Deletes a single `Game` using a unique key. */
  deleteGame: Maybe<DeleteGamePayload>;
  /** Deletes a single `Game` using a unique key. */
  deleteGameByGroupIdAndName: Maybe<DeleteGamePayload>;
  /** Deletes a single `GameAuxMeetupInfo` using its globally unique id. */
  deleteGameAuxMeetupInfoByNodeId: Maybe<DeleteGameAuxMeetupInfoPayload>;
  /** Deletes a single `GameAuxMeetupInfo` using a unique key. */
  deleteGameAuxMeetupInfo: Maybe<DeleteGameAuxMeetupInfoPayload>;
  /** Deletes a single `GameEvent` using its globally unique id. */
  deleteGameEventByNodeId: Maybe<DeleteGameEventPayload>;
  /** Deletes a single `GameEvent` using a unique key. */
  deleteGameEvent: Maybe<DeleteGameEventPayload>;
  /** Deletes a single `GameEventRecord` using its globally unique id. */
  deleteGameEventRecordByNodeId: Maybe<DeleteGameEventRecordPayload>;
  /** Deletes a single `GameEventRecord` using a unique key. */
  deleteGameEventRecord: Maybe<DeleteGameEventRecordPayload>;
  /** Deletes a single `GameEventRecord` using a unique key. */
  deleteGameEventRecordByGameIdAndEventIndex: Maybe<DeleteGameEventRecordPayload>;
  /** Deletes a single `GameState` using its globally unique id. */
  deleteGameStateByNodeId: Maybe<DeleteGameStatePayload>;
  /** Deletes a single `GameState` using a unique key. */
  deleteGameState: Maybe<DeleteGameStatePayload>;
  /** Deletes a single `Group` using its globally unique id. */
  deleteGroupByNodeId: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Group` using a unique key. */
  deleteGroup: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Group` using a unique key. */
  deleteGroupByName: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Group` using a unique key. */
  deleteGroupByUrlSlug: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Lineup` using its globally unique id. */
  deleteLineupByNodeId: Maybe<DeleteLineupPayload>;
  /** Deletes a single `Lineup` using a unique key. */
  deleteLineup: Maybe<DeleteLineupPayload>;
  /** Deletes a single `LineupChange` using its globally unique id. */
  deleteLineupChangeByNodeId: Maybe<DeleteLineupChangePayload>;
  /** Deletes a single `LineupChange` using a unique key. */
  deleteLineupChange: Maybe<DeleteLineupChangePayload>;
  /** Deletes a single `LineupForGameState` using its globally unique id. */
  deleteLineupForGameStateByNodeId: Maybe<DeleteLineupForGameStatePayload>;
  /** Deletes a single `LineupForGameState` using a unique key. */
  deleteLineupForGameState: Maybe<DeleteLineupForGameStatePayload>;
  /** Deletes a single `LineupSpot` using its globally unique id. */
  deleteLineupSpotByNodeId: Maybe<DeleteLineupSpotPayload>;
  /** Deletes a single `LineupSpot` using a unique key. */
  deleteLineupSpot: Maybe<DeleteLineupSpotPayload>;
  /** Deletes a single `LineupSpot` using a unique key. */
  deleteLineupSpotByLineupIdAndBattingOrder: Maybe<DeleteLineupSpotPayload>;
  /** Deletes a single `LineupSpot` using a unique key. */
  deleteLineupSpotByLineupIdAndPosition: Maybe<DeleteLineupSpotPayload>;
  /** Deletes a single `ManualEntryBattingLine` using its globally unique id. */
  deleteManualEntryBattingLineByNodeId: Maybe<DeleteManualEntryBattingLinePayload>;
  /** Deletes a single `ManualEntryBattingLine` using a unique key. */
  deleteManualEntryBattingLine: Maybe<DeleteManualEntryBattingLinePayload>;
  /** Deletes a single `ManualEntryLineScoreCell` using its globally unique id. */
  deleteManualEntryLineScoreCellByNodeId: Maybe<DeleteManualEntryLineScoreCellPayload>;
  /** Deletes a single `ManualEntryLineScoreCell` using a unique key. */
  deleteManualEntryLineScoreCell: Maybe<DeleteManualEntryLineScoreCellPayload>;
  /** Deletes a single `ManualEntryPitchingLine` using its globally unique id. */
  deleteManualEntryPitchingLineByNodeId: Maybe<DeleteManualEntryPitchingLinePayload>;
  /** Deletes a single `ManualEntryPitchingLine` using a unique key. */
  deleteManualEntryPitchingLine: Maybe<DeleteManualEntryPitchingLinePayload>;
  /** Deletes a single `OutOnPlayRunner` using its globally unique id. */
  deleteOutOnPlayRunnerByNodeId: Maybe<DeleteOutOnPlayRunnerPayload>;
  /** Deletes a single `OutOnPlayRunner` using a unique key. */
  deleteOutOnPlayRunner: Maybe<DeleteOutOnPlayRunnerPayload>;
  /** Deletes a single `PlateAppearance` using its globally unique id. */
  deletePlateAppearanceByNodeId: Maybe<DeletePlateAppearancePayload>;
  /** Deletes a single `PlateAppearance` using a unique key. */
  deletePlateAppearance: Maybe<DeletePlateAppearancePayload>;
  /** Deletes a single `Player` using its globally unique id. */
  deletePlayerByNodeId: Maybe<DeletePlayerPayload>;
  /** Deletes a single `Player` using a unique key. */
  deletePlayer: Maybe<DeletePlayerPayload>;
  /** Deletes a single `Player` using a unique key. */
  deletePlayerByFirstNameAndLastName: Maybe<DeletePlayerPayload>;
  /** Deletes a single `PlayerAuxMeetupInfo` using its globally unique id. */
  deletePlayerAuxMeetupInfoByNodeId: Maybe<DeletePlayerAuxMeetupInfoPayload>;
  /** Deletes a single `PlayerAuxMeetupInfo` using a unique key. */
  deletePlayerAuxMeetupInfo: Maybe<DeletePlayerAuxMeetupInfoPayload>;
  /** Deletes a single `PlayerGroupMembership` using its globally unique id. */
  deletePlayerGroupMembershipByNodeId: Maybe<DeletePlayerGroupMembershipPayload>;
  /** Deletes a single `PlayerGroupMembership` using a unique key. */
  deletePlayerGroupMembership: Maybe<DeletePlayerGroupMembershipPayload>;
  /** Deletes a single `ReduxDump` using its globally unique id. */
  deleteReduxDumpByNodeId: Maybe<DeleteReduxDumpPayload>;
  /** Deletes a single `ReduxDump` using a unique key. */
  deleteReduxDump: Maybe<DeleteReduxDumpPayload>;
  /** Deletes a single `ScoredRunner` using its globally unique id. */
  deleteScoredRunnerByNodeId: Maybe<DeleteScoredRunnerPayload>;
  /** Deletes a single `ScoredRunner` using a unique key. */
  deleteScoredRunner: Maybe<DeleteScoredRunnerPayload>;
  /** Deletes a single `SoloModeOpponentInning` using its globally unique id. */
  deleteSoloModeOpponentInningByNodeId: Maybe<DeleteSoloModeOpponentInningPayload>;
  /** Deletes a single `SoloModeOpponentInning` using a unique key. */
  deleteSoloModeOpponentInning: Maybe<DeleteSoloModeOpponentInningPayload>;
  /** Deletes a single `StolenBaseAttempt` using its globally unique id. */
  deleteStolenBaseAttemptByNodeId: Maybe<DeleteStolenBaseAttemptPayload>;
  /** Deletes a single `StolenBaseAttempt` using a unique key. */
  deleteStolenBaseAttempt: Maybe<DeleteStolenBaseAttemptPayload>;
  /** Deletes a single `Team` using its globally unique id. */
  deleteTeamByNodeId: Maybe<DeleteTeamPayload>;
  /** Deletes a single `Team` using a unique key. */
  deleteTeam: Maybe<DeleteTeamPayload>;
  /** Deletes a single `Team` using a unique key. */
  deleteTeamByGameIdAndRole: Maybe<DeleteTeamPayload>;
  initiatePasswordReset: Maybe<InitiatePasswordResetPayload>;
  initiatePlayerClaim: Maybe<InitiatePlayerClaimPayload>;
  login: Maybe<LoginPayload>;
  resetPassword: Maybe<ResetPasswordPayload>;
  verifyEmail: Maybe<VerifyEmailPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAtBatSkipArgs = {
  input: CreateAtBatSkipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateBaseRunnerArgs = {
  input: CreateBaseRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateBasepathMovementArgs = {
  input: CreateBasepathMovementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEarlyGameEndArgs = {
  input: CreateEarlyGameEndInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFieldArgs = {
  input: CreateFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameArgs = {
  input: CreateGameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameAuxMeetupInfoArgs = {
  input: CreateGameAuxMeetupInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameEventArgs = {
  input: CreateGameEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameEventRecordArgs = {
  input: CreateGameEventRecordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameStateArgs = {
  input: CreateGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGroupArgs = {
  input: CreateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLineupArgs = {
  input: CreateLineupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLineupChangeArgs = {
  input: CreateLineupChangeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLineupForGameStateArgs = {
  input: CreateLineupForGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLineupSpotArgs = {
  input: CreateLineupSpotInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateManualEntryBattingLineArgs = {
  input: CreateManualEntryBattingLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateManualEntryLineScoreCellArgs = {
  input: CreateManualEntryLineScoreCellInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateManualEntryPitchingLineArgs = {
  input: CreateManualEntryPitchingLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOutOnPlayRunnerArgs = {
  input: CreateOutOnPlayRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlateAppearanceArgs = {
  input: CreatePlateAppearanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlayerArgs = {
  input: CreatePlayerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlayerAuxMeetupInfoArgs = {
  input: CreatePlayerAuxMeetupInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlayerGroupMembershipArgs = {
  input: CreatePlayerGroupMembershipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReduxDumpArgs = {
  input: CreateReduxDumpInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateScoredRunnerArgs = {
  input: CreateScoredRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSoloModeOpponentInningArgs = {
  input: CreateSoloModeOpponentInningInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStolenBaseAttemptArgs = {
  input: CreateStolenBaseAttemptInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTeamArgs = {
  input: CreateTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAtBatSkipByNodeIdArgs = {
  input: UpdateAtBatSkipByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAtBatSkipArgs = {
  input: UpdateAtBatSkipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBaseRunnerByNodeIdArgs = {
  input: UpdateBaseRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBaseRunnerArgs = {
  input: UpdateBaseRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBasepathMovementByNodeIdArgs = {
  input: UpdateBasepathMovementByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBasepathMovementArgs = {
  input: UpdateBasepathMovementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEarlyGameEndByNodeIdArgs = {
  input: UpdateEarlyGameEndByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEarlyGameEndArgs = {
  input: UpdateEarlyGameEndInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldByNodeIdArgs = {
  input: UpdateFieldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldArgs = {
  input: UpdateFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameByNodeIdArgs = {
  input: UpdateGameByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameArgs = {
  input: UpdateGameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameByGroupIdAndNameArgs = {
  input: UpdateGameByGroupIdAndNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameAuxMeetupInfoByNodeIdArgs = {
  input: UpdateGameAuxMeetupInfoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameAuxMeetupInfoArgs = {
  input: UpdateGameAuxMeetupInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameEventByNodeIdArgs = {
  input: UpdateGameEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameEventArgs = {
  input: UpdateGameEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameEventRecordByNodeIdArgs = {
  input: UpdateGameEventRecordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameEventRecordArgs = {
  input: UpdateGameEventRecordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameEventRecordByGameIdAndEventIndexArgs = {
  input: UpdateGameEventRecordByGameIdAndEventIndexInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameStateByNodeIdArgs = {
  input: UpdateGameStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameStateArgs = {
  input: UpdateGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupByNodeIdArgs = {
  input: UpdateGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupArgs = {
  input: UpdateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupByNameArgs = {
  input: UpdateGroupByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupByUrlSlugArgs = {
  input: UpdateGroupByUrlSlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupByNodeIdArgs = {
  input: UpdateLineupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupArgs = {
  input: UpdateLineupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupChangeByNodeIdArgs = {
  input: UpdateLineupChangeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupChangeArgs = {
  input: UpdateLineupChangeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupForGameStateByNodeIdArgs = {
  input: UpdateLineupForGameStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupForGameStateArgs = {
  input: UpdateLineupForGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupSpotByNodeIdArgs = {
  input: UpdateLineupSpotByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupSpotArgs = {
  input: UpdateLineupSpotInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupSpotByLineupIdAndBattingOrderArgs = {
  input: UpdateLineupSpotByLineupIdAndBattingOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupSpotByLineupIdAndPositionArgs = {
  input: UpdateLineupSpotByLineupIdAndPositionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateManualEntryBattingLineByNodeIdArgs = {
  input: UpdateManualEntryBattingLineByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateManualEntryBattingLineArgs = {
  input: UpdateManualEntryBattingLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateManualEntryLineScoreCellByNodeIdArgs = {
  input: UpdateManualEntryLineScoreCellByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateManualEntryLineScoreCellArgs = {
  input: UpdateManualEntryLineScoreCellInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateManualEntryPitchingLineByNodeIdArgs = {
  input: UpdateManualEntryPitchingLineByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateManualEntryPitchingLineArgs = {
  input: UpdateManualEntryPitchingLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOutOnPlayRunnerByNodeIdArgs = {
  input: UpdateOutOnPlayRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOutOnPlayRunnerArgs = {
  input: UpdateOutOnPlayRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlateAppearanceByNodeIdArgs = {
  input: UpdatePlateAppearanceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlateAppearanceArgs = {
  input: UpdatePlateAppearanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerByNodeIdArgs = {
  input: UpdatePlayerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerArgs = {
  input: UpdatePlayerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerByFirstNameAndLastNameArgs = {
  input: UpdatePlayerByFirstNameAndLastNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerAuxMeetupInfoByNodeIdArgs = {
  input: UpdatePlayerAuxMeetupInfoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerAuxMeetupInfoArgs = {
  input: UpdatePlayerAuxMeetupInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerGroupMembershipByNodeIdArgs = {
  input: UpdatePlayerGroupMembershipByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerGroupMembershipArgs = {
  input: UpdatePlayerGroupMembershipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReduxDumpByNodeIdArgs = {
  input: UpdateReduxDumpByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReduxDumpArgs = {
  input: UpdateReduxDumpInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateScoredRunnerByNodeIdArgs = {
  input: UpdateScoredRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateScoredRunnerArgs = {
  input: UpdateScoredRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSoloModeOpponentInningByNodeIdArgs = {
  input: UpdateSoloModeOpponentInningByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSoloModeOpponentInningArgs = {
  input: UpdateSoloModeOpponentInningInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStolenBaseAttemptByNodeIdArgs = {
  input: UpdateStolenBaseAttemptByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStolenBaseAttemptArgs = {
  input: UpdateStolenBaseAttemptInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTeamByNodeIdArgs = {
  input: UpdateTeamByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTeamArgs = {
  input: UpdateTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTeamByGameIdAndRoleArgs = {
  input: UpdateTeamByGameIdAndRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAtBatSkipByNodeIdArgs = {
  input: DeleteAtBatSkipByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAtBatSkipArgs = {
  input: DeleteAtBatSkipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBaseRunnerByNodeIdArgs = {
  input: DeleteBaseRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBaseRunnerArgs = {
  input: DeleteBaseRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBasepathMovementByNodeIdArgs = {
  input: DeleteBasepathMovementByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBasepathMovementArgs = {
  input: DeleteBasepathMovementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEarlyGameEndByNodeIdArgs = {
  input: DeleteEarlyGameEndByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEarlyGameEndArgs = {
  input: DeleteEarlyGameEndInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldByNodeIdArgs = {
  input: DeleteFieldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldArgs = {
  input: DeleteFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameByNodeIdArgs = {
  input: DeleteGameByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameArgs = {
  input: DeleteGameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameByGroupIdAndNameArgs = {
  input: DeleteGameByGroupIdAndNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameAuxMeetupInfoByNodeIdArgs = {
  input: DeleteGameAuxMeetupInfoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameAuxMeetupInfoArgs = {
  input: DeleteGameAuxMeetupInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameEventByNodeIdArgs = {
  input: DeleteGameEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameEventArgs = {
  input: DeleteGameEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameEventRecordByNodeIdArgs = {
  input: DeleteGameEventRecordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameEventRecordArgs = {
  input: DeleteGameEventRecordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameEventRecordByGameIdAndEventIndexArgs = {
  input: DeleteGameEventRecordByGameIdAndEventIndexInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameStateByNodeIdArgs = {
  input: DeleteGameStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameStateArgs = {
  input: DeleteGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupByNodeIdArgs = {
  input: DeleteGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupArgs = {
  input: DeleteGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupByNameArgs = {
  input: DeleteGroupByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupByUrlSlugArgs = {
  input: DeleteGroupByUrlSlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupByNodeIdArgs = {
  input: DeleteLineupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupArgs = {
  input: DeleteLineupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupChangeByNodeIdArgs = {
  input: DeleteLineupChangeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupChangeArgs = {
  input: DeleteLineupChangeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupForGameStateByNodeIdArgs = {
  input: DeleteLineupForGameStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupForGameStateArgs = {
  input: DeleteLineupForGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupSpotByNodeIdArgs = {
  input: DeleteLineupSpotByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupSpotArgs = {
  input: DeleteLineupSpotInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupSpotByLineupIdAndBattingOrderArgs = {
  input: DeleteLineupSpotByLineupIdAndBattingOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupSpotByLineupIdAndPositionArgs = {
  input: DeleteLineupSpotByLineupIdAndPositionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteManualEntryBattingLineByNodeIdArgs = {
  input: DeleteManualEntryBattingLineByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteManualEntryBattingLineArgs = {
  input: DeleteManualEntryBattingLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteManualEntryLineScoreCellByNodeIdArgs = {
  input: DeleteManualEntryLineScoreCellByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteManualEntryLineScoreCellArgs = {
  input: DeleteManualEntryLineScoreCellInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteManualEntryPitchingLineByNodeIdArgs = {
  input: DeleteManualEntryPitchingLineByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteManualEntryPitchingLineArgs = {
  input: DeleteManualEntryPitchingLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOutOnPlayRunnerByNodeIdArgs = {
  input: DeleteOutOnPlayRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOutOnPlayRunnerArgs = {
  input: DeleteOutOnPlayRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlateAppearanceByNodeIdArgs = {
  input: DeletePlateAppearanceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlateAppearanceArgs = {
  input: DeletePlateAppearanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerByNodeIdArgs = {
  input: DeletePlayerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerArgs = {
  input: DeletePlayerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerByFirstNameAndLastNameArgs = {
  input: DeletePlayerByFirstNameAndLastNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerAuxMeetupInfoByNodeIdArgs = {
  input: DeletePlayerAuxMeetupInfoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerAuxMeetupInfoArgs = {
  input: DeletePlayerAuxMeetupInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerGroupMembershipByNodeIdArgs = {
  input: DeletePlayerGroupMembershipByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerGroupMembershipArgs = {
  input: DeletePlayerGroupMembershipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReduxDumpByNodeIdArgs = {
  input: DeleteReduxDumpByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReduxDumpArgs = {
  input: DeleteReduxDumpInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteScoredRunnerByNodeIdArgs = {
  input: DeleteScoredRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteScoredRunnerArgs = {
  input: DeleteScoredRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSoloModeOpponentInningByNodeIdArgs = {
  input: DeleteSoloModeOpponentInningByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSoloModeOpponentInningArgs = {
  input: DeleteSoloModeOpponentInningInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStolenBaseAttemptByNodeIdArgs = {
  input: DeleteStolenBaseAttemptByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStolenBaseAttemptArgs = {
  input: DeleteStolenBaseAttemptInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTeamByNodeIdArgs = {
  input: DeleteTeamByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTeamArgs = {
  input: DeleteTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTeamByGameIdAndRoleArgs = {
  input: DeleteTeamByGameIdAndRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationInitiatePasswordResetArgs = {
  input: InitiatePasswordResetInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationInitiatePlayerClaimArgs = {
  input: InitiatePlayerClaimInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLoginArgs = {
  input: LoginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationVerifyEmailArgs = {
  input: VerifyEmailInput;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type OutOnPlayRunner = Node & {
  __typename?: 'OutOnPlayRunner';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
  gameId: Scalars['UUID'];
  /** Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `OutOnPlayRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `OutOnPlayRunner`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `OutOnPlayRunner` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OutOnPlayRunnerCondition = {
  /** Checks for equality with the object’s `plateAppearanceId` field. */
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runnerId` field. */
  runnerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `OutOnPlayRunner` object types. All fields are combined with a logical ‘and.’ */
export type OutOnPlayRunnerFilter = {
  /** Filter by the object’s `plateAppearanceId` field. */
  plateAppearanceId?: Maybe<UuidFilter>;
  /** Filter by the object’s `runnerId` field. */
  runnerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<OutOnPlayRunnerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<OutOnPlayRunnerFilter>>;
  /** Negates the expression. */
  not?: Maybe<OutOnPlayRunnerFilter>;
};

/** The `game` to be created by this mutation. */
export type OutOnPlayRunnerGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `OutOnPlayRunnerInput` mutation. */
export type OutOnPlayRunnerGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<OutOnPlayRunnerGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `outOnPlayRunner` in the `GameInput` mutation. */
export type OutOnPlayRunnerGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `outOnPlayRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyDelete>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyUsingOutOnPlayRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyNodeIdUpdate>>;
  /** A `OutOnPlayRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<OutOnPlayRunnerGameIdFkeyOutOnPlayRunnerCreateInput>>;
};

/** The `outOnPlayRunner` to be created by this mutation. */
export type OutOnPlayRunnerGameIdFkeyOutOnPlayRunnerCreateInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** An input for mutations affecting `OutOnPlayRunner` */
export type OutOnPlayRunnerInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type OutOnPlayRunnerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `outOnPlayRunner` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type OutOnPlayRunnerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `outOnPlayRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `outOnPlayRunner` to look up the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyUsingOutOnPlayRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** The fields on `outOnPlayRunner` to look up the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingOutOnPlayRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `outOnPlayRunner` to look up the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingOutOnPlayRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The fields on `outOnPlayRunner` to look up the row to connect. */
export type OutOnPlayRunnerOutOnPlayRunnerPkeyConnect = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The fields on `outOnPlayRunner` to look up the row to delete. */
export type OutOnPlayRunnerOutOnPlayRunnerPkeyDelete = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** Represents an update to a `OutOnPlayRunner`. Fields that are set will be updated. */
export type OutOnPlayRunnerPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** Input for the nested mutation of `plateAppearance` in the `OutOnPlayRunnerInput` mutation. */
export type OutOnPlayRunnerPlateAppearanceIdFkeyInput = {
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectById?: Maybe<PlateAppearancePlateAppearancePkeyConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlateAppearanceNodeIdConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteById?: Maybe<PlateAppearancePlateAppearancePkeyDelete>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlateAppearanceNodeIdDelete>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateById?: Maybe<PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateByNodeId?: Maybe<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate>;
  /** A `PlateAppearanceInput` object that will be created and connected to this object. */
  create?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyPlateAppearanceCreateInput>;
};

/** Input for the nested mutation of `outOnPlayRunner` in the `PlateAppearanceInput` mutation. */
export type OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput = {
  /** Flag indicating whether all other `outOnPlayRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyDelete>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingOutOnPlayRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate>>;
  /** A `OutOnPlayRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<OutOnPlayRunnerPlateAppearanceIdFkeyOutOnPlayRunnerCreateInput>>;
};

/** The `outOnPlayRunner` to be created by this mutation. */
export type OutOnPlayRunnerPlateAppearanceIdFkeyOutOnPlayRunnerCreateInput = {
  runnerId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** The `plateAppearance` to be created by this mutation. */
export type OutOnPlayRunnerPlateAppearanceIdFkeyPlateAppearanceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** Input for the nested mutation of `player` in the `OutOnPlayRunnerInput` mutation. */
export type OutOnPlayRunnerRunnerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<OutOnPlayRunnerRunnerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `outOnPlayRunner` in the `PlayerInput` mutation. */
export type OutOnPlayRunnerRunnerIdFkeyInverseInput = {
  /** Flag indicating whether all other `outOnPlayRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyDelete>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingOutOnPlayRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate>>;
  /** A `OutOnPlayRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<OutOnPlayRunnerRunnerIdFkeyOutOnPlayRunnerCreateInput>>;
};

/** The `outOnPlayRunner` to be created by this mutation. */
export type OutOnPlayRunnerRunnerIdFkeyOutOnPlayRunnerCreateInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** The `player` to be created by this mutation. */
export type OutOnPlayRunnerRunnerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** Methods to use when ordering `OutOnPlayRunner`. */
export enum OutOnPlayRunnersOrderBy {
  NATURAL = 'NATURAL',
  PLATE_APPEARANCE_ID_ASC = 'PLATE_APPEARANCE_ID_ASC',
  PLATE_APPEARANCE_ID_DESC = 'PLATE_APPEARANCE_ID_DESC',
  RUNNER_ID_ASC = 'RUNNER_ID_ASC',
  RUNNER_ID_DESC = 'RUNNER_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export enum PermissionType {
  ADD_NEW_PLAYERS = 'ADD_NEW_PLAYERS',
  SAVE_DEBUG_DATA = 'SAVE_DEBUG_DATA'
}

export type PlateAppearance = Node & {
  __typename?: 'PlateAppearance';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  type: PlateAppearanceType;
  contact: Maybe<ContactQuality>;
  fieldedBy: Maybe<FieldingPosition>;
  runsScoredOnSacFly: Maybe<Scalars['Int']>;
  routinePlay: Scalars['Boolean'];
  gameId: Scalars['UUID'];
  batterId: Scalars['UUID'];
  /** Reads a single `Game` that is related to this `PlateAppearance`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `PlateAppearance`. */
  batter: Maybe<Player>;
  /** Reads and enables pagination through a set of `BasepathMovement`. */
  basepathMovements: Array<BasepathMovement>;
  /** Reads and enables pagination through a set of `OutOnPlayRunner`. */
  outOnPlayRunners: Array<OutOnPlayRunner>;
};


export type PlateAppearanceBasepathMovementsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BasepathMovementsOrderBy>>;
  condition?: Maybe<BasepathMovementCondition>;
  filter?: Maybe<BasepathMovementFilter>;
};


export type PlateAppearanceOutOnPlayRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<OutOnPlayRunnersOrderBy>>;
  condition?: Maybe<OutOnPlayRunnerCondition>;
  filter?: Maybe<OutOnPlayRunnerFilter>;
};

/** Input for the nested mutation of `player` in the `PlateAppearanceInput` mutation. */
export type PlateAppearanceBatterIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<PlateAppearanceOnPlateAppearanceForPlateAppearanceBatterIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<PlateAppearanceBatterIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `plateAppearance` in the `PlayerInput` mutation. */
export type PlateAppearanceBatterIdFkeyInverseInput = {
  /** Flag indicating whether all other `plateAppearance` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectById?: Maybe<Array<PlateAppearancePlateAppearancePkeyConnect>>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PlateAppearanceNodeIdConnect>>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteById?: Maybe<Array<PlateAppearancePlateAppearancePkeyDelete>>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PlateAppearanceNodeIdDelete>>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateById?: Maybe<Array<PlateAppearanceOnPlateAppearanceForPlateAppearanceBatterIdFkeyUsingPlateAppearancePkeyUpdate>>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyNodeIdUpdate>>;
  /** A `PlateAppearanceInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PlateAppearanceBatterIdFkeyPlateAppearanceCreateInput>>;
};

/** The `plateAppearance` to be created by this mutation. */
export type PlateAppearanceBatterIdFkeyPlateAppearanceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** The `player` to be created by this mutation. */
export type PlateAppearanceBatterIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/**
 * A condition to be used against `PlateAppearance` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PlateAppearanceCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<PlateAppearanceType>;
  /** Checks for equality with the object’s `contact` field. */
  contact?: Maybe<ContactQuality>;
  /** Checks for equality with the object’s `fieldedBy` field. */
  fieldedBy?: Maybe<FieldingPosition>;
  /** Checks for equality with the object’s `runsScoredOnSacFly` field. */
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `routinePlay` field. */
  routinePlay?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `batterId` field. */
  batterId?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `PlateAppearance` object types. All fields are combined with a logical ‘and.’ */
export type PlateAppearanceFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<PlateAppearanceTypeFilter>;
  /** Filter by the object’s `contact` field. */
  contact?: Maybe<ContactQualityFilter>;
  /** Filter by the object’s `fieldedBy` field. */
  fieldedBy?: Maybe<FieldingPositionFilter>;
  /** Filter by the object’s `runsScoredOnSacFly` field. */
  runsScoredOnSacFly?: Maybe<IntFilter>;
  /** Filter by the object’s `routinePlay` field. */
  routinePlay?: Maybe<BooleanFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Filter by the object’s `batterId` field. */
  batterId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PlateAppearanceFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PlateAppearanceFilter>>;
  /** Negates the expression. */
  not?: Maybe<PlateAppearanceFilter>;
};

/** The `game` to be created by this mutation. */
export type PlateAppearanceGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `PlateAppearanceInput` mutation. */
export type PlateAppearanceGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnPlateAppearanceForPlateAppearanceGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnPlateAppearanceForPlateAppearanceGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<PlateAppearanceOnPlateAppearanceForPlateAppearanceGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<PlateAppearanceGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `plateAppearance` in the `GameInput` mutation. */
export type PlateAppearanceGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `plateAppearance` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectById?: Maybe<Array<PlateAppearancePlateAppearancePkeyConnect>>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PlateAppearanceNodeIdConnect>>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteById?: Maybe<Array<PlateAppearancePlateAppearancePkeyDelete>>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PlateAppearanceNodeIdDelete>>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateById?: Maybe<Array<PlateAppearanceOnPlateAppearanceForPlateAppearanceGameIdFkeyUsingPlateAppearancePkeyUpdate>>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnPlateAppearanceForPlateAppearanceGameIdFkeyNodeIdUpdate>>;
  /** A `PlateAppearanceInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PlateAppearanceGameIdFkeyPlateAppearanceCreateInput>>;
};

/** The `plateAppearance` to be created by this mutation. */
export type PlateAppearanceGameIdFkeyPlateAppearanceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** An input for mutations affecting `PlateAppearance` */
export type PlateAppearanceInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PlateAppearanceNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PlateAppearanceNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `basepathMovement` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: BasepathMovementPatch;
};

/** The fields on `plateAppearance` to look up the row to update. */
export type PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate = {
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: UpdatePlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `plateAppearance` to look up the row to update. */
export type PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate = {
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: UpdatePlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `outOnPlayRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: OutOnPlayRunnerPatch;
};

/** The fields on `plateAppearance` to look up the row to update. */
export type PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate = {
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: UpdatePlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlateAppearanceOnPlateAppearanceForPlateAppearanceBatterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `plateAppearance` to look up the row to update. */
export type PlateAppearanceOnPlateAppearanceForPlateAppearanceBatterIdFkeyUsingPlateAppearancePkeyUpdate = {
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: UpdatePlateAppearanceOnPlateAppearanceForPlateAppearanceBatterIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlateAppearanceOnPlateAppearanceForPlateAppearanceGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `plateAppearance` to look up the row to update. */
export type PlateAppearanceOnPlateAppearanceForPlateAppearanceGameIdFkeyUsingPlateAppearancePkeyUpdate = {
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: UpdatePlateAppearanceOnPlateAppearanceForPlateAppearanceGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `PlateAppearance`. Fields that are set will be updated. */
export type PlateAppearancePatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** The fields on `plateAppearance` to look up the row to connect. */
export type PlateAppearancePlateAppearancePkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `plateAppearance` to look up the row to delete. */
export type PlateAppearancePlateAppearancePkeyDelete = {
  id: Scalars['UUID'];
};

export enum PlateAppearanceType {
  OUT = 'OUT',
  WALK = 'WALK',
  SINGLE = 'SINGLE',
  DOUBLE = 'DOUBLE',
  TRIPLE = 'TRIPLE',
  HOMERUN = 'HOMERUN',
  SACRIFICE_FLY = 'SACRIFICE_FLY',
  FIELDERS_CHOICE = 'FIELDERS_CHOICE',
  DOUBLE_PLAY = 'DOUBLE_PLAY'
}

/** A filter to be used against PlateAppearanceType fields. All fields are combined with a logical ‘and.’ */
export type PlateAppearanceTypeFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<PlateAppearanceType>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<PlateAppearanceType>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<PlateAppearanceType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<PlateAppearanceType>;
  /** Included in the specified list. */
  in?: Maybe<Array<PlateAppearanceType>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<PlateAppearanceType>>;
  /** Less than the specified value. */
  lessThan?: Maybe<PlateAppearanceType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<PlateAppearanceType>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<PlateAppearanceType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<PlateAppearanceType>;
};

/** Methods to use when ordering `PlateAppearance`. */
export enum PlateAppearancesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  TYPE_ASC = 'TYPE_ASC',
  TYPE_DESC = 'TYPE_DESC',
  CONTACT_ASC = 'CONTACT_ASC',
  CONTACT_DESC = 'CONTACT_DESC',
  FIELDED_BY_ASC = 'FIELDED_BY_ASC',
  FIELDED_BY_DESC = 'FIELDED_BY_DESC',
  RUNS_SCORED_ON_SAC_FLY_ASC = 'RUNS_SCORED_ON_SAC_FLY_ASC',
  RUNS_SCORED_ON_SAC_FLY_DESC = 'RUNS_SCORED_ON_SAC_FLY_DESC',
  ROUTINE_PLAY_ASC = 'ROUTINE_PLAY_ASC',
  ROUTINE_PLAY_DESC = 'ROUTINE_PLAY_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  BATTER_ID_ASC = 'BATTER_ID_ASC',
  BATTER_ID_DESC = 'BATTER_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type Player = Node & {
  __typename?: 'Player';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  legacyPlayerId: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName: Maybe<Scalars['String']>;
  nickname: Maybe<Scalars['String']>;
  imageUrl: Maybe<Scalars['String']>;
  timeCreated: Scalars['Datetime'];
  claimed: Scalars['Boolean'];
  timeUpdated: Scalars['Datetime'];
  timeClaimed: Maybe<Scalars['Datetime']>;
  active: Scalars['Boolean'];
  /** Reads and enables pagination through a set of `Team`. */
  teamsByCaptainId: Array<Team>;
  /** Reads and enables pagination through a set of `LineupSpot`. */
  lineupSpots: Array<LineupSpot>;
  /** Reads and enables pagination through a set of `PlateAppearance`. */
  plateAppearancesByBatterId: Array<PlateAppearance>;
  /** Reads and enables pagination through a set of `BasepathMovement`. */
  basepathMovementsByRunnerId: Array<BasepathMovement>;
  /** Reads and enables pagination through a set of `OutOnPlayRunner`. */
  outOnPlayRunnersByRunnerId: Array<OutOnPlayRunner>;
  /** Reads and enables pagination through a set of `StolenBaseAttempt`. */
  stolenBaseAttemptsByRunnerId: Array<StolenBaseAttempt>;
  /** Reads and enables pagination through a set of `GameState`. */
  gameStatesByPlayerAtBat: Array<GameState>;
  /** Reads and enables pagination through a set of `BaseRunner`. */
  baseRunnersByRunnerId: Array<BaseRunner>;
  /** Reads and enables pagination through a set of `ScoredRunner`. */
  scoredRunnersByRunnerId: Array<ScoredRunner>;
  /** Reads and enables pagination through a set of `PlayerGroupMembership`. */
  playerGroupMemberships: Array<PlayerGroupMembership>;
  /** Reads and enables pagination through a set of `AtBatSkip`. */
  atBatSkipsByBatterId: Array<AtBatSkip>;
  /** Reads and enables pagination through a set of `ManualEntryBattingLine`. */
  manualEntryBattingLines: Array<ManualEntryBattingLine>;
  /** Reads and enables pagination through a set of `ManualEntryPitchingLine`. */
  manualEntryPitchingLines: Array<ManualEntryPitchingLine>;
  /** Reads a single `PlayerAuxMeetupInfo` that is related to this `Player`. */
  playerAuxMeetupInfo: Maybe<PlayerAuxMeetupInfo>;
  /** Reads a single `GameAuxMeetupInfo` that is related to this `Player`. */
  gameAuxMeetupInfoByGameId: Maybe<GameAuxMeetupInfo>;
  /** Reads and enables pagination through a set of `CareerBattingStat`. */
  careerBattingStats: Array<CareerBattingStat>;
  /** Reads and enables pagination through a set of `GameBattingStat`. */
  gameBattingStats: Array<GameBattingStat>;
  /** Reads and enables pagination through a set of `SeasonBattingStat`. */
  seasonBattingStats: Array<SeasonBattingStat>;
  debut: Maybe<Scalars['Date']>;
  fullName: Maybe<Scalars['String']>;
  gamesPlayed: Maybe<Scalars['Int']>;
  /** sortable */
  gamesPlayedThisYear: Maybe<Scalars['Int']>;
};


export type PlayerTeamsByCaptainIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<TeamsOrderBy>>;
  condition?: Maybe<TeamCondition>;
  filter?: Maybe<TeamFilter>;
};


export type PlayerLineupSpotsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupSpotsOrderBy>>;
  condition?: Maybe<LineupSpotCondition>;
  filter?: Maybe<LineupSpotFilter>;
};


export type PlayerPlateAppearancesByBatterIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlateAppearancesOrderBy>>;
  condition?: Maybe<PlateAppearanceCondition>;
  filter?: Maybe<PlateAppearanceFilter>;
};


export type PlayerBasepathMovementsByRunnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BasepathMovementsOrderBy>>;
  condition?: Maybe<BasepathMovementCondition>;
  filter?: Maybe<BasepathMovementFilter>;
};


export type PlayerOutOnPlayRunnersByRunnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<OutOnPlayRunnersOrderBy>>;
  condition?: Maybe<OutOnPlayRunnerCondition>;
  filter?: Maybe<OutOnPlayRunnerFilter>;
};


export type PlayerStolenBaseAttemptsByRunnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<StolenBaseAttemptsOrderBy>>;
  condition?: Maybe<StolenBaseAttemptCondition>;
  filter?: Maybe<StolenBaseAttemptFilter>;
};


export type PlayerGameStatesByPlayerAtBatArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameStatesOrderBy>>;
  condition?: Maybe<GameStateCondition>;
  filter?: Maybe<GameStateFilter>;
};


export type PlayerBaseRunnersByRunnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BaseRunnersOrderBy>>;
  condition?: Maybe<BaseRunnerCondition>;
  filter?: Maybe<BaseRunnerFilter>;
};


export type PlayerScoredRunnersByRunnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ScoredRunnersOrderBy>>;
  condition?: Maybe<ScoredRunnerCondition>;
  filter?: Maybe<ScoredRunnerFilter>;
};


export type PlayerPlayerGroupMembershipsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlayerGroupMembershipsOrderBy>>;
  condition?: Maybe<PlayerGroupMembershipCondition>;
  filter?: Maybe<PlayerGroupMembershipFilter>;
};


export type PlayerAtBatSkipsByBatterIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<AtBatSkipsOrderBy>>;
  condition?: Maybe<AtBatSkipCondition>;
  filter?: Maybe<AtBatSkipFilter>;
};


export type PlayerManualEntryBattingLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ManualEntryBattingLinesOrderBy>>;
  condition?: Maybe<ManualEntryBattingLineCondition>;
  filter?: Maybe<ManualEntryBattingLineFilter>;
};


export type PlayerManualEntryPitchingLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ManualEntryPitchingLinesOrderBy>>;
  condition?: Maybe<ManualEntryPitchingLineCondition>;
  filter?: Maybe<ManualEntryPitchingLineFilter>;
};


export type PlayerCareerBattingStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerBattingStatsOrderBy>>;
  condition?: Maybe<CareerBattingStatCondition>;
  filter?: Maybe<CareerBattingStatFilter>;
};


export type PlayerGameBattingStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameBattingStatsOrderBy>>;
  condition?: Maybe<GameBattingStatCondition>;
  filter?: Maybe<GameBattingStatFilter>;
};


export type PlayerSeasonBattingStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonBattingStatsOrderBy>>;
  condition?: Maybe<SeasonBattingStatCondition>;
  filter?: Maybe<SeasonBattingStatFilter>;
};


export type PlayerDebutArgs = {
  groupId?: Maybe<Scalars['UUID']>;
};


export type PlayerGamesPlayedArgs = {
  beforeDate?: Maybe<Scalars['Datetime']>;
  afterDate?: Maybe<Scalars['Datetime']>;
};

export type PlayerAuxMeetupInfo = Node & {
  __typename?: 'PlayerAuxMeetupInfo';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  playerId: Scalars['UUID'];
  gender: Gender;
  bats: Handedness;
  throws: Handedness;
  preferredPositionFirst: FieldingPosition;
  preferredPositionSecond: FieldingPosition;
  preferredPositionThird: FieldingPosition;
  meetupMemberId: Scalars['String'];
  adminNickname: Maybe<Scalars['String']>;
  selfNickname: Maybe<Scalars['String']>;
  skillLevel: Maybe<Scalars['Int']>;
  favoriteTeam: Maybe<Scalars['String']>;
  hometown: Maybe<Scalars['String']>;
  school: Maybe<Scalars['String']>;
  dateDebuted: Maybe<Scalars['Date']>;
  /** Reads a single `Player` that is related to this `PlayerAuxMeetupInfo`. */
  player: Maybe<Player>;
};

/**
 * A condition to be used against `PlayerAuxMeetupInfo` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type PlayerAuxMeetupInfoCondition = {
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gender` field. */
  gender?: Maybe<Gender>;
  /** Checks for equality with the object’s `bats` field. */
  bats?: Maybe<Handedness>;
  /** Checks for equality with the object’s `throws` field. */
  throws?: Maybe<Handedness>;
  /** Checks for equality with the object’s `preferredPositionFirst` field. */
  preferredPositionFirst?: Maybe<FieldingPosition>;
  /** Checks for equality with the object’s `preferredPositionSecond` field. */
  preferredPositionSecond?: Maybe<FieldingPosition>;
  /** Checks for equality with the object’s `preferredPositionThird` field. */
  preferredPositionThird?: Maybe<FieldingPosition>;
  /** Checks for equality with the object’s `meetupMemberId` field. */
  meetupMemberId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `adminNickname` field. */
  adminNickname?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `selfNickname` field. */
  selfNickname?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skillLevel` field. */
  skillLevel?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `favoriteTeam` field. */
  favoriteTeam?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `hometown` field. */
  hometown?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `school` field. */
  school?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dateDebuted` field. */
  dateDebuted?: Maybe<Scalars['Date']>;
};

/** A filter to be used against `PlayerAuxMeetupInfo` object types. All fields are combined with a logical ‘and.’ */
export type PlayerAuxMeetupInfoFilter = {
  /** Filter by the object’s `playerId` field. */
  playerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `gender` field. */
  gender?: Maybe<GenderFilter>;
  /** Filter by the object’s `bats` field. */
  bats?: Maybe<HandednessFilter>;
  /** Filter by the object’s `throws` field. */
  throws?: Maybe<HandednessFilter>;
  /** Filter by the object’s `preferredPositionFirst` field. */
  preferredPositionFirst?: Maybe<FieldingPositionFilter>;
  /** Filter by the object’s `preferredPositionSecond` field. */
  preferredPositionSecond?: Maybe<FieldingPositionFilter>;
  /** Filter by the object’s `preferredPositionThird` field. */
  preferredPositionThird?: Maybe<FieldingPositionFilter>;
  /** Filter by the object’s `meetupMemberId` field. */
  meetupMemberId?: Maybe<StringFilter>;
  /** Filter by the object’s `adminNickname` field. */
  adminNickname?: Maybe<StringFilter>;
  /** Filter by the object’s `selfNickname` field. */
  selfNickname?: Maybe<StringFilter>;
  /** Filter by the object’s `skillLevel` field. */
  skillLevel?: Maybe<IntFilter>;
  /** Filter by the object’s `favoriteTeam` field. */
  favoriteTeam?: Maybe<StringFilter>;
  /** Filter by the object’s `hometown` field. */
  hometown?: Maybe<StringFilter>;
  /** Filter by the object’s `school` field. */
  school?: Maybe<StringFilter>;
  /** Filter by the object’s `dateDebuted` field. */
  dateDebuted?: Maybe<DateFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PlayerAuxMeetupInfoFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PlayerAuxMeetupInfoFilter>>;
  /** Negates the expression. */
  not?: Maybe<PlayerAuxMeetupInfoFilter>;
};

/** An input for mutations affecting `PlayerAuxMeetupInfo` */
export type PlayerAuxMeetupInfoInput = {
  playerId?: Maybe<Scalars['UUID']>;
  gender: Gender;
  bats: Handedness;
  throws: Handedness;
  preferredPositionFirst: FieldingPosition;
  preferredPositionSecond: FieldingPosition;
  preferredPositionThird: FieldingPosition;
  meetupMemberId: Scalars['String'];
  adminNickname?: Maybe<Scalars['String']>;
  selfNickname?: Maybe<Scalars['String']>;
  skillLevel?: Maybe<Scalars['Int']>;
  favoriteTeam?: Maybe<Scalars['String']>;
  hometown?: Maybe<Scalars['String']>;
  school?: Maybe<Scalars['String']>;
  dateDebuted?: Maybe<Scalars['Date']>;
  player?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PlayerAuxMeetupInfoNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `playerAuxMeetupInfo` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PlayerAuxMeetupInfoNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `playerAuxMeetupInfo` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerAuxMeetupInfoOnPlayerAuxMeetupInfoForPlayerAuxMeetupInfoPlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `playerAuxMeetupInfo` to look up the row to update. */
export type PlayerAuxMeetupInfoOnPlayerAuxMeetupInfoForPlayerAuxMeetupInfoPlayerIdFkeyUsingPlayerAuxMeetupInfoPkeyUpdate = {
  /** An object where the defined keys will be set on the `playerAuxMeetupInfo` being updated. */
  patch: UpdatePlayerAuxMeetupInfoOnPlayerAuxMeetupInfoForPlayerAuxMeetupInfoPlayerIdFkeyPatch;
  playerId: Scalars['UUID'];
};

/** Represents an update to a `PlayerAuxMeetupInfo`. Fields that are set will be updated. */
export type PlayerAuxMeetupInfoPatch = {
  playerId?: Maybe<Scalars['UUID']>;
  gender?: Maybe<Gender>;
  bats?: Maybe<Handedness>;
  throws?: Maybe<Handedness>;
  preferredPositionFirst?: Maybe<FieldingPosition>;
  preferredPositionSecond?: Maybe<FieldingPosition>;
  preferredPositionThird?: Maybe<FieldingPosition>;
  meetupMemberId?: Maybe<Scalars['String']>;
  adminNickname?: Maybe<Scalars['String']>;
  selfNickname?: Maybe<Scalars['String']>;
  skillLevel?: Maybe<Scalars['Int']>;
  favoriteTeam?: Maybe<Scalars['String']>;
  hometown?: Maybe<Scalars['String']>;
  school?: Maybe<Scalars['String']>;
  dateDebuted?: Maybe<Scalars['Date']>;
  player?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInput>;
};

/** The fields on `playerAuxMeetupInfo` to look up the row to connect. */
export type PlayerAuxMeetupInfoPlayerAuxMeetupInfoPkeyConnect = {
  playerId: Scalars['UUID'];
};

/** The fields on `playerAuxMeetupInfo` to look up the row to delete. */
export type PlayerAuxMeetupInfoPlayerAuxMeetupInfoPkeyDelete = {
  playerId: Scalars['UUID'];
};

/** Input for the nested mutation of `player` in the `PlayerAuxMeetupInfoInput` mutation. */
export type PlayerAuxMeetupInfoPlayerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnPlayerAuxMeetupInfoForPlayerAuxMeetupInfoPlayerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnPlayerAuxMeetupInfoForPlayerAuxMeetupInfoPlayerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<PlayerAuxMeetupInfoOnPlayerAuxMeetupInfoForPlayerAuxMeetupInfoPlayerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `playerAuxMeetupInfo` in the `PlayerInput` mutation. */
export type PlayerAuxMeetupInfoPlayerIdFkeyInverseInput = {
  /** Flag indicating whether all other `playerAuxMeetupInfo` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `playerAuxMeetupInfo` for the far side of the relationship. */
  connectByPlayerId?: Maybe<PlayerAuxMeetupInfoPlayerAuxMeetupInfoPkeyConnect>;
  /** The primary key(s) for `playerAuxMeetupInfo` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerAuxMeetupInfoNodeIdConnect>;
  /** The primary key(s) for `playerAuxMeetupInfo` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<PlayerAuxMeetupInfoPlayerAuxMeetupInfoPkeyDelete>;
  /** The primary key(s) for `playerAuxMeetupInfo` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerAuxMeetupInfoNodeIdDelete>;
  /** The primary key(s) and patch data for `playerAuxMeetupInfo` for the far side of the relationship. */
  updateByPlayerId?: Maybe<PlayerAuxMeetupInfoOnPlayerAuxMeetupInfoForPlayerAuxMeetupInfoPlayerIdFkeyUsingPlayerAuxMeetupInfoPkeyUpdate>;
  /** The primary key(s) and patch data for `playerAuxMeetupInfo` for the far side of the relationship. */
  updateByNodeId?: Maybe<PlayerOnPlayerAuxMeetupInfoForPlayerAuxMeetupInfoPlayerIdFkeyNodeIdUpdate>;
  /** A `PlayerAuxMeetupInfoInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PlayerAuxMeetupInfoPlayerIdFkeyPlayerAuxMeetupInfoCreateInput>>;
};

/** The `playerAuxMeetupInfo` to be created by this mutation. */
export type PlayerAuxMeetupInfoPlayerIdFkeyPlayerAuxMeetupInfoCreateInput = {
  gender: Gender;
  bats: Handedness;
  throws: Handedness;
  preferredPositionFirst: FieldingPosition;
  preferredPositionSecond: FieldingPosition;
  preferredPositionThird: FieldingPosition;
  meetupMemberId: Scalars['String'];
  adminNickname?: Maybe<Scalars['String']>;
  selfNickname?: Maybe<Scalars['String']>;
  skillLevel?: Maybe<Scalars['Int']>;
  favoriteTeam?: Maybe<Scalars['String']>;
  hometown?: Maybe<Scalars['String']>;
  school?: Maybe<Scalars['String']>;
  dateDebuted?: Maybe<Scalars['Date']>;
  player?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInput>;
};

/** The `player` to be created by this mutation. */
export type PlayerAuxMeetupInfoPlayerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** Methods to use when ordering `PlayerAuxMeetupInfo`. */
export enum PlayerAuxMeetupInfosOrderBy {
  NATURAL = 'NATURAL',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  GENDER_ASC = 'GENDER_ASC',
  GENDER_DESC = 'GENDER_DESC',
  BATS_ASC = 'BATS_ASC',
  BATS_DESC = 'BATS_DESC',
  THROWS_ASC = 'THROWS_ASC',
  THROWS_DESC = 'THROWS_DESC',
  PREFERRED_POSITION_FIRST_ASC = 'PREFERRED_POSITION_FIRST_ASC',
  PREFERRED_POSITION_FIRST_DESC = 'PREFERRED_POSITION_FIRST_DESC',
  PREFERRED_POSITION_SECOND_ASC = 'PREFERRED_POSITION_SECOND_ASC',
  PREFERRED_POSITION_SECOND_DESC = 'PREFERRED_POSITION_SECOND_DESC',
  PREFERRED_POSITION_THIRD_ASC = 'PREFERRED_POSITION_THIRD_ASC',
  PREFERRED_POSITION_THIRD_DESC = 'PREFERRED_POSITION_THIRD_DESC',
  MEETUP_MEMBER_ID_ASC = 'MEETUP_MEMBER_ID_ASC',
  MEETUP_MEMBER_ID_DESC = 'MEETUP_MEMBER_ID_DESC',
  ADMIN_NICKNAME_ASC = 'ADMIN_NICKNAME_ASC',
  ADMIN_NICKNAME_DESC = 'ADMIN_NICKNAME_DESC',
  SELF_NICKNAME_ASC = 'SELF_NICKNAME_ASC',
  SELF_NICKNAME_DESC = 'SELF_NICKNAME_DESC',
  SKILL_LEVEL_ASC = 'SKILL_LEVEL_ASC',
  SKILL_LEVEL_DESC = 'SKILL_LEVEL_DESC',
  FAVORITE_TEAM_ASC = 'FAVORITE_TEAM_ASC',
  FAVORITE_TEAM_DESC = 'FAVORITE_TEAM_DESC',
  HOMETOWN_ASC = 'HOMETOWN_ASC',
  HOMETOWN_DESC = 'HOMETOWN_DESC',
  SCHOOL_ASC = 'SCHOOL_ASC',
  SCHOOL_DESC = 'SCHOOL_DESC',
  DATE_DEBUTED_ASC = 'DATE_DEBUTED_ASC',
  DATE_DEBUTED_DESC = 'DATE_DEBUTED_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `Player` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PlayerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `nickname` field. */
  nickname?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `imageUrl` field. */
  imageUrl?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `claimed` field. */
  claimed?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `timeUpdated` field. */
  timeUpdated?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `timeClaimed` field. */
  timeClaimed?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `active` field. */
  active?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `Player` object types. All fields are combined with a logical ‘and.’ */
export type PlayerFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<IntFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: Maybe<StringFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: Maybe<StringFilter>;
  /** Filter by the object’s `nickname` field. */
  nickname?: Maybe<StringFilter>;
  /** Filter by the object’s `imageUrl` field. */
  imageUrl?: Maybe<StringFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `claimed` field. */
  claimed?: Maybe<BooleanFilter>;
  /** Filter by the object’s `timeUpdated` field. */
  timeUpdated?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `timeClaimed` field. */
  timeClaimed?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `active` field. */
  active?: Maybe<BooleanFilter>;
  /** Filter by the object’s `fullName` field. */
  fullName?: Maybe<StringFilter>;
  /** Filter by the object’s `gamesPlayed` field. */
  gamesPlayed?: Maybe<IntFilter>;
  /** Filter by the object’s `gamesPlayedThisYear` field. */
  gamesPlayedThisYear?: Maybe<IntFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PlayerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PlayerFilter>>;
  /** Negates the expression. */
  not?: Maybe<PlayerFilter>;
};

export type PlayerGroupMembership = Node & {
  __typename?: 'PlayerGroupMembership';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
  /** Reads a single `Player` that is related to this `PlayerGroupMembership`. */
  player: Maybe<Player>;
  /** Reads a single `Group` that is related to this `PlayerGroupMembership`. */
  group: Maybe<Group>;
};

/**
 * A condition to be used against `PlayerGroupMembership` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type PlayerGroupMembershipCondition = {
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `PlayerGroupMembership` object types. All fields are combined with a logical ‘and.’ */
export type PlayerGroupMembershipFilter = {
  /** Filter by the object’s `playerId` field. */
  playerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PlayerGroupMembershipFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PlayerGroupMembershipFilter>>;
  /** Negates the expression. */
  not?: Maybe<PlayerGroupMembershipFilter>;
};

/** The `group` to be created by this mutation. */
export type PlayerGroupMembershipGroupIdFkeyGroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey0InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `group` in the `PlayerGroupMembershipInput` mutation. */
export type PlayerGroupMembershipGroupIdFkeyInput = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByUrlSlug?: Maybe<GroupGroupUrlSlugKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByUrlSlug?: Maybe<GroupGroupUrlSlugKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByUrlSlug?: Maybe<GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingGroupUrlSlugKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyNodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<PlayerGroupMembershipGroupIdFkeyGroupCreateInput>;
};

/** Input for the nested mutation of `playerGroupMembership` in the `GroupInput` mutation. */
export type PlayerGroupMembershipGroupIdFkeyInverseInput = {
  /** Flag indicating whether all other `playerGroupMembership` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  connectByPlayerIdAndGroupId?: Maybe<Array<PlayerGroupMembershipPlayerGroupMembershipPkeyConnect>>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PlayerGroupMembershipNodeIdConnect>>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  deleteByPlayerIdAndGroupId?: Maybe<Array<PlayerGroupMembershipPlayerGroupMembershipPkeyDelete>>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PlayerGroupMembershipNodeIdDelete>>;
  /** The primary key(s) and patch data for `playerGroupMembership` for the far side of the relationship. */
  updateByPlayerIdAndGroupId?: Maybe<Array<PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingPlayerGroupMembershipPkeyUpdate>>;
  /** The primary key(s) and patch data for `playerGroupMembership` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyNodeIdUpdate>>;
  /** A `PlayerGroupMembershipInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PlayerGroupMembershipGroupIdFkeyPlayerGroupMembershipCreateInput>>;
};

/** The `playerGroupMembership` to be created by this mutation. */
export type PlayerGroupMembershipGroupIdFkeyPlayerGroupMembershipCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  player?: Maybe<PlayerGroupMembershipPlayerIdFkeyInput>;
  group?: Maybe<PlayerGroupMembershipGroupIdFkeyInput>;
};

/** An input for mutations affecting `PlayerGroupMembership` */
export type PlayerGroupMembershipInput = {
  playerId?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  player?: Maybe<PlayerGroupMembershipPlayerIdFkeyInput>;
  group?: Maybe<PlayerGroupMembershipGroupIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PlayerGroupMembershipNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `playerGroupMembership` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PlayerGroupMembershipNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `playerGroupMembership` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** The fields on `playerGroupMembership` to look up the row to update. */
export type PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingPlayerGroupMembershipPkeyUpdate = {
  /** An object where the defined keys will be set on the `playerGroupMembership` being updated. */
  patch: UpdatePlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyPatch;
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `playerGroupMembership` to look up the row to update. */
export type PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyUsingPlayerGroupMembershipPkeyUpdate = {
  /** An object where the defined keys will be set on the `playerGroupMembership` being updated. */
  patch: UpdatePlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyPatch;
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
};

/** Represents an update to a `PlayerGroupMembership`. Fields that are set will be updated. */
export type PlayerGroupMembershipPatch = {
  playerId?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  player?: Maybe<PlayerGroupMembershipPlayerIdFkeyInput>;
  group?: Maybe<PlayerGroupMembershipGroupIdFkeyInput>;
};

/** The fields on `playerGroupMembership` to look up the row to connect. */
export type PlayerGroupMembershipPlayerGroupMembershipPkeyConnect = {
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
};

/** The fields on `playerGroupMembership` to look up the row to delete. */
export type PlayerGroupMembershipPlayerGroupMembershipPkeyDelete = {
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
};

/** Input for the nested mutation of `player` in the `PlayerGroupMembershipInput` mutation. */
export type PlayerGroupMembershipPlayerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<PlayerGroupMembershipPlayerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `playerGroupMembership` in the `PlayerInput` mutation. */
export type PlayerGroupMembershipPlayerIdFkeyInverseInput = {
  /** Flag indicating whether all other `playerGroupMembership` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  connectByPlayerIdAndGroupId?: Maybe<Array<PlayerGroupMembershipPlayerGroupMembershipPkeyConnect>>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PlayerGroupMembershipNodeIdConnect>>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  deleteByPlayerIdAndGroupId?: Maybe<Array<PlayerGroupMembershipPlayerGroupMembershipPkeyDelete>>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PlayerGroupMembershipNodeIdDelete>>;
  /** The primary key(s) and patch data for `playerGroupMembership` for the far side of the relationship. */
  updateByPlayerIdAndGroupId?: Maybe<Array<PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyUsingPlayerGroupMembershipPkeyUpdate>>;
  /** The primary key(s) and patch data for `playerGroupMembership` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyNodeIdUpdate>>;
  /** A `PlayerGroupMembershipInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PlayerGroupMembershipPlayerIdFkeyPlayerGroupMembershipCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type PlayerGroupMembershipPlayerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** The `playerGroupMembership` to be created by this mutation. */
export type PlayerGroupMembershipPlayerIdFkeyPlayerGroupMembershipCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  player?: Maybe<PlayerGroupMembershipPlayerIdFkeyInput>;
  group?: Maybe<PlayerGroupMembershipGroupIdFkeyInput>;
};

/** Methods to use when ordering `PlayerGroupMembership`. */
export enum PlayerGroupMembershipsOrderBy {
  NATURAL = 'NATURAL',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** An input for mutations affecting `Player` */
export type PlayerInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PlayerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PlayerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `player` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnAtBatSkipForAtBatSkipBatterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `atBatSkip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `atBatSkip` being updated. */
  patch: AtBatSkipPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnAtBatSkipForAtBatSkipBatterIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnAtBatSkipForAtBatSkipBatterIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnAtBatSkipForAtBatSkipBatterIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnAtBatSkipForAtBatSkipBatterIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `baseRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: BaseRunnerPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `basepathMovement` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: BasepathMovementPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `careerBattingStat` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `careerBattingStat` being updated. */
  patch: CareerBattingStatPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey1UsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey1Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey1UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey1Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnGameAuxMeetupInfoForGameAuxMeetupInfoGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameAuxMeetupInfo` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameAuxMeetupInfo` being updated. */
  patch: GameAuxMeetupInfoPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnGameAuxMeetupInfoForGameAuxMeetupInfoGameIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnGameAuxMeetupInfoForGameAuxMeetupInfoGameIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnGameAuxMeetupInfoForGameAuxMeetupInfoGameIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnGameAuxMeetupInfoForGameAuxMeetupInfoGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnGameBattingStatForFakePublicGameBattingStatsForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameBattingStat` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameBattingStat` being updated. */
  patch: GameBattingStatPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnGameBattingStatForFakePublicGameBattingStatsForeignKey2UsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnGameBattingStatForFakePublicGameBattingStatsForeignKey2Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnGameBattingStatForFakePublicGameBattingStatsForeignKey2UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnGameBattingStatForFakePublicGameBattingStatsForeignKey2Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnGameStateForGameStatePlayerAtBatFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnGameStateForGameStatePlayerAtBatFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupSpot` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: LineupSpotPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnLineupSpotForLineupSpotPlayerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnLineupSpotForLineupSpotPlayerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnManualEntryBattingLineForManualEntryBattingLinePlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `manualEntryBattingLine` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `manualEntryBattingLine` being updated. */
  patch: ManualEntryBattingLinePatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnManualEntryBattingLineForManualEntryBattingLinePlayerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnManualEntryBattingLineForManualEntryBattingLinePlayerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnManualEntryBattingLineForManualEntryBattingLinePlayerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnManualEntryBattingLineForManualEntryBattingLinePlayerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnManualEntryPitchingLineForManualEntryPitchingLinePlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `manualEntryPitchingLine` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `manualEntryPitchingLine` being updated. */
  patch: ManualEntryPitchingLinePatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnManualEntryPitchingLineForManualEntryPitchingLinePlayerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnManualEntryPitchingLineForManualEntryPitchingLinePlayerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnManualEntryPitchingLineForManualEntryPitchingLinePlayerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnManualEntryPitchingLineForManualEntryPitchingLinePlayerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `outOnPlayRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: OutOnPlayRunnerPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnPlayerAuxMeetupInfoForPlayerAuxMeetupInfoPlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `playerAuxMeetupInfo` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `playerAuxMeetupInfo` being updated. */
  patch: PlayerAuxMeetupInfoPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlayerAuxMeetupInfoForPlayerAuxMeetupInfoPlayerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlayerAuxMeetupInfoForPlayerAuxMeetupInfoPlayerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlayerAuxMeetupInfoForPlayerAuxMeetupInfoPlayerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlayerAuxMeetupInfoForPlayerAuxMeetupInfoPlayerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `playerGroupMembership` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `playerGroupMembership` being updated. */
  patch: PlayerGroupMembershipPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scoredRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: ScoredRunnerPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `seasonBattingStat` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `seasonBattingStat` being updated. */
  patch: SeasonBattingStatPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey1UsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey1Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey1UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey1Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `stolenBaseAttempt` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: StolenBaseAttemptPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnTeamForTeamCaptainIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `team` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: TeamPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnTeamForTeamCaptainIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnTeamForTeamCaptainIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Player`. Fields that are set will be updated. */
export type PlayerPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** The fields on `player` to look up the row to connect. */
export type PlayerPlayerNameUniqueConnect = {
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to delete. */
export type PlayerPlayerNameUniqueDelete = {
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to connect. */
export type PlayerPlayerPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `player` to look up the row to delete. */
export type PlayerPlayerPkeyDelete = {
  id: Scalars['UUID'];
};

/** Methods to use when ordering `Player`. */
export enum PlayersOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  FIRST_NAME_ASC = 'FIRST_NAME_ASC',
  FIRST_NAME_DESC = 'FIRST_NAME_DESC',
  LAST_NAME_ASC = 'LAST_NAME_ASC',
  LAST_NAME_DESC = 'LAST_NAME_DESC',
  NICKNAME_ASC = 'NICKNAME_ASC',
  NICKNAME_DESC = 'NICKNAME_DESC',
  IMAGE_URL_ASC = 'IMAGE_URL_ASC',
  IMAGE_URL_DESC = 'IMAGE_URL_DESC',
  TIME_CREATED_ASC = 'TIME_CREATED_ASC',
  TIME_CREATED_DESC = 'TIME_CREATED_DESC',
  CLAIMED_ASC = 'CLAIMED_ASC',
  CLAIMED_DESC = 'CLAIMED_DESC',
  TIME_UPDATED_ASC = 'TIME_UPDATED_ASC',
  TIME_UPDATED_DESC = 'TIME_UPDATED_DESC',
  TIME_CLAIMED_ASC = 'TIME_CLAIMED_ASC',
  TIME_CLAIMED_DESC = 'TIME_CLAIMED_DESC',
  ACTIVE_ASC = 'ACTIVE_ASC',
  ACTIVE_DESC = 'ACTIVE_DESC',
  FULL_NAME_ASC = 'FULL_NAME_ASC',
  FULL_NAME_DESC = 'FULL_NAME_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. */
  node: Maybe<Node>;
  /** Reads a set of `AtBatSkip`. */
  atBatSkips: Maybe<Array<AtBatSkip>>;
  /** Reads a set of `BaseRunner`. */
  baseRunners: Maybe<Array<BaseRunner>>;
  /** Reads a set of `BasepathMovement`. */
  basepathMovements: Maybe<Array<BasepathMovement>>;
  /** Reads a set of `CareerBattingStat`. */
  careerBattingStats: Maybe<Array<CareerBattingStat>>;
  /** Reads a set of `EarlyGameEnd`. */
  earlyGameEnds: Maybe<Array<EarlyGameEnd>>;
  /** Reads a set of `Field`. */
  fields: Maybe<Array<Field>>;
  /** Reads a set of `Game`. */
  games: Maybe<Array<Game>>;
  /** Reads a set of `GameAuxMeetupInfo`. */
  gameAuxMeetupInfos: Maybe<Array<GameAuxMeetupInfo>>;
  /** Reads a set of `GameBattingStat`. */
  gameBattingStats: Maybe<Array<GameBattingStat>>;
  /** Reads a set of `GameEvent`. */
  gameEvents: Maybe<Array<GameEvent>>;
  /** Reads a set of `GameEventRecord`. */
  gameEventRecords: Maybe<Array<GameEventRecord>>;
  /** Reads a set of `GameState`. */
  gameStates: Maybe<Array<GameState>>;
  /** Reads a set of `Group`. */
  groups: Maybe<Array<Group>>;
  /** Reads a set of `Lineup`. */
  lineups: Maybe<Array<Lineup>>;
  /** Reads a set of `LineupChange`. */
  lineupChanges: Maybe<Array<LineupChange>>;
  /** Reads a set of `LineupForGameState`. */
  lineupForGameStates: Maybe<Array<LineupForGameState>>;
  /** Reads a set of `LineupSpot`. */
  lineupSpots: Maybe<Array<LineupSpot>>;
  /** Reads a set of `ManualEntryBattingLine`. */
  manualEntryBattingLines: Maybe<Array<ManualEntryBattingLine>>;
  /** Reads a set of `ManualEntryLineScoreCell`. */
  manualEntryLineScoreCells: Maybe<Array<ManualEntryLineScoreCell>>;
  /** Reads a set of `ManualEntryPitchingLine`. */
  manualEntryPitchingLines: Maybe<Array<ManualEntryPitchingLine>>;
  /** Reads a set of `OutOnPlayRunner`. */
  outOnPlayRunners: Maybe<Array<OutOnPlayRunner>>;
  /** Reads a set of `PlateAppearance`. */
  plateAppearances: Maybe<Array<PlateAppearance>>;
  /** Reads a set of `Player`. */
  players: Maybe<Array<Player>>;
  /** Reads a set of `PlayerAuxMeetupInfo`. */
  playerAuxMeetupInfos: Maybe<Array<PlayerAuxMeetupInfo>>;
  /** Reads a set of `PlayerGroupMembership`. */
  playerGroupMemberships: Maybe<Array<PlayerGroupMembership>>;
  /** Reads a set of `ReduxDump`. */
  reduxDumps: Maybe<Array<ReduxDump>>;
  /** Reads a set of `ScoredRunner`. */
  scoredRunners: Maybe<Array<ScoredRunner>>;
  /** Reads a set of `SeasonBattingStat`. */
  seasonBattingStats: Maybe<Array<SeasonBattingStat>>;
  /** Reads a set of `SoloModeOpponentInning`. */
  soloModeOpponentInnings: Maybe<Array<SoloModeOpponentInning>>;
  /** Reads a set of `StolenBaseAttempt`. */
  stolenBaseAttempts: Maybe<Array<StolenBaseAttempt>>;
  /** Reads a set of `Team`. */
  teams: Maybe<Array<Team>>;
  atBatSkip: Maybe<AtBatSkip>;
  baseRunner: Maybe<BaseRunner>;
  basepathMovement: Maybe<BasepathMovement>;
  careerBattingStat: Maybe<CareerBattingStat>;
  earlyGameEnd: Maybe<EarlyGameEnd>;
  field: Maybe<Field>;
  game: Maybe<Game>;
  gameByGroupIdAndName: Maybe<Game>;
  gameAuxMeetupInfo: Maybe<GameAuxMeetupInfo>;
  gameBattingStat: Maybe<GameBattingStat>;
  gameEvent: Maybe<GameEvent>;
  gameEventRecord: Maybe<GameEventRecord>;
  gameEventRecordByGameIdAndEventIndex: Maybe<GameEventRecord>;
  gameState: Maybe<GameState>;
  group: Maybe<Group>;
  groupByName: Maybe<Group>;
  groupByUrlSlug: Maybe<Group>;
  lineup: Maybe<Lineup>;
  lineupChange: Maybe<LineupChange>;
  lineupForGameState: Maybe<LineupForGameState>;
  lineupSpot: Maybe<LineupSpot>;
  lineupSpotByLineupIdAndBattingOrder: Maybe<LineupSpot>;
  lineupSpotByLineupIdAndPosition: Maybe<LineupSpot>;
  manualEntryBattingLine: Maybe<ManualEntryBattingLine>;
  manualEntryLineScoreCell: Maybe<ManualEntryLineScoreCell>;
  manualEntryPitchingLine: Maybe<ManualEntryPitchingLine>;
  outOnPlayRunner: Maybe<OutOnPlayRunner>;
  plateAppearance: Maybe<PlateAppearance>;
  player: Maybe<Player>;
  playerByFirstNameAndLastName: Maybe<Player>;
  playerAuxMeetupInfo: Maybe<PlayerAuxMeetupInfo>;
  playerGroupMembership: Maybe<PlayerGroupMembership>;
  reduxDump: Maybe<ReduxDump>;
  scoredRunner: Maybe<ScoredRunner>;
  seasonBattingStat: Maybe<SeasonBattingStat>;
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  team: Maybe<Team>;
  teamByGameIdAndRole: Maybe<Team>;
  canUserSaveGameData: Maybe<Scalars['Boolean']>;
  /** Reads and enables pagination through a set of `UserGroupPermission`. */
  currentUserGroupPermissions: Maybe<Array<Maybe<UserGroupPermission>>>;
  currentUserPermissions: Maybe<Array<Maybe<PermissionType>>>;
  doesUserHaveGroupPermission: Maybe<Scalars['Boolean']>;
  doesUserHavePermission: Maybe<Scalars['Boolean']>;
  firstDateOfYear: Maybe<Scalars['Datetime']>;
  getAvg: Maybe<Scalars['Float']>;
  getCurrentUser: Maybe<Player>;
  getCurrentUserId: Maybe<Scalars['UUID']>;
  getObp: Maybe<Scalars['Float']>;
  getOps: Maybe<Scalars['Float']>;
  getPlateAppearances: Maybe<Array<Maybe<GetPlateAppearancesRecord>>>;
  getRunsScored: Maybe<Array<Maybe<GetRunsScoredRecord>>>;
  getSlg: Maybe<Scalars['Float']>;
  getTb: Maybe<Scalars['Int']>;
  getTeamForPlayer: Maybe<Scalars['UUID']>;
  lastDateOfYear: Maybe<Scalars['Datetime']>;
  /** Reads a single `AtBatSkip` using its globally unique `ID`. */
  atBatSkipByNodeId: Maybe<AtBatSkip>;
  /** Reads a single `BaseRunner` using its globally unique `ID`. */
  baseRunnerByNodeId: Maybe<BaseRunner>;
  /** Reads a single `BasepathMovement` using its globally unique `ID`. */
  basepathMovementByNodeId: Maybe<BasepathMovement>;
  /** Reads a single `CareerBattingStat` using its globally unique `ID`. */
  careerBattingStatByNodeId: Maybe<CareerBattingStat>;
  /** Reads a single `EarlyGameEnd` using its globally unique `ID`. */
  earlyGameEndByNodeId: Maybe<EarlyGameEnd>;
  /** Reads a single `Field` using its globally unique `ID`. */
  fieldByNodeId: Maybe<Field>;
  /** Reads a single `Game` using its globally unique `ID`. */
  gameByNodeId: Maybe<Game>;
  /** Reads a single `GameAuxMeetupInfo` using its globally unique `ID`. */
  gameAuxMeetupInfoByNodeId: Maybe<GameAuxMeetupInfo>;
  /** Reads a single `GameBattingStat` using its globally unique `ID`. */
  gameBattingStatByNodeId: Maybe<GameBattingStat>;
  /** Reads a single `GameEvent` using its globally unique `ID`. */
  gameEventByNodeId: Maybe<GameEvent>;
  /** Reads a single `GameEventRecord` using its globally unique `ID`. */
  gameEventRecordByNodeId: Maybe<GameEventRecord>;
  /** Reads a single `GameState` using its globally unique `ID`. */
  gameStateByNodeId: Maybe<GameState>;
  /** Reads a single `Group` using its globally unique `ID`. */
  groupByNodeId: Maybe<Group>;
  /** Reads a single `Lineup` using its globally unique `ID`. */
  lineupByNodeId: Maybe<Lineup>;
  /** Reads a single `LineupChange` using its globally unique `ID`. */
  lineupChangeByNodeId: Maybe<LineupChange>;
  /** Reads a single `LineupForGameState` using its globally unique `ID`. */
  lineupForGameStateByNodeId: Maybe<LineupForGameState>;
  /** Reads a single `LineupSpot` using its globally unique `ID`. */
  lineupSpotByNodeId: Maybe<LineupSpot>;
  /** Reads a single `ManualEntryBattingLine` using its globally unique `ID`. */
  manualEntryBattingLineByNodeId: Maybe<ManualEntryBattingLine>;
  /** Reads a single `ManualEntryLineScoreCell` using its globally unique `ID`. */
  manualEntryLineScoreCellByNodeId: Maybe<ManualEntryLineScoreCell>;
  /** Reads a single `ManualEntryPitchingLine` using its globally unique `ID`. */
  manualEntryPitchingLineByNodeId: Maybe<ManualEntryPitchingLine>;
  /** Reads a single `OutOnPlayRunner` using its globally unique `ID`. */
  outOnPlayRunnerByNodeId: Maybe<OutOnPlayRunner>;
  /** Reads a single `PlateAppearance` using its globally unique `ID`. */
  plateAppearanceByNodeId: Maybe<PlateAppearance>;
  /** Reads a single `Player` using its globally unique `ID`. */
  playerByNodeId: Maybe<Player>;
  /** Reads a single `PlayerAuxMeetupInfo` using its globally unique `ID`. */
  playerAuxMeetupInfoByNodeId: Maybe<PlayerAuxMeetupInfo>;
  /** Reads a single `PlayerGroupMembership` using its globally unique `ID`. */
  playerGroupMembershipByNodeId: Maybe<PlayerGroupMembership>;
  /** Reads a single `ReduxDump` using its globally unique `ID`. */
  reduxDumpByNodeId: Maybe<ReduxDump>;
  /** Reads a single `ScoredRunner` using its globally unique `ID`. */
  scoredRunnerByNodeId: Maybe<ScoredRunner>;
  /** Reads a single `SeasonBattingStat` using its globally unique `ID`. */
  seasonBattingStatByNodeId: Maybe<SeasonBattingStat>;
  /** Reads a single `SoloModeOpponentInning` using its globally unique `ID`. */
  soloModeOpponentInningByNodeId: Maybe<SoloModeOpponentInning>;
  /** Reads a single `StolenBaseAttempt` using its globally unique `ID`. */
  stolenBaseAttemptByNodeId: Maybe<StolenBaseAttempt>;
  /** Reads a single `Team` using its globally unique `ID`. */
  teamByNodeId: Maybe<Team>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAtBatSkipsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<AtBatSkipsOrderBy>>;
  condition?: Maybe<AtBatSkipCondition>;
  filter?: Maybe<AtBatSkipFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryBaseRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BaseRunnersOrderBy>>;
  condition?: Maybe<BaseRunnerCondition>;
  filter?: Maybe<BaseRunnerFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryBasepathMovementsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BasepathMovementsOrderBy>>;
  condition?: Maybe<BasepathMovementCondition>;
  filter?: Maybe<BasepathMovementFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCareerBattingStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerBattingStatsOrderBy>>;
  condition?: Maybe<CareerBattingStatCondition>;
  filter?: Maybe<CareerBattingStatFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEarlyGameEndsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EarlyGameEndsOrderBy>>;
  condition?: Maybe<EarlyGameEndCondition>;
  filter?: Maybe<EarlyGameEndFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<FieldsOrderBy>>;
  condition?: Maybe<FieldCondition>;
  filter?: Maybe<FieldFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GamesOrderBy>>;
  condition?: Maybe<GameCondition>;
  filter?: Maybe<GameFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGameAuxMeetupInfosArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameAuxMeetupInfosOrderBy>>;
  condition?: Maybe<GameAuxMeetupInfoCondition>;
  filter?: Maybe<GameAuxMeetupInfoFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGameBattingStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameBattingStatsOrderBy>>;
  condition?: Maybe<GameBattingStatCondition>;
  filter?: Maybe<GameBattingStatFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventsOrderBy>>;
  condition?: Maybe<GameEventCondition>;
  filter?: Maybe<GameEventFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventRecordsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventRecordsOrderBy>>;
  condition?: Maybe<GameEventRecordCondition>;
  filter?: Maybe<GameEventRecordFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameStatesOrderBy>>;
  condition?: Maybe<GameStateCondition>;
  filter?: Maybe<GameStateFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
  condition?: Maybe<GroupCondition>;
  filter?: Maybe<GroupFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupsOrderBy>>;
  condition?: Maybe<LineupCondition>;
  filter?: Maybe<LineupFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupChangesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupChangesOrderBy>>;
  condition?: Maybe<LineupChangeCondition>;
  filter?: Maybe<LineupChangeFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupForGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupForGameStatesOrderBy>>;
  condition?: Maybe<LineupForGameStateCondition>;
  filter?: Maybe<LineupForGameStateFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupSpotsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupSpotsOrderBy>>;
  condition?: Maybe<LineupSpotCondition>;
  filter?: Maybe<LineupSpotFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryManualEntryBattingLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ManualEntryBattingLinesOrderBy>>;
  condition?: Maybe<ManualEntryBattingLineCondition>;
  filter?: Maybe<ManualEntryBattingLineFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryManualEntryLineScoreCellsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ManualEntryLineScoreCellsOrderBy>>;
  condition?: Maybe<ManualEntryLineScoreCellCondition>;
  filter?: Maybe<ManualEntryLineScoreCellFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryManualEntryPitchingLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ManualEntryPitchingLinesOrderBy>>;
  condition?: Maybe<ManualEntryPitchingLineCondition>;
  filter?: Maybe<ManualEntryPitchingLineFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOutOnPlayRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<OutOnPlayRunnersOrderBy>>;
  condition?: Maybe<OutOnPlayRunnerCondition>;
  filter?: Maybe<OutOnPlayRunnerFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlateAppearancesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlateAppearancesOrderBy>>;
  condition?: Maybe<PlateAppearanceCondition>;
  filter?: Maybe<PlateAppearanceFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlayersOrderBy>>;
  condition?: Maybe<PlayerCondition>;
  filter?: Maybe<PlayerFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerAuxMeetupInfosArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlayerAuxMeetupInfosOrderBy>>;
  condition?: Maybe<PlayerAuxMeetupInfoCondition>;
  filter?: Maybe<PlayerAuxMeetupInfoFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerGroupMembershipsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlayerGroupMembershipsOrderBy>>;
  condition?: Maybe<PlayerGroupMembershipCondition>;
  filter?: Maybe<PlayerGroupMembershipFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReduxDumpsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ReduxDumpsOrderBy>>;
  condition?: Maybe<ReduxDumpCondition>;
  filter?: Maybe<ReduxDumpFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryScoredRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ScoredRunnersOrderBy>>;
  condition?: Maybe<ScoredRunnerCondition>;
  filter?: Maybe<ScoredRunnerFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySeasonBattingStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonBattingStatsOrderBy>>;
  condition?: Maybe<SeasonBattingStatCondition>;
  filter?: Maybe<SeasonBattingStatFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySoloModeOpponentInningsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SoloModeOpponentInningsOrderBy>>;
  condition?: Maybe<SoloModeOpponentInningCondition>;
  filter?: Maybe<SoloModeOpponentInningFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryStolenBaseAttemptsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<StolenBaseAttemptsOrderBy>>;
  condition?: Maybe<StolenBaseAttemptCondition>;
  filter?: Maybe<StolenBaseAttemptFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<TeamsOrderBy>>;
  condition?: Maybe<TeamCondition>;
  filter?: Maybe<TeamFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAtBatSkipArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBaseRunnerArgs = {
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBasepathMovementArgs = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCareerBattingStatArgs = {
  groupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEarlyGameEndArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameByGroupIdAndNameArgs = {
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameAuxMeetupInfoArgs = {
  gameId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameBattingStatArgs = {
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventRecordArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventRecordByGameIdAndEventIndexArgs = {
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameStateArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupByNameArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupByUrlSlugArgs = {
  urlSlug: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupChangeArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupForGameStateArgs = {
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupSpotArgs = {
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupSpotByLineupIdAndBattingOrderArgs = {
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupSpotByLineupIdAndPositionArgs = {
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};


/** The root query type which gives access points into the data universe. */
export type QueryManualEntryBattingLineArgs = {
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryManualEntryLineScoreCellArgs = {
  gameId: Scalars['UUID'];
  inning: Scalars['Int'];
  halfInning: HalfInning;
};


/** The root query type which gives access points into the data universe. */
export type QueryManualEntryPitchingLineArgs = {
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOutOnPlayRunnerArgs = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlateAppearanceArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerByFirstNameAndLastNameArgs = {
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerAuxMeetupInfoArgs = {
  playerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerGroupMembershipArgs = {
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReduxDumpArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryScoredRunnerArgs = {
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySeasonBattingStatArgs = {
  groupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySoloModeOpponentInningArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStolenBaseAttemptArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamByGameIdAndRoleArgs = {
  gameId: Scalars['UUID'];
  role: TeamRole;
};


/** The root query type which gives access points into the data universe. */
export type QueryCanUserSaveGameDataArgs = {
  gameId?: Maybe<Scalars['UUID']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentUserGroupPermissionsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  filter?: Maybe<UserGroupPermissionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentUserPermissionsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDoesUserHaveGroupPermissionArgs = {
  groupId?: Maybe<Scalars['UUID']>;
  permission?: Maybe<GroupPermissionType>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDoesUserHavePermissionArgs = {
  permission?: Maybe<PermissionType>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFirstDateOfYearArgs = {
  year?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetAvgArgs = {
  hits?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetObpArgs = {
  hits?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetOpsArgs = {
  hits?: Maybe<Scalars['Int']>;
  totalBases?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetPlateAppearancesArgs = {
  playerId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  beforeDate?: Maybe<Scalars['Datetime']>;
  afterDate?: Maybe<Scalars['Datetime']>;
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  filter?: Maybe<GetPlateAppearancesRecordFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetRunsScoredArgs = {
  groupId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  beforeDate?: Maybe<Scalars['Datetime']>;
  afterDate?: Maybe<Scalars['Datetime']>;
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  filter?: Maybe<GetRunsScoredRecordFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetSlgArgs = {
  totalBases?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetTbArgs = {
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetTeamForPlayerArgs = {
  playerId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLastDateOfYearArgs = {
  year?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAtBatSkipByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBaseRunnerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBasepathMovementByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCareerBattingStatByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEarlyGameEndByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameAuxMeetupInfoByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameBattingStatByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventRecordByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameStateByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupChangeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupForGameStateByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupSpotByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryManualEntryBattingLineByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryManualEntryLineScoreCellByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryManualEntryPitchingLineByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOutOnPlayRunnerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlateAppearanceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerAuxMeetupInfoByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerGroupMembershipByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReduxDumpByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryScoredRunnerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySeasonBattingStatByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySoloModeOpponentInningByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStolenBaseAttemptByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

export type ReduxDump = Node & {
  __typename?: 'ReduxDump';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  storeData: Scalars['JSON'];
  timeCreated: Maybe<Scalars['Datetime']>;
};

/**
 * A condition to be used against `ReduxDump` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ReduxDumpCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `storeData` field. */
  storeData?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `ReduxDump` object types. All fields are combined with a logical ‘and.’ */
export type ReduxDumpFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `storeData` field. */
  storeData?: Maybe<JsonFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: Maybe<DatetimeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ReduxDumpFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ReduxDumpFilter>>;
  /** Negates the expression. */
  not?: Maybe<ReduxDumpFilter>;
};

/** An input for mutations affecting `ReduxDump` */
export type ReduxDumpInput = {
  id?: Maybe<Scalars['UUID']>;
  storeData: Scalars['JSON'];
  timeCreated?: Maybe<Scalars['Datetime']>;
};

/** Represents an update to a `ReduxDump`. Fields that are set will be updated. */
export type ReduxDumpPatch = {
  id?: Maybe<Scalars['UUID']>;
  storeData?: Maybe<Scalars['JSON']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
};

/** Methods to use when ordering `ReduxDump`. */
export enum ReduxDumpsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  STORE_DATA_ASC = 'STORE_DATA_ASC',
  STORE_DATA_DESC = 'STORE_DATA_DESC',
  TIME_CREATED_ASC = 'TIME_CREATED_ASC',
  TIME_CREATED_DESC = 'TIME_CREATED_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** All input for the `resetPassword` mutation. */
export type ResetPasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  playerId: Scalars['UUID'];
  resetToken: Scalars['String'];
  newPassword: Scalars['String'];
};

/** The output of our `resetPassword` mutation. */
export type ResetPasswordPayload = {
  __typename?: 'ResetPasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  boolean: Maybe<Scalars['Boolean']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type ScoredRunner = Node & {
  __typename?: 'ScoredRunner';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
  battedIn: Scalars['Boolean'];
  gameId: Scalars['UUID'];
  /** Reads a single `GameEventRecord` that is related to this `ScoredRunner`. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Reads a single `Player` that is related to this `ScoredRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `ScoredRunner`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `ScoredRunner` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ScoredRunnerCondition = {
  /** Checks for equality with the object’s `gameEventRecordId` field. */
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runnerId` field. */
  runnerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `battedIn` field. */
  battedIn?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `ScoredRunner` object types. All fields are combined with a logical ‘and.’ */
export type ScoredRunnerFilter = {
  /** Filter by the object’s `gameEventRecordId` field. */
  gameEventRecordId?: Maybe<UuidFilter>;
  /** Filter by the object’s `runnerId` field. */
  runnerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `battedIn` field. */
  battedIn?: Maybe<BooleanFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ScoredRunnerFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ScoredRunnerFilter>>;
  /** Negates the expression. */
  not?: Maybe<ScoredRunnerFilter>;
};

/** The `gameEventRecord` to be created by this mutation. */
export type ScoredRunnerGameEventRecordIdFkeyGameEventRecordCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** Input for the nested mutation of `gameEventRecord` in the `ScoredRunnerInput` mutation. */
export type ScoredRunnerGameEventRecordIdFkeyInput = {
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectById?: Maybe<GameEventRecordGameEventRecordPkeyConnect>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByGameIdAndEventIndex?: Maybe<GameEventRecordGameEventRecordGameIdEventIndexKeyConnect>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameEventRecordNodeIdConnect>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteById?: Maybe<GameEventRecordGameEventRecordPkeyDelete>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByGameIdAndEventIndex?: Maybe<GameEventRecordGameEventRecordGameIdEventIndexKeyDelete>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameEventRecordNodeIdDelete>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateById?: Maybe<GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordPkeyUpdate>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByGameIdAndEventIndex?: Maybe<GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByNodeId?: Maybe<ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate>;
  /** A `GameEventRecordInput` object that will be created and connected to this object. */
  create?: Maybe<ScoredRunnerGameEventRecordIdFkeyGameEventRecordCreateInput>;
};

/** Input for the nested mutation of `scoredRunner` in the `GameEventRecordInput` mutation. */
export type ScoredRunnerGameEventRecordIdFkeyInverseInput = {
  /** Flag indicating whether all other `scoredRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ScoredRunnerNodeIdConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyDelete>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ScoredRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingScoredRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate>>;
  /** A `ScoredRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ScoredRunnerGameEventRecordIdFkeyScoredRunnerCreateInput>>;
};

/** The `scoredRunner` to be created by this mutation. */
export type ScoredRunnerGameEventRecordIdFkeyScoredRunnerCreateInput = {
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** The `game` to be created by this mutation. */
export type ScoredRunnerGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `ScoredRunnerInput` mutation. */
export type ScoredRunnerGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnScoredRunnerForScoredRunnerGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnScoredRunnerForScoredRunnerGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<ScoredRunnerOnScoredRunnerForScoredRunnerGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<ScoredRunnerGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `scoredRunner` in the `GameInput` mutation. */
export type ScoredRunnerGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `scoredRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ScoredRunnerNodeIdConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyDelete>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ScoredRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerOnScoredRunnerForScoredRunnerGameIdFkeyUsingScoredRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnScoredRunnerForScoredRunnerGameIdFkeyNodeIdUpdate>>;
  /** A `ScoredRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ScoredRunnerGameIdFkeyScoredRunnerCreateInput>>;
};

/** The `scoredRunner` to be created by this mutation. */
export type ScoredRunnerGameIdFkeyScoredRunnerCreateInput = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn: Scalars['Boolean'];
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** An input for mutations affecting `ScoredRunner` */
export type ScoredRunnerInput = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ScoredRunnerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `scoredRunner` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ScoredRunnerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `scoredRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** The fields on `scoredRunner` to look up the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingScoredRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: UpdateScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch;
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `scoredRunner` to look up the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerGameIdFkeyUsingScoredRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: UpdateScoredRunnerOnScoredRunnerForScoredRunnerGameIdFkeyPatch;
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `scoredRunner` to look up the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingScoredRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: UpdateScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch;
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** Represents an update to a `ScoredRunner`. Fields that are set will be updated. */
export type ScoredRunnerPatch = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** Input for the nested mutation of `player` in the `ScoredRunnerInput` mutation. */
export type ScoredRunnerRunnerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<ScoredRunnerRunnerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `scoredRunner` in the `PlayerInput` mutation. */
export type ScoredRunnerRunnerIdFkeyInverseInput = {
  /** Flag indicating whether all other `scoredRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ScoredRunnerNodeIdConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyDelete>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ScoredRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingScoredRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate>>;
  /** A `ScoredRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ScoredRunnerRunnerIdFkeyScoredRunnerCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type ScoredRunnerRunnerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** The `scoredRunner` to be created by this mutation. */
export type ScoredRunnerRunnerIdFkeyScoredRunnerCreateInput = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  battedIn: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** The fields on `scoredRunner` to look up the row to connect. */
export type ScoredRunnerScoredRunnerPkeyConnect = {
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The fields on `scoredRunner` to look up the row to delete. */
export type ScoredRunnerScoredRunnerPkeyDelete = {
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** Methods to use when ordering `ScoredRunner`. */
export enum ScoredRunnersOrderBy {
  NATURAL = 'NATURAL',
  GAME_EVENT_RECORD_ID_ASC = 'GAME_EVENT_RECORD_ID_ASC',
  GAME_EVENT_RECORD_ID_DESC = 'GAME_EVENT_RECORD_ID_DESC',
  RUNNER_ID_ASC = 'RUNNER_ID_ASC',
  RUNNER_ID_DESC = 'RUNNER_ID_DESC',
  BATTED_IN_ASC = 'BATTED_IN_ASC',
  BATTED_IN_DESC = 'BATTED_IN_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type SeasonBattingStat = Node & {
  __typename?: 'SeasonBattingStat';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  groupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
  season: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['Int']>;
  plateAppearances: Scalars['Int'];
  atBats: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  gidp: Scalars['Int'];
  runs: Scalars['Int'];
  rbi: Scalars['Int'];
  stolenBases: Scalars['Int'];
  avg: Scalars['Float'];
  obp: Scalars['Float'];
  slg: Scalars['Float'];
  ops: Scalars['Float'];
  /** Reads a single `Group` that is related to this `SeasonBattingStat`. */
  group: Maybe<Group>;
  /** Reads a single `Player` that is related to this `SeasonBattingStat`. */
  player: Maybe<Player>;
  qualified: Maybe<Scalars['Boolean']>;
};

/**
 * A condition to be used against `SeasonBattingStat` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SeasonBattingStatCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stolenBases` field. */
  stolenBases?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `avg` field. */
  avg?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `obp` field. */
  obp?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `slg` field. */
  slg?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The fields on `seasonBattingStat` to look up the row to connect. */
export type SeasonBattingStatFakePublicSeasonBattingStatsPrimaryKeyConnect = {
  groupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The fields on `seasonBattingStat` to look up the row to delete. */
export type SeasonBattingStatFakePublicSeasonBattingStatsPrimaryKeyDelete = {
  groupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** A filter to be used against `SeasonBattingStat` object types. All fields are combined with a logical ‘and.’ */
export type SeasonBattingStatFilter = {
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<UuidFilter>;
  /** Filter by the object’s `playerId` field. */
  playerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `season` field. */
  season?: Maybe<IntFilter>;
  /** Filter by the object’s `games` field. */
  games?: Maybe<IntFilter>;
  /** Filter by the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<IntFilter>;
  /** Filter by the object’s `atBats` field. */
  atBats?: Maybe<IntFilter>;
  /** Filter by the object’s `hits` field. */
  hits?: Maybe<IntFilter>;
  /** Filter by the object’s `singles` field. */
  singles?: Maybe<IntFilter>;
  /** Filter by the object’s `doubles` field. */
  doubles?: Maybe<IntFilter>;
  /** Filter by the object’s `triples` field. */
  triples?: Maybe<IntFilter>;
  /** Filter by the object’s `homeruns` field. */
  homeruns?: Maybe<IntFilter>;
  /** Filter by the object’s `walks` field. */
  walks?: Maybe<IntFilter>;
  /** Filter by the object’s `strikeouts` field. */
  strikeouts?: Maybe<IntFilter>;
  /** Filter by the object’s `sacFlies` field. */
  sacFlies?: Maybe<IntFilter>;
  /** Filter by the object’s `gidp` field. */
  gidp?: Maybe<IntFilter>;
  /** Filter by the object’s `runs` field. */
  runs?: Maybe<IntFilter>;
  /** Filter by the object’s `rbi` field. */
  rbi?: Maybe<IntFilter>;
  /** Filter by the object’s `stolenBases` field. */
  stolenBases?: Maybe<IntFilter>;
  /** Filter by the object’s `avg` field. */
  avg?: Maybe<FloatFilter>;
  /** Filter by the object’s `obp` field. */
  obp?: Maybe<FloatFilter>;
  /** Filter by the object’s `slg` field. */
  slg?: Maybe<FloatFilter>;
  /** Filter by the object’s `ops` field. */
  ops?: Maybe<FloatFilter>;
  /** Filter by the object’s `qualified` field. */
  qualified?: Maybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SeasonBattingStatFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SeasonBattingStatFilter>>;
  /** Negates the expression. */
  not?: Maybe<SeasonBattingStatFilter>;
};

/** The globally unique `ID` look up for the row to connect. */
export type SeasonBattingStatNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `seasonBattingStat` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type SeasonBattingStatNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `seasonBattingStat` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonBattingStatOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** The fields on `seasonBattingStat` to look up the row to update. */
export type SeasonBattingStatOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0UsingFakePublicSeasonBattingStatsPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `seasonBattingStat` being updated. */
  patch: UpdateSeasonBattingStatOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0Patch;
  groupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonBattingStatOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `seasonBattingStat` to look up the row to update. */
export type SeasonBattingStatOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey1UsingFakePublicSeasonBattingStatsPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `seasonBattingStat` being updated. */
  patch: UpdateSeasonBattingStatOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey1Patch;
  groupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** Represents an update to a `SeasonBattingStat`. Fields that are set will be updated. */
export type SeasonBattingStatPatch = {
  groupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  avg?: Maybe<Scalars['Float']>;
  obp?: Maybe<Scalars['Float']>;
  slg?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  group?: Maybe<FakePublicSeasonBattingStatsForeignKey0Input>;
  player?: Maybe<FakePublicSeasonBattingStatsForeignKey1Input>;
};

/** Methods to use when ordering `SeasonBattingStat`. */
export enum SeasonBattingStatsOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  STOLEN_BASES_ASC = 'STOLEN_BASES_ASC',
  STOLEN_BASES_DESC = 'STOLEN_BASES_DESC',
  AVG_ASC = 'AVG_ASC',
  AVG_DESC = 'AVG_DESC',
  OBP_ASC = 'OBP_ASC',
  OBP_DESC = 'OBP_DESC',
  SLG_ASC = 'SLG_ASC',
  SLG_DESC = 'SLG_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type SoloModeOpponentInning = Node & {
  __typename?: 'SoloModeOpponentInning';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  runsScored: Scalars['Int'];
  gameId: Scalars['UUID'];
  /** Reads a single `Game` that is related to this `SoloModeOpponentInning`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `SoloModeOpponentInning` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type SoloModeOpponentInningCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runsScored` field. */
  runsScored?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `SoloModeOpponentInning` object types. All fields are combined with a logical ‘and.’ */
export type SoloModeOpponentInningFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `runsScored` field. */
  runsScored?: Maybe<IntFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<SoloModeOpponentInningFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<SoloModeOpponentInningFilter>>;
  /** Negates the expression. */
  not?: Maybe<SoloModeOpponentInningFilter>;
};

/** The `game` to be created by this mutation. */
export type SoloModeOpponentInningGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `SoloModeOpponentInningInput` mutation. */
export type SoloModeOpponentInningGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<SoloModeOpponentInningOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<SoloModeOpponentInningGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `soloModeOpponentInning` in the `GameInput` mutation. */
export type SoloModeOpponentInningGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `soloModeOpponentInning` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  connectById?: Maybe<Array<SoloModeOpponentInningSoloModeOpponentInningPkeyConnect>>;
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<SoloModeOpponentInningNodeIdConnect>>;
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  deleteById?: Maybe<Array<SoloModeOpponentInningSoloModeOpponentInningPkeyDelete>>;
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<SoloModeOpponentInningNodeIdDelete>>;
  /** The primary key(s) and patch data for `soloModeOpponentInning` for the far side of the relationship. */
  updateById?: Maybe<Array<SoloModeOpponentInningOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyUsingSoloModeOpponentInningPkeyUpdate>>;
  /** The primary key(s) and patch data for `soloModeOpponentInning` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyNodeIdUpdate>>;
  /** A `SoloModeOpponentInningInput` object that will be created and connected to this object. */
  create?: Maybe<Array<SoloModeOpponentInningGameIdFkeySoloModeOpponentInningCreateInput>>;
};

/** The `soloModeOpponentInning` to be created by this mutation. */
export type SoloModeOpponentInningGameIdFkeySoloModeOpponentInningCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  runsScored: Scalars['Int'];
  game?: Maybe<SoloModeOpponentInningGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventSoloModeOpponentInningIdFkeyInverseInput>;
};

/** An input for mutations affecting `SoloModeOpponentInning` */
export type SoloModeOpponentInningInput = {
  id?: Maybe<Scalars['UUID']>;
  runsScored: Scalars['Int'];
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<SoloModeOpponentInningGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventSoloModeOpponentInningIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type SoloModeOpponentInningNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `soloModeOpponentInning` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type SoloModeOpponentInningNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `soloModeOpponentInning` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type SoloModeOpponentInningOnGameEventForGameEventSoloModeOpponentInningIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `soloModeOpponentInning` to look up the row to update. */
export type SoloModeOpponentInningOnGameEventForGameEventSoloModeOpponentInningIdFkeyUsingSoloModeOpponentInningPkeyUpdate = {
  /** An object where the defined keys will be set on the `soloModeOpponentInning` being updated. */
  patch: UpdateSoloModeOpponentInningOnGameEventForGameEventSoloModeOpponentInningIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type SoloModeOpponentInningOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `soloModeOpponentInning` to look up the row to update. */
export type SoloModeOpponentInningOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyUsingSoloModeOpponentInningPkeyUpdate = {
  /** An object where the defined keys will be set on the `soloModeOpponentInning` being updated. */
  patch: UpdateSoloModeOpponentInningOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `SoloModeOpponentInning`. Fields that are set will be updated. */
export type SoloModeOpponentInningPatch = {
  id?: Maybe<Scalars['UUID']>;
  runsScored?: Maybe<Scalars['Int']>;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<SoloModeOpponentInningGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventSoloModeOpponentInningIdFkeyInverseInput>;
};

/** The fields on `soloModeOpponentInning` to look up the row to connect. */
export type SoloModeOpponentInningSoloModeOpponentInningPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `soloModeOpponentInning` to look up the row to delete. */
export type SoloModeOpponentInningSoloModeOpponentInningPkeyDelete = {
  id: Scalars['UUID'];
};

/** Methods to use when ordering `SoloModeOpponentInning`. */
export enum SoloModeOpponentInningsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  RUNS_SCORED_ASC = 'RUNS_SCORED_ASC',
  RUNS_SCORED_DESC = 'RUNS_SCORED_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type StolenBaseAttempt = Node & {
  __typename?: 'StolenBaseAttempt';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  runnerId: Scalars['UUID'];
  success: Scalars['Boolean'];
  gameId: Scalars['UUID'];
  /** Reads a single `Player` that is related to this `StolenBaseAttempt`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `StolenBaseAttempt`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `StolenBaseAttempt` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type StolenBaseAttemptCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runnerId` field. */
  runnerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `success` field. */
  success?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** A filter to be used against `StolenBaseAttempt` object types. All fields are combined with a logical ‘and.’ */
export type StolenBaseAttemptFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `runnerId` field. */
  runnerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `success` field. */
  success?: Maybe<BooleanFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<StolenBaseAttemptFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<StolenBaseAttemptFilter>>;
  /** Negates the expression. */
  not?: Maybe<StolenBaseAttemptFilter>;
};

/** The `game` to be created by this mutation. */
export type StolenBaseAttemptGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `StolenBaseAttemptInput` mutation. */
export type StolenBaseAttemptGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<StolenBaseAttemptGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `stolenBaseAttempt` in the `GameInput` mutation. */
export type StolenBaseAttemptGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `stolenBaseAttempt` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectById?: Maybe<Array<StolenBaseAttemptStolenBaseAttemptPkeyConnect>>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<StolenBaseAttemptNodeIdConnect>>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteById?: Maybe<Array<StolenBaseAttemptStolenBaseAttemptPkeyDelete>>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<StolenBaseAttemptNodeIdDelete>>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateById?: Maybe<Array<StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyUsingStolenBaseAttemptPkeyUpdate>>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyNodeIdUpdate>>;
  /** A `StolenBaseAttemptInput` object that will be created and connected to this object. */
  create?: Maybe<Array<StolenBaseAttemptGameIdFkeyStolenBaseAttemptCreateInput>>;
};

/** The `stolenBaseAttempt` to be created by this mutation. */
export type StolenBaseAttemptGameIdFkeyStolenBaseAttemptCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success: Scalars['Boolean'];
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** An input for mutations affecting `StolenBaseAttempt` */
export type StolenBaseAttemptInput = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type StolenBaseAttemptNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `stolenBaseAttempt` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type StolenBaseAttemptNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `stolenBaseAttempt` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `stolenBaseAttempt` to look up the row to update. */
export type StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingStolenBaseAttemptPkeyUpdate = {
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: UpdateStolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `stolenBaseAttempt` to look up the row to update. */
export type StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyUsingStolenBaseAttemptPkeyUpdate = {
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: UpdateStolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `stolenBaseAttempt` to look up the row to update. */
export type StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingStolenBaseAttemptPkeyUpdate = {
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: UpdateStolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `StolenBaseAttempt`. Fields that are set will be updated. */
export type StolenBaseAttemptPatch = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** Input for the nested mutation of `player` in the `StolenBaseAttemptInput` mutation. */
export type StolenBaseAttemptRunnerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<StolenBaseAttemptRunnerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `stolenBaseAttempt` in the `PlayerInput` mutation. */
export type StolenBaseAttemptRunnerIdFkeyInverseInput = {
  /** Flag indicating whether all other `stolenBaseAttempt` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectById?: Maybe<Array<StolenBaseAttemptStolenBaseAttemptPkeyConnect>>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<StolenBaseAttemptNodeIdConnect>>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteById?: Maybe<Array<StolenBaseAttemptStolenBaseAttemptPkeyDelete>>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<StolenBaseAttemptNodeIdDelete>>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateById?: Maybe<Array<StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingStolenBaseAttemptPkeyUpdate>>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate>>;
  /** A `StolenBaseAttemptInput` object that will be created and connected to this object. */
  create?: Maybe<Array<StolenBaseAttemptRunnerIdFkeyStolenBaseAttemptCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type StolenBaseAttemptRunnerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** The `stolenBaseAttempt` to be created by this mutation. */
export type StolenBaseAttemptRunnerIdFkeyStolenBaseAttemptCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  success: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** The fields on `stolenBaseAttempt` to look up the row to connect. */
export type StolenBaseAttemptStolenBaseAttemptPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `stolenBaseAttempt` to look up the row to delete. */
export type StolenBaseAttemptStolenBaseAttemptPkeyDelete = {
  id: Scalars['UUID'];
};

/** Methods to use when ordering `StolenBaseAttempt`. */
export enum StolenBaseAttemptsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  RUNNER_ID_ASC = 'RUNNER_ID_ASC',
  RUNNER_ID_DESC = 'RUNNER_ID_DESC',
  SUCCESS_ASC = 'SUCCESS_ASC',
  SUCCESS_DESC = 'SUCCESS_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['String']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['String']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-sensitive). */
  includes?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: Maybe<Scalars['String']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: Maybe<Scalars['String']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: Maybe<Scalars['String']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
};

export type Team = Node & {
  __typename?: 'Team';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  gameId: Scalars['UUID'];
  role: TeamRole;
  name: Maybe<Scalars['String']>;
  captainId: Maybe<Scalars['UUID']>;
  winner: Maybe<Scalars['Boolean']>;
  soloModeOpponent: Scalars['Boolean'];
  /** Reads a single `Game` that is related to this `Team`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `Team`. */
  captain: Maybe<Player>;
  /** Reads and enables pagination through a set of `Lineup`. */
  lineups: Array<Lineup>;
  /** Reads and enables pagination through a set of `ManualEntryBattingLine`. */
  manualEntryBattingLines: Array<ManualEntryBattingLine>;
  /** Reads and enables pagination through a set of `ManualEntryPitchingLine`. */
  manualEntryPitchingLines: Array<ManualEntryPitchingLine>;
  /** Reads and enables pagination through a set of `GameBattingStat`. */
  gameBattingStats: Array<GameBattingStat>;
  finalLineup: Maybe<Lineup>;
};


export type TeamLineupsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupsOrderBy>>;
  condition?: Maybe<LineupCondition>;
  filter?: Maybe<LineupFilter>;
};


export type TeamManualEntryBattingLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ManualEntryBattingLinesOrderBy>>;
  condition?: Maybe<ManualEntryBattingLineCondition>;
  filter?: Maybe<ManualEntryBattingLineFilter>;
};


export type TeamManualEntryPitchingLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ManualEntryPitchingLinesOrderBy>>;
  condition?: Maybe<ManualEntryPitchingLineCondition>;
  filter?: Maybe<ManualEntryPitchingLineFilter>;
};


export type TeamGameBattingStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameBattingStatsOrderBy>>;
  condition?: Maybe<GameBattingStatCondition>;
  filter?: Maybe<GameBattingStatFilter>;
};

/** Input for the nested mutation of `player` in the `TeamInput` mutation. */
export type TeamCaptainIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<TeamOnTeamForTeamCaptainIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<TeamCaptainIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `team` in the `PlayerInput` mutation. */
export type TeamCaptainIdFkeyInverseInput = {
  /** Flag indicating whether all other `team` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectById?: Maybe<Array<TeamTeamPkeyConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByGameIdAndRole?: Maybe<Array<TeamTeamGameIdRoleKeyConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TeamNodeIdConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteById?: Maybe<Array<TeamTeamPkeyDelete>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByGameIdAndRole?: Maybe<Array<TeamTeamGameIdRoleKeyDelete>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TeamNodeIdDelete>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateById?: Maybe<Array<TeamOnTeamForTeamCaptainIdFkeyUsingTeamPkeyUpdate>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByGameIdAndRole?: Maybe<Array<TeamOnTeamForTeamCaptainIdFkeyUsingTeamGameIdRoleKeyUpdate>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnTeamForTeamCaptainIdFkeyNodeIdUpdate>>;
  /** A `TeamInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TeamCaptainIdFkeyTeamCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type TeamCaptainIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** The `team` to be created by this mutation. */
export type TeamCaptainIdFkeyTeamCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role: TeamRole;
  name?: Maybe<Scalars['String']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineTeamIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineTeamIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey1InverseInput>;
};

/** A condition to be used against `Team` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TeamCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `role` field. */
  role?: Maybe<TeamRole>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `captainId` field. */
  captainId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `winner` field. */
  winner?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `soloModeOpponent` field. */
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `Team` object types. All fields are combined with a logical ‘and.’ */
export type TeamFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<UuidFilter>;
  /** Filter by the object’s `gameId` field. */
  gameId?: Maybe<UuidFilter>;
  /** Filter by the object’s `role` field. */
  role?: Maybe<TeamRoleFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `captainId` field. */
  captainId?: Maybe<UuidFilter>;
  /** Filter by the object’s `winner` field. */
  winner?: Maybe<BooleanFilter>;
  /** Filter by the object’s `soloModeOpponent` field. */
  soloModeOpponent?: Maybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TeamFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TeamFilter>>;
  /** Negates the expression. */
  not?: Maybe<TeamFilter>;
};

/** The `game` to be created by this mutation. */
export type TeamGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode: Scalars['Boolean'];
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** Input for the nested mutation of `game` in the `TeamInput` mutation. */
export type TeamGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnTeamForTeamGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnTeamForTeamGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<TeamOnTeamForTeamGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<TeamGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `team` in the `GameInput` mutation. */
export type TeamGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `team` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectById?: Maybe<Array<TeamTeamPkeyConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByGameIdAndRole?: Maybe<Array<TeamTeamGameIdRoleKeyConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TeamNodeIdConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteById?: Maybe<Array<TeamTeamPkeyDelete>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByGameIdAndRole?: Maybe<Array<TeamTeamGameIdRoleKeyDelete>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TeamNodeIdDelete>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateById?: Maybe<Array<TeamOnTeamForTeamGameIdFkeyUsingTeamPkeyUpdate>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByGameIdAndRole?: Maybe<Array<TeamOnTeamForTeamGameIdFkeyUsingTeamGameIdRoleKeyUpdate>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnTeamForTeamGameIdFkeyNodeIdUpdate>>;
  /** A `TeamInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TeamGameIdFkeyTeamCreateInput>>;
};

/** The `team` to be created by this mutation. */
export type TeamGameIdFkeyTeamCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  role: TeamRole;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineTeamIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineTeamIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey1InverseInput>;
};

/** An input for mutations affecting `Team` */
export type TeamInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role: TeamRole;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineTeamIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineTeamIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey1InverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TeamNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `team` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TeamNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `team` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TeamOnGameBattingStatForFakePublicGameBattingStatsForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameBattingStat` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameBattingStat` being updated. */
  patch: GameBattingStatPatch;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnGameBattingStatForFakePublicGameBattingStatsForeignKey1UsingTeamGameIdRoleKeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnGameBattingStatForFakePublicGameBattingStatsForeignKey1Patch;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnGameBattingStatForFakePublicGameBattingStatsForeignKey1UsingTeamPkeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnGameBattingStatForFakePublicGameBattingStatsForeignKey1Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TeamOnLineupForLineupTeamIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: LineupPatch;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnLineupForLineupTeamIdFkeyUsingTeamGameIdRoleKeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnLineupForLineupTeamIdFkeyPatch;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnLineupForLineupTeamIdFkeyUsingTeamPkeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnLineupForLineupTeamIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TeamOnManualEntryBattingLineForManualEntryBattingLineTeamIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `manualEntryBattingLine` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `manualEntryBattingLine` being updated. */
  patch: ManualEntryBattingLinePatch;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnManualEntryBattingLineForManualEntryBattingLineTeamIdFkeyUsingTeamGameIdRoleKeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnManualEntryBattingLineForManualEntryBattingLineTeamIdFkeyPatch;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnManualEntryBattingLineForManualEntryBattingLineTeamIdFkeyUsingTeamPkeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnManualEntryBattingLineForManualEntryBattingLineTeamIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TeamOnManualEntryPitchingLineForManualEntryPitchingLineTeamIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `manualEntryPitchingLine` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `manualEntryPitchingLine` being updated. */
  patch: ManualEntryPitchingLinePatch;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnManualEntryPitchingLineForManualEntryPitchingLineTeamIdFkeyUsingTeamGameIdRoleKeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnManualEntryPitchingLineForManualEntryPitchingLineTeamIdFkeyPatch;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnManualEntryPitchingLineForManualEntryPitchingLineTeamIdFkeyUsingTeamPkeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnManualEntryPitchingLineForManualEntryPitchingLineTeamIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TeamOnTeamForTeamCaptainIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnTeamForTeamCaptainIdFkeyUsingTeamGameIdRoleKeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnTeamForTeamCaptainIdFkeyPatch;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnTeamForTeamCaptainIdFkeyUsingTeamPkeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnTeamForTeamCaptainIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TeamOnTeamForTeamGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnTeamForTeamGameIdFkeyUsingTeamGameIdRoleKeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnTeamForTeamGameIdFkeyPatch;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnTeamForTeamGameIdFkeyUsingTeamPkeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnTeamForTeamGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Team`. Fields that are set will be updated. */
export type TeamPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role?: Maybe<TeamRole>;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineTeamIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineTeamIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey1InverseInput>;
};

export enum TeamRole {
  AWAY = 'AWAY',
  HOME = 'HOME'
}

/** A filter to be used against TeamRole fields. All fields are combined with a logical ‘and.’ */
export type TeamRoleFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<TeamRole>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<TeamRole>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<TeamRole>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<TeamRole>;
  /** Included in the specified list. */
  in?: Maybe<Array<TeamRole>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<TeamRole>>;
  /** Less than the specified value. */
  lessThan?: Maybe<TeamRole>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<TeamRole>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<TeamRole>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<TeamRole>;
};

/** The fields on `team` to look up the row to connect. */
export type TeamTeamGameIdRoleKeyConnect = {
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to delete. */
export type TeamTeamGameIdRoleKeyDelete = {
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to connect. */
export type TeamTeamPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `team` to look up the row to delete. */
export type TeamTeamPkeyDelete = {
  id: Scalars['UUID'];
};

/** Methods to use when ordering `Team`. */
export enum TeamsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  ROLE_ASC = 'ROLE_ASC',
  ROLE_DESC = 'ROLE_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  CAPTAIN_ID_ASC = 'CAPTAIN_ID_ASC',
  CAPTAIN_ID_DESC = 'CAPTAIN_ID_DESC',
  WINNER_ASC = 'WINNER_ASC',
  WINNER_DESC = 'WINNER_DESC',
  SOLO_MODE_OPPONENT_ASC = 'SOLO_MODE_OPPONENT_ASC',
  SOLO_MODE_OPPONENT_DESC = 'SOLO_MODE_OPPONENT_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type TraditionalStatLine = {
  __typename?: 'TraditionalStatLine';
  playerId: Maybe<Scalars['UUID']>;
  games: Maybe<Scalars['Int']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
};

/** A filter to be used against `TraditionalStatLine` object types. All fields are combined with a logical ‘and.’ */
export type TraditionalStatLineFilter = {
  /** Filter by the object’s `playerId` field. */
  playerId?: Maybe<UuidFilter>;
  /** Filter by the object’s `games` field. */
  games?: Maybe<IntFilter>;
  /** Filter by the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<IntFilter>;
  /** Filter by the object’s `atBats` field. */
  atBats?: Maybe<IntFilter>;
  /** Filter by the object’s `hits` field. */
  hits?: Maybe<IntFilter>;
  /** Filter by the object’s `singles` field. */
  singles?: Maybe<IntFilter>;
  /** Filter by the object’s `doubles` field. */
  doubles?: Maybe<IntFilter>;
  /** Filter by the object’s `triples` field. */
  triples?: Maybe<IntFilter>;
  /** Filter by the object’s `homeruns` field. */
  homeruns?: Maybe<IntFilter>;
  /** Filter by the object’s `walks` field. */
  walks?: Maybe<IntFilter>;
  /** Filter by the object’s `strikeouts` field. */
  strikeouts?: Maybe<IntFilter>;
  /** Filter by the object’s `sacFlies` field. */
  sacFlies?: Maybe<IntFilter>;
  /** Filter by the object’s `gidp` field. */
  gidp?: Maybe<IntFilter>;
  /** Filter by the object’s `runs` field. */
  runs?: Maybe<IntFilter>;
  /** Filter by the object’s `rbi` field. */
  rbi?: Maybe<IntFilter>;
  /** Filter by the object’s `xbh` field. */
  xbh?: Maybe<IntFilter>;
  /** Filter by the object’s `battingAverage` field. */
  battingAverage?: Maybe<FloatFilter>;
  /** Filter by the object’s `onBasePct` field. */
  onBasePct?: Maybe<FloatFilter>;
  /** Filter by the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<FloatFilter>;
  /** Filter by the object’s `ops` field. */
  ops?: Maybe<FloatFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TraditionalStatLineFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TraditionalStatLineFilter>>;
  /** Negates the expression. */
  not?: Maybe<TraditionalStatLineFilter>;
};


/** A filter to be used against UUID fields. All fields are combined with a logical ‘and.’ */
export type UuidFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['UUID']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['UUID']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['UUID']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['UUID']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['UUID']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['UUID']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['UUID']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['UUID']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['UUID']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['UUID']>;
};

/** All input for the `updateAtBatSkipByNodeId` mutation. */
export type UpdateAtBatSkipByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AtBatSkip` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `AtBatSkip` being updated. */
  patch: AtBatSkipPatch;
};

/** All input for the `updateAtBatSkip` mutation. */
export type UpdateAtBatSkipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `AtBatSkip` being updated. */
  patch: AtBatSkipPatch;
  id: Scalars['UUID'];
};

/** The output of our update `AtBatSkip` mutation. */
export type UpdateAtBatSkipPayload = {
  __typename?: 'UpdateAtBatSkipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `AtBatSkip` that was updated by this mutation. */
  atBatSkip: Maybe<AtBatSkip>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `AtBatSkip`. */
  batter: Maybe<Player>;
  /** Reads a single `Game` that is related to this `AtBatSkip`. */
  game: Maybe<Game>;
};

/** All input for the `updateBaseRunnerByNodeId` mutation. */
export type UpdateBaseRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `BaseRunner` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `BaseRunner` being updated. */
  patch: BaseRunnerPatch;
};

/** All input for the `updateBaseRunner` mutation. */
export type UpdateBaseRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `BaseRunner` being updated. */
  patch: BaseRunnerPatch;
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our update `BaseRunner` mutation. */
export type UpdateBaseRunnerPayload = {
  __typename?: 'UpdateBaseRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BaseRunner` that was updated by this mutation. */
  baseRunner: Maybe<BaseRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `BaseRunner`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Player` that is related to this `BaseRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BaseRunner`. */
  game: Maybe<Game>;
};

/** All input for the `updateBasepathMovementByNodeId` mutation. */
export type UpdateBasepathMovementByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `BasepathMovement` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `BasepathMovement` being updated. */
  patch: BasepathMovementPatch;
};

/** All input for the `updateBasepathMovement` mutation. */
export type UpdateBasepathMovementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `BasepathMovement` being updated. */
  patch: BasepathMovementPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our update `BasepathMovement` mutation. */
export type UpdateBasepathMovementPayload = {
  __typename?: 'UpdateBasepathMovementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BasepathMovement` that was updated by this mutation. */
  basepathMovement: Maybe<BasepathMovement>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `BasepathMovement`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `BasepathMovement`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BasepathMovement`. */
  game: Maybe<Game>;
};

/** All input for the `updateEarlyGameEndByNodeId` mutation. */
export type UpdateEarlyGameEndByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `EarlyGameEnd` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `EarlyGameEnd` being updated. */
  patch: EarlyGameEndPatch;
};

/** All input for the `updateEarlyGameEnd` mutation. */
export type UpdateEarlyGameEndInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `EarlyGameEnd` being updated. */
  patch: EarlyGameEndPatch;
  id: Scalars['UUID'];
};

/** The output of our update `EarlyGameEnd` mutation. */
export type UpdateEarlyGameEndPayload = {
  __typename?: 'UpdateEarlyGameEndPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EarlyGameEnd` that was updated by this mutation. */
  earlyGameEnd: Maybe<EarlyGameEnd>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `EarlyGameEnd`. */
  game: Maybe<Game>;
};

/** All input for the `updateFieldByNodeId` mutation. */
export type UpdateFieldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Field` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Field` being updated. */
  patch: FieldPatch;
};

/** All input for the `updateField` mutation. */
export type UpdateFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Field` being updated. */
  patch: FieldPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Field` mutation. */
export type UpdateFieldPayload = {
  __typename?: 'UpdateFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Field` that was updated by this mutation. */
  field: Maybe<Field>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updateGameAuxMeetupInfoByNodeId` mutation. */
export type UpdateGameAuxMeetupInfoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameAuxMeetupInfo` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GameAuxMeetupInfo` being updated. */
  patch: GameAuxMeetupInfoPatch;
};

/** All input for the `updateGameAuxMeetupInfo` mutation. */
export type UpdateGameAuxMeetupInfoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GameAuxMeetupInfo` being updated. */
  patch: GameAuxMeetupInfoPatch;
  gameId: Scalars['UUID'];
};

/** The output of our update `GameAuxMeetupInfo` mutation. */
export type UpdateGameAuxMeetupInfoPayload = {
  __typename?: 'UpdateGameAuxMeetupInfoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameAuxMeetupInfo` that was updated by this mutation. */
  gameAuxMeetupInfo: Maybe<GameAuxMeetupInfo>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `GameAuxMeetupInfo`. */
  game: Maybe<Player>;
};

/** All input for the `updateGameByGroupIdAndName` mutation. */
export type UpdateGameByGroupIdAndNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Game` being updated. */
  patch: GamePatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** All input for the `updateGameByNodeId` mutation. */
export type UpdateGameByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Game` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Game` being updated. */
  patch: GamePatch;
};

/** All input for the `updateGameEventByNodeId` mutation. */
export type UpdateGameEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameEvent` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GameEvent` being updated. */
  patch: GameEventPatch;
};

/** All input for the `updateGameEvent` mutation. */
export type UpdateGameEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GameEvent` being updated. */
  patch: GameEventPatch;
  id: Scalars['UUID'];
};

/** The output of our update `GameEvent` mutation. */
export type UpdateGameEventPayload = {
  __typename?: 'UpdateGameEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEvent` that was updated by this mutation. */
  gameEvent: Maybe<GameEvent>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `GameEvent`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `StolenBaseAttempt` that is related to this `GameEvent`. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Reads a single `LineupChange` that is related to this `GameEvent`. */
  lineupChange: Maybe<LineupChange>;
  /** Reads a single `SoloModeOpponentInning` that is related to this `GameEvent`. */
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  /** Reads a single `AtBatSkip` that is related to this `GameEvent`. */
  atBatSkip: Maybe<AtBatSkip>;
  /** Reads a single `Game` that is related to this `GameEvent`. */
  game: Maybe<Game>;
  /** Reads a single `EarlyGameEnd` that is related to this `GameEvent`. */
  earlyGameEnd: Maybe<EarlyGameEnd>;
};

/** All input for the `updateGameEventRecordByGameIdAndEventIndex` mutation. */
export type UpdateGameEventRecordByGameIdAndEventIndexInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GameEventRecord` being updated. */
  patch: GameEventRecordPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** All input for the `updateGameEventRecordByNodeId` mutation. */
export type UpdateGameEventRecordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameEventRecord` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** All input for the `updateGameEventRecord` mutation. */
export type UpdateGameEventRecordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GameEventRecord` being updated. */
  patch: GameEventRecordPatch;
  id: Scalars['UUID'];
};

/** The output of our update `GameEventRecord` mutation. */
export type UpdateGameEventRecordPayload = {
  __typename?: 'UpdateGameEventRecordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEventRecord` that was updated by this mutation. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameEventRecord`. */
  game: Maybe<Game>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateBefore: Maybe<GameState>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateAfter: Maybe<GameState>;
  /** Reads a single `GameEvent` that is related to this `GameEventRecord`. */
  gameEvent: Maybe<GameEvent>;
};

/** All input for the `updateGame` mutation. */
export type UpdateGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Game` being updated. */
  patch: GamePatch;
  id: Scalars['UUID'];
};

/** The output of our update `Game` mutation. */
export type UpdateGamePayload = {
  __typename?: 'UpdateGamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Game` that was updated by this mutation. */
  game: Maybe<Game>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Group` that is related to this `Game`. */
  group: Maybe<Group>;
  /** Reads a single `Field` that is related to this `Game`. */
  field: Maybe<Field>;
};

/** All input for the `updateGameStateByNodeId` mutation. */
export type UpdateGameStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameState` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GameState` being updated. */
  patch: GameStatePatch;
};

/** All input for the `updateGameState` mutation. */
export type UpdateGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GameState` being updated. */
  patch: GameStatePatch;
  id: Scalars['UUID'];
};

/** The output of our update `GameState` mutation. */
export type UpdateGameStatePayload = {
  __typename?: 'UpdateGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameState` that was updated by this mutation. */
  gameState: Maybe<GameState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameState`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `GameState`. */
  playerByPlayerAtBat: Maybe<Player>;
};

/** All input for the `updateGroupByName` mutation. */
export type UpdateGroupByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
  name: Scalars['String'];
};

/** All input for the `updateGroupByNodeId` mutation. */
export type UpdateGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Group` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
};

/** All input for the `updateGroupByUrlSlug` mutation. */
export type UpdateGroupByUrlSlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
  urlSlug: Scalars['String'];
};

/** All input for the `updateGroup` mutation. */
export type UpdateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Group` mutation. */
export type UpdateGroupPayload = {
  __typename?: 'UpdateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Group` that was updated by this mutation. */
  group: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updateLineupByNodeId` mutation. */
export type UpdateLineupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Lineup` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Lineup` being updated. */
  patch: LineupPatch;
};

/** All input for the `updateLineupChangeByNodeId` mutation. */
export type UpdateLineupChangeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupChange` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LineupChange` being updated. */
  patch: LineupChangePatch;
};

/** All input for the `updateLineupChange` mutation. */
export type UpdateLineupChangeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LineupChange` being updated. */
  patch: LineupChangePatch;
  id: Scalars['UUID'];
};

/** The output of our update `LineupChange` mutation. */
export type UpdateLineupChangePayload = {
  __typename?: 'UpdateLineupChangePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupChange` that was updated by this mutation. */
  lineupChange: Maybe<LineupChange>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupBefore: Maybe<Lineup>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupAfter: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupChange`. */
  game: Maybe<Game>;
};

/** All input for the `updateLineupForGameStateByNodeId` mutation. */
export type UpdateLineupForGameStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupForGameState` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LineupForGameState` being updated. */
  patch: LineupForGameStatePatch;
};

/** All input for the `updateLineupForGameState` mutation. */
export type UpdateLineupForGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LineupForGameState` being updated. */
  patch: LineupForGameStatePatch;
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** The output of our update `LineupForGameState` mutation. */
export type UpdateLineupForGameStatePayload = {
  __typename?: 'UpdateLineupForGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupForGameState` that was updated by this mutation. */
  lineupForGameState: Maybe<LineupForGameState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `LineupForGameState`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Lineup` that is related to this `LineupForGameState`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupForGameState`. */
  game: Maybe<Game>;
};

/** All input for the `updateLineup` mutation. */
export type UpdateLineupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Lineup` being updated. */
  patch: LineupPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Lineup` mutation. */
export type UpdateLineupPayload = {
  __typename?: 'UpdateLineupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Lineup` that was updated by this mutation. */
  lineup: Maybe<Lineup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Team` that is related to this `Lineup`. */
  team: Maybe<Team>;
  /** Reads a single `Game` that is related to this `Lineup`. */
  game: Maybe<Game>;
};

/** All input for the `updateLineupSpotByLineupIdAndBattingOrder` mutation. */
export type UpdateLineupSpotByLineupIdAndBattingOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LineupSpot` being updated. */
  patch: LineupSpotPatch;
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** All input for the `updateLineupSpotByLineupIdAndPosition` mutation. */
export type UpdateLineupSpotByLineupIdAndPositionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LineupSpot` being updated. */
  patch: LineupSpotPatch;
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** All input for the `updateLineupSpotByNodeId` mutation. */
export type UpdateLineupSpotByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupSpot` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LineupSpot` being updated. */
  patch: LineupSpotPatch;
};

/** All input for the `updateLineupSpot` mutation. */
export type UpdateLineupSpotInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LineupSpot` being updated. */
  patch: LineupSpotPatch;
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The output of our update `LineupSpot` mutation. */
export type UpdateLineupSpotPayload = {
  __typename?: 'UpdateLineupSpotPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupSpot` that was updated by this mutation. */
  lineupSpot: Maybe<LineupSpot>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupSpot`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Player` that is related to this `LineupSpot`. */
  player: Maybe<Player>;
  /** Reads a single `Game` that is related to this `LineupSpot`. */
  game: Maybe<Game>;
};

/** All input for the `updateManualEntryBattingLineByNodeId` mutation. */
export type UpdateManualEntryBattingLineByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ManualEntryBattingLine` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ManualEntryBattingLine` being updated. */
  patch: ManualEntryBattingLinePatch;
};

/** All input for the `updateManualEntryBattingLine` mutation. */
export type UpdateManualEntryBattingLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ManualEntryBattingLine` being updated. */
  patch: ManualEntryBattingLinePatch;
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The output of our update `ManualEntryBattingLine` mutation. */
export type UpdateManualEntryBattingLinePayload = {
  __typename?: 'UpdateManualEntryBattingLinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ManualEntryBattingLine` that was updated by this mutation. */
  manualEntryBattingLine: Maybe<ManualEntryBattingLine>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `ManualEntryBattingLine`. */
  game: Maybe<Game>;
  /** Reads a single `Team` that is related to this `ManualEntryBattingLine`. */
  team: Maybe<Team>;
  /** Reads a single `Player` that is related to this `ManualEntryBattingLine`. */
  player: Maybe<Player>;
};

/** All input for the `updateManualEntryLineScoreCellByNodeId` mutation. */
export type UpdateManualEntryLineScoreCellByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ManualEntryLineScoreCell` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ManualEntryLineScoreCell` being updated. */
  patch: ManualEntryLineScoreCellPatch;
};

/** All input for the `updateManualEntryLineScoreCell` mutation. */
export type UpdateManualEntryLineScoreCellInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ManualEntryLineScoreCell` being updated. */
  patch: ManualEntryLineScoreCellPatch;
  gameId: Scalars['UUID'];
  inning: Scalars['Int'];
  halfInning: HalfInning;
};

/** The output of our update `ManualEntryLineScoreCell` mutation. */
export type UpdateManualEntryLineScoreCellPayload = {
  __typename?: 'UpdateManualEntryLineScoreCellPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ManualEntryLineScoreCell` that was updated by this mutation. */
  manualEntryLineScoreCell: Maybe<ManualEntryLineScoreCell>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `ManualEntryLineScoreCell`. */
  game: Maybe<Game>;
};

/** All input for the `updateManualEntryPitchingLineByNodeId` mutation. */
export type UpdateManualEntryPitchingLineByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ManualEntryPitchingLine` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ManualEntryPitchingLine` being updated. */
  patch: ManualEntryPitchingLinePatch;
};

/** All input for the `updateManualEntryPitchingLine` mutation. */
export type UpdateManualEntryPitchingLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ManualEntryPitchingLine` being updated. */
  patch: ManualEntryPitchingLinePatch;
  gameId: Scalars['UUID'];
  teamId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The output of our update `ManualEntryPitchingLine` mutation. */
export type UpdateManualEntryPitchingLinePayload = {
  __typename?: 'UpdateManualEntryPitchingLinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ManualEntryPitchingLine` that was updated by this mutation. */
  manualEntryPitchingLine: Maybe<ManualEntryPitchingLine>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `ManualEntryPitchingLine`. */
  game: Maybe<Game>;
  /** Reads a single `Team` that is related to this `ManualEntryPitchingLine`. */
  team: Maybe<Team>;
  /** Reads a single `Player` that is related to this `ManualEntryPitchingLine`. */
  player: Maybe<Player>;
};

/** All input for the `updateOutOnPlayRunnerByNodeId` mutation. */
export type UpdateOutOnPlayRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OutOnPlayRunner` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `OutOnPlayRunner` being updated. */
  patch: OutOnPlayRunnerPatch;
};

/** All input for the `updateOutOnPlayRunner` mutation. */
export type UpdateOutOnPlayRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `OutOnPlayRunner` being updated. */
  patch: OutOnPlayRunnerPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our update `OutOnPlayRunner` mutation. */
export type UpdateOutOnPlayRunnerPayload = {
  __typename?: 'UpdateOutOnPlayRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `OutOnPlayRunner` that was updated by this mutation. */
  outOnPlayRunner: Maybe<OutOnPlayRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `OutOnPlayRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `OutOnPlayRunner`. */
  game: Maybe<Game>;
};

/** All input for the `updatePlateAppearanceByNodeId` mutation. */
export type UpdatePlateAppearanceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlateAppearance` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** All input for the `updatePlateAppearance` mutation. */
export type UpdatePlateAppearanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlateAppearance` being updated. */
  patch: PlateAppearancePatch;
  id: Scalars['UUID'];
};

/** The output of our update `PlateAppearance` mutation. */
export type UpdatePlateAppearancePayload = {
  __typename?: 'UpdatePlateAppearancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlateAppearance` that was updated by this mutation. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `PlateAppearance`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `PlateAppearance`. */
  batter: Maybe<Player>;
};

/** All input for the `updatePlayerAuxMeetupInfoByNodeId` mutation. */
export type UpdatePlayerAuxMeetupInfoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlayerAuxMeetupInfo` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlayerAuxMeetupInfo` being updated. */
  patch: PlayerAuxMeetupInfoPatch;
};

/** All input for the `updatePlayerAuxMeetupInfo` mutation. */
export type UpdatePlayerAuxMeetupInfoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlayerAuxMeetupInfo` being updated. */
  patch: PlayerAuxMeetupInfoPatch;
  playerId: Scalars['UUID'];
};

/** The output of our update `PlayerAuxMeetupInfo` mutation. */
export type UpdatePlayerAuxMeetupInfoPayload = {
  __typename?: 'UpdatePlayerAuxMeetupInfoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlayerAuxMeetupInfo` that was updated by this mutation. */
  playerAuxMeetupInfo: Maybe<PlayerAuxMeetupInfo>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `PlayerAuxMeetupInfo`. */
  player: Maybe<Player>;
};

/** All input for the `updatePlayerByFirstNameAndLastName` mutation. */
export type UpdatePlayerByFirstNameAndLastNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Player` being updated. */
  patch: PlayerPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** All input for the `updatePlayerByNodeId` mutation. */
export type UpdatePlayerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Player` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Player` being updated. */
  patch: PlayerPatch;
};

/** All input for the `updatePlayerGroupMembershipByNodeId` mutation. */
export type UpdatePlayerGroupMembershipByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlayerGroupMembership` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlayerGroupMembership` being updated. */
  patch: PlayerGroupMembershipPatch;
};

/** All input for the `updatePlayerGroupMembership` mutation. */
export type UpdatePlayerGroupMembershipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlayerGroupMembership` being updated. */
  patch: PlayerGroupMembershipPatch;
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
};

/** The output of our update `PlayerGroupMembership` mutation. */
export type UpdatePlayerGroupMembershipPayload = {
  __typename?: 'UpdatePlayerGroupMembershipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlayerGroupMembership` that was updated by this mutation. */
  playerGroupMembership: Maybe<PlayerGroupMembership>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `PlayerGroupMembership`. */
  player: Maybe<Player>;
  /** Reads a single `Group` that is related to this `PlayerGroupMembership`. */
  group: Maybe<Group>;
};

/** All input for the `updatePlayer` mutation. */
export type UpdatePlayerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Player` being updated. */
  patch: PlayerPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Player` mutation. */
export type UpdatePlayerPayload = {
  __typename?: 'UpdatePlayerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Player` that was updated by this mutation. */
  player: Maybe<Player>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updateReduxDumpByNodeId` mutation. */
export type UpdateReduxDumpByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ReduxDump` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ReduxDump` being updated. */
  patch: ReduxDumpPatch;
};

/** All input for the `updateReduxDump` mutation. */
export type UpdateReduxDumpInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ReduxDump` being updated. */
  patch: ReduxDumpPatch;
  id: Scalars['UUID'];
};

/** The output of our update `ReduxDump` mutation. */
export type UpdateReduxDumpPayload = {
  __typename?: 'UpdateReduxDumpPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ReduxDump` that was updated by this mutation. */
  reduxDump: Maybe<ReduxDump>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updateScoredRunnerByNodeId` mutation. */
export type UpdateScoredRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ScoredRunner` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ScoredRunner` being updated. */
  patch: ScoredRunnerPatch;
};

/** All input for the `updateScoredRunner` mutation. */
export type UpdateScoredRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ScoredRunner` being updated. */
  patch: ScoredRunnerPatch;
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our update `ScoredRunner` mutation. */
export type UpdateScoredRunnerPayload = {
  __typename?: 'UpdateScoredRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ScoredRunner` that was updated by this mutation. */
  scoredRunner: Maybe<ScoredRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameEventRecord` that is related to this `ScoredRunner`. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Reads a single `Player` that is related to this `ScoredRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `ScoredRunner`. */
  game: Maybe<Game>;
};

/** All input for the `updateSoloModeOpponentInningByNodeId` mutation. */
export type UpdateSoloModeOpponentInningByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SoloModeOpponentInning` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `SoloModeOpponentInning` being updated. */
  patch: SoloModeOpponentInningPatch;
};

/** All input for the `updateSoloModeOpponentInning` mutation. */
export type UpdateSoloModeOpponentInningInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `SoloModeOpponentInning` being updated. */
  patch: SoloModeOpponentInningPatch;
  id: Scalars['UUID'];
};

/** The output of our update `SoloModeOpponentInning` mutation. */
export type UpdateSoloModeOpponentInningPayload = {
  __typename?: 'UpdateSoloModeOpponentInningPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `SoloModeOpponentInning` that was updated by this mutation. */
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `SoloModeOpponentInning`. */
  game: Maybe<Game>;
};

/** All input for the `updateStolenBaseAttemptByNodeId` mutation. */
export type UpdateStolenBaseAttemptByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StolenBaseAttempt` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `StolenBaseAttempt` being updated. */
  patch: StolenBaseAttemptPatch;
};

/** All input for the `updateStolenBaseAttempt` mutation. */
export type UpdateStolenBaseAttemptInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `StolenBaseAttempt` being updated. */
  patch: StolenBaseAttemptPatch;
  id: Scalars['UUID'];
};

/** The output of our update `StolenBaseAttempt` mutation. */
export type UpdateStolenBaseAttemptPayload = {
  __typename?: 'UpdateStolenBaseAttemptPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `StolenBaseAttempt` that was updated by this mutation. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `StolenBaseAttempt`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `StolenBaseAttempt`. */
  game: Maybe<Game>;
};

/** All input for the `updateTeamByGameIdAndRole` mutation. */
export type UpdateTeamByGameIdAndRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Team` being updated. */
  patch: TeamPatch;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** All input for the `updateTeamByNodeId` mutation. */
export type UpdateTeamByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Team` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Team` being updated. */
  patch: TeamPatch;
};

/** All input for the `updateTeam` mutation. */
export type UpdateTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Team` being updated. */
  patch: TeamPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Team` mutation. */
export type UpdateTeamPayload = {
  __typename?: 'UpdateTeamPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Team` that was updated by this mutation. */
  team: Maybe<Team>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `Team`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `Team`. */
  captain: Maybe<Player>;
};

export type UserGroupPermission = {
  __typename?: 'UserGroupPermission';
  groupId: Maybe<Scalars['UUID']>;
  permission: Maybe<GroupPermissionType>;
};

/** A filter to be used against `UserGroupPermission` object types. All fields are combined with a logical ‘and.’ */
export type UserGroupPermissionFilter = {
  /** Filter by the object’s `groupId` field. */
  groupId?: Maybe<UuidFilter>;
  /** Filter by the object’s `permission` field. */
  permission?: Maybe<GroupPermissionTypeFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserGroupPermissionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserGroupPermissionFilter>>;
  /** Negates the expression. */
  not?: Maybe<UserGroupPermissionFilter>;
};

/** All input for the `verifyEmail` mutation. */
export type VerifyEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  email: Scalars['String'];
  code: Scalars['String'];
};

/** The output of our `verifyEmail` mutation. */
export type VerifyEmailPayload = {
  __typename?: 'VerifyEmailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  boolean: Maybe<Scalars['Boolean']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** An object where the defined keys will be set on the `atBatSkip` being updated. */
export type UpdateAtBatSkipOnAtBatSkipForAtBatSkipBatterIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `atBatSkip` being updated. */
export type UpdateAtBatSkipOnAtBatSkipForAtBatSkipGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `atBatSkip` being updated. */
export type UpdateAtBatSkipOnGameEventForGameEventAtBatSkipIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `baseRunner` being updated. */
export type UpdateBaseRunnerOnBaseRunnerForBaseRunnerGameIdFkeyPatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  base?: Maybe<BaseType>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `baseRunner` being updated. */
export type UpdateBaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch = {
  runnerId?: Maybe<Scalars['UUID']>;
  base?: Maybe<BaseType>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `baseRunner` being updated. */
export type UpdateBaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  base?: Maybe<BaseType>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `basepathMovement` being updated. */
export type UpdateBasepathMovementOnBasepathMovementForBasepathMovementGameIdFkeyPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe?: Maybe<Scalars['Boolean']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `basepathMovement` being updated. */
export type UpdateBasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch = {
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `basepathMovement` being updated. */
export type UpdateBasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `careerBattingStat` being updated. */
export type UpdateCareerBattingStatOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0Patch = {
  playerId?: Maybe<Scalars['UUID']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  avg?: Maybe<Scalars['Float']>;
  obp?: Maybe<Scalars['Float']>;
  slg?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  group?: Maybe<FakePublicCareerBattingStatsForeignKey0Input>;
  player?: Maybe<FakePublicCareerBattingStatsForeignKey1Input>;
};

/** An object where the defined keys will be set on the `careerBattingStat` being updated. */
export type UpdateCareerBattingStatOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey1Patch = {
  groupId?: Maybe<Scalars['UUID']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  avg?: Maybe<Scalars['Float']>;
  obp?: Maybe<Scalars['Float']>;
  slg?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  group?: Maybe<FakePublicCareerBattingStatsForeignKey0Input>;
  player?: Maybe<FakePublicCareerBattingStatsForeignKey1Input>;
};

/** An object where the defined keys will be set on the `earlyGameEnd` being updated. */
export type UpdateEarlyGameEndOnEarlyGameEndForEarlyGameEndGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  reason?: Maybe<EarlyGameEndReason>;
  game?: Maybe<EarlyGameEndGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventEarlyGameEndIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `earlyGameEnd` being updated. */
export type UpdateEarlyGameEndOnGameEventForGameEventEarlyGameEndIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  reason?: Maybe<EarlyGameEndReason>;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<EarlyGameEndGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventEarlyGameEndIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `field` being updated. */
export type UpdateFieldOnGameForGameFieldIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  games?: Maybe<GameFieldIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameAuxMeetupInfo` being updated. */
export type UpdateGameAuxMeetupInfoOnGameAuxMeetupInfoForGameAuxMeetupInfoGameIdFkeyPatch = {
  imageGalleryUrl?: Maybe<Scalars['String']>;
  meetupEventId?: Maybe<Scalars['String']>;
  advanced?: Maybe<Scalars['Boolean']>;
  player?: Maybe<GameAuxMeetupInfoGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `gameBattingStat` being updated. */
export type UpdateGameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey0Patch = {
  teamId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  game?: Maybe<FakePublicGameBattingStatsForeignKey0Input>;
  team?: Maybe<FakePublicGameBattingStatsForeignKey1Input>;
  player?: Maybe<FakePublicGameBattingStatsForeignKey2Input>;
};

/** An object where the defined keys will be set on the `gameBattingStat` being updated. */
export type UpdateGameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey1Patch = {
  gameId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  game?: Maybe<FakePublicGameBattingStatsForeignKey0Input>;
  team?: Maybe<FakePublicGameBattingStatsForeignKey1Input>;
  player?: Maybe<FakePublicGameBattingStatsForeignKey2Input>;
};

/** An object where the defined keys will be set on the `gameBattingStat` being updated. */
export type UpdateGameBattingStatOnGameBattingStatForFakePublicGameBattingStatsForeignKey2Patch = {
  gameId?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  game?: Maybe<FakePublicGameBattingStatsForeignKey0Input>;
  team?: Maybe<FakePublicGameBattingStatsForeignKey1Input>;
  player?: Maybe<FakePublicGameBattingStatsForeignKey2Input>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventAtBatSkipIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventEarlyGameEndIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventLineupChangeIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventPlateAppearanceIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventSoloModeOpponentInningIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEventRecord` being updated. */
export type UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEventRecord` being updated. */
export type UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEventRecord` being updated. */
export type UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEventRecord` being updated. */
export type UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEventRecord` being updated. */
export type UpdateGameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnAtBatSkipForAtBatSkipGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnBaseRunnerForBaseRunnerGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnBasepathMovementForBasepathMovementGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnEarlyGameEndForEarlyGameEndGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameBattingStatForFakePublicGameBattingStatsForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameEventForGameEventGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameEventRecordForGameEventRecordGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameForGameFieldIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameForGameGroupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameStateForGameStateGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnLineupChangeForLineupChangeGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnLineupForGameStateForLineupForGameStateGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnLineupForLineupGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnLineupSpotForLineupSpotGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnManualEntryBattingLineForManualEntryBattingLineGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnManualEntryLineScoreCellForManualEntryLineScoreCellGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnManualEntryPitchingLineForManualEntryPitchingLineGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnPlateAppearanceForPlateAppearanceGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnScoredRunnerForScoredRunnerGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnTeamForTeamGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  manualEntry?: Maybe<Scalars['Boolean']>;
  legacyMeetup?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineGameIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineGameIdFkeyInverseInput>;
  manualEntryLineScoreCells?: Maybe<ManualEntryLineScoreCellGameIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnGameEventRecordForGameEventRecordGameStateAfterFkPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnGameStateForGameStateGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnGameStateForGameStatePlayerAtBatFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey0InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnGameForGameGroupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey0InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey0InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey0InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `lineupChange` being updated. */
export type UpdateLineupChangeOnGameEventForGameEventLineupChangeIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineupChange` being updated. */
export type UpdateLineupChangeOnLineupChangeForLineupChangeGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineupChange` being updated. */
export type UpdateLineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineupChange` being updated. */
export type UpdateLineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineupForGameState` being updated. */
export type UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateGameIdFkeyPatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  lineupId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `lineupForGameState` being updated. */
export type UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch = {
  lineupId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `lineupForGameState` being updated. */
export type UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `lineup` being updated. */
export type UpdateLineupOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineup` being updated. */
export type UpdateLineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineup` being updated. */
export type UpdateLineupOnLineupForLineupGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineup` being updated. */
export type UpdateLineupOnLineupForLineupTeamIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineup` being updated. */
export type UpdateLineupOnLineupSpotForLineupSpotLineupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineupSpot` being updated. */
export type UpdateLineupSpotOnLineupSpotForLineupSpotGameIdFkeyPatch = {
  lineupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder?: Maybe<Scalars['Int']>;
  position?: Maybe<FieldingPosition>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `lineupSpot` being updated. */
export type UpdateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch = {
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder?: Maybe<Scalars['Int']>;
  position?: Maybe<FieldingPosition>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `lineupSpot` being updated. */
export type UpdateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch = {
  lineupId?: Maybe<Scalars['UUID']>;
  battingOrder?: Maybe<Scalars['Int']>;
  position?: Maybe<FieldingPosition>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `manualEntryBattingLine` being updated. */
export type UpdateManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLineGameIdFkeyPatch = {
  teamId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  game?: Maybe<ManualEntryBattingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryBattingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryBattingLinePlayerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `manualEntryBattingLine` being updated. */
export type UpdateManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLinePlayerIdFkeyPatch = {
  gameId?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  game?: Maybe<ManualEntryBattingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryBattingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryBattingLinePlayerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `manualEntryBattingLine` being updated. */
export type UpdateManualEntryBattingLineOnManualEntryBattingLineForManualEntryBattingLineTeamIdFkeyPatch = {
  gameId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  game?: Maybe<ManualEntryBattingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryBattingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryBattingLinePlayerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `manualEntryLineScoreCell` being updated. */
export type UpdateManualEntryLineScoreCellOnManualEntryLineScoreCellForManualEntryLineScoreCellGameIdFkeyPatch = {
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  runs?: Maybe<Scalars['Int']>;
  game?: Maybe<ManualEntryLineScoreCellGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `manualEntryPitchingLine` being updated. */
export type UpdateManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLineGameIdFkeyPatch = {
  teamId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  inningsPitched?: Maybe<Scalars['Int']>;
  won?: Maybe<Scalars['Boolean']>;
  lost?: Maybe<Scalars['Boolean']>;
  save?: Maybe<Scalars['Boolean']>;
  completeGame?: Maybe<Scalars['Boolean']>;
  qualityStart?: Maybe<Scalars['Boolean']>;
  runsAllowed?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  game?: Maybe<ManualEntryPitchingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryPitchingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `manualEntryPitchingLine` being updated. */
export type UpdateManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLinePlayerIdFkeyPatch = {
  gameId?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  inningsPitched?: Maybe<Scalars['Int']>;
  won?: Maybe<Scalars['Boolean']>;
  lost?: Maybe<Scalars['Boolean']>;
  save?: Maybe<Scalars['Boolean']>;
  completeGame?: Maybe<Scalars['Boolean']>;
  qualityStart?: Maybe<Scalars['Boolean']>;
  runsAllowed?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  game?: Maybe<ManualEntryPitchingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryPitchingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `manualEntryPitchingLine` being updated. */
export type UpdateManualEntryPitchingLineOnManualEntryPitchingLineForManualEntryPitchingLineTeamIdFkeyPatch = {
  gameId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  inningsPitched?: Maybe<Scalars['Int']>;
  won?: Maybe<Scalars['Boolean']>;
  lost?: Maybe<Scalars['Boolean']>;
  save?: Maybe<Scalars['Boolean']>;
  completeGame?: Maybe<Scalars['Boolean']>;
  qualityStart?: Maybe<Scalars['Boolean']>;
  runsAllowed?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  game?: Maybe<ManualEntryPitchingLineGameIdFkeyInput>;
  team?: Maybe<ManualEntryPitchingLineTeamIdFkeyInput>;
  player?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
export type UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
export type UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch = {
  runnerId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
export type UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `plateAppearance` being updated. */
export type UpdatePlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `plateAppearance` being updated. */
export type UpdatePlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `plateAppearance` being updated. */
export type UpdatePlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `plateAppearance` being updated. */
export type UpdatePlateAppearanceOnPlateAppearanceForPlateAppearanceBatterIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `plateAppearance` being updated. */
export type UpdatePlateAppearanceOnPlateAppearanceForPlateAppearanceGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `playerAuxMeetupInfo` being updated. */
export type UpdatePlayerAuxMeetupInfoOnPlayerAuxMeetupInfoForPlayerAuxMeetupInfoPlayerIdFkeyPatch = {
  gender?: Maybe<Gender>;
  bats?: Maybe<Handedness>;
  throws?: Maybe<Handedness>;
  preferredPositionFirst?: Maybe<FieldingPosition>;
  preferredPositionSecond?: Maybe<FieldingPosition>;
  preferredPositionThird?: Maybe<FieldingPosition>;
  meetupMemberId?: Maybe<Scalars['String']>;
  adminNickname?: Maybe<Scalars['String']>;
  selfNickname?: Maybe<Scalars['String']>;
  skillLevel?: Maybe<Scalars['Int']>;
  favoriteTeam?: Maybe<Scalars['String']>;
  hometown?: Maybe<Scalars['String']>;
  school?: Maybe<Scalars['String']>;
  dateDebuted?: Maybe<Scalars['Date']>;
  player?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `playerGroupMembership` being updated. */
export type UpdatePlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyPatch = {
  playerId?: Maybe<Scalars['UUID']>;
  player?: Maybe<PlayerGroupMembershipPlayerIdFkeyInput>;
  group?: Maybe<PlayerGroupMembershipGroupIdFkeyInput>;
};

/** An object where the defined keys will be set on the `playerGroupMembership` being updated. */
export type UpdatePlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyPatch = {
  groupId?: Maybe<Scalars['UUID']>;
  player?: Maybe<PlayerGroupMembershipPlayerIdFkeyInput>;
  group?: Maybe<PlayerGroupMembershipGroupIdFkeyInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnAtBatSkipForAtBatSkipBatterIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnCareerBattingStatForFakePublicCareerBattingStatsForeignKey1Patch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnGameAuxMeetupInfoForGameAuxMeetupInfoGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnGameBattingStatForFakePublicGameBattingStatsForeignKey2Patch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnGameStateForGameStatePlayerAtBatFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnLineupSpotForLineupSpotPlayerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnManualEntryBattingLineForManualEntryBattingLinePlayerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnManualEntryPitchingLineForManualEntryPitchingLinePlayerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnPlayerAuxMeetupInfoForPlayerAuxMeetupInfoPlayerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey1Patch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnTeamForTeamCaptainIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  active?: Maybe<Scalars['Boolean']>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLinePlayerIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLinePlayerIdFkeyInverseInput>;
  playerAuxMeetupInfo?: Maybe<PlayerAuxMeetupInfoPlayerIdFkeyInverseInput>;
  gameAuxMeetupInfo?: Maybe<GameAuxMeetupInfoGameIdFkeyInverseInput>;
  careerBattingStats?: Maybe<FakePublicCareerBattingStatsForeignKey1InverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey2InverseInput>;
  seasonBattingStats?: Maybe<FakePublicSeasonBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `scoredRunner` being updated. */
export type UpdateScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch = {
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `scoredRunner` being updated. */
export type UpdateScoredRunnerOnScoredRunnerForScoredRunnerGameIdFkeyPatch = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn?: Maybe<Scalars['Boolean']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `scoredRunner` being updated. */
export type UpdateScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  battedIn?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `seasonBattingStat` being updated. */
export type UpdateSeasonBattingStatOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey0Patch = {
  playerId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  avg?: Maybe<Scalars['Float']>;
  obp?: Maybe<Scalars['Float']>;
  slg?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  group?: Maybe<FakePublicSeasonBattingStatsForeignKey0Input>;
  player?: Maybe<FakePublicSeasonBattingStatsForeignKey1Input>;
};

/** An object where the defined keys will be set on the `seasonBattingStat` being updated. */
export type UpdateSeasonBattingStatOnSeasonBattingStatForFakePublicSeasonBattingStatsForeignKey1Patch = {
  groupId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  avg?: Maybe<Scalars['Float']>;
  obp?: Maybe<Scalars['Float']>;
  slg?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  group?: Maybe<FakePublicSeasonBattingStatsForeignKey0Input>;
  player?: Maybe<FakePublicSeasonBattingStatsForeignKey1Input>;
};

/** An object where the defined keys will be set on the `soloModeOpponentInning` being updated. */
export type UpdateSoloModeOpponentInningOnGameEventForGameEventSoloModeOpponentInningIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  runsScored?: Maybe<Scalars['Int']>;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<SoloModeOpponentInningGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventSoloModeOpponentInningIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `soloModeOpponentInning` being updated. */
export type UpdateSoloModeOpponentInningOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  runsScored?: Maybe<Scalars['Int']>;
  game?: Maybe<SoloModeOpponentInningGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventSoloModeOpponentInningIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
export type UpdateStolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
export type UpdateStolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success?: Maybe<Scalars['Boolean']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
export type UpdateStolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  success?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `team` being updated. */
export type UpdateTeamOnGameBattingStatForFakePublicGameBattingStatsForeignKey1Patch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role?: Maybe<TeamRole>;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineTeamIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineTeamIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `team` being updated. */
export type UpdateTeamOnLineupForLineupTeamIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role?: Maybe<TeamRole>;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineTeamIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineTeamIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `team` being updated. */
export type UpdateTeamOnManualEntryBattingLineForManualEntryBattingLineTeamIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role?: Maybe<TeamRole>;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineTeamIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineTeamIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `team` being updated. */
export type UpdateTeamOnManualEntryPitchingLineForManualEntryPitchingLineTeamIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role?: Maybe<TeamRole>;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineTeamIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineTeamIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `team` being updated. */
export type UpdateTeamOnTeamForTeamCaptainIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role?: Maybe<TeamRole>;
  name?: Maybe<Scalars['String']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineTeamIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineTeamIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `team` being updated. */
export type UpdateTeamOnTeamForTeamGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  role?: Maybe<TeamRole>;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
  manualEntryBattingLines?: Maybe<ManualEntryBattingLineTeamIdFkeyInverseInput>;
  manualEntryPitchingLines?: Maybe<ManualEntryPitchingLineTeamIdFkeyInverseInput>;
  gameBattingStats?: Maybe<FakePublicGameBattingStatsForeignKey1InverseInput>;
};

export type GameEventRecord_GameStateFragment = (
  { __typename?: 'GameState' }
  & Pick<GameState, 'inning' | 'halfInning' | 'outs' | 'playerAtBat' | 'score'>
  & { lineups: Maybe<Array<Maybe<(
    { __typename?: 'Lineup' }
    & Pick<Lineup, 'id'>
    & { team: Maybe<(
      { __typename?: 'Team' }
      & Pick<Team, 'role'>
    )> }
  )>>>, baseRunners: Array<(
    { __typename?: 'BaseRunner' }
    & Pick<BaseRunner, 'runnerId' | 'base'>
  )> }
);

export type UnpackedGame_GameFragment = (
  { __typename?: 'Game' }
  & Pick<Game, 'id' | 'gameLength' | 'name' | 'score' | 'timeStarted' | 'timeEnded'>
  & { gameStates: Array<(
    { __typename?: 'GameState' }
    & Pick<GameState, 'id' | 'inning' | 'halfInning' | 'outs' | 'playerAtBat' | 'score'>
    & { lineups: Maybe<Array<Maybe<(
      { __typename?: 'Lineup' }
      & Pick<Lineup, 'id'>
      & { team: Maybe<(
        { __typename?: 'Team' }
        & Pick<Team, 'role'>
      )> }
    )>>>, baseRunners: Array<(
      { __typename?: 'BaseRunner' }
      & Pick<BaseRunner, 'runnerId' | 'base'>
    )> }
  )>, gameEventRecords: Array<(
    { __typename?: 'GameEventRecord' }
    & Pick<GameEventRecord, 'eventIndex' | 'gameStateBeforeId' | 'gameStateAfterId'>
    & { gameEvent: Maybe<(
      { __typename?: 'GameEvent' }
      & { lineupChange: Maybe<(
        { __typename?: 'LineupChange' }
        & Pick<LineupChange, 'lineupBeforeId' | 'lineupAfterId'>
      )>, stolenBaseAttempt: Maybe<(
        { __typename?: 'StolenBaseAttempt' }
        & Pick<StolenBaseAttempt, 'runnerId' | 'success'>
      )>, plateAppearance: Maybe<(
        { __typename?: 'PlateAppearance' }
        & Pick<PlateAppearance, 'batterId' | 'type' | 'contact' | 'fieldedBy' | 'runsScoredOnSacFly'>
        & { outOnPlayRunners: Array<(
          { __typename?: 'OutOnPlayRunner' }
          & Pick<OutOnPlayRunner, 'runnerId'>
        )>, basepathMovements: Array<(
          { __typename?: 'BasepathMovement' }
          & Pick<BasepathMovement, 'runnerId' | 'endBase' | 'wasSafe'>
        )> }
      )>, soloModeOpponentInning: Maybe<(
        { __typename?: 'SoloModeOpponentInning' }
        & Pick<SoloModeOpponentInning, 'runsScored'>
      )>, atBatSkip: Maybe<(
        { __typename?: 'AtBatSkip' }
        & Pick<AtBatSkip, 'batterId'>
      )>, earlyGameEnd: Maybe<(
        { __typename?: 'EarlyGameEnd' }
        & Pick<EarlyGameEnd, 'reason'>
      )> }
    )>, scoredRunners: Array<(
      { __typename?: 'ScoredRunner' }
      & Pick<ScoredRunner, 'runnerId' | 'battedIn'>
    )> }
  )>, teams: Array<(
    { __typename?: 'Team' }
    & Pick<Team, 'name' | 'role' | 'winner' | 'soloModeOpponent'>
    & { lineups: Array<(
      { __typename?: 'Lineup' }
      & Pick<Lineup, 'id'>
      & { lineupSpots: Array<(
        { __typename?: 'LineupSpot' }
        & Pick<LineupSpot, 'playerId' | 'position'>
      )> }
    )> }
  )> }
);

export type AddPlayerToGroupMutationVariables = Exact<{
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
}>;


export type AddPlayerToGroupMutation = (
  { __typename?: 'Mutation' }
  & { updatePlayer: Maybe<(
    { __typename?: 'UpdatePlayerPayload' }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'firstName' | 'lastName'>
      & { groups: Array<(
        { __typename?: 'PlayerGroupMembership' }
        & Pick<PlayerGroupMembership, 'groupId'>
      )> }
    )> }
  )> }
);

export type CreateGameMutationVariables = Exact<{
  input: CreateGameInput;
}>;


export type CreateGameMutation = (
  { __typename?: 'Mutation' }
  & { createGame: Maybe<(
    { __typename?: 'CreateGamePayload' }
    & { game: Maybe<(
      { __typename?: 'Game' }
      & UnpackedGame_GameFragment
    )> }
  )> }
);

export type CreatePlayerMutationVariables = Exact<{
  input: CreatePlayerInput;
}>;


export type CreatePlayerMutation = (
  { __typename?: 'Mutation' }
  & { createPlayer: Maybe<(
    { __typename?: 'CreatePlayerPayload' }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'firstName' | 'lastName'>
      & { groups: Array<(
        { __typename?: 'PlayerGroupMembership' }
        & Pick<PlayerGroupMembership, 'groupId'>
      )> }
    )> }
  )> }
);

export type DumpReduxStoreMutationVariables = Exact<{
  storeJson: Scalars['JSON'];
}>;


export type DumpReduxStoreMutation = (
  { __typename?: 'Mutation' }
  & { createReduxDump: Maybe<(
    { __typename?: 'CreateReduxDumpPayload' }
    & { reduxDump: Maybe<(
      { __typename?: 'ReduxDump' }
      & Pick<ReduxDump, 'id'>
    )> }
  )> }
);

export type GetAllGamesQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetAllGamesQuery = (
  { __typename?: 'Query' }
  & { games: Maybe<Array<(
    { __typename?: 'Game' }
    & UnpackedGame_GameFragment
  )>> }
);

export type GetAllGroupsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllGroupsQuery = (
  { __typename?: 'Query' }
  & { groups: Maybe<Array<(
    { __typename?: 'Group' }
    & Pick<Group, 'id' | 'name' | 'soloMode' | 'urlSlug' | 'allowSkippingAtBats' | 'allowSteals'>
  )>> }
);

export type GetAllPlayersQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllPlayersQuery = (
  { __typename?: 'Query' }
  & { players: Maybe<Array<(
    { __typename?: 'Player' }
    & Pick<Player, 'id' | 'firstName' | 'lastName'>
    & { groups: Array<(
      { __typename?: 'PlayerGroupMembership' }
      & Pick<PlayerGroupMembership, 'groupId'>
    )> }
  )>> }
);

export type GetGameQueryVariables = Exact<{
  id: Scalars['UUID'];
}>;


export type GetGameQuery = (
  { __typename?: 'Query' }
  & { game: Maybe<(
    { __typename?: 'Game' }
    & UnpackedGame_GameFragment
  )> }
);

export type GetSoloModeOpponentBatterIdQueryVariables = Exact<{ [key: string]: never; }>;


export type GetSoloModeOpponentBatterIdQuery = (
  { __typename?: 'Query' }
  & { player: Maybe<(
    { __typename?: 'Player' }
    & Pick<Player, 'id'>
  )> }
);

export type ClaimPlayerAccountMutationVariables = Exact<{
  playerId: Scalars['UUID'];
  email: Scalars['String'];
}>;


export type ClaimPlayerAccountMutation = (
  { __typename?: 'Mutation' }
  & { initiatePlayerClaim: Maybe<(
    { __typename?: 'InitiatePlayerClaimPayload' }
    & { success: InitiatePlayerClaimPayload['boolean'] }
  )> }
);

export type ResetPasswordMutationVariables = Exact<{
  playerId: Scalars['UUID'];
  resetToken: Scalars['String'];
  newPassword: Scalars['String'];
}>;


export type ResetPasswordMutation = (
  { __typename?: 'Mutation' }
  & { resetPassword: Maybe<(
    { __typename?: 'ResetPasswordPayload' }
    & { success: ResetPasswordPayload['boolean'] }
  )> }
);

export type VerifyEmailMutationVariables = Exact<{
  email: Scalars['String'];
  code: Scalars['String'];
}>;


export type VerifyEmailMutation = (
  { __typename?: 'Mutation' }
  & { verifyEmail: Maybe<(
    { __typename?: 'VerifyEmailPayload' }
    & { success: VerifyEmailPayload['boolean'] }
  )> }
);

export type GetAllAvailableSeasonsQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetAllAvailableSeasonsQuery = (
  { __typename?: 'Query' }
  & { group: Maybe<(
    { __typename?: 'Group' }
    & Pick<Group, 'allSeasons'>
  )> }
);

export type GetCareerStatLeadersQueryVariables = Exact<{
  groupId: Scalars['UUID'];
  qualifyingPAs: Scalars['Int'];
}>;


export type GetCareerStatLeadersQuery = (
  { __typename?: 'Query' }
  & { doublesLeaders: Maybe<Array<(
    { __typename?: 'CareerBattingStat' }
    & { value: CareerBattingStat['doubles'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, homerunsLeaders: Maybe<Array<(
    { __typename?: 'CareerBattingStat' }
    & { value: CareerBattingStat['homeruns'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, walksLeaders: Maybe<Array<(
    { __typename?: 'CareerBattingStat' }
    & { value: CareerBattingStat['walks'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, rbiLeaders: Maybe<Array<(
    { __typename?: 'CareerBattingStat' }
    & { value: CareerBattingStat['rbi'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, onBasePctLeaders: Maybe<Array<(
    { __typename?: 'CareerBattingStat' }
    & { value: CareerBattingStat['obp'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, opsLeaders: Maybe<Array<(
    { __typename?: 'CareerBattingStat' }
    & { value: CareerBattingStat['ops'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>> }
);

export type GetCareerStatsQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetCareerStatsQuery = (
  { __typename?: 'Query' }
  & { careerBattingStats: Maybe<Array<(
    { __typename?: 'CareerBattingStat' }
    & Pick<CareerBattingStat, 'seasons' | 'games' | 'plateAppearances' | 'atBats' | 'hits' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'stolenBases' | 'gidp' | 'runs' | 'rbi' | 'avg' | 'obp' | 'slg' | 'ops'>
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>> }
);

export type GetGameDetailsQueryVariables = Exact<{
  gameId: Scalars['UUID'];
}>;


export type GetGameDetailsQuery = (
  { __typename?: 'Query' }
  & { game: Maybe<(
    { __typename?: 'Game' }
    & Pick<Game, 'id' | 'soloMode' | 'gameLength' | 'name' | 'score' | 'timeStarted' | 'timeEnded'>
    & { lineScore: Maybe<Array<Maybe<(
      { __typename?: 'LineScoreCell' }
      & Pick<LineScoreCell, 'inning' | 'halfInning' | 'runs' | 'hits'>
    )>>>, teams: Array<(
      { __typename?: 'Team' }
      & Pick<Team, 'id' | 'name' | 'role' | 'winner' | 'soloModeOpponent'>
      & { finalLineup: Maybe<(
        { __typename?: 'Lineup' }
        & { lineupSpots: Array<(
          { __typename?: 'LineupSpot' }
          & Pick<LineupSpot, 'position'>
          & { player: Maybe<(
            { __typename?: 'Player' }
            & Pick<Player, 'id' | 'fullName'>
          )> }
        )> }
      )> }
    )>, boxScore: Array<(
      { __typename?: 'GameBattingStat' }
      & Pick<GameBattingStat, 'playerId' | 'teamId' | 'plateAppearances' | 'atBats' | 'hits' | 'runs' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'rbi'>
    )>, gameStates: Array<(
      { __typename?: 'GameState' }
      & Pick<GameState, 'id' | 'inning' | 'halfInning' | 'outs' | 'score'>
      & { playerByPlayerAtBat: Maybe<(
        { __typename?: 'Player' }
        & Pick<Player, 'id' | 'firstName' | 'lastName'>
      )>, lineups: Maybe<Array<Maybe<(
        { __typename?: 'Lineup' }
        & Pick<Lineup, 'id'>
        & { team: Maybe<(
          { __typename?: 'Team' }
          & Pick<Team, 'role'>
        )> }
      )>>>, baseRunners: Array<(
        { __typename?: 'BaseRunner' }
        & Pick<BaseRunner, 'base'>
        & { runner: Maybe<(
          { __typename?: 'Player' }
          & Pick<Player, 'id' | 'firstName' | 'lastName'>
        )> }
      )> }
    )>, gameEventRecords: Array<(
      { __typename?: 'GameEventRecord' }
      & Pick<GameEventRecord, 'eventIndex' | 'gameStateBeforeId' | 'gameStateAfterId'>
      & { gameEvent: Maybe<(
        { __typename?: 'GameEvent' }
        & { lineupChange: Maybe<(
          { __typename?: 'LineupChange' }
          & Pick<LineupChange, 'lineupBeforeId' | 'lineupAfterId'>
        )>, stolenBaseAttempt: Maybe<(
          { __typename?: 'StolenBaseAttempt' }
          & Pick<StolenBaseAttempt, 'success'>
          & { runner: Maybe<(
            { __typename?: 'Player' }
            & Pick<Player, 'id' | 'firstName' | 'lastName'>
          )> }
        )>, plateAppearance: Maybe<(
          { __typename?: 'PlateAppearance' }
          & Pick<PlateAppearance, 'type' | 'contact' | 'fieldedBy' | 'runsScoredOnSacFly'>
          & { outOnPlayRunners: Array<(
            { __typename?: 'OutOnPlayRunner' }
            & Pick<OutOnPlayRunner, 'runnerId'>
          )>, basepathMovements: Array<(
            { __typename?: 'BasepathMovement' }
            & Pick<BasepathMovement, 'runnerId' | 'endBase' | 'wasSafe'>
          )> }
        )> }
      )>, scoredRunners: Array<(
        { __typename?: 'ScoredRunner' }
        & Pick<ScoredRunner, 'battedIn'>
        & { runner: Maybe<(
          { __typename?: 'Player' }
          & Pick<Player, 'id' | 'firstName' | 'lastName'>
        )> }
      )>, gameStateBefore: Maybe<(
        { __typename?: 'GameState' }
        & Pick<GameState, 'inning' | 'halfInning'>
        & { playerByPlayerAtBat: Maybe<(
          { __typename?: 'Player' }
          & Pick<Player, 'id' | 'firstName' | 'lastName'>
        )> }
      )> }
    )> }
  )> }
);

export type GetGameSummariesQueryVariables = Exact<{
  groupId: Scalars['UUID'];
  season: Scalars['Int'];
}>;


export type GetGameSummariesQuery = (
  { __typename?: 'Query' }
  & { games: Maybe<Array<(
    { __typename?: 'Game' }
    & Pick<Game, 'id' | 'name' | 'timeStarted' | 'timeEnded' | 'score'>
  )>> }
);

export type GetGameSummaryQueryVariables = Exact<{
  gameId: Scalars['UUID'];
}>;


export type GetGameSummaryQuery = (
  { __typename?: 'Query' }
  & { game: Maybe<(
    { __typename?: 'Game' }
    & Pick<Game, 'id'>
    & { lineScore: Maybe<Array<Maybe<(
      { __typename?: 'LineScoreCell' }
      & Pick<LineScoreCell, 'inning' | 'halfInning' | 'hits' | 'runs'>
    )>>>, teams: Array<(
      { __typename?: 'Team' }
      & Pick<Team, 'name' | 'role' | 'winner' | 'soloModeOpponent'>
    )> }
  )> }
);

export type GetGameTitleQueryVariables = Exact<{
  gameId: Scalars['UUID'];
}>;


export type GetGameTitleQuery = (
  { __typename?: 'Query' }
  & { game: Maybe<(
    { __typename?: 'Game' }
    & Pick<Game, 'id' | 'name' | 'timeStarted'>
  )> }
);

export type GetLatestGameSummaryQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetLatestGameSummaryQuery = (
  { __typename?: 'Query' }
  & { games: Maybe<Array<(
    { __typename?: 'Game' }
    & Pick<Game, 'id' | 'name' | 'timeStarted' | 'timeEnded' | 'score' | 'gameLength'>
    & { teams: Array<(
      { __typename?: 'Team' }
      & Pick<Team, 'role' | 'name' | 'winner'>
    )> }
  )>> }
);

export type GetPlayerProfileQueryVariables = Exact<{
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
}>;


export type GetPlayerProfileQuery = (
  { __typename?: 'Query' }
  & { player: Maybe<(
    { __typename?: 'Player' }
    & Pick<Player, 'id' | 'fullName' | 'debut' | 'claimed'>
    & { groups: Array<(
      { __typename?: 'PlayerGroupMembership' }
      & Pick<PlayerGroupMembership, 'groupId'>
    )>, careerBattingStats: Array<(
      { __typename?: 'CareerBattingStat' }
      & Pick<CareerBattingStat, 'games' | 'plateAppearances' | 'atBats' | 'hits' | 'runs' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'rbi' | 'stolenBases'>
    )>, seasonBattingStats: Array<(
      { __typename?: 'SeasonBattingStat' }
      & Pick<SeasonBattingStat, 'season' | 'games' | 'plateAppearances' | 'atBats' | 'hits' | 'runs' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'rbi' | 'stolenBases'>
    )>, gameBattingStats: Array<(
      { __typename?: 'GameBattingStat' }
      & Pick<GameBattingStat, 'plateAppearances' | 'atBats' | 'hits' | 'runs' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'rbi' | 'stolenBases'>
      & { game: Maybe<(
        { __typename?: 'Game' }
        & Pick<Game, 'season' | 'groupId' | 'id' | 'name' | 'timeStarted' | 'timeEnded'>
      )> }
    )> }
  )> }
);

export type GetPreviewLeadersQueryVariables = Exact<{
  groupId: Scalars['UUID'];
  currentSeason: Scalars['Int'];
}>;


export type GetPreviewLeadersQuery = (
  { __typename?: 'Query' }
  & { doubles: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & { value: SeasonBattingStat['doubles'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, homeruns: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & { value: SeasonBattingStat['homeruns'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, walks: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & { value: SeasonBattingStat['walks'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, rbi: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & { value: SeasonBattingStat['rbi'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, onBasePct: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & { value: SeasonBattingStat['obp'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, ops: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & { value: SeasonBattingStat['ops'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>> }
);

export type GetPreviewStatsQueryVariables = Exact<{
  groupId: Scalars['UUID'];
  currentSeason: Scalars['Int'];
}>;


export type GetPreviewStatsQuery = (
  { __typename?: 'Query' }
  & { seasonBattingStats: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & Pick<SeasonBattingStat, 'games' | 'plateAppearances' | 'atBats' | 'hits' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'runs' | 'rbi' | 'avg' | 'obp' | 'slg' | 'ops' | 'stolenBases'>
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>> }
);

export type GetSingleSeasonStatLeadersQueryVariables = Exact<{
  groupId: Scalars['UUID'];
  qualifyingPAs: Scalars['Int'];
}>;


export type GetSingleSeasonStatLeadersQuery = (
  { __typename?: 'Query' }
  & { doublesLeaders: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & Pick<SeasonBattingStat, 'season'>
    & { value: SeasonBattingStat['doubles'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, homerunsLeaders: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & Pick<SeasonBattingStat, 'season'>
    & { value: SeasonBattingStat['homeruns'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, walksLeaders: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & Pick<SeasonBattingStat, 'season'>
    & { value: SeasonBattingStat['walks'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, rbiLeaders: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & Pick<SeasonBattingStat, 'season'>
    & { value: SeasonBattingStat['rbi'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, onBasePctLeaders: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & Pick<SeasonBattingStat, 'season'>
    & { value: SeasonBattingStat['obp'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, opsLeaders: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & Pick<SeasonBattingStat, 'season'>
    & { value: SeasonBattingStat['ops'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>> }
);

export type GetStatLeadersForSeasonQueryVariables = Exact<{
  groupId: Scalars['UUID'];
  season: Scalars['Int'];
}>;


export type GetStatLeadersForSeasonQuery = (
  { __typename?: 'Query' }
  & { doublesLeaders: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & { value: SeasonBattingStat['doubles'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, homerunsLeaders: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & { value: SeasonBattingStat['homeruns'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, walksLeaders: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & { value: SeasonBattingStat['walks'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, rbiLeaders: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & { value: SeasonBattingStat['rbi'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, onBasePctLeaders: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & { value: SeasonBattingStat['obp'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, opsLeaders: Maybe<Array<(
    { __typename?: 'SeasonBattingStat' }
    & { value: SeasonBattingStat['ops'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>> }
);

export type GetStatsForSeasonQueryVariables = Exact<{
  groupId: Scalars['UUID'];
  season: Scalars['Int'];
}>;


export type GetStatsForSeasonQuery = (
  { __typename?: 'Query' }
  & { group: Maybe<(
    { __typename?: 'Group' }
    & Pick<Group, 'gamesInSeason'>
    & { seasonBattingStats: Array<(
      { __typename?: 'SeasonBattingStat' }
      & Pick<SeasonBattingStat, 'games' | 'plateAppearances' | 'atBats' | 'hits' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'runs' | 'rbi' | 'avg' | 'obp' | 'slg' | 'ops' | 'stolenBases'>
      & { player: Maybe<(
        { __typename?: 'Player' }
        & Pick<Player, 'id' | 'fullName'>
      )> }
    )> }
  )> }
);

export type LoginMutationVariables = Exact<{
  email: Scalars['String'];
  password: Scalars['String'];
}>;


export type LoginMutation = (
  { __typename?: 'Mutation' }
  & { login: Maybe<(
    { __typename?: 'LoginPayload' }
    & Pick<LoginPayload, 'jwt'>
  )> }
);

export type GetCurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCurrentUserQuery = (
  { __typename?: 'Query' }
  & { user: Maybe<(
    { __typename?: 'Player' }
    & Pick<Player, 'id' | 'fullName'>
  )> }
);

export type GetPermissionsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPermissionsQuery = (
  { __typename?: 'Query' }
  & Pick<Query, 'currentUserPermissions'>
  & { currentUserGroupPermissions: Maybe<Array<Maybe<(
    { __typename?: 'UserGroupPermission' }
    & Pick<UserGroupPermission, 'groupId' | 'permission'>
  )>>> }
);

export const GameEventRecord_GameStateFragmentDoc = gql`
    fragment GameEventRecord_GameState on GameState {
  inning
  halfInning
  outs
  playerAtBat
  score
  lineups {
    id
    team {
      role
    }
  }
  baseRunners {
    runnerId
    base
  }
}
    `;
export const UnpackedGame_GameFragmentDoc = gql`
    fragment UnpackedGame_Game on Game {
  id
  gameLength
  name
  score
  timeStarted
  timeEnded
  gameStates(orderBy: GAME_STATE_INDEX_ASC) {
    id
    inning
    halfInning
    outs
    playerAtBat
    score
    lineups {
      id
      team {
        role
      }
    }
    baseRunners {
      runnerId
      base
    }
  }
  gameEventRecords(orderBy: EVENT_INDEX_ASC) {
    eventIndex
    gameEvent {
      lineupChange {
        lineupBeforeId
        lineupAfterId
      }
      stolenBaseAttempt {
        runnerId
        success
      }
      plateAppearance {
        batterId
        type
        contact
        fieldedBy
        outOnPlayRunners {
          runnerId
        }
        basepathMovements {
          runnerId
          endBase
          wasSafe
        }
        runsScoredOnSacFly
      }
      soloModeOpponentInning {
        runsScored
      }
      atBatSkip {
        batterId
      }
      earlyGameEnd {
        reason
      }
    }
    scoredRunners {
      runnerId
      battedIn
    }
    gameStateBeforeId
    gameStateAfterId
  }
  teams {
    name
    role
    lineups {
      id
      lineupSpots(orderBy: BATTING_ORDER_ASC) {
        playerId
        position
      }
    }
    winner
    soloModeOpponent
  }
}
    `;
export const AddPlayerToGroupDocument = gql`
    mutation AddPlayerToGroup($playerId: UUID!, $groupId: UUID!) {
  updatePlayer(
    input: {id: $playerId, patch: {playerGroupMemberships: {create: [{groupId: $groupId}]}}}
  ) {
    player {
      id
      firstName
      lastName
      groups: playerGroupMemberships {
        groupId
      }
    }
  }
}
    `;
export type AddPlayerToGroupMutationFn = Apollo.MutationFunction<AddPlayerToGroupMutation, AddPlayerToGroupMutationVariables>;

/**
 * __useAddPlayerToGroupMutation__
 *
 * To run a mutation, you first call `useAddPlayerToGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddPlayerToGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addPlayerToGroupMutation, { data, loading, error }] = useAddPlayerToGroupMutation({
 *   variables: {
 *      playerId: // value for 'playerId'
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useAddPlayerToGroupMutation(baseOptions?: Apollo.MutationHookOptions<AddPlayerToGroupMutation, AddPlayerToGroupMutationVariables>) {
        return Apollo.useMutation<AddPlayerToGroupMutation, AddPlayerToGroupMutationVariables>(AddPlayerToGroupDocument, baseOptions);
      }
export type AddPlayerToGroupMutationHookResult = ReturnType<typeof useAddPlayerToGroupMutation>;
export type AddPlayerToGroupMutationResult = Apollo.MutationResult<AddPlayerToGroupMutation>;
export type AddPlayerToGroupMutationOptions = Apollo.BaseMutationOptions<AddPlayerToGroupMutation, AddPlayerToGroupMutationVariables>;
export const CreateGameDocument = gql`
    mutation CreateGame($input: CreateGameInput!) {
  createGame(input: $input) {
    game {
      ...UnpackedGame_Game
    }
  }
}
    ${UnpackedGame_GameFragmentDoc}`;
export type CreateGameMutationFn = Apollo.MutationFunction<CreateGameMutation, CreateGameMutationVariables>;

/**
 * __useCreateGameMutation__
 *
 * To run a mutation, you first call `useCreateGameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGameMutation, { data, loading, error }] = useCreateGameMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateGameMutation(baseOptions?: Apollo.MutationHookOptions<CreateGameMutation, CreateGameMutationVariables>) {
        return Apollo.useMutation<CreateGameMutation, CreateGameMutationVariables>(CreateGameDocument, baseOptions);
      }
export type CreateGameMutationHookResult = ReturnType<typeof useCreateGameMutation>;
export type CreateGameMutationResult = Apollo.MutationResult<CreateGameMutation>;
export type CreateGameMutationOptions = Apollo.BaseMutationOptions<CreateGameMutation, CreateGameMutationVariables>;
export const CreatePlayerDocument = gql`
    mutation CreatePlayer($input: CreatePlayerInput!) {
  createPlayer(input: $input) {
    player {
      id
      firstName
      lastName
      groups: playerGroupMemberships {
        groupId
      }
    }
  }
}
    `;
export type CreatePlayerMutationFn = Apollo.MutationFunction<CreatePlayerMutation, CreatePlayerMutationVariables>;

/**
 * __useCreatePlayerMutation__
 *
 * To run a mutation, you first call `useCreatePlayerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlayerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlayerMutation, { data, loading, error }] = useCreatePlayerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePlayerMutation(baseOptions?: Apollo.MutationHookOptions<CreatePlayerMutation, CreatePlayerMutationVariables>) {
        return Apollo.useMutation<CreatePlayerMutation, CreatePlayerMutationVariables>(CreatePlayerDocument, baseOptions);
      }
export type CreatePlayerMutationHookResult = ReturnType<typeof useCreatePlayerMutation>;
export type CreatePlayerMutationResult = Apollo.MutationResult<CreatePlayerMutation>;
export type CreatePlayerMutationOptions = Apollo.BaseMutationOptions<CreatePlayerMutation, CreatePlayerMutationVariables>;
export const DumpReduxStoreDocument = gql`
    mutation DumpReduxStore($storeJson: JSON!) {
  createReduxDump(input: {reduxDump: {storeData: $storeJson}}) {
    reduxDump {
      id
    }
  }
}
    `;
export type DumpReduxStoreMutationFn = Apollo.MutationFunction<DumpReduxStoreMutation, DumpReduxStoreMutationVariables>;

/**
 * __useDumpReduxStoreMutation__
 *
 * To run a mutation, you first call `useDumpReduxStoreMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDumpReduxStoreMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [dumpReduxStoreMutation, { data, loading, error }] = useDumpReduxStoreMutation({
 *   variables: {
 *      storeJson: // value for 'storeJson'
 *   },
 * });
 */
export function useDumpReduxStoreMutation(baseOptions?: Apollo.MutationHookOptions<DumpReduxStoreMutation, DumpReduxStoreMutationVariables>) {
        return Apollo.useMutation<DumpReduxStoreMutation, DumpReduxStoreMutationVariables>(DumpReduxStoreDocument, baseOptions);
      }
export type DumpReduxStoreMutationHookResult = ReturnType<typeof useDumpReduxStoreMutation>;
export type DumpReduxStoreMutationResult = Apollo.MutationResult<DumpReduxStoreMutation>;
export type DumpReduxStoreMutationOptions = Apollo.BaseMutationOptions<DumpReduxStoreMutation, DumpReduxStoreMutationVariables>;
export const GetAllGamesDocument = gql`
    query GetAllGames($groupId: UUID!) {
  games(condition: {groupId: $groupId}) {
    ...UnpackedGame_Game
  }
}
    ${UnpackedGame_GameFragmentDoc}`;

/**
 * __useGetAllGamesQuery__
 *
 * To run a query within a React component, call `useGetAllGamesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllGamesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllGamesQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetAllGamesQuery(baseOptions: Apollo.QueryHookOptions<GetAllGamesQuery, GetAllGamesQueryVariables>) {
        return Apollo.useQuery<GetAllGamesQuery, GetAllGamesQueryVariables>(GetAllGamesDocument, baseOptions);
      }
export function useGetAllGamesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllGamesQuery, GetAllGamesQueryVariables>) {
          return Apollo.useLazyQuery<GetAllGamesQuery, GetAllGamesQueryVariables>(GetAllGamesDocument, baseOptions);
        }
export type GetAllGamesQueryHookResult = ReturnType<typeof useGetAllGamesQuery>;
export type GetAllGamesLazyQueryHookResult = ReturnType<typeof useGetAllGamesLazyQuery>;
export type GetAllGamesQueryResult = Apollo.QueryResult<GetAllGamesQuery, GetAllGamesQueryVariables>;
export const GetAllGroupsDocument = gql`
    query GetAllGroups {
  groups {
    id
    name
    soloMode
    urlSlug
    allowSkippingAtBats
    allowSteals
  }
}
    `;

/**
 * __useGetAllGroupsQuery__
 *
 * To run a query within a React component, call `useGetAllGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllGroupsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllGroupsQuery(baseOptions?: Apollo.QueryHookOptions<GetAllGroupsQuery, GetAllGroupsQueryVariables>) {
        return Apollo.useQuery<GetAllGroupsQuery, GetAllGroupsQueryVariables>(GetAllGroupsDocument, baseOptions);
      }
export function useGetAllGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllGroupsQuery, GetAllGroupsQueryVariables>) {
          return Apollo.useLazyQuery<GetAllGroupsQuery, GetAllGroupsQueryVariables>(GetAllGroupsDocument, baseOptions);
        }
export type GetAllGroupsQueryHookResult = ReturnType<typeof useGetAllGroupsQuery>;
export type GetAllGroupsLazyQueryHookResult = ReturnType<typeof useGetAllGroupsLazyQuery>;
export type GetAllGroupsQueryResult = Apollo.QueryResult<GetAllGroupsQuery, GetAllGroupsQueryVariables>;
export const GetAllPlayersDocument = gql`
    query GetAllPlayers {
  players {
    id
    firstName
    lastName
    groups: playerGroupMemberships {
      groupId
    }
  }
}
    `;

/**
 * __useGetAllPlayersQuery__
 *
 * To run a query within a React component, call `useGetAllPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllPlayersQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllPlayersQuery(baseOptions?: Apollo.QueryHookOptions<GetAllPlayersQuery, GetAllPlayersQueryVariables>) {
        return Apollo.useQuery<GetAllPlayersQuery, GetAllPlayersQueryVariables>(GetAllPlayersDocument, baseOptions);
      }
export function useGetAllPlayersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllPlayersQuery, GetAllPlayersQueryVariables>) {
          return Apollo.useLazyQuery<GetAllPlayersQuery, GetAllPlayersQueryVariables>(GetAllPlayersDocument, baseOptions);
        }
export type GetAllPlayersQueryHookResult = ReturnType<typeof useGetAllPlayersQuery>;
export type GetAllPlayersLazyQueryHookResult = ReturnType<typeof useGetAllPlayersLazyQuery>;
export type GetAllPlayersQueryResult = Apollo.QueryResult<GetAllPlayersQuery, GetAllPlayersQueryVariables>;
export const GetGameDocument = gql`
    query GetGame($id: UUID!) {
  game(id: $id) {
    ...UnpackedGame_Game
  }
}
    ${UnpackedGame_GameFragmentDoc}`;

/**
 * __useGetGameQuery__
 *
 * To run a query within a React component, call `useGetGameQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetGameQuery(baseOptions: Apollo.QueryHookOptions<GetGameQuery, GetGameQueryVariables>) {
        return Apollo.useQuery<GetGameQuery, GetGameQueryVariables>(GetGameDocument, baseOptions);
      }
export function useGetGameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGameQuery, GetGameQueryVariables>) {
          return Apollo.useLazyQuery<GetGameQuery, GetGameQueryVariables>(GetGameDocument, baseOptions);
        }
export type GetGameQueryHookResult = ReturnType<typeof useGetGameQuery>;
export type GetGameLazyQueryHookResult = ReturnType<typeof useGetGameLazyQuery>;
export type GetGameQueryResult = Apollo.QueryResult<GetGameQuery, GetGameQueryVariables>;
export const GetSoloModeOpponentBatterIdDocument = gql`
    query GetSoloModeOpponentBatterId {
  player: playerByFirstNameAndLastName(firstName: "Opponent", lastName: "Batter") {
    id
  }
}
    `;

/**
 * __useGetSoloModeOpponentBatterIdQuery__
 *
 * To run a query within a React component, call `useGetSoloModeOpponentBatterIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSoloModeOpponentBatterIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSoloModeOpponentBatterIdQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetSoloModeOpponentBatterIdQuery(baseOptions?: Apollo.QueryHookOptions<GetSoloModeOpponentBatterIdQuery, GetSoloModeOpponentBatterIdQueryVariables>) {
        return Apollo.useQuery<GetSoloModeOpponentBatterIdQuery, GetSoloModeOpponentBatterIdQueryVariables>(GetSoloModeOpponentBatterIdDocument, baseOptions);
      }
export function useGetSoloModeOpponentBatterIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSoloModeOpponentBatterIdQuery, GetSoloModeOpponentBatterIdQueryVariables>) {
          return Apollo.useLazyQuery<GetSoloModeOpponentBatterIdQuery, GetSoloModeOpponentBatterIdQueryVariables>(GetSoloModeOpponentBatterIdDocument, baseOptions);
        }
export type GetSoloModeOpponentBatterIdQueryHookResult = ReturnType<typeof useGetSoloModeOpponentBatterIdQuery>;
export type GetSoloModeOpponentBatterIdLazyQueryHookResult = ReturnType<typeof useGetSoloModeOpponentBatterIdLazyQuery>;
export type GetSoloModeOpponentBatterIdQueryResult = Apollo.QueryResult<GetSoloModeOpponentBatterIdQuery, GetSoloModeOpponentBatterIdQueryVariables>;
export const ClaimPlayerAccountDocument = gql`
    mutation ClaimPlayerAccount($playerId: UUID!, $email: String!) {
  initiatePlayerClaim(input: {playerId: $playerId, email: $email}) {
    success: boolean
  }
}
    `;
export type ClaimPlayerAccountMutationFn = Apollo.MutationFunction<ClaimPlayerAccountMutation, ClaimPlayerAccountMutationVariables>;

/**
 * __useClaimPlayerAccountMutation__
 *
 * To run a mutation, you first call `useClaimPlayerAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useClaimPlayerAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [claimPlayerAccountMutation, { data, loading, error }] = useClaimPlayerAccountMutation({
 *   variables: {
 *      playerId: // value for 'playerId'
 *      email: // value for 'email'
 *   },
 * });
 */
export function useClaimPlayerAccountMutation(baseOptions?: Apollo.MutationHookOptions<ClaimPlayerAccountMutation, ClaimPlayerAccountMutationVariables>) {
        return Apollo.useMutation<ClaimPlayerAccountMutation, ClaimPlayerAccountMutationVariables>(ClaimPlayerAccountDocument, baseOptions);
      }
export type ClaimPlayerAccountMutationHookResult = ReturnType<typeof useClaimPlayerAccountMutation>;
export type ClaimPlayerAccountMutationResult = Apollo.MutationResult<ClaimPlayerAccountMutation>;
export type ClaimPlayerAccountMutationOptions = Apollo.BaseMutationOptions<ClaimPlayerAccountMutation, ClaimPlayerAccountMutationVariables>;
export const ResetPasswordDocument = gql`
    mutation ResetPassword($playerId: UUID!, $resetToken: String!, $newPassword: String!) {
  resetPassword(
    input: {playerId: $playerId, resetToken: $resetToken, newPassword: $newPassword}
  ) {
    success: boolean
  }
}
    `;
export type ResetPasswordMutationFn = Apollo.MutationFunction<ResetPasswordMutation, ResetPasswordMutationVariables>;

/**
 * __useResetPasswordMutation__
 *
 * To run a mutation, you first call `useResetPasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResetPasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resetPasswordMutation, { data, loading, error }] = useResetPasswordMutation({
 *   variables: {
 *      playerId: // value for 'playerId'
 *      resetToken: // value for 'resetToken'
 *      newPassword: // value for 'newPassword'
 *   },
 * });
 */
export function useResetPasswordMutation(baseOptions?: Apollo.MutationHookOptions<ResetPasswordMutation, ResetPasswordMutationVariables>) {
        return Apollo.useMutation<ResetPasswordMutation, ResetPasswordMutationVariables>(ResetPasswordDocument, baseOptions);
      }
export type ResetPasswordMutationHookResult = ReturnType<typeof useResetPasswordMutation>;
export type ResetPasswordMutationResult = Apollo.MutationResult<ResetPasswordMutation>;
export type ResetPasswordMutationOptions = Apollo.BaseMutationOptions<ResetPasswordMutation, ResetPasswordMutationVariables>;
export const VerifyEmailDocument = gql`
    mutation VerifyEmail($email: String!, $code: String!) {
  verifyEmail(input: {email: $email, code: $code}) {
    success: boolean
  }
}
    `;
export type VerifyEmailMutationFn = Apollo.MutationFunction<VerifyEmailMutation, VerifyEmailMutationVariables>;

/**
 * __useVerifyEmailMutation__
 *
 * To run a mutation, you first call `useVerifyEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVerifyEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [verifyEmailMutation, { data, loading, error }] = useVerifyEmailMutation({
 *   variables: {
 *      email: // value for 'email'
 *      code: // value for 'code'
 *   },
 * });
 */
export function useVerifyEmailMutation(baseOptions?: Apollo.MutationHookOptions<VerifyEmailMutation, VerifyEmailMutationVariables>) {
        return Apollo.useMutation<VerifyEmailMutation, VerifyEmailMutationVariables>(VerifyEmailDocument, baseOptions);
      }
export type VerifyEmailMutationHookResult = ReturnType<typeof useVerifyEmailMutation>;
export type VerifyEmailMutationResult = Apollo.MutationResult<VerifyEmailMutation>;
export type VerifyEmailMutationOptions = Apollo.BaseMutationOptions<VerifyEmailMutation, VerifyEmailMutationVariables>;
export const GetAllAvailableSeasonsDocument = gql`
    query GetAllAvailableSeasons($groupId: UUID!) {
  group(id: $groupId) {
    allSeasons
  }
}
    `;

/**
 * __useGetAllAvailableSeasonsQuery__
 *
 * To run a query within a React component, call `useGetAllAvailableSeasonsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllAvailableSeasonsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllAvailableSeasonsQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetAllAvailableSeasonsQuery(baseOptions: Apollo.QueryHookOptions<GetAllAvailableSeasonsQuery, GetAllAvailableSeasonsQueryVariables>) {
        return Apollo.useQuery<GetAllAvailableSeasonsQuery, GetAllAvailableSeasonsQueryVariables>(GetAllAvailableSeasonsDocument, baseOptions);
      }
export function useGetAllAvailableSeasonsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllAvailableSeasonsQuery, GetAllAvailableSeasonsQueryVariables>) {
          return Apollo.useLazyQuery<GetAllAvailableSeasonsQuery, GetAllAvailableSeasonsQueryVariables>(GetAllAvailableSeasonsDocument, baseOptions);
        }
export type GetAllAvailableSeasonsQueryHookResult = ReturnType<typeof useGetAllAvailableSeasonsQuery>;
export type GetAllAvailableSeasonsLazyQueryHookResult = ReturnType<typeof useGetAllAvailableSeasonsLazyQuery>;
export type GetAllAvailableSeasonsQueryResult = Apollo.QueryResult<GetAllAvailableSeasonsQuery, GetAllAvailableSeasonsQueryVariables>;
export const GetCareerStatLeadersDocument = gql`
    query GetCareerStatLeaders($groupId: UUID!, $qualifyingPAs: Int!) {
  doublesLeaders: careerBattingStats(
    condition: {groupId: $groupId}
    orderBy: DOUBLES_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    value: doubles
  }
  homerunsLeaders: careerBattingStats(
    condition: {groupId: $groupId}
    orderBy: HOMERUNS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    value: homeruns
  }
  walksLeaders: careerBattingStats(
    condition: {groupId: $groupId}
    orderBy: WALKS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    value: walks
  }
  rbiLeaders: careerBattingStats(
    condition: {groupId: $groupId}
    orderBy: RBI_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    value: rbi
  }
  onBasePctLeaders: careerBattingStats(
    condition: {groupId: $groupId}
    filter: {plateAppearances: {greaterThanOrEqualTo: $qualifyingPAs}}
    orderBy: OBP_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    value: obp
  }
  opsLeaders: careerBattingStats(
    condition: {groupId: $groupId}
    filter: {plateAppearances: {greaterThanOrEqualTo: $qualifyingPAs}}
    orderBy: OPS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    value: ops
  }
}
    `;

/**
 * __useGetCareerStatLeadersQuery__
 *
 * To run a query within a React component, call `useGetCareerStatLeadersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCareerStatLeadersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCareerStatLeadersQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      qualifyingPAs: // value for 'qualifyingPAs'
 *   },
 * });
 */
export function useGetCareerStatLeadersQuery(baseOptions: Apollo.QueryHookOptions<GetCareerStatLeadersQuery, GetCareerStatLeadersQueryVariables>) {
        return Apollo.useQuery<GetCareerStatLeadersQuery, GetCareerStatLeadersQueryVariables>(GetCareerStatLeadersDocument, baseOptions);
      }
export function useGetCareerStatLeadersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCareerStatLeadersQuery, GetCareerStatLeadersQueryVariables>) {
          return Apollo.useLazyQuery<GetCareerStatLeadersQuery, GetCareerStatLeadersQueryVariables>(GetCareerStatLeadersDocument, baseOptions);
        }
export type GetCareerStatLeadersQueryHookResult = ReturnType<typeof useGetCareerStatLeadersQuery>;
export type GetCareerStatLeadersLazyQueryHookResult = ReturnType<typeof useGetCareerStatLeadersLazyQuery>;
export type GetCareerStatLeadersQueryResult = Apollo.QueryResult<GetCareerStatLeadersQuery, GetCareerStatLeadersQueryVariables>;
export const GetCareerStatsDocument = gql`
    query GetCareerStats($groupId: UUID!) {
  careerBattingStats(condition: {groupId: $groupId}, orderBy: GAMES_DESC) {
    player {
      id
      fullName
    }
    seasons
    games
    plateAppearances
    atBats
    hits
    doubles
    triples
    homeruns
    walks
    strikeouts
    sacFlies
    stolenBases
    gidp
    runs
    rbi
    avg
    obp
    slg
    ops
  }
}
    `;

/**
 * __useGetCareerStatsQuery__
 *
 * To run a query within a React component, call `useGetCareerStatsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCareerStatsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCareerStatsQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetCareerStatsQuery(baseOptions: Apollo.QueryHookOptions<GetCareerStatsQuery, GetCareerStatsQueryVariables>) {
        return Apollo.useQuery<GetCareerStatsQuery, GetCareerStatsQueryVariables>(GetCareerStatsDocument, baseOptions);
      }
export function useGetCareerStatsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCareerStatsQuery, GetCareerStatsQueryVariables>) {
          return Apollo.useLazyQuery<GetCareerStatsQuery, GetCareerStatsQueryVariables>(GetCareerStatsDocument, baseOptions);
        }
export type GetCareerStatsQueryHookResult = ReturnType<typeof useGetCareerStatsQuery>;
export type GetCareerStatsLazyQueryHookResult = ReturnType<typeof useGetCareerStatsLazyQuery>;
export type GetCareerStatsQueryResult = Apollo.QueryResult<GetCareerStatsQuery, GetCareerStatsQueryVariables>;
export const GetGameDetailsDocument = gql`
    query GetGameDetails($gameId: UUID!) {
  game(id: $gameId) {
    id
    soloMode
    gameLength
    name
    score
    timeStarted
    timeEnded
    lineScore {
      inning
      halfInning
      runs
      hits
    }
    teams {
      id
      name
      role
      winner
      soloModeOpponent
      finalLineup {
        lineupSpots(orderBy: BATTING_ORDER_ASC) {
          player {
            id
            fullName
          }
          position
        }
      }
    }
    boxScore: gameBattingStats {
      playerId
      teamId
      plateAppearances
      atBats
      hits
      runs
      doubles
      triples
      homeruns
      walks
      strikeouts
      sacFlies
      gidp
      rbi
    }
    gameStates(orderBy: GAME_STATE_INDEX_ASC) {
      id
      inning
      halfInning
      outs
      playerByPlayerAtBat {
        id
        firstName
        lastName
      }
      score
      lineups {
        id
        team {
          role
        }
      }
      baseRunners {
        runner {
          id
          firstName
          lastName
        }
        base
      }
    }
    gameEventRecords(orderBy: EVENT_INDEX_ASC) {
      eventIndex
      gameEvent {
        lineupChange {
          lineupBeforeId
          lineupAfterId
        }
        stolenBaseAttempt {
          runner {
            id
            firstName
            lastName
          }
          success
        }
        plateAppearance {
          type
          contact
          fieldedBy
          outOnPlayRunners {
            runnerId
          }
          basepathMovements {
            runnerId
            endBase
            wasSafe
          }
          runsScoredOnSacFly
        }
      }
      scoredRunners {
        runner {
          id
          firstName
          lastName
        }
        battedIn
      }
      gameStateBeforeId
      gameStateBefore {
        inning
        halfInning
        playerByPlayerAtBat {
          id
          firstName
          lastName
        }
      }
      gameStateAfterId
    }
  }
}
    `;

/**
 * __useGetGameDetailsQuery__
 *
 * To run a query within a React component, call `useGetGameDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameDetailsQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useGetGameDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetGameDetailsQuery, GetGameDetailsQueryVariables>) {
        return Apollo.useQuery<GetGameDetailsQuery, GetGameDetailsQueryVariables>(GetGameDetailsDocument, baseOptions);
      }
export function useGetGameDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGameDetailsQuery, GetGameDetailsQueryVariables>) {
          return Apollo.useLazyQuery<GetGameDetailsQuery, GetGameDetailsQueryVariables>(GetGameDetailsDocument, baseOptions);
        }
export type GetGameDetailsQueryHookResult = ReturnType<typeof useGetGameDetailsQuery>;
export type GetGameDetailsLazyQueryHookResult = ReturnType<typeof useGetGameDetailsLazyQuery>;
export type GetGameDetailsQueryResult = Apollo.QueryResult<GetGameDetailsQuery, GetGameDetailsQueryVariables>;
export const GetGameSummariesDocument = gql`
    query GetGameSummaries($groupId: UUID!, $season: Int!) {
  games(condition: {groupId: $groupId}, filter: {season: {equalTo: $season}}) {
    id
    name
    timeStarted
    timeEnded
    score
  }
}
    `;

/**
 * __useGetGameSummariesQuery__
 *
 * To run a query within a React component, call `useGetGameSummariesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameSummariesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameSummariesQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      season: // value for 'season'
 *   },
 * });
 */
export function useGetGameSummariesQuery(baseOptions: Apollo.QueryHookOptions<GetGameSummariesQuery, GetGameSummariesQueryVariables>) {
        return Apollo.useQuery<GetGameSummariesQuery, GetGameSummariesQueryVariables>(GetGameSummariesDocument, baseOptions);
      }
export function useGetGameSummariesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGameSummariesQuery, GetGameSummariesQueryVariables>) {
          return Apollo.useLazyQuery<GetGameSummariesQuery, GetGameSummariesQueryVariables>(GetGameSummariesDocument, baseOptions);
        }
export type GetGameSummariesQueryHookResult = ReturnType<typeof useGetGameSummariesQuery>;
export type GetGameSummariesLazyQueryHookResult = ReturnType<typeof useGetGameSummariesLazyQuery>;
export type GetGameSummariesQueryResult = Apollo.QueryResult<GetGameSummariesQuery, GetGameSummariesQueryVariables>;
export const GetGameSummaryDocument = gql`
    query GetGameSummary($gameId: UUID!) {
  game(id: $gameId) {
    id
    lineScore {
      inning
      halfInning
      hits
      runs
    }
    teams {
      name
      role
      winner
      soloModeOpponent
    }
  }
}
    `;

/**
 * __useGetGameSummaryQuery__
 *
 * To run a query within a React component, call `useGetGameSummaryQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameSummaryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameSummaryQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useGetGameSummaryQuery(baseOptions: Apollo.QueryHookOptions<GetGameSummaryQuery, GetGameSummaryQueryVariables>) {
        return Apollo.useQuery<GetGameSummaryQuery, GetGameSummaryQueryVariables>(GetGameSummaryDocument, baseOptions);
      }
export function useGetGameSummaryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGameSummaryQuery, GetGameSummaryQueryVariables>) {
          return Apollo.useLazyQuery<GetGameSummaryQuery, GetGameSummaryQueryVariables>(GetGameSummaryDocument, baseOptions);
        }
export type GetGameSummaryQueryHookResult = ReturnType<typeof useGetGameSummaryQuery>;
export type GetGameSummaryLazyQueryHookResult = ReturnType<typeof useGetGameSummaryLazyQuery>;
export type GetGameSummaryQueryResult = Apollo.QueryResult<GetGameSummaryQuery, GetGameSummaryQueryVariables>;
export const GetGameTitleDocument = gql`
    query GetGameTitle($gameId: UUID!) {
  game(id: $gameId) {
    id
    name
    timeStarted
  }
}
    `;

/**
 * __useGetGameTitleQuery__
 *
 * To run a query within a React component, call `useGetGameTitleQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameTitleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameTitleQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useGetGameTitleQuery(baseOptions: Apollo.QueryHookOptions<GetGameTitleQuery, GetGameTitleQueryVariables>) {
        return Apollo.useQuery<GetGameTitleQuery, GetGameTitleQueryVariables>(GetGameTitleDocument, baseOptions);
      }
export function useGetGameTitleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGameTitleQuery, GetGameTitleQueryVariables>) {
          return Apollo.useLazyQuery<GetGameTitleQuery, GetGameTitleQueryVariables>(GetGameTitleDocument, baseOptions);
        }
export type GetGameTitleQueryHookResult = ReturnType<typeof useGetGameTitleQuery>;
export type GetGameTitleLazyQueryHookResult = ReturnType<typeof useGetGameTitleLazyQuery>;
export type GetGameTitleQueryResult = Apollo.QueryResult<GetGameTitleQuery, GetGameTitleQueryVariables>;
export const GetLatestGameSummaryDocument = gql`
    query GetLatestGameSummary($groupId: UUID!) {
  games(orderBy: TIME_STARTED_DESC, first: 1, condition: {groupId: $groupId}) {
    id
    name
    timeStarted
    timeEnded
    score
    gameLength
    teams {
      role
      name
      winner
    }
  }
}
    `;

/**
 * __useGetLatestGameSummaryQuery__
 *
 * To run a query within a React component, call `useGetLatestGameSummaryQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLatestGameSummaryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLatestGameSummaryQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetLatestGameSummaryQuery(baseOptions: Apollo.QueryHookOptions<GetLatestGameSummaryQuery, GetLatestGameSummaryQueryVariables>) {
        return Apollo.useQuery<GetLatestGameSummaryQuery, GetLatestGameSummaryQueryVariables>(GetLatestGameSummaryDocument, baseOptions);
      }
export function useGetLatestGameSummaryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLatestGameSummaryQuery, GetLatestGameSummaryQueryVariables>) {
          return Apollo.useLazyQuery<GetLatestGameSummaryQuery, GetLatestGameSummaryQueryVariables>(GetLatestGameSummaryDocument, baseOptions);
        }
export type GetLatestGameSummaryQueryHookResult = ReturnType<typeof useGetLatestGameSummaryQuery>;
export type GetLatestGameSummaryLazyQueryHookResult = ReturnType<typeof useGetLatestGameSummaryLazyQuery>;
export type GetLatestGameSummaryQueryResult = Apollo.QueryResult<GetLatestGameSummaryQuery, GetLatestGameSummaryQueryVariables>;
export const GetPlayerProfileDocument = gql`
    query GetPlayerProfile($playerId: UUID!, $groupId: UUID!) {
  player(id: $playerId) {
    id
    fullName
    debut(groupId: $groupId)
    claimed
    groups: playerGroupMemberships {
      groupId
    }
    careerBattingStats(condition: {groupId: $groupId}) {
      games
      plateAppearances
      atBats
      hits
      runs
      doubles
      triples
      homeruns
      walks
      strikeouts
      sacFlies
      gidp
      rbi
      stolenBases
    }
    seasonBattingStats(orderBy: SEASON_DESC, condition: {groupId: $groupId}) {
      season
      games
      plateAppearances
      atBats
      hits
      runs
      doubles
      triples
      homeruns
      walks
      strikeouts
      sacFlies
      gidp
      rbi
      stolenBases
    }
    gameBattingStats {
      game {
        season
        groupId
        id
        name
        timeStarted
        timeEnded
      }
      plateAppearances
      atBats
      hits
      runs
      doubles
      triples
      homeruns
      walks
      strikeouts
      sacFlies
      gidp
      rbi
      stolenBases
    }
  }
}
    `;

/**
 * __useGetPlayerProfileQuery__
 *
 * To run a query within a React component, call `useGetPlayerProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlayerProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlayerProfileQuery({
 *   variables: {
 *      playerId: // value for 'playerId'
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetPlayerProfileQuery(baseOptions: Apollo.QueryHookOptions<GetPlayerProfileQuery, GetPlayerProfileQueryVariables>) {
        return Apollo.useQuery<GetPlayerProfileQuery, GetPlayerProfileQueryVariables>(GetPlayerProfileDocument, baseOptions);
      }
export function useGetPlayerProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlayerProfileQuery, GetPlayerProfileQueryVariables>) {
          return Apollo.useLazyQuery<GetPlayerProfileQuery, GetPlayerProfileQueryVariables>(GetPlayerProfileDocument, baseOptions);
        }
export type GetPlayerProfileQueryHookResult = ReturnType<typeof useGetPlayerProfileQuery>;
export type GetPlayerProfileLazyQueryHookResult = ReturnType<typeof useGetPlayerProfileLazyQuery>;
export type GetPlayerProfileQueryResult = Apollo.QueryResult<GetPlayerProfileQuery, GetPlayerProfileQueryVariables>;
export const GetPreviewLeadersDocument = gql`
    query GetPreviewLeaders($groupId: UUID!, $currentSeason: Int!) {
  doubles: seasonBattingStats(
    condition: {groupId: $groupId, season: $currentSeason}
    orderBy: DOUBLES_DESC
    first: 1
  ) {
    player {
      id
      fullName
    }
    value: doubles
  }
  homeruns: seasonBattingStats(
    condition: {groupId: $groupId, season: $currentSeason}
    orderBy: HOMERUNS_DESC
    first: 1
  ) {
    player {
      id
      fullName
    }
    value: homeruns
  }
  walks: seasonBattingStats(
    condition: {groupId: $groupId, season: $currentSeason}
    orderBy: WALKS_DESC
    first: 1
  ) {
    player {
      id
      fullName
    }
    value: walks
  }
  rbi: seasonBattingStats(
    condition: {groupId: $groupId, season: $currentSeason}
    orderBy: RBI_DESC
    first: 1
  ) {
    player {
      id
      fullName
    }
    value: rbi
  }
  onBasePct: seasonBattingStats(
    condition: {groupId: $groupId, season: $currentSeason}
    filter: {qualified: {equalTo: true}}
    orderBy: OBP_DESC
    first: 1
  ) {
    player {
      id
      fullName
    }
    value: obp
  }
  ops: seasonBattingStats(
    condition: {groupId: $groupId, season: $currentSeason}
    filter: {qualified: {equalTo: true}}
    orderBy: OPS_DESC
    first: 1
  ) {
    player {
      id
      fullName
    }
    value: ops
  }
}
    `;

/**
 * __useGetPreviewLeadersQuery__
 *
 * To run a query within a React component, call `useGetPreviewLeadersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPreviewLeadersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPreviewLeadersQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      currentSeason: // value for 'currentSeason'
 *   },
 * });
 */
export function useGetPreviewLeadersQuery(baseOptions: Apollo.QueryHookOptions<GetPreviewLeadersQuery, GetPreviewLeadersQueryVariables>) {
        return Apollo.useQuery<GetPreviewLeadersQuery, GetPreviewLeadersQueryVariables>(GetPreviewLeadersDocument, baseOptions);
      }
export function useGetPreviewLeadersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPreviewLeadersQuery, GetPreviewLeadersQueryVariables>) {
          return Apollo.useLazyQuery<GetPreviewLeadersQuery, GetPreviewLeadersQueryVariables>(GetPreviewLeadersDocument, baseOptions);
        }
export type GetPreviewLeadersQueryHookResult = ReturnType<typeof useGetPreviewLeadersQuery>;
export type GetPreviewLeadersLazyQueryHookResult = ReturnType<typeof useGetPreviewLeadersLazyQuery>;
export type GetPreviewLeadersQueryResult = Apollo.QueryResult<GetPreviewLeadersQuery, GetPreviewLeadersQueryVariables>;
export const GetPreviewStatsDocument = gql`
    query GetPreviewStats($groupId: UUID!, $currentSeason: Int!) {
  seasonBattingStats(
    condition: {groupId: $groupId, season: $currentSeason}
    orderBy: GAMES_DESC
    first: 25
  ) {
    player {
      id
      fullName
    }
    games
    plateAppearances
    atBats
    hits
    doubles
    triples
    homeruns
    walks
    strikeouts
    sacFlies
    gidp
    runs
    rbi
    avg
    obp
    slg
    ops
    stolenBases
  }
}
    `;

/**
 * __useGetPreviewStatsQuery__
 *
 * To run a query within a React component, call `useGetPreviewStatsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPreviewStatsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPreviewStatsQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      currentSeason: // value for 'currentSeason'
 *   },
 * });
 */
export function useGetPreviewStatsQuery(baseOptions: Apollo.QueryHookOptions<GetPreviewStatsQuery, GetPreviewStatsQueryVariables>) {
        return Apollo.useQuery<GetPreviewStatsQuery, GetPreviewStatsQueryVariables>(GetPreviewStatsDocument, baseOptions);
      }
export function useGetPreviewStatsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPreviewStatsQuery, GetPreviewStatsQueryVariables>) {
          return Apollo.useLazyQuery<GetPreviewStatsQuery, GetPreviewStatsQueryVariables>(GetPreviewStatsDocument, baseOptions);
        }
export type GetPreviewStatsQueryHookResult = ReturnType<typeof useGetPreviewStatsQuery>;
export type GetPreviewStatsLazyQueryHookResult = ReturnType<typeof useGetPreviewStatsLazyQuery>;
export type GetPreviewStatsQueryResult = Apollo.QueryResult<GetPreviewStatsQuery, GetPreviewStatsQueryVariables>;
export const GetSingleSeasonStatLeadersDocument = gql`
    query GetSingleSeasonStatLeaders($groupId: UUID!, $qualifyingPAs: Int!) {
  doublesLeaders: seasonBattingStats(
    condition: {groupId: $groupId}
    orderBy: DOUBLES_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    season
    value: doubles
  }
  homerunsLeaders: seasonBattingStats(
    condition: {groupId: $groupId}
    orderBy: HOMERUNS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    season
    value: homeruns
  }
  walksLeaders: seasonBattingStats(
    condition: {groupId: $groupId}
    orderBy: WALKS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    season
    value: walks
  }
  rbiLeaders: seasonBattingStats(
    condition: {groupId: $groupId}
    orderBy: RBI_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    season
    value: rbi
  }
  onBasePctLeaders: seasonBattingStats(
    condition: {groupId: $groupId}
    filter: {plateAppearances: {greaterThanOrEqualTo: $qualifyingPAs}}
    orderBy: OBP_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    season
    value: obp
  }
  opsLeaders: seasonBattingStats(
    condition: {groupId: $groupId}
    filter: {plateAppearances: {greaterThanOrEqualTo: $qualifyingPAs}}
    orderBy: OPS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    season
    value: ops
  }
}
    `;

/**
 * __useGetSingleSeasonStatLeadersQuery__
 *
 * To run a query within a React component, call `useGetSingleSeasonStatLeadersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleSeasonStatLeadersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleSeasonStatLeadersQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      qualifyingPAs: // value for 'qualifyingPAs'
 *   },
 * });
 */
export function useGetSingleSeasonStatLeadersQuery(baseOptions: Apollo.QueryHookOptions<GetSingleSeasonStatLeadersQuery, GetSingleSeasonStatLeadersQueryVariables>) {
        return Apollo.useQuery<GetSingleSeasonStatLeadersQuery, GetSingleSeasonStatLeadersQueryVariables>(GetSingleSeasonStatLeadersDocument, baseOptions);
      }
export function useGetSingleSeasonStatLeadersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleSeasonStatLeadersQuery, GetSingleSeasonStatLeadersQueryVariables>) {
          return Apollo.useLazyQuery<GetSingleSeasonStatLeadersQuery, GetSingleSeasonStatLeadersQueryVariables>(GetSingleSeasonStatLeadersDocument, baseOptions);
        }
export type GetSingleSeasonStatLeadersQueryHookResult = ReturnType<typeof useGetSingleSeasonStatLeadersQuery>;
export type GetSingleSeasonStatLeadersLazyQueryHookResult = ReturnType<typeof useGetSingleSeasonStatLeadersLazyQuery>;
export type GetSingleSeasonStatLeadersQueryResult = Apollo.QueryResult<GetSingleSeasonStatLeadersQuery, GetSingleSeasonStatLeadersQueryVariables>;
export const GetStatLeadersForSeasonDocument = gql`
    query GetStatLeadersForSeason($groupId: UUID!, $season: Int!) {
  doublesLeaders: seasonBattingStats(
    condition: {groupId: $groupId, season: $season}
    orderBy: DOUBLES_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    value: doubles
  }
  homerunsLeaders: seasonBattingStats(
    condition: {groupId: $groupId, season: $season}
    orderBy: HOMERUNS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    value: homeruns
  }
  walksLeaders: seasonBattingStats(
    condition: {groupId: $groupId, season: $season}
    orderBy: WALKS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    value: walks
  }
  rbiLeaders: seasonBattingStats(
    condition: {groupId: $groupId, season: $season}
    orderBy: RBI_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    value: rbi
  }
  onBasePctLeaders: seasonBattingStats(
    condition: {groupId: $groupId, season: $season}
    filter: {qualified: {equalTo: true}}
    orderBy: OBP_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    value: obp
  }
  opsLeaders: seasonBattingStats(
    condition: {groupId: $groupId, season: $season}
    filter: {qualified: {equalTo: true}}
    orderBy: OPS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    value: ops
  }
}
    `;

/**
 * __useGetStatLeadersForSeasonQuery__
 *
 * To run a query within a React component, call `useGetStatLeadersForSeasonQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStatLeadersForSeasonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStatLeadersForSeasonQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      season: // value for 'season'
 *   },
 * });
 */
export function useGetStatLeadersForSeasonQuery(baseOptions: Apollo.QueryHookOptions<GetStatLeadersForSeasonQuery, GetStatLeadersForSeasonQueryVariables>) {
        return Apollo.useQuery<GetStatLeadersForSeasonQuery, GetStatLeadersForSeasonQueryVariables>(GetStatLeadersForSeasonDocument, baseOptions);
      }
export function useGetStatLeadersForSeasonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStatLeadersForSeasonQuery, GetStatLeadersForSeasonQueryVariables>) {
          return Apollo.useLazyQuery<GetStatLeadersForSeasonQuery, GetStatLeadersForSeasonQueryVariables>(GetStatLeadersForSeasonDocument, baseOptions);
        }
export type GetStatLeadersForSeasonQueryHookResult = ReturnType<typeof useGetStatLeadersForSeasonQuery>;
export type GetStatLeadersForSeasonLazyQueryHookResult = ReturnType<typeof useGetStatLeadersForSeasonLazyQuery>;
export type GetStatLeadersForSeasonQueryResult = Apollo.QueryResult<GetStatLeadersForSeasonQuery, GetStatLeadersForSeasonQueryVariables>;
export const GetStatsForSeasonDocument = gql`
    query GetStatsForSeason($groupId: UUID!, $season: Int!) {
  group(id: $groupId) {
    gamesInSeason(season: $season)
    seasonBattingStats(condition: {season: $season}, orderBy: GAMES_DESC) {
      player {
        id
        fullName
      }
      games
      plateAppearances
      atBats
      hits
      doubles
      triples
      homeruns
      walks
      strikeouts
      sacFlies
      gidp
      runs
      rbi
      avg
      obp
      slg
      ops
      stolenBases
    }
  }
}
    `;

/**
 * __useGetStatsForSeasonQuery__
 *
 * To run a query within a React component, call `useGetStatsForSeasonQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStatsForSeasonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStatsForSeasonQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      season: // value for 'season'
 *   },
 * });
 */
export function useGetStatsForSeasonQuery(baseOptions: Apollo.QueryHookOptions<GetStatsForSeasonQuery, GetStatsForSeasonQueryVariables>) {
        return Apollo.useQuery<GetStatsForSeasonQuery, GetStatsForSeasonQueryVariables>(GetStatsForSeasonDocument, baseOptions);
      }
export function useGetStatsForSeasonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStatsForSeasonQuery, GetStatsForSeasonQueryVariables>) {
          return Apollo.useLazyQuery<GetStatsForSeasonQuery, GetStatsForSeasonQueryVariables>(GetStatsForSeasonDocument, baseOptions);
        }
export type GetStatsForSeasonQueryHookResult = ReturnType<typeof useGetStatsForSeasonQuery>;
export type GetStatsForSeasonLazyQueryHookResult = ReturnType<typeof useGetStatsForSeasonLazyQuery>;
export type GetStatsForSeasonQueryResult = Apollo.QueryResult<GetStatsForSeasonQuery, GetStatsForSeasonQueryVariables>;
export const LoginDocument = gql`
    mutation Login($email: String!, $password: String!) {
  login(input: {email: $email, password: $password}) {
    jwt
  }
}
    `;
export type LoginMutationFn = Apollo.MutationFunction<LoginMutation, LoginMutationVariables>;

/**
 * __useLoginMutation__
 *
 * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginMutation, { data, loading, error }] = useLoginMutation({
 *   variables: {
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useLoginMutation(baseOptions?: Apollo.MutationHookOptions<LoginMutation, LoginMutationVariables>) {
        return Apollo.useMutation<LoginMutation, LoginMutationVariables>(LoginDocument, baseOptions);
      }
export type LoginMutationHookResult = ReturnType<typeof useLoginMutation>;
export type LoginMutationResult = Apollo.MutationResult<LoginMutation>;
export type LoginMutationOptions = Apollo.BaseMutationOptions<LoginMutation, LoginMutationVariables>;
export const GetCurrentUserDocument = gql`
    query GetCurrentUser {
  user: getCurrentUser {
    id
    fullName
  }
}
    `;

/**
 * __useGetCurrentUserQuery__
 *
 * To run a query within a React component, call `useGetCurrentUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCurrentUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCurrentUserQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetCurrentUserQuery(baseOptions?: Apollo.QueryHookOptions<GetCurrentUserQuery, GetCurrentUserQueryVariables>) {
        return Apollo.useQuery<GetCurrentUserQuery, GetCurrentUserQueryVariables>(GetCurrentUserDocument, baseOptions);
      }
export function useGetCurrentUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCurrentUserQuery, GetCurrentUserQueryVariables>) {
          return Apollo.useLazyQuery<GetCurrentUserQuery, GetCurrentUserQueryVariables>(GetCurrentUserDocument, baseOptions);
        }
export type GetCurrentUserQueryHookResult = ReturnType<typeof useGetCurrentUserQuery>;
export type GetCurrentUserLazyQueryHookResult = ReturnType<typeof useGetCurrentUserLazyQuery>;
export type GetCurrentUserQueryResult = Apollo.QueryResult<GetCurrentUserQuery, GetCurrentUserQueryVariables>;
export const GetPermissionsDocument = gql`
    query GetPermissions {
  currentUserPermissions
  currentUserGroupPermissions {
    groupId
    permission
  }
}
    `;

/**
 * __useGetPermissionsQuery__
 *
 * To run a query within a React component, call `useGetPermissionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPermissionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPermissionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPermissionsQuery(baseOptions?: Apollo.QueryHookOptions<GetPermissionsQuery, GetPermissionsQueryVariables>) {
        return Apollo.useQuery<GetPermissionsQuery, GetPermissionsQueryVariables>(GetPermissionsDocument, baseOptions);
      }
export function useGetPermissionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPermissionsQuery, GetPermissionsQueryVariables>) {
          return Apollo.useLazyQuery<GetPermissionsQuery, GetPermissionsQueryVariables>(GetPermissionsDocument, baseOptions);
        }
export type GetPermissionsQueryHookResult = ReturnType<typeof useGetPermissionsQuery>;
export type GetPermissionsLazyQueryHookResult = ReturnType<typeof useGetPermissionsLazyQuery>;
export type GetPermissionsQueryResult = Apollo.QueryResult<GetPermissionsQuery, GetPermissionsQueryVariables>;
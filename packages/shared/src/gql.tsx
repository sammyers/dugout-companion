/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: any;
  /** The day, does not include a time. */
  Date: string;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: string;
  /** The exact time of day, does not include the date. May or may not have a timezone offset. */
  Time: any;
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: string;
};

export type BaseRunner = Node & {
  __typename?: 'BaseRunner';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
  base: BaseType;
  /** Reads a single `GameState` that is related to this `BaseRunner`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Player` that is related to this `BaseRunner`. */
  runner: Maybe<Player>;
};

/** The fields on `baseRunner` to look up the row to connect. */
export type BaseRunnerBaseRunnerPkeyConnect = {
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The fields on `baseRunner` to look up the row to delete. */
export type BaseRunnerBaseRunnerPkeyDelete = {
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/**
 * A condition to be used against `BaseRunner` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type BaseRunnerCondition = {
  /** Checks for equality with the object’s `gameStateId` field. */
  gameStateId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runnerId` field. */
  runnerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `base` field. */
  base?: Maybe<BaseType>;
};

/** The `baseRunner` to be created by this mutation. */
export type BaseRunnerGameStateIdFkeyBaseRunnerCreateInput = {
  runnerId?: Maybe<Scalars['UUID']>;
  base: BaseType;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
};

/** The `gameState` to be created by this mutation. */
export type BaseRunnerGameStateIdFkeyGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `gameState` in the `BaseRunnerInput` mutation. */
export type BaseRunnerGameStateIdFkeyInput = {
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<GameStateGameStatePkeyConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameStateNodeIdConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<GameStateGameStatePkeyDelete>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameStateNodeIdDelete>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingGameStatePkeyUpdate>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<BaseRunnerGameStateIdFkeyGameStateCreateInput>;
};

/** Input for the nested mutation of `baseRunner` in the `GameStateInput` mutation. */
export type BaseRunnerGameStateIdFkeyInverseInput = {
  /** Flag indicating whether all other `baseRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BaseRunnerNodeIdConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyDelete>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BaseRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingBaseRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate>>;
  /** A `BaseRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BaseRunnerGameStateIdFkeyBaseRunnerCreateInput>>;
};

/** An input for mutations affecting `BaseRunner` */
export type BaseRunnerInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  base: BaseType;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type BaseRunnerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `baseRunner` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type BaseRunnerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `baseRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `baseRunner` to look up the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingBaseRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: UpdateBaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `baseRunner` to look up the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingBaseRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: UpdateBaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** Represents an update to a `BaseRunner`. Fields that are set will be updated. */
export type BaseRunnerPatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  base?: Maybe<BaseType>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
};

/** The `baseRunner` to be created by this mutation. */
export type BaseRunnerRunnerIdFkeyBaseRunnerCreateInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  base: BaseType;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
};

/** Input for the nested mutation of `player` in the `BaseRunnerInput` mutation. */
export type BaseRunnerRunnerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<BaseRunnerRunnerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `baseRunner` in the `PlayerInput` mutation. */
export type BaseRunnerRunnerIdFkeyInverseInput = {
  /** Flag indicating whether all other `baseRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BaseRunnerNodeIdConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyDelete>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BaseRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingBaseRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate>>;
  /** A `BaseRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BaseRunnerRunnerIdFkeyBaseRunnerCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type BaseRunnerRunnerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** Methods to use when ordering `BaseRunner`. */
export enum BaseRunnersOrderBy {
  NATURAL = 'NATURAL',
  GAME_STATE_ID_ASC = 'GAME_STATE_ID_ASC',
  GAME_STATE_ID_DESC = 'GAME_STATE_ID_DESC',
  RUNNER_ID_ASC = 'RUNNER_ID_ASC',
  RUNNER_ID_DESC = 'RUNNER_ID_DESC',
  BASE_ASC = 'BASE_ASC',
  BASE_DESC = 'BASE_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export enum BaseType {
  FIRST = 'FIRST',
  SECOND = 'SECOND',
  THIRD = 'THIRD'
}

export type BasepathMovement = Node & {
  __typename?: 'BasepathMovement';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
  endBase: Maybe<BaseType>;
  wasSafe: Scalars['Boolean'];
  /** Reads a single `PlateAppearance` that is related to this `BasepathMovement`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `BasepathMovement`. */
  runner: Maybe<Player>;
};

/** The fields on `basepathMovement` to look up the row to connect. */
export type BasepathMovementBasepathMovementPkeyConnect = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The fields on `basepathMovement` to look up the row to delete. */
export type BasepathMovementBasepathMovementPkeyDelete = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/**
 * A condition to be used against `BasepathMovement` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type BasepathMovementCondition = {
  /** Checks for equality with the object’s `plateAppearanceId` field. */
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runnerId` field. */
  runnerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `endBase` field. */
  endBase?: Maybe<BaseType>;
  /** Checks for equality with the object’s `wasSafe` field. */
  wasSafe?: Maybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `BasepathMovement` */
export type BasepathMovementInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe: Scalars['Boolean'];
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type BasepathMovementNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `basepathMovement` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type BasepathMovementNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `basepathMovement` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** The fields on `basepathMovement` to look up the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingBasepathMovementPkeyUpdate = {
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: UpdateBasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `basepathMovement` to look up the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingBasepathMovementPkeyUpdate = {
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: UpdateBasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** Represents an update to a `BasepathMovement`. Fields that are set will be updated. */
export type BasepathMovementPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe?: Maybe<Scalars['Boolean']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
};

/** The `basepathMovement` to be created by this mutation. */
export type BasepathMovementPlateAppearanceIdFkeyBasepathMovementCreateInput = {
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe: Scalars['Boolean'];
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
};

/** Input for the nested mutation of `plateAppearance` in the `BasepathMovementInput` mutation. */
export type BasepathMovementPlateAppearanceIdFkeyInput = {
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectById?: Maybe<PlateAppearancePlateAppearancePkeyConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlateAppearanceNodeIdConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteById?: Maybe<PlateAppearancePlateAppearancePkeyDelete>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlateAppearanceNodeIdDelete>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateById?: Maybe<PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateByNodeId?: Maybe<BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate>;
  /** A `PlateAppearanceInput` object that will be created and connected to this object. */
  create?: Maybe<BasepathMovementPlateAppearanceIdFkeyPlateAppearanceCreateInput>;
};

/** Input for the nested mutation of `basepathMovement` in the `PlateAppearanceInput` mutation. */
export type BasepathMovementPlateAppearanceIdFkeyInverseInput = {
  /** Flag indicating whether all other `basepathMovement` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BasepathMovementNodeIdConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyDelete>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BasepathMovementNodeIdDelete>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingBasepathMovementPkeyUpdate>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate>>;
  /** A `BasepathMovementInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BasepathMovementPlateAppearanceIdFkeyBasepathMovementCreateInput>>;
};

/** The `plateAppearance` to be created by this mutation. */
export type BasepathMovementPlateAppearanceIdFkeyPlateAppearanceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** The `basepathMovement` to be created by this mutation. */
export type BasepathMovementRunnerIdFkeyBasepathMovementCreateInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe: Scalars['Boolean'];
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
};

/** Input for the nested mutation of `player` in the `BasepathMovementInput` mutation. */
export type BasepathMovementRunnerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<BasepathMovementRunnerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `basepathMovement` in the `PlayerInput` mutation. */
export type BasepathMovementRunnerIdFkeyInverseInput = {
  /** Flag indicating whether all other `basepathMovement` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BasepathMovementNodeIdConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyDelete>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BasepathMovementNodeIdDelete>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingBasepathMovementPkeyUpdate>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate>>;
  /** A `BasepathMovementInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BasepathMovementRunnerIdFkeyBasepathMovementCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type BasepathMovementRunnerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** Methods to use when ordering `BasepathMovement`. */
export enum BasepathMovementsOrderBy {
  NATURAL = 'NATURAL',
  PLATE_APPEARANCE_ID_ASC = 'PLATE_APPEARANCE_ID_ASC',
  PLATE_APPEARANCE_ID_DESC = 'PLATE_APPEARANCE_ID_DESC',
  RUNNER_ID_ASC = 'RUNNER_ID_ASC',
  RUNNER_ID_DESC = 'RUNNER_ID_DESC',
  END_BASE_ASC = 'END_BASE_ASC',
  END_BASE_DESC = 'END_BASE_DESC',
  WAS_SAFE_ASC = 'WAS_SAFE_ASC',
  WAS_SAFE_DESC = 'WAS_SAFE_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}


export type CareerStat = {
  __typename?: 'CareerStat';
  groupId: Maybe<Scalars['UUID']>;
  playerId: Maybe<Scalars['UUID']>;
  legacyPlayerId: Maybe<Scalars['Int']>;
  seasons: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['Int']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
  /** Reads a single `Player` that is related to this `CareerStat`. */
  player: Maybe<Player>;
  /** Reads a single `LegacyPlayer` that is related to this `CareerStat`. */
  legacyPlayer: Maybe<LegacyPlayer>;
  /** Reads a single `Group` that is related to this `CareerStat`. */
  group: Maybe<Group>;
};

/**
 * A condition to be used against `CareerStat` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CareerStatCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `seasons` field. */
  seasons?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The globally unique `ID` look up for the row to update. */
export type CareerStatOnCareerStatForFakePublicCareerStatsForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CareerStatOnCareerStatForFakePublicCareerStatsForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: LegacyPlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CareerStatOnCareerStatForFakePublicCareerStatsForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** Methods to use when ordering `CareerStat`. */
export enum CareerStatsOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  SEASONS_ASC = 'SEASONS_ASC',
  SEASONS_DESC = 'SEASONS_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC'
}

export type CareerStatsQualifiedBatter = {
  __typename?: 'CareerStatsQualifiedBatter';
  groupId: Maybe<Scalars['UUID']>;
  playerId: Maybe<Scalars['UUID']>;
  legacyPlayerId: Maybe<Scalars['Int']>;
  seasons: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['Int']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
  /** Reads a single `Player` that is related to this `CareerStatsQualifiedBatter`. */
  player: Maybe<Player>;
  /** Reads a single `LegacyPlayer` that is related to this `CareerStatsQualifiedBatter`. */
  legacyPlayer: Maybe<LegacyPlayer>;
  /** Reads a single `Group` that is related to this `CareerStatsQualifiedBatter`. */
  group: Maybe<Group>;
};

/**
 * A condition to be used against `CareerStatsQualifiedBatter` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type CareerStatsQualifiedBatterCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `seasons` field. */
  seasons?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The globally unique `ID` look up for the row to update. */
export type CareerStatsQualifiedBatterOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CareerStatsQualifiedBatterOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: LegacyPlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CareerStatsQualifiedBatterOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** Methods to use when ordering `CareerStatsQualifiedBatter`. */
export enum CareerStatsQualifiedBattersOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  SEASONS_ASC = 'SEASONS_ASC',
  SEASONS_DESC = 'SEASONS_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC'
}

export enum ContactQuality {
  NONE = 'NONE',
  GROUNDER = 'GROUNDER',
  LINE_DRIVE = 'LINE_DRIVE',
  POPUP = 'POPUP',
  LAZY_FLY = 'LAZY_FLY',
  LONG_FLY = 'LONG_FLY'
}

/** All input for the create `BaseRunner` mutation. */
export type CreateBaseRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `BaseRunner` to be created by this mutation. */
  baseRunner: BaseRunnerInput;
};

/** The output of our create `BaseRunner` mutation. */
export type CreateBaseRunnerPayload = {
  __typename?: 'CreateBaseRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BaseRunner` that was created by this mutation. */
  baseRunner: Maybe<BaseRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `BaseRunner`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Player` that is related to this `BaseRunner`. */
  runner: Maybe<Player>;
};

/** All input for the create `BasepathMovement` mutation. */
export type CreateBasepathMovementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `BasepathMovement` to be created by this mutation. */
  basepathMovement: BasepathMovementInput;
};

/** The output of our create `BasepathMovement` mutation. */
export type CreateBasepathMovementPayload = {
  __typename?: 'CreateBasepathMovementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BasepathMovement` that was created by this mutation. */
  basepathMovement: Maybe<BasepathMovement>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `BasepathMovement`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `BasepathMovement`. */
  runner: Maybe<Player>;
};

/** All input for the create `Field` mutation. */
export type CreateFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Field` to be created by this mutation. */
  field: FieldInput;
};

/** The output of our create `Field` mutation. */
export type CreateFieldPayload = {
  __typename?: 'CreateFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Field` that was created by this mutation. */
  field: Maybe<Field>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `ForeignDbField` mutation. */
export type CreateForeignDbFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ForeignDbField` to be created by this mutation. */
  foreignDbField: ForeignDbFieldInput;
};

/** The output of our create `ForeignDbField` mutation. */
export type CreateForeignDbFieldPayload = {
  __typename?: 'CreateForeignDbFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ForeignDbField` that was created by this mutation. */
  foreignDbField: Maybe<ForeignDbField>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `ForeignDbGame` mutation. */
export type CreateForeignDbGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ForeignDbGame` to be created by this mutation. */
  foreignDbGame: ForeignDbGameInput;
};

/** The output of our create `ForeignDbGame` mutation. */
export type CreateForeignDbGamePayload = {
  __typename?: 'CreateForeignDbGamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ForeignDbGame` that was created by this mutation. */
  foreignDbGame: Maybe<ForeignDbGame>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `ForeignDbPlayer` mutation. */
export type CreateForeignDbPlayerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ForeignDbPlayer` to be created by this mutation. */
  foreignDbPlayer: ForeignDbPlayerInput;
};

/** The output of our create `ForeignDbPlayer` mutation. */
export type CreateForeignDbPlayerPayload = {
  __typename?: 'CreateForeignDbPlayerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ForeignDbPlayer` that was created by this mutation. */
  foreignDbPlayer: Maybe<ForeignDbPlayer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `ForeignDbStatLine` mutation. */
export type CreateForeignDbStatLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ForeignDbStatLine` to be created by this mutation. */
  foreignDbStatLine: ForeignDbStatLineInput;
};

/** The output of our create `ForeignDbStatLine` mutation. */
export type CreateForeignDbStatLinePayload = {
  __typename?: 'CreateForeignDbStatLinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ForeignDbStatLine` that was created by this mutation. */
  foreignDbStatLine: Maybe<ForeignDbStatLine>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `ForeignDbTeam` mutation. */
export type CreateForeignDbTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ForeignDbTeam` to be created by this mutation. */
  foreignDbTeam: ForeignDbTeamInput;
};

/** The output of our create `ForeignDbTeam` mutation. */
export type CreateForeignDbTeamPayload = {
  __typename?: 'CreateForeignDbTeamPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ForeignDbTeam` that was created by this mutation. */
  foreignDbTeam: Maybe<ForeignDbTeam>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `GameEvent` mutation. */
export type CreateGameEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GameEvent` to be created by this mutation. */
  gameEvent: GameEventInput;
};

/** The output of our create `GameEvent` mutation. */
export type CreateGameEventPayload = {
  __typename?: 'CreateGameEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEvent` that was created by this mutation. */
  gameEvent: Maybe<GameEvent>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `GameEvent`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `StolenBaseAttempt` that is related to this `GameEvent`. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Reads a single `LineupChange` that is related to this `GameEvent`. */
  lineupChange: Maybe<LineupChange>;
};

/** All input for the create `GameEventRecord` mutation. */
export type CreateGameEventRecordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GameEventRecord` to be created by this mutation. */
  gameEventRecord: GameEventRecordInput;
};

/** The output of our create `GameEventRecord` mutation. */
export type CreateGameEventRecordPayload = {
  __typename?: 'CreateGameEventRecordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEventRecord` that was created by this mutation. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameEventRecord`. */
  game: Maybe<Game>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateBefore: Maybe<GameState>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateAfter: Maybe<GameState>;
  /** Reads a single `GameEvent` that is related to this `GameEventRecord`. */
  gameEvent: Maybe<GameEvent>;
};

/** All input for the create `Game` mutation. */
export type CreateGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Game` to be created by this mutation. */
  game: GameInput;
};

/** The output of our create `Game` mutation. */
export type CreateGamePayload = {
  __typename?: 'CreateGamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Game` that was created by this mutation. */
  game: Maybe<Game>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Group` that is related to this `Game`. */
  group: Maybe<Group>;
  /** Reads a single `Field` that is related to this `Game`. */
  field: Maybe<Field>;
};

/** All input for the create `GameState` mutation. */
export type CreateGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GameState` to be created by this mutation. */
  gameState: GameStateInput;
};

/** The output of our create `GameState` mutation. */
export type CreateGameStatePayload = {
  __typename?: 'CreateGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameState` that was created by this mutation. */
  gameState: Maybe<GameState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameState`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `GameState`. */
  playerByPlayerAtBat: Maybe<Player>;
};

/** All input for the create `Group` mutation. */
export type CreateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Group` to be created by this mutation. */
  group: GroupInput;
};

/** The output of our create `Group` mutation. */
export type CreateGroupPayload = {
  __typename?: 'CreateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Group` that was created by this mutation. */
  group: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `LineupChange` mutation. */
export type CreateLineupChangeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LineupChange` to be created by this mutation. */
  lineupChange: LineupChangeInput;
};

/** The output of our create `LineupChange` mutation. */
export type CreateLineupChangePayload = {
  __typename?: 'CreateLineupChangePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupChange` that was created by this mutation. */
  lineupChange: Maybe<LineupChange>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupBefore: Maybe<Lineup>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupAfter: Maybe<Lineup>;
};

/** All input for the create `LineupForGameState` mutation. */
export type CreateLineupForGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LineupForGameState` to be created by this mutation. */
  lineupForGameState: LineupForGameStateInput;
};

/** The output of our create `LineupForGameState` mutation. */
export type CreateLineupForGameStatePayload = {
  __typename?: 'CreateLineupForGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupForGameState` that was created by this mutation. */
  lineupForGameState: Maybe<LineupForGameState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `LineupForGameState`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Lineup` that is related to this `LineupForGameState`. */
  lineup: Maybe<Lineup>;
};

/** All input for the create `Lineup` mutation. */
export type CreateLineupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Lineup` to be created by this mutation. */
  lineup: LineupInput;
};

/** The output of our create `Lineup` mutation. */
export type CreateLineupPayload = {
  __typename?: 'CreateLineupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Lineup` that was created by this mutation. */
  lineup: Maybe<Lineup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Team` that is related to this `Lineup`. */
  team: Maybe<Team>;
};

/** All input for the create `LineupSpot` mutation. */
export type CreateLineupSpotInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LineupSpot` to be created by this mutation. */
  lineupSpot: LineupSpotInput;
};

/** The output of our create `LineupSpot` mutation. */
export type CreateLineupSpotPayload = {
  __typename?: 'CreateLineupSpotPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupSpot` that was created by this mutation. */
  lineupSpot: Maybe<LineupSpot>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupSpot`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Player` that is related to this `LineupSpot`. */
  player: Maybe<Player>;
};

/** All input for the create `OutOnPlayRunner` mutation. */
export type CreateOutOnPlayRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OutOnPlayRunner` to be created by this mutation. */
  outOnPlayRunner: OutOnPlayRunnerInput;
};

/** The output of our create `OutOnPlayRunner` mutation. */
export type CreateOutOnPlayRunnerPayload = {
  __typename?: 'CreateOutOnPlayRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `OutOnPlayRunner` that was created by this mutation. */
  outOnPlayRunner: Maybe<OutOnPlayRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `OutOnPlayRunner`. */
  runner: Maybe<Player>;
};

/** All input for the create `PlateAppearance` mutation. */
export type CreatePlateAppearanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PlateAppearance` to be created by this mutation. */
  plateAppearance: PlateAppearanceInput;
};

/** The output of our create `PlateAppearance` mutation. */
export type CreatePlateAppearancePayload = {
  __typename?: 'CreatePlateAppearancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlateAppearance` that was created by this mutation. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `Player` mutation. */
export type CreatePlayerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Player` to be created by this mutation. */
  player: PlayerInput;
};

/** The output of our create `Player` mutation. */
export type CreatePlayerPayload = {
  __typename?: 'CreatePlayerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Player` that was created by this mutation. */
  player: Maybe<Player>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Group` that is related to this `Player`. */
  group: Maybe<Group>;
  /** Reads a single `LegacyPlayer` that is related to this `Player`. */
  legacyPlayer: Maybe<LegacyPlayer>;
};

/** All input for the create `ScoredRunner` mutation. */
export type CreateScoredRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ScoredRunner` to be created by this mutation. */
  scoredRunner: ScoredRunnerInput;
};

/** The output of our create `ScoredRunner` mutation. */
export type CreateScoredRunnerPayload = {
  __typename?: 'CreateScoredRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ScoredRunner` that was created by this mutation. */
  scoredRunner: Maybe<ScoredRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameEventRecord` that is related to this `ScoredRunner`. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Reads a single `Player` that is related to this `ScoredRunner`. */
  runner: Maybe<Player>;
};

/** All input for the create `StolenBaseAttempt` mutation. */
export type CreateStolenBaseAttemptInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StolenBaseAttempt` to be created by this mutation. */
  stolenBaseAttempt: StolenBaseAttemptInput;
};

/** The output of our create `StolenBaseAttempt` mutation. */
export type CreateStolenBaseAttemptPayload = {
  __typename?: 'CreateStolenBaseAttemptPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `StolenBaseAttempt` that was created by this mutation. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `StolenBaseAttempt`. */
  runner: Maybe<Player>;
};

/** All input for the create `Team` mutation. */
export type CreateTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Team` to be created by this mutation. */
  team: TeamInput;
};

/** The output of our create `Team` mutation. */
export type CreateTeamPayload = {
  __typename?: 'CreateTeamPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Team` that was created by this mutation. */
  team: Maybe<Team>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `Team`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `Team`. */
  captain: Maybe<Player>;
};



/** All input for the `deleteBaseRunnerByNodeId` mutation. */
export type DeleteBaseRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `BaseRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteBaseRunner` mutation. */
export type DeleteBaseRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our delete `BaseRunner` mutation. */
export type DeleteBaseRunnerPayload = {
  __typename?: 'DeleteBaseRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BaseRunner` that was deleted by this mutation. */
  baseRunner: Maybe<BaseRunner>;
  deletedBaseRunnerNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `BaseRunner`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Player` that is related to this `BaseRunner`. */
  runner: Maybe<Player>;
};

/** All input for the `deleteBasepathMovementByNodeId` mutation. */
export type DeleteBasepathMovementByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `BasepathMovement` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteBasepathMovement` mutation. */
export type DeleteBasepathMovementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our delete `BasepathMovement` mutation. */
export type DeleteBasepathMovementPayload = {
  __typename?: 'DeleteBasepathMovementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BasepathMovement` that was deleted by this mutation. */
  basepathMovement: Maybe<BasepathMovement>;
  deletedBasepathMovementNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `BasepathMovement`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `BasepathMovement`. */
  runner: Maybe<Player>;
};

/** All input for the `deleteFieldByNodeId` mutation. */
export type DeleteFieldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Field` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteField` mutation. */
export type DeleteFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Field` mutation. */
export type DeleteFieldPayload = {
  __typename?: 'DeleteFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Field` that was deleted by this mutation. */
  field: Maybe<Field>;
  deletedFieldNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteGameByName` mutation. */
export type DeleteGameByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** All input for the `deleteGameByNodeId` mutation. */
export type DeleteGameByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Game` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGameEventByNodeId` mutation. */
export type DeleteGameEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameEvent` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGameEvent` mutation. */
export type DeleteGameEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `GameEvent` mutation. */
export type DeleteGameEventPayload = {
  __typename?: 'DeleteGameEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEvent` that was deleted by this mutation. */
  gameEvent: Maybe<GameEvent>;
  deletedGameEventNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `GameEvent`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `StolenBaseAttempt` that is related to this `GameEvent`. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Reads a single `LineupChange` that is related to this `GameEvent`. */
  lineupChange: Maybe<LineupChange>;
};

/** All input for the `deleteGameEventRecordByGameIdAndEventIndex` mutation. */
export type DeleteGameEventRecordByGameIdAndEventIndexInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** All input for the `deleteGameEventRecordByNodeId` mutation. */
export type DeleteGameEventRecordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameEventRecord` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGameEventRecord` mutation. */
export type DeleteGameEventRecordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `GameEventRecord` mutation. */
export type DeleteGameEventRecordPayload = {
  __typename?: 'DeleteGameEventRecordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEventRecord` that was deleted by this mutation. */
  gameEventRecord: Maybe<GameEventRecord>;
  deletedGameEventRecordNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameEventRecord`. */
  game: Maybe<Game>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateBefore: Maybe<GameState>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateAfter: Maybe<GameState>;
  /** Reads a single `GameEvent` that is related to this `GameEventRecord`. */
  gameEvent: Maybe<GameEvent>;
};

/** All input for the `deleteGame` mutation. */
export type DeleteGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Game` mutation. */
export type DeleteGamePayload = {
  __typename?: 'DeleteGamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Game` that was deleted by this mutation. */
  game: Maybe<Game>;
  deletedGameNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Group` that is related to this `Game`. */
  group: Maybe<Group>;
  /** Reads a single `Field` that is related to this `Game`. */
  field: Maybe<Field>;
};

/** All input for the `deleteGameStateByNodeId` mutation. */
export type DeleteGameStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameState` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGameState` mutation. */
export type DeleteGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `GameState` mutation. */
export type DeleteGameStatePayload = {
  __typename?: 'DeleteGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameState` that was deleted by this mutation. */
  gameState: Maybe<GameState>;
  deletedGameStateNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameState`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `GameState`. */
  playerByPlayerAtBat: Maybe<Player>;
};

/** All input for the `deleteGroupByName` mutation. */
export type DeleteGroupByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** All input for the `deleteGroupByNodeId` mutation. */
export type DeleteGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Group` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGroup` mutation. */
export type DeleteGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Group` mutation. */
export type DeleteGroupPayload = {
  __typename?: 'DeleteGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Group` that was deleted by this mutation. */
  group: Maybe<Group>;
  deletedGroupNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteLineupByNodeId` mutation. */
export type DeleteLineupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Lineup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLineupChangeByNodeId` mutation. */
export type DeleteLineupChangeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupChange` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLineupChange` mutation. */
export type DeleteLineupChangeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `LineupChange` mutation. */
export type DeleteLineupChangePayload = {
  __typename?: 'DeleteLineupChangePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupChange` that was deleted by this mutation. */
  lineupChange: Maybe<LineupChange>;
  deletedLineupChangeNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupBefore: Maybe<Lineup>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupAfter: Maybe<Lineup>;
};

/** All input for the `deleteLineupForGameStateByNodeId` mutation. */
export type DeleteLineupForGameStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupForGameState` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLineupForGameState` mutation. */
export type DeleteLineupForGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** The output of our delete `LineupForGameState` mutation. */
export type DeleteLineupForGameStatePayload = {
  __typename?: 'DeleteLineupForGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupForGameState` that was deleted by this mutation. */
  lineupForGameState: Maybe<LineupForGameState>;
  deletedLineupForGameStateNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `LineupForGameState`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Lineup` that is related to this `LineupForGameState`. */
  lineup: Maybe<Lineup>;
};

/** All input for the `deleteLineup` mutation. */
export type DeleteLineupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Lineup` mutation. */
export type DeleteLineupPayload = {
  __typename?: 'DeleteLineupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Lineup` that was deleted by this mutation. */
  lineup: Maybe<Lineup>;
  deletedLineupNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Team` that is related to this `Lineup`. */
  team: Maybe<Team>;
};

/** All input for the `deleteLineupSpotByLineupIdAndBattingOrder` mutation. */
export type DeleteLineupSpotByLineupIdAndBattingOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** All input for the `deleteLineupSpotByLineupIdAndPosition` mutation. */
export type DeleteLineupSpotByLineupIdAndPositionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** All input for the `deleteLineupSpotByNodeId` mutation. */
export type DeleteLineupSpotByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupSpot` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLineupSpot` mutation. */
export type DeleteLineupSpotInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The output of our delete `LineupSpot` mutation. */
export type DeleteLineupSpotPayload = {
  __typename?: 'DeleteLineupSpotPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupSpot` that was deleted by this mutation. */
  lineupSpot: Maybe<LineupSpot>;
  deletedLineupSpotNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupSpot`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Player` that is related to this `LineupSpot`. */
  player: Maybe<Player>;
};

/** All input for the `deleteOutOnPlayRunnerByNodeId` mutation. */
export type DeleteOutOnPlayRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OutOnPlayRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOutOnPlayRunner` mutation. */
export type DeleteOutOnPlayRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our delete `OutOnPlayRunner` mutation. */
export type DeleteOutOnPlayRunnerPayload = {
  __typename?: 'DeleteOutOnPlayRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `OutOnPlayRunner` that was deleted by this mutation. */
  outOnPlayRunner: Maybe<OutOnPlayRunner>;
  deletedOutOnPlayRunnerNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `OutOnPlayRunner`. */
  runner: Maybe<Player>;
};

/** All input for the `deletePlateAppearanceByNodeId` mutation. */
export type DeletePlateAppearanceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlateAppearance` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlateAppearance` mutation. */
export type DeletePlateAppearanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `PlateAppearance` mutation. */
export type DeletePlateAppearancePayload = {
  __typename?: 'DeletePlateAppearancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlateAppearance` that was deleted by this mutation. */
  plateAppearance: Maybe<PlateAppearance>;
  deletedPlateAppearanceNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deletePlayerByFirstNameAndLastName` mutation. */
export type DeletePlayerByFirstNameAndLastNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** All input for the `deletePlayerByNodeId` mutation. */
export type DeletePlayerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Player` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlayer` mutation. */
export type DeletePlayerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Player` mutation. */
export type DeletePlayerPayload = {
  __typename?: 'DeletePlayerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Player` that was deleted by this mutation. */
  player: Maybe<Player>;
  deletedPlayerNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Group` that is related to this `Player`. */
  group: Maybe<Group>;
  /** Reads a single `LegacyPlayer` that is related to this `Player`. */
  legacyPlayer: Maybe<LegacyPlayer>;
};

/** All input for the `deleteScoredRunnerByNodeId` mutation. */
export type DeleteScoredRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ScoredRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteScoredRunner` mutation. */
export type DeleteScoredRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our delete `ScoredRunner` mutation. */
export type DeleteScoredRunnerPayload = {
  __typename?: 'DeleteScoredRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ScoredRunner` that was deleted by this mutation. */
  scoredRunner: Maybe<ScoredRunner>;
  deletedScoredRunnerNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameEventRecord` that is related to this `ScoredRunner`. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Reads a single `Player` that is related to this `ScoredRunner`. */
  runner: Maybe<Player>;
};

/** All input for the `deleteStolenBaseAttemptByNodeId` mutation. */
export type DeleteStolenBaseAttemptByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StolenBaseAttempt` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStolenBaseAttempt` mutation. */
export type DeleteStolenBaseAttemptInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `StolenBaseAttempt` mutation. */
export type DeleteStolenBaseAttemptPayload = {
  __typename?: 'DeleteStolenBaseAttemptPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `StolenBaseAttempt` that was deleted by this mutation. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  deletedStolenBaseAttemptNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `StolenBaseAttempt`. */
  runner: Maybe<Player>;
};

/** All input for the `deleteTeamByGameIdAndRole` mutation. */
export type DeleteTeamByGameIdAndRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** All input for the `deleteTeamByNodeId` mutation. */
export type DeleteTeamByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Team` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTeam` mutation. */
export type DeleteTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Team` mutation. */
export type DeleteTeamPayload = {
  __typename?: 'DeleteTeamPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Team` that was deleted by this mutation. */
  team: Maybe<Team>;
  deletedTeamNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `Team`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `Team`. */
  captain: Maybe<Player>;
};

/** The `careerStat` to be created by this mutation. */
export type FakePublicCareerStatsForeignKey0CareerStatsCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicCareerStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicCareerStatsForeignKey1Input>;
  group?: Maybe<FakePublicCareerStatsForeignKey2Input>;
};

/** Input for the nested mutation of `player` in the `CareerStatInput` mutation. */
export type FakePublicCareerStatsForeignKey0Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnCareerStatForFakePublicCareerStatsForeignKey0UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnCareerStatForFakePublicCareerStatsForeignKey0UsingPlayerFirstNameLastNameKeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<CareerStatOnCareerStatForFakePublicCareerStatsForeignKey0NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicCareerStatsForeignKey0PlayerCreateInput>;
};

/** Input for the nested mutation of `careerStat` in the `PlayerInput` mutation. */
export type FakePublicCareerStatsForeignKey0InverseInput = {
  /** A `CareerStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicCareerStatsForeignKey0CareerStatsCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type FakePublicCareerStatsForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `careerStat` to be created by this mutation. */
export type FakePublicCareerStatsForeignKey1CareerStatsCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicCareerStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicCareerStatsForeignKey1Input>;
  group?: Maybe<FakePublicCareerStatsForeignKey2Input>;
};

/** Input for the nested mutation of `legacyPlayer` in the `CareerStatInput` mutation. */
export type FakePublicCareerStatsForeignKey1Input = {
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyPlayerNodeIdConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyPlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByPlayerId?: Maybe<LegacyPlayerOnCareerStatForFakePublicCareerStatsForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByNodeId?: Maybe<CareerStatOnCareerStatForFakePublicCareerStatsForeignKey1NodeIdUpdate>;
  /** A `LegacyPlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicCareerStatsForeignKey1LegacyPlayerCreateInput>;
};

/** Input for the nested mutation of `careerStat` in the `LegacyPlayerInput` mutation. */
export type FakePublicCareerStatsForeignKey1InverseInput = {
  /** A `CareerStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicCareerStatsForeignKey1CareerStatsCreateInput>>;
};

/** The `legacyPlayer` to be created by this mutation. */
export type FakePublicCareerStatsForeignKey1LegacyPlayerCreateInput = {
  playerId: Scalars['Int'];
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** The `careerStat` to be created by this mutation. */
export type FakePublicCareerStatsForeignKey2CareerStatsCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicCareerStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicCareerStatsForeignKey1Input>;
  group?: Maybe<FakePublicCareerStatsForeignKey2Input>;
};

/** The `group` to be created by this mutation. */
export type FakePublicCareerStatsForeignKey2GroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** Input for the nested mutation of `group` in the `CareerStatInput` mutation. */
export type FakePublicCareerStatsForeignKey2Input = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnCareerStatForFakePublicCareerStatsForeignKey2UsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnCareerStatForFakePublicCareerStatsForeignKey2UsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<CareerStatOnCareerStatForFakePublicCareerStatsForeignKey2NodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicCareerStatsForeignKey2GroupCreateInput>;
};

/** Input for the nested mutation of `careerStat` in the `GroupInput` mutation. */
export type FakePublicCareerStatsForeignKey2InverseInput = {
  /** A `CareerStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicCareerStatsForeignKey2CareerStatsCreateInput>>;
};

/** The `careerStatsQualifiedBatter` to be created by this mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey0CareerStatsQualifiedBattersCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2Input>;
};

/** Input for the nested mutation of `player` in the `CareerStatsQualifiedBatterInput` mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey0Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0UsingPlayerFirstNameLastNameKeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<CareerStatsQualifiedBatterOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0PlayerCreateInput>;
};

/** Input for the nested mutation of `careerStatsQualifiedBatter` in the `PlayerInput` mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput = {
  /** A `CareerStatsQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicCareerStatsQualifiedBattersForeignKey0CareerStatsQualifiedBattersCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `careerStatsQualifiedBatter` to be created by this mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey1CareerStatsQualifiedBattersCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2Input>;
};

/** Input for the nested mutation of `legacyPlayer` in the `CareerStatsQualifiedBatterInput` mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey1Input = {
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyPlayerNodeIdConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyPlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByPlayerId?: Maybe<LegacyPlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByNodeId?: Maybe<CareerStatsQualifiedBatterOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey1NodeIdUpdate>;
  /** A `LegacyPlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1LegacyPlayerCreateInput>;
};

/** Input for the nested mutation of `careerStatsQualifiedBatter` in the `LegacyPlayerInput` mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput = {
  /** A `CareerStatsQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicCareerStatsQualifiedBattersForeignKey1CareerStatsQualifiedBattersCreateInput>>;
};

/** The `legacyPlayer` to be created by this mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey1LegacyPlayerCreateInput = {
  playerId: Scalars['Int'];
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** The `careerStatsQualifiedBatter` to be created by this mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey2CareerStatsQualifiedBattersCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2Input>;
};

/** The `group` to be created by this mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey2GroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** Input for the nested mutation of `group` in the `CareerStatsQualifiedBatterInput` mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey2Input = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2UsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2UsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<CareerStatsQualifiedBatterOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2NodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2GroupCreateInput>;
};

/** Input for the nested mutation of `careerStatsQualifiedBatter` in the `GroupInput` mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput = {
  /** A `CareerStatsQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicCareerStatsQualifiedBattersForeignKey2CareerStatsQualifiedBattersCreateInput>>;
};

/** Input for the nested mutation of `player` in the `LegacySeasonStatInput` mutation. */
export type FakePublicLegacySeasonStatsForeignKey0Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0UsingPlayerFirstNameLastNameKeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacySeasonStatOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicLegacySeasonStatsForeignKey0PlayerCreateInput>;
};

/** Input for the nested mutation of `legacySeasonStat` in the `PlayerInput` mutation. */
export type FakePublicLegacySeasonStatsForeignKey0InverseInput = {
  /** A `LegacySeasonStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicLegacySeasonStatsForeignKey0LegacySeasonStatsCreateInput>>;
};

/** The `legacySeasonStat` to be created by this mutation. */
export type FakePublicLegacySeasonStatsForeignKey0LegacySeasonStatsCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['BigInt']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicLegacySeasonStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicLegacySeasonStatsForeignKey1Input>;
  group?: Maybe<FakePublicLegacySeasonStatsForeignKey2Input>;
};

/** The `player` to be created by this mutation. */
export type FakePublicLegacySeasonStatsForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** Input for the nested mutation of `legacyPlayer` in the `LegacySeasonStatInput` mutation. */
export type FakePublicLegacySeasonStatsForeignKey1Input = {
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyPlayerNodeIdConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyPlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByPlayerId?: Maybe<LegacyPlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacySeasonStatOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey1NodeIdUpdate>;
  /** A `LegacyPlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicLegacySeasonStatsForeignKey1LegacyPlayerCreateInput>;
};

/** Input for the nested mutation of `legacySeasonStat` in the `LegacyPlayerInput` mutation. */
export type FakePublicLegacySeasonStatsForeignKey1InverseInput = {
  /** A `LegacySeasonStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicLegacySeasonStatsForeignKey1LegacySeasonStatsCreateInput>>;
};

/** The `legacyPlayer` to be created by this mutation. */
export type FakePublicLegacySeasonStatsForeignKey1LegacyPlayerCreateInput = {
  playerId: Scalars['Int'];
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** The `legacySeasonStat` to be created by this mutation. */
export type FakePublicLegacySeasonStatsForeignKey1LegacySeasonStatsCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['BigInt']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicLegacySeasonStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicLegacySeasonStatsForeignKey1Input>;
  group?: Maybe<FakePublicLegacySeasonStatsForeignKey2Input>;
};

/** The `group` to be created by this mutation. */
export type FakePublicLegacySeasonStatsForeignKey2GroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** Input for the nested mutation of `group` in the `LegacySeasonStatInput` mutation. */
export type FakePublicLegacySeasonStatsForeignKey2Input = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2UsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2UsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacySeasonStatOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2NodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicLegacySeasonStatsForeignKey2GroupCreateInput>;
};

/** Input for the nested mutation of `legacySeasonStat` in the `GroupInput` mutation. */
export type FakePublicLegacySeasonStatsForeignKey2InverseInput = {
  /** A `LegacySeasonStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicLegacySeasonStatsForeignKey2LegacySeasonStatsCreateInput>>;
};

/** The `legacySeasonStat` to be created by this mutation. */
export type FakePublicLegacySeasonStatsForeignKey2LegacySeasonStatsCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['BigInt']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicLegacySeasonStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicLegacySeasonStatsForeignKey1Input>;
  group?: Maybe<FakePublicLegacySeasonStatsForeignKey2Input>;
};

/** Input for the nested mutation of `legacyPlayer` in the `PlayerInput` mutation. */
export type FakePublicPlayerForeignKey0Input = {
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyPlayerNodeIdConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyPlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByPlayerId?: Maybe<LegacyPlayerOnPlayerForFakePublicPlayerForeignKey0UsingFakePublicLegacyPlayerPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByNodeId?: Maybe<PlayerOnPlayerForFakePublicPlayerForeignKey0NodeIdUpdate>;
  /** A `LegacyPlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicPlayerForeignKey0LegacyPlayerCreateInput>;
};

/** Input for the nested mutation of `player` in the `LegacyPlayerInput` mutation. */
export type FakePublicPlayerForeignKey0InverseInput = {
  /** Flag indicating whether all other `player` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<Array<PlayerPlayerPkeyConnect>>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<Array<PlayerPlayerFirstNameLastNameKeyConnect>>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PlayerNodeIdConnect>>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<Array<PlayerPlayerPkeyDelete>>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<Array<PlayerPlayerFirstNameLastNameKeyDelete>>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PlayerNodeIdDelete>>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<Array<PlayerOnPlayerForFakePublicPlayerForeignKey0UsingPlayerPkeyUpdate>>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<Array<PlayerOnPlayerForFakePublicPlayerForeignKey0UsingPlayerFirstNameLastNameKeyUpdate>>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LegacyPlayerOnPlayerForFakePublicPlayerForeignKey0NodeIdUpdate>>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicPlayerForeignKey0PlayerCreateInput>>;
};

/** The `legacyPlayer` to be created by this mutation. */
export type FakePublicPlayerForeignKey0LegacyPlayerCreateInput = {
  playerId: Scalars['Int'];
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** The `player` to be created by this mutation. */
export type FakePublicPlayerForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** Input for the nested mutation of `player` in the `SeasonStatsAllTimeQualifiedBatterInput` mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0UsingPlayerFirstNameLastNameKeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatsAllTimeQualifiedBatterOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0PlayerCreateInput>;
};

/** Input for the nested mutation of `seasonStatsAllTimeQualifiedBatter` in the `PlayerInput` mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput = {
  /** A `SeasonStatsAllTimeQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0SeasonStatsAllTimeQualifiedBattersCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `seasonStatsAllTimeQualifiedBatter` to be created by this mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0SeasonStatsAllTimeQualifiedBattersCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['BigInt']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2Input>;
};

/** Input for the nested mutation of `legacyPlayer` in the `SeasonStatsAllTimeQualifiedBatterInput` mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1Input = {
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyPlayerNodeIdConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyPlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByPlayerId?: Maybe<LegacyPlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatsAllTimeQualifiedBatterOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1NodeIdUpdate>;
  /** A `LegacyPlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1LegacyPlayerCreateInput>;
};

/** Input for the nested mutation of `seasonStatsAllTimeQualifiedBatter` in the `LegacyPlayerInput` mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput = {
  /** A `SeasonStatsAllTimeQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1SeasonStatsAllTimeQualifiedBattersCreateInput>>;
};

/** The `legacyPlayer` to be created by this mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1LegacyPlayerCreateInput = {
  playerId: Scalars['Int'];
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** The `seasonStatsAllTimeQualifiedBatter` to be created by this mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1SeasonStatsAllTimeQualifiedBattersCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['BigInt']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2Input>;
};

/** The `group` to be created by this mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2GroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** Input for the nested mutation of `group` in the `SeasonStatsAllTimeQualifiedBatterInput` mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2Input = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2UsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2UsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatsAllTimeQualifiedBatterOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2NodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2GroupCreateInput>;
};

/** Input for the nested mutation of `seasonStatsAllTimeQualifiedBatter` in the `GroupInput` mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput = {
  /** A `SeasonStatsAllTimeQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2SeasonStatsAllTimeQualifiedBattersCreateInput>>;
};

/** The `seasonStatsAllTimeQualifiedBatter` to be created by this mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2SeasonStatsAllTimeQualifiedBattersCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['BigInt']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2Input>;
};

/** Input for the nested mutation of `player` in the `SeasonStatInput` mutation. */
export type FakePublicSeasonStatsForeignKey0Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnSeasonStatForFakePublicSeasonStatsForeignKey0UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnSeasonStatForFakePublicSeasonStatsForeignKey0UsingPlayerFirstNameLastNameKeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatOnSeasonStatForFakePublicSeasonStatsForeignKey0NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsForeignKey0PlayerCreateInput>;
};

/** Input for the nested mutation of `seasonStat` in the `PlayerInput` mutation. */
export type FakePublicSeasonStatsForeignKey0InverseInput = {
  /** A `SeasonStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsForeignKey0SeasonStatsCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type FakePublicSeasonStatsForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `seasonStat` to be created by this mutation. */
export type FakePublicSeasonStatsForeignKey0SeasonStatsCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['BigInt']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsForeignKey2Input>;
};

/** Input for the nested mutation of `legacyPlayer` in the `SeasonStatInput` mutation. */
export type FakePublicSeasonStatsForeignKey1Input = {
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyPlayerNodeIdConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyPlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByPlayerId?: Maybe<LegacyPlayerOnSeasonStatForFakePublicSeasonStatsForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatOnSeasonStatForFakePublicSeasonStatsForeignKey1NodeIdUpdate>;
  /** A `LegacyPlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsForeignKey1LegacyPlayerCreateInput>;
};

/** Input for the nested mutation of `seasonStat` in the `LegacyPlayerInput` mutation. */
export type FakePublicSeasonStatsForeignKey1InverseInput = {
  /** A `SeasonStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsForeignKey1SeasonStatsCreateInput>>;
};

/** The `legacyPlayer` to be created by this mutation. */
export type FakePublicSeasonStatsForeignKey1LegacyPlayerCreateInput = {
  playerId: Scalars['Int'];
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** The `seasonStat` to be created by this mutation. */
export type FakePublicSeasonStatsForeignKey1SeasonStatsCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['BigInt']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsForeignKey2Input>;
};

/** The `group` to be created by this mutation. */
export type FakePublicSeasonStatsForeignKey2GroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** Input for the nested mutation of `group` in the `SeasonStatInput` mutation. */
export type FakePublicSeasonStatsForeignKey2Input = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnSeasonStatForFakePublicSeasonStatsForeignKey2UsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnSeasonStatForFakePublicSeasonStatsForeignKey2UsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatOnSeasonStatForFakePublicSeasonStatsForeignKey2NodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsForeignKey2GroupCreateInput>;
};

/** Input for the nested mutation of `seasonStat` in the `GroupInput` mutation. */
export type FakePublicSeasonStatsForeignKey2InverseInput = {
  /** A `SeasonStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsForeignKey2SeasonStatsCreateInput>>;
};

/** The `seasonStat` to be created by this mutation. */
export type FakePublicSeasonStatsForeignKey2SeasonStatsCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['BigInt']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsForeignKey2Input>;
};

/** Input for the nested mutation of `player` in the `SeasonStatsQualifiedBatterInput` mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey0Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0UsingPlayerFirstNameLastNameKeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatsQualifiedBatterOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0PlayerCreateInput>;
};

/** Input for the nested mutation of `seasonStatsQualifiedBatter` in the `PlayerInput` mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput = {
  /** A `SeasonStatsQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsQualifiedBattersForeignKey0SeasonStatsQualifiedBattersCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `seasonStatsQualifiedBatter` to be created by this mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey0SeasonStatsQualifiedBattersCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['BigInt']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2Input>;
};

/** Input for the nested mutation of `legacyPlayer` in the `SeasonStatsQualifiedBatterInput` mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey1Input = {
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyPlayerNodeIdConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyPlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByPlayerId?: Maybe<LegacyPlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatsQualifiedBatterOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey1NodeIdUpdate>;
  /** A `LegacyPlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1LegacyPlayerCreateInput>;
};

/** Input for the nested mutation of `seasonStatsQualifiedBatter` in the `LegacyPlayerInput` mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput = {
  /** A `SeasonStatsQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsQualifiedBattersForeignKey1SeasonStatsQualifiedBattersCreateInput>>;
};

/** The `legacyPlayer` to be created by this mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey1LegacyPlayerCreateInput = {
  playerId: Scalars['Int'];
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** The `seasonStatsQualifiedBatter` to be created by this mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey1SeasonStatsQualifiedBattersCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['BigInt']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2Input>;
};

/** The `group` to be created by this mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey2GroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** Input for the nested mutation of `group` in the `SeasonStatsQualifiedBatterInput` mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey2Input = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2UsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2UsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatsQualifiedBatterOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2NodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2GroupCreateInput>;
};

/** Input for the nested mutation of `seasonStatsQualifiedBatter` in the `GroupInput` mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput = {
  /** A `SeasonStatsQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsQualifiedBattersForeignKey2SeasonStatsQualifiedBattersCreateInput>>;
};

/** The `seasonStatsQualifiedBatter` to be created by this mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey2SeasonStatsQualifiedBattersCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['BigInt']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2Input>;
};

export type Field = Node & {
  __typename?: 'Field';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  name: Scalars['String'];
  notes: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `Game`. */
  games: Array<Game>;
};


export type FieldGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GamesOrderBy>>;
  condition?: Maybe<GameCondition>;
};

/** A condition to be used against `Field` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FieldCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
};

/** The fields on `field` to look up the row to connect. */
export type FieldFieldPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `field` to look up the row to delete. */
export type FieldFieldPkeyDelete = {
  id: Scalars['UUID'];
};

/** An input for mutations affecting `Field` */
export type FieldInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  games?: Maybe<GameFieldIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type FieldNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `field` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type FieldNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `field` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type FieldOnGameForGameFieldIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `field` to look up the row to update. */
export type FieldOnGameForGameFieldIdFkeyUsingFieldPkeyUpdate = {
  /** An object where the defined keys will be set on the `field` being updated. */
  patch: UpdateFieldOnGameForGameFieldIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Field`. Fields that are set will be updated. */
export type FieldPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  games?: Maybe<GameFieldIdFkeyInverseInput>;
};

export enum FieldingPosition {
  PITCHER = 'PITCHER',
  CATCHER = 'CATCHER',
  FIRST_BASE = 'FIRST_BASE',
  SECOND_BASE = 'SECOND_BASE',
  THIRD_BASE = 'THIRD_BASE',
  SHORTSTOP = 'SHORTSTOP',
  LEFT_FIELD = 'LEFT_FIELD',
  CENTER_FIELD = 'CENTER_FIELD',
  LEFT_CENTER = 'LEFT_CENTER',
  RIGHT_CENTER = 'RIGHT_CENTER',
  RIGHT_FIELD = 'RIGHT_FIELD'
}

/** Methods to use when ordering `Field`. */
export enum FieldsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  NOTES_ASC = 'NOTES_ASC',
  NOTES_DESC = 'NOTES_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type ForeignDbField = {
  __typename?: 'ForeignDbField';
  fieldId: Scalars['Int'];
  fieldName: Scalars['String'];
  fieldAddress: Scalars['String'];
  fieldNumber: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `ForeignDbField` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ForeignDbFieldCondition = {
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `fieldName` field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fieldAddress` field. */
  fieldAddress?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fieldNumber` field. */
  fieldNumber?: Maybe<Scalars['String']>;
};

/** An input for mutations affecting `ForeignDbField` */
export type ForeignDbFieldInput = {
  fieldId: Scalars['Int'];
  fieldName: Scalars['String'];
  fieldAddress: Scalars['String'];
  fieldNumber?: Maybe<Scalars['String']>;
};

/** Methods to use when ordering `ForeignDbField`. */
export enum ForeignDbFieldsOrderBy {
  NATURAL = 'NATURAL',
  FIELD_ID_ASC = 'FIELD_ID_ASC',
  FIELD_ID_DESC = 'FIELD_ID_DESC',
  FIELD_NAME_ASC = 'FIELD_NAME_ASC',
  FIELD_NAME_DESC = 'FIELD_NAME_DESC',
  FIELD_ADDRESS_ASC = 'FIELD_ADDRESS_ASC',
  FIELD_ADDRESS_DESC = 'FIELD_ADDRESS_DESC',
  FIELD_NUMBER_ASC = 'FIELD_NUMBER_ASC',
  FIELD_NUMBER_DESC = 'FIELD_NUMBER_DESC'
}

export type ForeignDbGame = {
  __typename?: 'ForeignDbGame';
  gameId: Scalars['Int'];
  gameTitle: Scalars['String'];
  gameDate: Scalars['Date'];
  gameStartTime: Scalars['Time'];
  gameEndTime: Scalars['Time'];
  gameTeamId1: Scalars['Int'];
  gameTeamId2: Scalars['Int'];
  season: Scalars['Int'];
};

/**
 * A condition to be used against `ForeignDbGame` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ForeignDbGameCondition = {
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameTitle` field. */
  gameTitle?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `gameDate` field. */
  gameDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `gameStartTime` field. */
  gameStartTime?: Maybe<Scalars['Time']>;
  /** Checks for equality with the object’s `gameEndTime` field. */
  gameEndTime?: Maybe<Scalars['Time']>;
  /** Checks for equality with the object’s `gameTeamId1` field. */
  gameTeamId1?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameTeamId2` field. */
  gameTeamId2?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
};

/** An input for mutations affecting `ForeignDbGame` */
export type ForeignDbGameInput = {
  gameId: Scalars['Int'];
  gameTitle: Scalars['String'];
  gameDate: Scalars['Date'];
  gameStartTime: Scalars['Time'];
  gameEndTime: Scalars['Time'];
  gameTeamId1: Scalars['Int'];
  gameTeamId2: Scalars['Int'];
  season: Scalars['Int'];
};

/** Methods to use when ordering `ForeignDbGame`. */
export enum ForeignDbGamesOrderBy {
  NATURAL = 'NATURAL',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  GAME_TITLE_ASC = 'GAME_TITLE_ASC',
  GAME_TITLE_DESC = 'GAME_TITLE_DESC',
  GAME_DATE_ASC = 'GAME_DATE_ASC',
  GAME_DATE_DESC = 'GAME_DATE_DESC',
  GAME_START_TIME_ASC = 'GAME_START_TIME_ASC',
  GAME_START_TIME_DESC = 'GAME_START_TIME_DESC',
  GAME_END_TIME_ASC = 'GAME_END_TIME_ASC',
  GAME_END_TIME_DESC = 'GAME_END_TIME_DESC',
  GAME_TEAM_ID_1_ASC = 'GAME_TEAM_ID_1_ASC',
  GAME_TEAM_ID_1_DESC = 'GAME_TEAM_ID_1_DESC',
  GAME_TEAM_ID_2_ASC = 'GAME_TEAM_ID_2_ASC',
  GAME_TEAM_ID_2_DESC = 'GAME_TEAM_ID_2_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC'
}

export type ForeignDbPlayer = {
  __typename?: 'ForeignDbPlayer';
  playerId: Scalars['Int'];
  playerName: Scalars['String'];
  playerImage: Maybe<Scalars['String']>;
  memberId: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `ForeignDbPlayer` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ForeignDbPlayerCondition = {
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerName` field. */
  playerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `playerImage` field. */
  playerImage?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars['String']>;
};

/** An input for mutations affecting `ForeignDbPlayer` */
export type ForeignDbPlayerInput = {
  playerId: Scalars['Int'];
  playerName: Scalars['String'];
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
};

/** Methods to use when ordering `ForeignDbPlayer`. */
export enum ForeignDbPlayersOrderBy {
  NATURAL = 'NATURAL',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  PLAYER_NAME_ASC = 'PLAYER_NAME_ASC',
  PLAYER_NAME_DESC = 'PLAYER_NAME_DESC',
  PLAYER_IMAGE_ASC = 'PLAYER_IMAGE_ASC',
  PLAYER_IMAGE_DESC = 'PLAYER_IMAGE_DESC',
  MEMBER_ID_ASC = 'MEMBER_ID_ASC',
  MEMBER_ID_DESC = 'MEMBER_ID_DESC'
}

export type ForeignDbStatLine = {
  __typename?: 'ForeignDbStatLine';
  sbStatsId: Scalars['Int'];
  playerId: Scalars['Int'];
  gameId: Scalars['Int'];
  sbStatsTeam: Scalars['Int'];
  sbStatsAb: Scalars['Int'];
  sbStatsRuns: Scalars['Int'];
  sbStatsHits: Scalars['Int'];
  sbStats1B: Scalars['Int'];
  sbStats2B: Scalars['Int'];
  sbStats3B: Scalars['Int'];
  sbStatsHr: Scalars['Int'];
  sbStatsRbi: Scalars['Int'];
  sbStatsBb: Scalars['Int'];
  sbStatsSo: Scalars['Int'];
  sbStatsSac: Scalars['Int'];
};

/**
 * A condition to be used against `ForeignDbStatLine` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ForeignDbStatLineCondition = {
  /** Checks for equality with the object’s `sbStatsId` field. */
  sbStatsId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsTeam` field. */
  sbStatsTeam?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsAb` field. */
  sbStatsAb?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsRuns` field. */
  sbStatsRuns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsHits` field. */
  sbStatsHits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStats1B` field. */
  sbStats1B?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStats2B` field. */
  sbStats2B?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStats3B` field. */
  sbStats3B?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsHr` field. */
  sbStatsHr?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsRbi` field. */
  sbStatsRbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsBb` field. */
  sbStatsBb?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsSo` field. */
  sbStatsSo?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsSac` field. */
  sbStatsSac?: Maybe<Scalars['Int']>;
};

/** An input for mutations affecting `ForeignDbStatLine` */
export type ForeignDbStatLineInput = {
  sbStatsId: Scalars['Int'];
  playerId: Scalars['Int'];
  gameId: Scalars['Int'];
  sbStatsTeam: Scalars['Int'];
  sbStatsAb: Scalars['Int'];
  sbStatsRuns: Scalars['Int'];
  sbStatsHits: Scalars['Int'];
  sbStats1B: Scalars['Int'];
  sbStats2B: Scalars['Int'];
  sbStats3B: Scalars['Int'];
  sbStatsHr: Scalars['Int'];
  sbStatsRbi: Scalars['Int'];
  sbStatsBb: Scalars['Int'];
  sbStatsSo: Scalars['Int'];
  sbStatsSac: Scalars['Int'];
};

/** Methods to use when ordering `ForeignDbStatLine`. */
export enum ForeignDbStatLinesOrderBy {
  NATURAL = 'NATURAL',
  SB_STATS_ID_ASC = 'SB_STATS_ID_ASC',
  SB_STATS_ID_DESC = 'SB_STATS_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  SB_STATS_TEAM_ASC = 'SB_STATS_TEAM_ASC',
  SB_STATS_TEAM_DESC = 'SB_STATS_TEAM_DESC',
  SB_STATS_AB_ASC = 'SB_STATS_AB_ASC',
  SB_STATS_AB_DESC = 'SB_STATS_AB_DESC',
  SB_STATS_RUNS_ASC = 'SB_STATS_RUNS_ASC',
  SB_STATS_RUNS_DESC = 'SB_STATS_RUNS_DESC',
  SB_STATS_HITS_ASC = 'SB_STATS_HITS_ASC',
  SB_STATS_HITS_DESC = 'SB_STATS_HITS_DESC',
  SB_STATS_1B_ASC = 'SB_STATS_1B_ASC',
  SB_STATS_1B_DESC = 'SB_STATS_1B_DESC',
  SB_STATS_2B_ASC = 'SB_STATS_2B_ASC',
  SB_STATS_2B_DESC = 'SB_STATS_2B_DESC',
  SB_STATS_3B_ASC = 'SB_STATS_3B_ASC',
  SB_STATS_3B_DESC = 'SB_STATS_3B_DESC',
  SB_STATS_HR_ASC = 'SB_STATS_HR_ASC',
  SB_STATS_HR_DESC = 'SB_STATS_HR_DESC',
  SB_STATS_RBI_ASC = 'SB_STATS_RBI_ASC',
  SB_STATS_RBI_DESC = 'SB_STATS_RBI_DESC',
  SB_STATS_BB_ASC = 'SB_STATS_BB_ASC',
  SB_STATS_BB_DESC = 'SB_STATS_BB_DESC',
  SB_STATS_SO_ASC = 'SB_STATS_SO_ASC',
  SB_STATS_SO_DESC = 'SB_STATS_SO_DESC',
  SB_STATS_SAC_ASC = 'SB_STATS_SAC_ASC',
  SB_STATS_SAC_DESC = 'SB_STATS_SAC_DESC'
}

export type ForeignDbTeam = {
  __typename?: 'ForeignDbTeam';
  teamId: Scalars['Int'];
  teamName: Scalars['String'];
};

/**
 * A condition to be used against `ForeignDbTeam` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ForeignDbTeamCondition = {
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `teamName` field. */
  teamName?: Maybe<Scalars['String']>;
};

/** An input for mutations affecting `ForeignDbTeam` */
export type ForeignDbTeamInput = {
  teamId: Scalars['Int'];
  teamName: Scalars['String'];
};

/** Methods to use when ordering `ForeignDbTeam`. */
export enum ForeignDbTeamsOrderBy {
  NATURAL = 'NATURAL',
  TEAM_ID_ASC = 'TEAM_ID_ASC',
  TEAM_ID_DESC = 'TEAM_ID_DESC',
  TEAM_NAME_ASC = 'TEAM_NAME_ASC',
  TEAM_NAME_DESC = 'TEAM_NAME_DESC'
}

export type Game = Node & {
  __typename?: 'Game';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  groupId: Scalars['UUID'];
  name: Maybe<Scalars['String']>;
  fieldId: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength: Scalars['Int'];
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved: Scalars['Datetime'];
  /** Reads a single `Group` that is related to this `Game`. */
  group: Maybe<Group>;
  /** Reads a single `Field` that is related to this `Game`. */
  field: Maybe<Field>;
  /** Reads and enables pagination through a set of `Team`. */
  teams: Array<Team>;
  /** Reads and enables pagination through a set of `GameState`. */
  gameStates: Array<GameState>;
  /** Reads and enables pagination through a set of `GameEventRecord`. */
  gameEventRecords: Array<GameEventRecord>;
  /** Reads and enables pagination through a set of `TraditionalStatLine`. */
  boxScore: Maybe<Array<Maybe<TraditionalStatLine>>>;
  /** Reads and enables pagination through a set of `LineScoreCell`. */
  lineScore: Maybe<Array<Maybe<LineScoreCell>>>;
};


export type GameTeamsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<TeamsOrderBy>>;
  condition?: Maybe<TeamCondition>;
};


export type GameGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameStatesOrderBy>>;
  condition?: Maybe<GameStateCondition>;
};


export type GameGameEventRecordsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventRecordsOrderBy>>;
  condition?: Maybe<GameEventRecordCondition>;
};


export type GameBoxScoreArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};


export type GameLineScoreArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};

/** A condition to be used against `Game` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GameCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `score` field. */
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  /** Checks for equality with the object’s `gameLength` field. */
  gameLength?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `timeStarted` field. */
  timeStarted?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `timeEnded` field. */
  timeEnded?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `timeSaved` field. */
  timeSaved?: Maybe<Scalars['Datetime']>;
};

export type GameEvent = Node & {
  __typename?: 'GameEvent';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  plateAppearanceId: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId: Maybe<Scalars['UUID']>;
  lineupChangeId: Maybe<Scalars['UUID']>;
  /** Reads a single `PlateAppearance` that is related to this `GameEvent`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `StolenBaseAttempt` that is related to this `GameEvent`. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Reads a single `LineupChange` that is related to this `GameEvent`. */
  lineupChange: Maybe<LineupChange>;
  /** Reads and enables pagination through a set of `GameEventRecord`. */
  gameEventRecords: Array<GameEventRecord>;
};


export type GameEventGameEventRecordsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventRecordsOrderBy>>;
  condition?: Maybe<GameEventRecordCondition>;
};

/**
 * A condition to be used against `GameEvent` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GameEventCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `plateAppearanceId` field. */
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `stolenBaseAttemptId` field. */
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `lineupChangeId` field. */
  lineupChangeId?: Maybe<Scalars['UUID']>;
};

/** The fields on `gameEvent` to look up the row to connect. */
export type GameEventGameEventPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `gameEvent` to look up the row to delete. */
export type GameEventGameEventPkeyDelete = {
  id: Scalars['UUID'];
};

/** An input for mutations affecting `GameEvent` */
export type GameEventInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventLineupChangeIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `lineupChange` in the `GameEventInput` mutation. */
export type GameEventLineupChangeIdFkeyInput = {
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectById?: Maybe<LineupChangeLineupChangePkeyConnect>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectByNodeId?: Maybe<LineupChangeNodeIdConnect>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteById?: Maybe<LineupChangeLineupChangePkeyDelete>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LineupChangeNodeIdDelete>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateById?: Maybe<LineupChangeOnGameEventForGameEventLineupChangeIdFkeyUsingLineupChangePkeyUpdate>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate>;
  /** A `LineupChangeInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventLineupChangeIdFkeyLineupChangeCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `LineupChangeInput` mutation. */
export type GameEventLineupChangeIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventLineupChangeIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LineupChangeOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventLineupChangeIdFkeyGameEventCreateInput>>;
};

/** The `lineupChange` to be created by this mutation. */
export type GameEventLineupChangeIdFkeyLineupChangeCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GameEventNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GameEventNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: LineupChangePatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventLineupChangeIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventLineupChangeIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventPlateAppearanceIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventPlateAppearanceIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `stolenBaseAttempt` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: StolenBaseAttemptPatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `GameEvent`. Fields that are set will be updated. */
export type GameEventPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventPlateAppearanceIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `plateAppearance` in the `GameEventInput` mutation. */
export type GameEventPlateAppearanceIdFkeyInput = {
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectById?: Maybe<PlateAppearancePlateAppearancePkeyConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlateAppearanceNodeIdConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteById?: Maybe<PlateAppearancePlateAppearancePkeyDelete>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlateAppearanceNodeIdDelete>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateById?: Maybe<PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate>;
  /** A `PlateAppearanceInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventPlateAppearanceIdFkeyPlateAppearanceCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `PlateAppearanceInput` mutation. */
export type GameEventPlateAppearanceIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventPlateAppearanceIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventPlateAppearanceIdFkeyGameEventCreateInput>>;
};

/** The `plateAppearance` to be created by this mutation. */
export type GameEventPlateAppearanceIdFkeyPlateAppearanceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

export type GameEventRecord = Node & {
  __typename?: 'GameEventRecord';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
  gameStateBeforeId: Scalars['UUID'];
  gameStateAfterId: Scalars['UUID'];
  gameEventId: Scalars['UUID'];
  notes: Maybe<Scalars['String']>;
  /** Reads a single `Game` that is related to this `GameEventRecord`. */
  game: Maybe<Game>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateBefore: Maybe<GameState>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateAfter: Maybe<GameState>;
  /** Reads a single `GameEvent` that is related to this `GameEventRecord`. */
  gameEvent: Maybe<GameEvent>;
  /** Reads and enables pagination through a set of `ScoredRunner`. */
  scoredRunners: Array<ScoredRunner>;
};


export type GameEventRecordScoredRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ScoredRunnersOrderBy>>;
  condition?: Maybe<ScoredRunnerCondition>;
};

/**
 * A condition to be used against `GameEventRecord` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type GameEventRecordCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `eventIndex` field. */
  eventIndex?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameStateBeforeId` field. */
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameStateAfterId` field. */
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameEventId` field. */
  gameEventId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventRecordGameEventIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** The `gameEventRecord` to be created by this mutation. */
export type GameEventRecordGameEventIdFkeyGameEventRecordCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** Input for the nested mutation of `gameEvent` in the `GameEventRecordInput` mutation. */
export type GameEventRecordGameEventIdFkeyInput = {
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<GameEventGameEventPkeyConnect>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameEventNodeIdConnect>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<GameEventGameEventPkeyDelete>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameEventNodeIdDelete>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventPkeyUpdate>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventRecordGameEventIdFkeyGameEventCreateInput>;
};

/** Input for the nested mutation of `gameEventRecord` in the `GameEventInput` mutation. */
export type GameEventRecordGameEventIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventRecordGameEventRecordPkeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventRecordNodeIdConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventRecordGameEventRecordPkeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventRecordNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByGameIdAndEventIndex?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate>>;
  /** A `GameEventRecordInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventRecordGameEventIdFkeyGameEventRecordCreateInput>>;
};

/** The fields on `gameEventRecord` to look up the row to connect. */
export type GameEventRecordGameEventRecordGameIdEventIndexKeyConnect = {
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to delete. */
export type GameEventRecordGameEventRecordGameIdEventIndexKeyDelete = {
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to connect. */
export type GameEventRecordGameEventRecordPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `gameEventRecord` to look up the row to delete. */
export type GameEventRecordGameEventRecordPkeyDelete = {
  id: Scalars['UUID'];
};

/** The `game` to be created by this mutation. */
export type GameEventRecordGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
};

/** The `gameEventRecord` to be created by this mutation. */
export type GameEventRecordGameIdFkeyGameEventRecordCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** Input for the nested mutation of `game` in the `GameEventRecordInput` mutation. */
export type GameEventRecordGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByName?: Maybe<GameGameNameKeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByName?: Maybe<GameGameNameKeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByName?: Maybe<GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameNameKeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventRecordGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `gameEventRecord` in the `GameInput` mutation. */
export type GameEventRecordGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventRecordGameEventRecordPkeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventRecordNodeIdConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventRecordGameEventRecordPkeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventRecordNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByGameIdAndEventIndex?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate>>;
  /** A `GameEventRecordInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventRecordGameIdFkeyGameEventRecordCreateInput>>;
};

/** The `gameEventRecord` to be created by this mutation. */
export type GameEventRecordGameStateAfterFkGameEventRecordCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** The `gameState` to be created by this mutation. */
export type GameEventRecordGameStateAfterFkGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `gameState` in the `GameEventRecordInput` mutation. */
export type GameEventRecordGameStateAfterFkInput = {
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<GameStateGameStatePkeyConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameStateNodeIdConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<GameStateGameStatePkeyDelete>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameStateNodeIdDelete>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameStatePkeyUpdate>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventRecordGameStateAfterFkGameStateCreateInput>;
};

/** Input for the nested mutation of `gameEventRecord` in the `GameStateInput` mutation. */
export type GameEventRecordGameStateAfterFkInverseInput = {
  /** Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventRecordGameEventRecordPkeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventRecordNodeIdConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventRecordGameEventRecordPkeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventRecordNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByGameIdAndEventIndex?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordGameIdEventIndexKeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate>>;
  /** A `GameEventRecordInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventRecordGameStateAfterFkGameEventRecordCreateInput>>;
};

/** The `gameEventRecord` to be created by this mutation. */
export type GameEventRecordGameStateBeforeFkGameEventRecordCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** The `gameState` to be created by this mutation. */
export type GameEventRecordGameStateBeforeFkGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `gameState` in the `GameEventRecordInput` mutation. */
export type GameEventRecordGameStateBeforeFkInput = {
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<GameStateGameStatePkeyConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameStateNodeIdConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<GameStateGameStatePkeyDelete>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameStateNodeIdDelete>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameStatePkeyUpdate>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventRecordGameStateBeforeFkGameStateCreateInput>;
};

/** Input for the nested mutation of `gameEventRecord` in the `GameStateInput` mutation. */
export type GameEventRecordGameStateBeforeFkInverseInput = {
  /** Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventRecordGameEventRecordPkeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventRecordNodeIdConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventRecordGameEventRecordPkeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventRecordNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByGameIdAndEventIndex?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordGameIdEventIndexKeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate>>;
  /** A `GameEventRecordInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventRecordGameStateBeforeFkGameEventRecordCreateInput>>;
};

/** An input for mutations affecting `GameEventRecord` */
export type GameEventRecordInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GameEventRecordNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GameEventRecordNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordGameIdEventIndexKeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordGameIdEventIndexKeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scoredRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: ScoredRunnerPatch;
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `GameEventRecord`. Fields that are set will be updated. */
export type GameEventRecordPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** Methods to use when ordering `GameEventRecord`. */
export enum GameEventRecordsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  EVENT_INDEX_ASC = 'EVENT_INDEX_ASC',
  EVENT_INDEX_DESC = 'EVENT_INDEX_DESC',
  GAME_STATE_BEFORE_ID_ASC = 'GAME_STATE_BEFORE_ID_ASC',
  GAME_STATE_BEFORE_ID_DESC = 'GAME_STATE_BEFORE_ID_DESC',
  GAME_STATE_AFTER_ID_ASC = 'GAME_STATE_AFTER_ID_ASC',
  GAME_STATE_AFTER_ID_DESC = 'GAME_STATE_AFTER_ID_DESC',
  GAME_EVENT_ID_ASC = 'GAME_EVENT_ID_ASC',
  GAME_EVENT_ID_DESC = 'GAME_EVENT_ID_DESC',
  NOTES_ASC = 'NOTES_ASC',
  NOTES_DESC = 'NOTES_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** The `gameEvent` to be created by this mutation. */
export type GameEventStolenBaseAttemptIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `stolenBaseAttempt` in the `GameEventInput` mutation. */
export type GameEventStolenBaseAttemptIdFkeyInput = {
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectById?: Maybe<StolenBaseAttemptStolenBaseAttemptPkeyConnect>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectByNodeId?: Maybe<StolenBaseAttemptNodeIdConnect>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteById?: Maybe<StolenBaseAttemptStolenBaseAttemptPkeyDelete>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteByNodeId?: Maybe<StolenBaseAttemptNodeIdDelete>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateById?: Maybe<StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingStolenBaseAttemptPkeyUpdate>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate>;
  /** A `StolenBaseAttemptInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventStolenBaseAttemptIdFkeyStolenBaseAttemptCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `StolenBaseAttemptInput` mutation. */
export type GameEventStolenBaseAttemptIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventStolenBaseAttemptIdFkeyGameEventCreateInput>>;
};

/** The `stolenBaseAttempt` to be created by this mutation. */
export type GameEventStolenBaseAttemptIdFkeyStolenBaseAttemptCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success: Scalars['Boolean'];
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** Methods to use when ordering `GameEvent`. */
export enum GameEventsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  PLATE_APPEARANCE_ID_ASC = 'PLATE_APPEARANCE_ID_ASC',
  PLATE_APPEARANCE_ID_DESC = 'PLATE_APPEARANCE_ID_DESC',
  STOLEN_BASE_ATTEMPT_ID_ASC = 'STOLEN_BASE_ATTEMPT_ID_ASC',
  STOLEN_BASE_ATTEMPT_ID_DESC = 'STOLEN_BASE_ATTEMPT_ID_DESC',
  LINEUP_CHANGE_ID_ASC = 'LINEUP_CHANGE_ID_ASC',
  LINEUP_CHANGE_ID_DESC = 'LINEUP_CHANGE_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** The `field` to be created by this mutation. */
export type GameFieldIdFkeyFieldCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  games?: Maybe<GameFieldIdFkeyInverseInput>;
};

/** The `game` to be created by this mutation. */
export type GameFieldIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
};

/** Input for the nested mutation of `field` in the `GameInput` mutation. */
export type GameFieldIdFkeyInput = {
  /** The primary key(s) for `field` for the far side of the relationship. */
  connectById?: Maybe<FieldFieldPkeyConnect>;
  /** The primary key(s) for `field` for the far side of the relationship. */
  connectByNodeId?: Maybe<FieldNodeIdConnect>;
  /** The primary key(s) for `field` for the far side of the relationship. */
  deleteById?: Maybe<FieldFieldPkeyDelete>;
  /** The primary key(s) for `field` for the far side of the relationship. */
  deleteByNodeId?: Maybe<FieldNodeIdDelete>;
  /** The primary key(s) and patch data for `field` for the far side of the relationship. */
  updateById?: Maybe<FieldOnGameForGameFieldIdFkeyUsingFieldPkeyUpdate>;
  /** The primary key(s) and patch data for `field` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameOnGameForGameFieldIdFkeyNodeIdUpdate>;
  /** A `FieldInput` object that will be created and connected to this object. */
  create?: Maybe<GameFieldIdFkeyFieldCreateInput>;
};

/** Input for the nested mutation of `game` in the `FieldInput` mutation. */
export type GameFieldIdFkeyInverseInput = {
  /** Flag indicating whether all other `game` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<Array<GameGamePkeyConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByName?: Maybe<Array<GameGameNameKeyConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameNodeIdConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameGamePkeyDelete>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByName?: Maybe<Array<GameGameNameKeyDelete>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameNodeIdDelete>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<Array<GameOnGameForGameFieldIdFkeyUsingGamePkeyUpdate>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByName?: Maybe<Array<GameOnGameForGameFieldIdFkeyUsingGameNameKeyUpdate>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<FieldOnGameForGameFieldIdFkeyNodeIdUpdate>>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameFieldIdFkeyGameCreateInput>>;
};

/** The fields on `game` to look up the row to connect. */
export type GameGameNameKeyConnect = {
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to delete. */
export type GameGameNameKeyDelete = {
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to connect. */
export type GameGamePkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `game` to look up the row to delete. */
export type GameGamePkeyDelete = {
  id: Scalars['UUID'];
};

/** The `game` to be created by this mutation. */
export type GameGroupIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
};

/** The `group` to be created by this mutation. */
export type GameGroupIdFkeyGroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** Input for the nested mutation of `group` in the `GameInput` mutation. */
export type GameGroupIdFkeyInput = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnGameForGameGroupIdFkeyUsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnGameForGameGroupIdFkeyUsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameOnGameForGameGroupIdFkeyNodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<GameGroupIdFkeyGroupCreateInput>;
};

/** Input for the nested mutation of `game` in the `GroupInput` mutation. */
export type GameGroupIdFkeyInverseInput = {
  /** Flag indicating whether all other `game` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<Array<GameGamePkeyConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByName?: Maybe<Array<GameGameNameKeyConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameNodeIdConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameGamePkeyDelete>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByName?: Maybe<Array<GameGameNameKeyDelete>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameNodeIdDelete>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<Array<GameOnGameForGameGroupIdFkeyUsingGamePkeyUpdate>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByName?: Maybe<Array<GameOnGameForGameGroupIdFkeyUsingGameNameKeyUpdate>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GroupOnGameForGameGroupIdFkeyNodeIdUpdate>>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameGroupIdFkeyGameCreateInput>>;
};

/** An input for mutations affecting `Game` */
export type GameInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GameNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GameNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `game` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameNameKeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameEventRecordForGameEventRecordGameIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameEventRecordForGameEventRecordGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameForGameFieldIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `field` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `field` being updated. */
  patch: FieldPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameForGameFieldIdFkeyUsingGameNameKeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameForGameFieldIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameForGameFieldIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameForGameFieldIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameForGameGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameForGameGroupIdFkeyUsingGameNameKeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameForGameGroupIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameForGameGroupIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameForGameGroupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameStateForGameStateGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameStateForGameStateGameIdFkeyUsingGameNameKeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameStateForGameStateGameIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameStateForGameStateGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameStateForGameStateGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnTeamForTeamGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `team` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: TeamPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnTeamForTeamGameIdFkeyUsingGameNameKeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnTeamForTeamGameIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnTeamForTeamGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnTeamForTeamGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Game`. Fields that are set will be updated. */
export type GamePatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
};

export type GameState = Node & {
  __typename?: 'GameState';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  gameId: Scalars['UUID'];
  gameStateIndex: Scalars['Int'];
  playerAtBat: Scalars['UUID'];
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  /** Reads a single `Game` that is related to this `GameState`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `GameState`. */
  playerByPlayerAtBat: Maybe<Player>;
  /** Reads and enables pagination through a set of `BaseRunner`. */
  baseRunners: Array<BaseRunner>;
  /** Reads and enables pagination through a set of `LineupForGameState`. */
  lineupForGameStates: Array<LineupForGameState>;
  /** Reads and enables pagination through a set of `GameEventRecord`. */
  gameEventRecordsByGameStateBeforeId: Array<GameEventRecord>;
  /** Reads and enables pagination through a set of `GameEventRecord`. */
  gameEventRecordsByGameStateAfterId: Array<GameEventRecord>;
  /** Reads and enables pagination through a set of `Lineup`. */
  lineups: Maybe<Array<Maybe<Lineup>>>;
};


export type GameStateBaseRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BaseRunnersOrderBy>>;
  condition?: Maybe<BaseRunnerCondition>;
};


export type GameStateLineupForGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupForGameStatesOrderBy>>;
  condition?: Maybe<LineupForGameStateCondition>;
};


export type GameStateGameEventRecordsByGameStateBeforeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventRecordsOrderBy>>;
  condition?: Maybe<GameEventRecordCondition>;
};


export type GameStateGameEventRecordsByGameStateAfterIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventRecordsOrderBy>>;
  condition?: Maybe<GameEventRecordCondition>;
};


export type GameStateLineupsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};

/**
 * A condition to be used against `GameState` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GameStateCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameStateIndex` field. */
  gameStateIndex?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerAtBat` field. */
  playerAtBat?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `inning` field. */
  inning?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `halfInning` field. */
  halfInning?: Maybe<HalfInning>;
  /** Checks for equality with the object’s `outs` field. */
  outs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `score` field. */
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
};

/** The `game` to be created by this mutation. */
export type GameStateGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
};

/** The `gameState` to be created by this mutation. */
export type GameStateGameIdFkeyGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `game` in the `GameStateInput` mutation. */
export type GameStateGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByName?: Maybe<GameGameNameKeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByName?: Maybe<GameGameNameKeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnGameStateForGameStateGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByName?: Maybe<GameOnGameStateForGameStateGameIdFkeyUsingGameNameKeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameStateOnGameStateForGameStateGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<GameStateGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `gameState` in the `GameInput` mutation. */
export type GameStateGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameState` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<Array<GameStateGameStatePkeyConnect>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameStateNodeIdConnect>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameStateGameStatePkeyDelete>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameStateNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<Array<GameStateOnGameStateForGameStateGameIdFkeyUsingGameStatePkeyUpdate>>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnGameStateForGameStateGameIdFkeyNodeIdUpdate>>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameStateGameIdFkeyGameStateCreateInput>>;
};

/** The fields on `gameState` to look up the row to connect. */
export type GameStateGameStatePkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `gameState` to look up the row to delete. */
export type GameStateGameStatePkeyDelete = {
  id: Scalars['UUID'];
};

/** An input for mutations affecting `GameState` */
export type GameStateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GameStateNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GameStateNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `gameState` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `baseRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: BaseRunnerPatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnGameEventRecordForGameEventRecordGameStateAfterFkPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnGameStateForGameStateGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnGameStateForGameStateGameIdFkeyUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnGameStateForGameStateGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnGameStateForGameStatePlayerAtBatFkeyUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnGameStateForGameStatePlayerAtBatFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupForGameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: LineupForGameStatePatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `GameState`. Fields that are set will be updated. */
export type GameStatePatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** The `gameState` to be created by this mutation. */
export type GameStatePlayerAtBatFkeyGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `player` in the `GameStateInput` mutation. */
export type GameStatePlayerAtBatFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerFirstNameLastNameKeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameStateOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<GameStatePlayerAtBatFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `gameState` in the `PlayerInput` mutation. */
export type GameStatePlayerAtBatFkeyInverseInput = {
  /** Flag indicating whether all other `gameState` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<Array<GameStateGameStatePkeyConnect>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameStateNodeIdConnect>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameStateGameStatePkeyDelete>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameStateNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<Array<GameStateOnGameStateForGameStatePlayerAtBatFkeyUsingGameStatePkeyUpdate>>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate>>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameStatePlayerAtBatFkeyGameStateCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type GameStatePlayerAtBatFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** Methods to use when ordering `GameState`. */
export enum GameStatesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  GAME_STATE_INDEX_ASC = 'GAME_STATE_INDEX_ASC',
  GAME_STATE_INDEX_DESC = 'GAME_STATE_INDEX_DESC',
  PLAYER_AT_BAT_ASC = 'PLAYER_AT_BAT_ASC',
  PLAYER_AT_BAT_DESC = 'PLAYER_AT_BAT_DESC',
  INNING_ASC = 'INNING_ASC',
  INNING_DESC = 'INNING_DESC',
  HALF_INNING_ASC = 'HALF_INNING_ASC',
  HALF_INNING_DESC = 'HALF_INNING_DESC',
  OUTS_ASC = 'OUTS_ASC',
  OUTS_DESC = 'OUTS_DESC',
  SCORE_ASC = 'SCORE_ASC',
  SCORE_DESC = 'SCORE_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** Methods to use when ordering `Game`. */
export enum GamesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  FIELD_ID_ASC = 'FIELD_ID_ASC',
  FIELD_ID_DESC = 'FIELD_ID_DESC',
  SCORE_ASC = 'SCORE_ASC',
  SCORE_DESC = 'SCORE_DESC',
  GAME_LENGTH_ASC = 'GAME_LENGTH_ASC',
  GAME_LENGTH_DESC = 'GAME_LENGTH_DESC',
  TIME_STARTED_ASC = 'TIME_STARTED_ASC',
  TIME_STARTED_DESC = 'TIME_STARTED_DESC',
  TIME_ENDED_ASC = 'TIME_ENDED_ASC',
  TIME_ENDED_DESC = 'TIME_ENDED_DESC',
  TIME_SAVED_ASC = 'TIME_SAVED_ASC',
  TIME_SAVED_DESC = 'TIME_SAVED_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** The return type of our `getPlateAppearancesConnection` query. */
export type GetPlateAppearancesRecord = {
  __typename?: 'GetPlateAppearancesRecord';
  gameId: Maybe<Scalars['UUID']>;
  gameStartTime: Maybe<Scalars['Datetime']>;
  playerId: Maybe<Scalars['UUID']>;
  type: Maybe<PlateAppearanceType>;
  contact: Maybe<ContactQuality>;
  hitTo: Maybe<FieldingPosition>;
  runsScored: Maybe<Scalars['Int']>;
  inning: Maybe<Scalars['Int']>;
  halfInning: Maybe<HalfInning>;
  gameStateBeforeId: Maybe<Scalars['UUID']>;
  gameEventRecordId: Maybe<Scalars['UUID']>;
};

/** The return type of our `getRunsScoredConnection` query. */
export type GetRunsScoredRecord = {
  __typename?: 'GetRunsScoredRecord';
  batterId: Maybe<Scalars['UUID']>;
  runnerId: Maybe<Scalars['UUID']>;
  battedIn: Maybe<Scalars['Boolean']>;
};

export type Group = Node & {
  __typename?: 'Group';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  name: Scalars['String'];
  notes: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `Player`. */
  players: Array<Player>;
  /** Reads and enables pagination through a set of `Game`. */
  games: Array<Game>;
  /** Reads and enables pagination through a set of `CareerStat`. */
  careerStats: Array<CareerStat>;
  /** Reads and enables pagination through a set of `CareerStatsQualifiedBatter`. */
  careerStatsQualifiedBatters: Array<CareerStatsQualifiedBatter>;
  /** Reads and enables pagination through a set of `LegacySeasonStat`. */
  legacySeasonStats: Array<LegacySeasonStat>;
  /** Reads and enables pagination through a set of `SeasonStat`. */
  seasonStats: Array<SeasonStat>;
  /** Reads and enables pagination through a set of `SeasonStatsAllTimeQualifiedBatter`. */
  seasonStatsAllTimeQualifiedBatters: Array<SeasonStatsAllTimeQualifiedBatter>;
  /** Reads and enables pagination through a set of `SeasonStatsQualifiedBatter`. */
  seasonStatsQualifiedBatters: Array<SeasonStatsQualifiedBatter>;
  allSeasons: Maybe<Array<Maybe<Scalars['Int']>>>;
};


export type GroupPlayersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlayersOrderBy>>;
  condition?: Maybe<PlayerCondition>;
};


export type GroupGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GamesOrderBy>>;
  condition?: Maybe<GameCondition>;
};


export type GroupCareerStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsOrderBy>>;
  condition?: Maybe<CareerStatCondition>;
};


export type GroupCareerStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<CareerStatsQualifiedBatterCondition>;
};


export type GroupLegacySeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacySeasonStatsOrderBy>>;
  condition?: Maybe<LegacySeasonStatCondition>;
};


export type GroupSeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsOrderBy>>;
  condition?: Maybe<SeasonStatCondition>;
};


export type GroupSeasonStatsAllTimeQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsAllTimeQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsAllTimeQualifiedBatterCondition>;
};


export type GroupSeasonStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsQualifiedBatterCondition>;
};


export type GroupAllSeasonsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};

/** A condition to be used against `Group` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GroupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
};

/** The fields on `group` to look up the row to connect. */
export type GroupGroupNameKeyConnect = {
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to delete. */
export type GroupGroupNameKeyDelete = {
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to connect. */
export type GroupGroupPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to delete. */
export type GroupGroupPkeyDelete = {
  id: Scalars['UUID'];
};

/** An input for mutations affecting `Group` */
export type GroupInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GroupNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GroupNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `group` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnCareerStatForFakePublicCareerStatsForeignKey2UsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnCareerStatForFakePublicCareerStatsForeignKey2Patch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnCareerStatForFakePublicCareerStatsForeignKey2UsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnCareerStatForFakePublicCareerStatsForeignKey2Patch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2UsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2Patch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2UsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GroupOnGameForGameGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `group` to look up the row to update. */
export type GroupOnGameForGameGroupIdFkeyUsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnGameForGameGroupIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnGameForGameGroupIdFkeyUsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnGameForGameGroupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2UsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2Patch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2UsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GroupOnPlayerForPlayerGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `group` to look up the row to update. */
export type GroupOnPlayerForPlayerGroupIdFkeyUsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnPlayerForPlayerGroupIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnPlayerForPlayerGroupIdFkeyUsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnPlayerForPlayerGroupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonStatForFakePublicSeasonStatsForeignKey2UsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonStatForFakePublicSeasonStatsForeignKey2Patch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonStatForFakePublicSeasonStatsForeignKey2UsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonStatForFakePublicSeasonStatsForeignKey2Patch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2UsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2Patch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2UsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2Patch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2UsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2Patch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2UsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2Patch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Group`. Fields that are set will be updated. */
export type GroupPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** Methods to use when ordering `Group`. */
export enum GroupsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  NOTES_ASC = 'NOTES_ASC',
  NOTES_DESC = 'NOTES_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export enum HalfInning {
  TOP = 'TOP',
  BOTTOM = 'BOTTOM'
}

export type LegacyField = Node & {
  __typename?: 'LegacyField';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  fieldId: Scalars['Int'];
  fieldName: Maybe<Scalars['String']>;
  fieldAddress: Maybe<Scalars['String']>;
  fieldNumber: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `LegacyField` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LegacyFieldCondition = {
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `fieldName` field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fieldAddress` field. */
  fieldAddress?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fieldNumber` field. */
  fieldNumber?: Maybe<Scalars['String']>;
};

/** Methods to use when ordering `LegacyField`. */
export enum LegacyFieldsOrderBy {
  NATURAL = 'NATURAL',
  FIELD_ID_ASC = 'FIELD_ID_ASC',
  FIELD_ID_DESC = 'FIELD_ID_DESC',
  FIELD_NAME_ASC = 'FIELD_NAME_ASC',
  FIELD_NAME_DESC = 'FIELD_NAME_DESC',
  FIELD_ADDRESS_ASC = 'FIELD_ADDRESS_ASC',
  FIELD_ADDRESS_DESC = 'FIELD_ADDRESS_DESC',
  FIELD_NUMBER_ASC = 'FIELD_NUMBER_ASC',
  FIELD_NUMBER_DESC = 'FIELD_NUMBER_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type LegacyGame = Node & {
  __typename?: 'LegacyGame';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameId: Scalars['Int'];
  gameTitle: Maybe<Scalars['String']>;
  gameDate: Maybe<Scalars['Date']>;
  gameStartTime: Maybe<Scalars['Time']>;
  gameEndTime: Maybe<Scalars['Time']>;
  gameTeamId1: Maybe<Scalars['Int']>;
  gameTeamId2: Maybe<Scalars['Int']>;
  season: Maybe<Scalars['Int']>;
};

/**
 * A condition to be used against `LegacyGame` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LegacyGameCondition = {
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameTitle` field. */
  gameTitle?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `gameDate` field. */
  gameDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `gameStartTime` field. */
  gameStartTime?: Maybe<Scalars['Time']>;
  /** Checks for equality with the object’s `gameEndTime` field. */
  gameEndTime?: Maybe<Scalars['Time']>;
  /** Checks for equality with the object’s `gameTeamId1` field. */
  gameTeamId1?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameTeamId2` field. */
  gameTeamId2?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
};

/** Methods to use when ordering `LegacyGame`. */
export enum LegacyGamesOrderBy {
  NATURAL = 'NATURAL',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  GAME_TITLE_ASC = 'GAME_TITLE_ASC',
  GAME_TITLE_DESC = 'GAME_TITLE_DESC',
  GAME_DATE_ASC = 'GAME_DATE_ASC',
  GAME_DATE_DESC = 'GAME_DATE_DESC',
  GAME_START_TIME_ASC = 'GAME_START_TIME_ASC',
  GAME_START_TIME_DESC = 'GAME_START_TIME_DESC',
  GAME_END_TIME_ASC = 'GAME_END_TIME_ASC',
  GAME_END_TIME_DESC = 'GAME_END_TIME_DESC',
  GAME_TEAM_ID_1_ASC = 'GAME_TEAM_ID_1_ASC',
  GAME_TEAM_ID_1_DESC = 'GAME_TEAM_ID_1_DESC',
  GAME_TEAM_ID_2_ASC = 'GAME_TEAM_ID_2_ASC',
  GAME_TEAM_ID_2_DESC = 'GAME_TEAM_ID_2_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type LegacyPlayer = Node & {
  __typename?: 'LegacyPlayer';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  playerId: Scalars['Int'];
  playerName: Maybe<Scalars['String']>;
  playerImage: Maybe<Scalars['String']>;
  memberId: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `CareerStat`. */
  careerStats: Array<CareerStat>;
  /** Reads and enables pagination through a set of `CareerStatsQualifiedBatter`. */
  careerStatsQualifiedBatters: Array<CareerStatsQualifiedBatter>;
  /** Reads and enables pagination through a set of `LegacySeasonStat`. */
  legacySeasonStats: Array<LegacySeasonStat>;
  /** Reads and enables pagination through a set of `Player`. */
  players: Array<Player>;
  /** Reads and enables pagination through a set of `SeasonStat`. */
  seasonStats: Array<SeasonStat>;
  /** Reads and enables pagination through a set of `SeasonStatsAllTimeQualifiedBatter`. */
  seasonStatsAllTimeQualifiedBatters: Array<SeasonStatsAllTimeQualifiedBatter>;
  /** Reads and enables pagination through a set of `SeasonStatsQualifiedBatter`. */
  seasonStatsQualifiedBatters: Array<SeasonStatsQualifiedBatter>;
};


export type LegacyPlayerCareerStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsOrderBy>>;
  condition?: Maybe<CareerStatCondition>;
};


export type LegacyPlayerCareerStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<CareerStatsQualifiedBatterCondition>;
};


export type LegacyPlayerLegacySeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacySeasonStatsOrderBy>>;
  condition?: Maybe<LegacySeasonStatCondition>;
};


export type LegacyPlayerPlayersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlayersOrderBy>>;
  condition?: Maybe<PlayerCondition>;
};


export type LegacyPlayerSeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsOrderBy>>;
  condition?: Maybe<SeasonStatCondition>;
};


export type LegacyPlayerSeasonStatsAllTimeQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsAllTimeQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsAllTimeQualifiedBatterCondition>;
};


export type LegacyPlayerSeasonStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsQualifiedBatterCondition>;
};

/**
 * A condition to be used against `LegacyPlayer` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LegacyPlayerCondition = {
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerName` field. */
  playerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `playerImage` field. */
  playerImage?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars['String']>;
};

/** The fields on `legacyPlayer` to look up the row to connect. */
export type LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect = {
  playerId: Scalars['Int'];
};

/** The fields on `legacyPlayer` to look up the row to delete. */
export type LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete = {
  playerId: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LegacyPlayerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LegacyPlayerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `legacyPlayer` to look up the row to update. */
export type LegacyPlayerOnCareerStatForFakePublicCareerStatsForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: UpdateLegacyPlayerOnCareerStatForFakePublicCareerStatsForeignKey1Patch;
  playerId: Scalars['Int'];
};

/** The fields on `legacyPlayer` to look up the row to update. */
export type LegacyPlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: UpdateLegacyPlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey1Patch;
  playerId: Scalars['Int'];
};

/** The fields on `legacyPlayer` to look up the row to update. */
export type LegacyPlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: UpdateLegacyPlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey1Patch;
  playerId: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyPlayerOnPlayerForFakePublicPlayerForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `legacyPlayer` to look up the row to update. */
export type LegacyPlayerOnPlayerForFakePublicPlayerForeignKey0UsingFakePublicLegacyPlayerPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: UpdateLegacyPlayerOnPlayerForFakePublicPlayerForeignKey0Patch;
  playerId: Scalars['Int'];
};

/** The fields on `legacyPlayer` to look up the row to update. */
export type LegacyPlayerOnSeasonStatForFakePublicSeasonStatsForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: UpdateLegacyPlayerOnSeasonStatForFakePublicSeasonStatsForeignKey1Patch;
  playerId: Scalars['Int'];
};

/** The fields on `legacyPlayer` to look up the row to update. */
export type LegacyPlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: UpdateLegacyPlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1Patch;
  playerId: Scalars['Int'];
};

/** The fields on `legacyPlayer` to look up the row to update. */
export type LegacyPlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: UpdateLegacyPlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey1Patch;
  playerId: Scalars['Int'];
};

/** Represents an update to a `LegacyPlayer`. Fields that are set will be updated. */
export type LegacyPlayerPatch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** Methods to use when ordering `LegacyPlayer`. */
export enum LegacyPlayersOrderBy {
  NATURAL = 'NATURAL',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  PLAYER_NAME_ASC = 'PLAYER_NAME_ASC',
  PLAYER_NAME_DESC = 'PLAYER_NAME_DESC',
  PLAYER_IMAGE_ASC = 'PLAYER_IMAGE_ASC',
  PLAYER_IMAGE_DESC = 'PLAYER_IMAGE_DESC',
  MEMBER_ID_ASC = 'MEMBER_ID_ASC',
  MEMBER_ID_DESC = 'MEMBER_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type LegacySeason = {
  __typename?: 'LegacySeason';
  groupId: Maybe<Scalars['UUID']>;
  year: Maybe<Scalars['Int']>;
  totalGames: Maybe<Scalars['BigInt']>;
};

/**
 * A condition to be used against `LegacySeason` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LegacySeasonCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `year` field. */
  year?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `totalGames` field. */
  totalGames?: Maybe<Scalars['BigInt']>;
};

export type LegacySeasonStat = {
  __typename?: 'LegacySeasonStat';
  groupId: Maybe<Scalars['UUID']>;
  playerId: Maybe<Scalars['UUID']>;
  legacyPlayerId: Maybe<Scalars['Int']>;
  season: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['BigInt']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
  /** Reads a single `Player` that is related to this `LegacySeasonStat`. */
  player: Maybe<Player>;
  /** Reads a single `LegacyPlayer` that is related to this `LegacySeasonStat`. */
  legacyPlayer: Maybe<LegacyPlayer>;
  /** Reads a single `Group` that is related to this `LegacySeasonStat`. */
  group: Maybe<Group>;
};

/**
 * A condition to be used against `LegacySeasonStat` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LegacySeasonStatCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The globally unique `ID` look up for the row to update. */
export type LegacySeasonStatOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type LegacySeasonStatOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: LegacyPlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type LegacySeasonStatOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** Methods to use when ordering `LegacySeasonStat`. */
export enum LegacySeasonStatsOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC'
}

/** Methods to use when ordering `LegacySeason`. */
export enum LegacySeasonsOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  YEAR_ASC = 'YEAR_ASC',
  YEAR_DESC = 'YEAR_DESC',
  TOTAL_GAMES_ASC = 'TOTAL_GAMES_ASC',
  TOTAL_GAMES_DESC = 'TOTAL_GAMES_DESC'
}

export type LegacyStatLine = {
  __typename?: 'LegacyStatLine';
  sbStatsId: Maybe<Scalars['Int']>;
  playerId: Maybe<Scalars['Int']>;
  gameId: Maybe<Scalars['Int']>;
  sbStatsTeam: Maybe<Scalars['Int']>;
  sbStatsAb: Maybe<Scalars['Int']>;
  sbStatsRuns: Maybe<Scalars['Int']>;
  sbStatsHits: Maybe<Scalars['Int']>;
  sbStats1B: Maybe<Scalars['Int']>;
  sbStats2B: Maybe<Scalars['Int']>;
  sbStats3B: Maybe<Scalars['Int']>;
  sbStatsHr: Maybe<Scalars['Int']>;
  sbStatsRbi: Maybe<Scalars['Int']>;
  sbStatsBb: Maybe<Scalars['Int']>;
  sbStatsSo: Maybe<Scalars['Int']>;
  sbStatsSac: Maybe<Scalars['Int']>;
};

/**
 * A condition to be used against `LegacyStatLine` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LegacyStatLineCondition = {
  /** Checks for equality with the object’s `sbStatsId` field. */
  sbStatsId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsTeam` field. */
  sbStatsTeam?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsAb` field. */
  sbStatsAb?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsRuns` field. */
  sbStatsRuns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsHits` field. */
  sbStatsHits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStats1B` field. */
  sbStats1B?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStats2B` field. */
  sbStats2B?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStats3B` field. */
  sbStats3B?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsHr` field. */
  sbStatsHr?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsRbi` field. */
  sbStatsRbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsBb` field. */
  sbStatsBb?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsSo` field. */
  sbStatsSo?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsSac` field. */
  sbStatsSac?: Maybe<Scalars['Int']>;
};

/** Methods to use when ordering `LegacyStatLine`. */
export enum LegacyStatLinesOrderBy {
  NATURAL = 'NATURAL',
  SB_STATS_ID_ASC = 'SB_STATS_ID_ASC',
  SB_STATS_ID_DESC = 'SB_STATS_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  SB_STATS_TEAM_ASC = 'SB_STATS_TEAM_ASC',
  SB_STATS_TEAM_DESC = 'SB_STATS_TEAM_DESC',
  SB_STATS_AB_ASC = 'SB_STATS_AB_ASC',
  SB_STATS_AB_DESC = 'SB_STATS_AB_DESC',
  SB_STATS_RUNS_ASC = 'SB_STATS_RUNS_ASC',
  SB_STATS_RUNS_DESC = 'SB_STATS_RUNS_DESC',
  SB_STATS_HITS_ASC = 'SB_STATS_HITS_ASC',
  SB_STATS_HITS_DESC = 'SB_STATS_HITS_DESC',
  SB_STATS_1B_ASC = 'SB_STATS_1B_ASC',
  SB_STATS_1B_DESC = 'SB_STATS_1B_DESC',
  SB_STATS_2B_ASC = 'SB_STATS_2B_ASC',
  SB_STATS_2B_DESC = 'SB_STATS_2B_DESC',
  SB_STATS_3B_ASC = 'SB_STATS_3B_ASC',
  SB_STATS_3B_DESC = 'SB_STATS_3B_DESC',
  SB_STATS_HR_ASC = 'SB_STATS_HR_ASC',
  SB_STATS_HR_DESC = 'SB_STATS_HR_DESC',
  SB_STATS_RBI_ASC = 'SB_STATS_RBI_ASC',
  SB_STATS_RBI_DESC = 'SB_STATS_RBI_DESC',
  SB_STATS_BB_ASC = 'SB_STATS_BB_ASC',
  SB_STATS_BB_DESC = 'SB_STATS_BB_DESC',
  SB_STATS_SO_ASC = 'SB_STATS_SO_ASC',
  SB_STATS_SO_DESC = 'SB_STATS_SO_DESC',
  SB_STATS_SAC_ASC = 'SB_STATS_SAC_ASC',
  SB_STATS_SAC_DESC = 'SB_STATS_SAC_DESC'
}

export type LegacyTeam = Node & {
  __typename?: 'LegacyTeam';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  teamId: Scalars['Int'];
  teamName: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `LegacyTeam` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LegacyTeamCondition = {
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `teamName` field. */
  teamName?: Maybe<Scalars['String']>;
};

/** Methods to use when ordering `LegacyTeam`. */
export enum LegacyTeamsOrderBy {
  NATURAL = 'NATURAL',
  TEAM_ID_ASC = 'TEAM_ID_ASC',
  TEAM_ID_DESC = 'TEAM_ID_DESC',
  TEAM_NAME_ASC = 'TEAM_NAME_ASC',
  TEAM_NAME_DESC = 'TEAM_NAME_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type LineScoreCell = {
  __typename?: 'LineScoreCell';
  inning: Maybe<Scalars['Int']>;
  halfInning: Maybe<HalfInning>;
  runs: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
};

export type Lineup = Node & {
  __typename?: 'Lineup';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  teamId: Scalars['UUID'];
  /** Reads a single `Team` that is related to this `Lineup`. */
  team: Maybe<Team>;
  /** Reads and enables pagination through a set of `LineupSpot`. */
  lineupSpots: Array<LineupSpot>;
  /** Reads and enables pagination through a set of `LineupChange`. */
  lineupChangesByLineupBeforeId: Array<LineupChange>;
  /** Reads and enables pagination through a set of `LineupChange`. */
  lineupChangesByLineupAfterId: Array<LineupChange>;
  /** Reads and enables pagination through a set of `LineupForGameState`. */
  lineupForGameStates: Array<LineupForGameState>;
};


export type LineupLineupSpotsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupSpotsOrderBy>>;
  condition?: Maybe<LineupSpotCondition>;
};


export type LineupLineupChangesByLineupBeforeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupChangesOrderBy>>;
  condition?: Maybe<LineupChangeCondition>;
};


export type LineupLineupChangesByLineupAfterIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupChangesOrderBy>>;
  condition?: Maybe<LineupChangeCondition>;
};


export type LineupLineupForGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupForGameStatesOrderBy>>;
  condition?: Maybe<LineupForGameStateCondition>;
};

export type LineupChange = Node & {
  __typename?: 'LineupChange';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  lineupBeforeId: Scalars['UUID'];
  lineupAfterId: Scalars['UUID'];
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupBefore: Maybe<Lineup>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupAfter: Maybe<Lineup>;
};

/**
 * A condition to be used against `LineupChange` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LineupChangeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `lineupBeforeId` field. */
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `lineupAfterId` field. */
  lineupAfterId?: Maybe<Scalars['UUID']>;
};

/** An input for mutations affecting `LineupChange` */
export type LineupChangeInput = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** Input for the nested mutation of `lineup` in the `LineupChangeInput` mutation. */
export type LineupChangeLineupAfterIdFkeyInput = {
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectById?: Maybe<LineupLineupPkeyConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectByNodeId?: Maybe<LineupNodeIdConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteById?: Maybe<LineupLineupPkeyDelete>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LineupNodeIdDelete>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateById?: Maybe<LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupPkeyUpdate>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate>;
  /** A `LineupInput` object that will be created and connected to this object. */
  create?: Maybe<LineupChangeLineupAfterIdFkeyLineupCreateInput>;
};

/** Input for the nested mutation of `lineupChange` in the `LineupInput` mutation. */
export type LineupChangeLineupAfterIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupChange` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectById?: Maybe<Array<LineupChangeLineupChangePkeyConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupChangeNodeIdConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteById?: Maybe<Array<LineupChangeLineupChangePkeyDelete>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupChangeNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateById?: Maybe<Array<LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupChangePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate>>;
  /** A `LineupChangeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupChangeLineupAfterIdFkeyLineupChangeCreateInput>>;
};

/** The `lineupChange` to be created by this mutation. */
export type LineupChangeLineupAfterIdFkeyLineupChangeCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** The `lineup` to be created by this mutation. */
export type LineupChangeLineupAfterIdFkeyLineupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** Input for the nested mutation of `lineupChange` in the `LineupInput` mutation. */
export type LineupChangeLineupBeforeIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupChange` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectById?: Maybe<Array<LineupChangeLineupChangePkeyConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupChangeNodeIdConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteById?: Maybe<Array<LineupChangeLineupChangePkeyDelete>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupChangeNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateById?: Maybe<Array<LineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyUsingLineupChangePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LineupOnLineupChangeForLineupChangeLineupBeforeIdFkeyNodeIdUpdate>>;
  /** A `LineupChangeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupChangeLineupBeforeIdFkeyLineupChangeCreateInput>>;
};

/** The `lineupChange` to be created by this mutation. */
export type LineupChangeLineupBeforeIdFkeyLineupChangeCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** The fields on `lineupChange` to look up the row to connect. */
export type LineupChangeLineupChangePkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `lineupChange` to look up the row to delete. */
export type LineupChangeLineupChangePkeyDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LineupChangeNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LineupChangeNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupChangeOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `lineupChange` to look up the row to update. */
export type LineupChangeOnGameEventForGameEventLineupChangeIdFkeyUsingLineupChangePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: UpdateLineupChangeOnGameEventForGameEventLineupChangeIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: LineupPatch;
};

/** The fields on `lineupChange` to look up the row to update. */
export type LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupChangePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: UpdateLineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `lineupChange` to look up the row to update. */
export type LineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyUsingLineupChangePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: UpdateLineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `LineupChange`. Fields that are set will be updated. */
export type LineupChangePatch = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** Methods to use when ordering `LineupChange`. */
export enum LineupChangesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  LINEUP_BEFORE_ID_ASC = 'LINEUP_BEFORE_ID_ASC',
  LINEUP_BEFORE_ID_DESC = 'LINEUP_BEFORE_ID_DESC',
  LINEUP_AFTER_ID_ASC = 'LINEUP_AFTER_ID_ASC',
  LINEUP_AFTER_ID_DESC = 'LINEUP_AFTER_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `Lineup` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type LineupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: Maybe<Scalars['UUID']>;
};

export type LineupForGameState = Node & {
  __typename?: 'LineupForGameState';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
  /** Reads a single `GameState` that is related to this `LineupForGameState`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Lineup` that is related to this `LineupForGameState`. */
  lineup: Maybe<Lineup>;
};

/**
 * A condition to be used against `LineupForGameState` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LineupForGameStateCondition = {
  /** Checks for equality with the object’s `gameStateId` field. */
  gameStateId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `lineupId` field. */
  lineupId?: Maybe<Scalars['UUID']>;
};

/** The `gameState` to be created by this mutation. */
export type LineupForGameStateGameStateIdFkeyGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `gameState` in the `LineupForGameStateInput` mutation. */
export type LineupForGameStateGameStateIdFkeyInput = {
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<GameStateGameStatePkeyConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameStateNodeIdConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<GameStateGameStatePkeyDelete>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameStateNodeIdDelete>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingGameStatePkeyUpdate>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<LineupForGameStateGameStateIdFkeyGameStateCreateInput>;
};

/** Input for the nested mutation of `lineupForGameState` in the `GameStateInput` mutation. */
export type LineupForGameStateGameStateIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupForGameState` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupForGameStateNodeIdConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyDelete>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupForGameStateNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingLineupForGameStatePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate>>;
  /** A `LineupForGameStateInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupForGameStateGameStateIdFkeyLineupForGameStateCreateInput>>;
};

/** The `lineupForGameState` to be created by this mutation. */
export type LineupForGameStateGameStateIdFkeyLineupForGameStateCreateInput = {
  lineupId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
};

/** An input for mutations affecting `LineupForGameState` */
export type LineupForGameStateInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  lineupId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
};

/** The fields on `lineupForGameState` to look up the row to connect. */
export type LineupForGameStateLineupForGameStatePkeyConnect = {
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** The fields on `lineupForGameState` to look up the row to delete. */
export type LineupForGameStateLineupForGameStatePkeyDelete = {
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** Input for the nested mutation of `lineup` in the `LineupForGameStateInput` mutation. */
export type LineupForGameStateLineupIdFkeyInput = {
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectById?: Maybe<LineupLineupPkeyConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectByNodeId?: Maybe<LineupNodeIdConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteById?: Maybe<LineupLineupPkeyDelete>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LineupNodeIdDelete>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateById?: Maybe<LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupPkeyUpdate>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate>;
  /** A `LineupInput` object that will be created and connected to this object. */
  create?: Maybe<LineupForGameStateLineupIdFkeyLineupCreateInput>;
};

/** Input for the nested mutation of `lineupForGameState` in the `LineupInput` mutation. */
export type LineupForGameStateLineupIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupForGameState` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupForGameStateNodeIdConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyDelete>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupForGameStateNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupForGameStatePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate>>;
  /** A `LineupForGameStateInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupForGameStateLineupIdFkeyLineupForGameStateCreateInput>>;
};

/** The `lineup` to be created by this mutation. */
export type LineupForGameStateLineupIdFkeyLineupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** The `lineupForGameState` to be created by this mutation. */
export type LineupForGameStateLineupIdFkeyLineupForGameStateCreateInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type LineupForGameStateNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `lineupForGameState` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LineupForGameStateNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `lineupForGameState` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `lineupForGameState` to look up the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingLineupForGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: LineupPatch;
};

/** The fields on `lineupForGameState` to look up the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupForGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** Represents an update to a `LineupForGameState`. Fields that are set will be updated. */
export type LineupForGameStatePatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  lineupId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
};

/** Methods to use when ordering `LineupForGameState`. */
export enum LineupForGameStatesOrderBy {
  NATURAL = 'NATURAL',
  GAME_STATE_ID_ASC = 'GAME_STATE_ID_ASC',
  GAME_STATE_ID_DESC = 'GAME_STATE_ID_DESC',
  LINEUP_ID_ASC = 'LINEUP_ID_ASC',
  LINEUP_ID_DESC = 'LINEUP_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** An input for mutations affecting `Lineup` */
export type LineupInput = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** The fields on `lineup` to look up the row to connect. */
export type LineupLineupPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `lineup` to look up the row to delete. */
export type LineupLineupPkeyDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LineupNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LineupNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `lineup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: LineupChangePatch;
};

/** The fields on `lineup` to look up the row to update. */
export type LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: UpdateLineupOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupChangeForLineupChangeLineupBeforeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: LineupChangePatch;
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupForGameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: LineupForGameStatePatch;
};

/** The fields on `lineup` to look up the row to update. */
export type LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: UpdateLineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupForLineupTeamIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `team` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: TeamPatch;
};

/** The fields on `lineup` to look up the row to update. */
export type LineupOnLineupForLineupTeamIdFkeyUsingLineupPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: UpdateLineupOnLineupForLineupTeamIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupSpot` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: LineupSpotPatch;
};

/** The fields on `lineup` to look up the row to update. */
export type LineupOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: UpdateLineupOnLineupSpotForLineupSpotLineupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Lineup`. Fields that are set will be updated. */
export type LineupPatch = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

export type LineupSpot = Node & {
  __typename?: 'LineupSpot';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
  position: Maybe<FieldingPosition>;
  /** Reads a single `Lineup` that is related to this `LineupSpot`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Player` that is related to this `LineupSpot`. */
  player: Maybe<Player>;
};

/**
 * A condition to be used against `LineupSpot` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LineupSpotCondition = {
  /** Checks for equality with the object’s `lineupId` field. */
  lineupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `battingOrder` field. */
  battingOrder?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `position` field. */
  position?: Maybe<FieldingPosition>;
};

/** An input for mutations affecting `LineupSpot` */
export type LineupSpotInput = {
  lineupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder: Scalars['Int'];
  position?: Maybe<FieldingPosition>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
};

/** Input for the nested mutation of `lineup` in the `LineupSpotInput` mutation. */
export type LineupSpotLineupIdFkeyInput = {
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectById?: Maybe<LineupLineupPkeyConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectByNodeId?: Maybe<LineupNodeIdConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteById?: Maybe<LineupLineupPkeyDelete>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LineupNodeIdDelete>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateById?: Maybe<LineupOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupPkeyUpdate>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate>;
  /** A `LineupInput` object that will be created and connected to this object. */
  create?: Maybe<LineupSpotLineupIdFkeyLineupCreateInput>;
};

/** Input for the nested mutation of `lineupSpot` in the `LineupInput` mutation. */
export type LineupSpotLineupIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupSpot` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupSpotNodeIdConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupSpotNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPlayerId?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotPkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPosition?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LineupOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate>>;
  /** A `LineupSpotInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupSpotLineupIdFkeyLineupSpotCreateInput>>;
};

/** The `lineup` to be created by this mutation. */
export type LineupSpotLineupIdFkeyLineupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** The `lineupSpot` to be created by this mutation. */
export type LineupSpotLineupIdFkeyLineupSpotCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder: Scalars['Int'];
  position?: Maybe<FieldingPosition>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
};

/** The fields on `lineupSpot` to look up the row to connect. */
export type LineupSpotLineupSpotLineupIdBattingOrderKeyConnect = {
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** The fields on `lineupSpot` to look up the row to delete. */
export type LineupSpotLineupSpotLineupIdBattingOrderKeyDelete = {
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** The fields on `lineupSpot` to look up the row to connect. */
export type LineupSpotLineupSpotLineupIdPositionKeyConnect = {
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** The fields on `lineupSpot` to look up the row to delete. */
export type LineupSpotLineupSpotLineupIdPositionKeyDelete = {
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** The fields on `lineupSpot` to look up the row to connect. */
export type LineupSpotLineupSpotPkeyConnect = {
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The fields on `lineupSpot` to look up the row to delete. */
export type LineupSpotLineupSpotPkeyDelete = {
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LineupSpotNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `lineupSpot` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LineupSpotNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `lineupSpot` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: LineupPatch;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch;
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch;
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch;
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch;
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch;
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch;
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** Represents an update to a `LineupSpot`. Fields that are set will be updated. */
export type LineupSpotPatch = {
  lineupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder?: Maybe<Scalars['Int']>;
  position?: Maybe<FieldingPosition>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
};

/** Input for the nested mutation of `player` in the `LineupSpotInput` mutation. */
export type LineupSpotPlayerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<LineupSpotPlayerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `lineupSpot` in the `PlayerInput` mutation. */
export type LineupSpotPlayerIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupSpot` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupSpotNodeIdConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupSpotNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPlayerId?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotPkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPosition?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate>>;
  /** A `LineupSpotInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupSpotPlayerIdFkeyLineupSpotCreateInput>>;
};

/** The `lineupSpot` to be created by this mutation. */
export type LineupSpotPlayerIdFkeyLineupSpotCreateInput = {
  lineupId?: Maybe<Scalars['UUID']>;
  battingOrder: Scalars['Int'];
  position?: Maybe<FieldingPosition>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
};

/** The `player` to be created by this mutation. */
export type LineupSpotPlayerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** Methods to use when ordering `LineupSpot`. */
export enum LineupSpotsOrderBy {
  NATURAL = 'NATURAL',
  LINEUP_ID_ASC = 'LINEUP_ID_ASC',
  LINEUP_ID_DESC = 'LINEUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  BATTING_ORDER_ASC = 'BATTING_ORDER_ASC',
  BATTING_ORDER_DESC = 'BATTING_ORDER_DESC',
  POSITION_ASC = 'POSITION_ASC',
  POSITION_DESC = 'POSITION_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** Input for the nested mutation of `team` in the `LineupInput` mutation. */
export type LineupTeamIdFkeyInput = {
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectById?: Maybe<TeamTeamPkeyConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByGameIdAndRole?: Maybe<TeamTeamGameIdRoleKeyConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByNodeId?: Maybe<TeamNodeIdConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteById?: Maybe<TeamTeamPkeyDelete>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByGameIdAndRole?: Maybe<TeamTeamGameIdRoleKeyDelete>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TeamNodeIdDelete>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateById?: Maybe<TeamOnLineupForLineupTeamIdFkeyUsingTeamPkeyUpdate>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByGameIdAndRole?: Maybe<TeamOnLineupForLineupTeamIdFkeyUsingTeamGameIdRoleKeyUpdate>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupOnLineupForLineupTeamIdFkeyNodeIdUpdate>;
  /** A `TeamInput` object that will be created and connected to this object. */
  create?: Maybe<LineupTeamIdFkeyTeamCreateInput>;
};

/** Input for the nested mutation of `lineup` in the `TeamInput` mutation. */
export type LineupTeamIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineup` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectById?: Maybe<Array<LineupLineupPkeyConnect>>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupNodeIdConnect>>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteById?: Maybe<Array<LineupLineupPkeyDelete>>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateById?: Maybe<Array<LineupOnLineupForLineupTeamIdFkeyUsingLineupPkeyUpdate>>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TeamOnLineupForLineupTeamIdFkeyNodeIdUpdate>>;
  /** A `LineupInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupTeamIdFkeyLineupCreateInput>>;
};

/** The `lineup` to be created by this mutation. */
export type LineupTeamIdFkeyLineupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** The `team` to be created by this mutation. */
export type LineupTeamIdFkeyTeamCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role: TeamRole;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

/** Methods to use when ordering `Lineup`. */
export enum LineupsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  TEAM_ID_ASC = 'TEAM_ID_ASC',
  TEAM_ID_DESC = 'TEAM_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type ModernSeasonStat = {
  __typename?: 'ModernSeasonStat';
  groupId: Maybe<Scalars['UUID']>;
  playerId: Maybe<Scalars['UUID']>;
  legacyPlayerId: Maybe<Scalars['Int']>;
  season: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['BigInt']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
};

/**
 * A condition to be used against `ModernSeasonStat` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ModernSeasonStatCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** Methods to use when ordering `ModernSeasonStat`. */
export enum ModernSeasonStatsOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC'
}

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a single `BaseRunner`. */
  createBaseRunner: Maybe<CreateBaseRunnerPayload>;
  /** Creates a single `BasepathMovement`. */
  createBasepathMovement: Maybe<CreateBasepathMovementPayload>;
  /** Creates a single `Field`. */
  createField: Maybe<CreateFieldPayload>;
  /** Creates a single `ForeignDbField`. */
  createForeignDbField: Maybe<CreateForeignDbFieldPayload>;
  /** Creates a single `ForeignDbGame`. */
  createForeignDbGame: Maybe<CreateForeignDbGamePayload>;
  /** Creates a single `ForeignDbPlayer`. */
  createForeignDbPlayer: Maybe<CreateForeignDbPlayerPayload>;
  /** Creates a single `ForeignDbStatLine`. */
  createForeignDbStatLine: Maybe<CreateForeignDbStatLinePayload>;
  /** Creates a single `ForeignDbTeam`. */
  createForeignDbTeam: Maybe<CreateForeignDbTeamPayload>;
  /** Creates a single `Game`. */
  createGame: Maybe<CreateGamePayload>;
  /** Creates a single `GameEvent`. */
  createGameEvent: Maybe<CreateGameEventPayload>;
  /** Creates a single `GameEventRecord`. */
  createGameEventRecord: Maybe<CreateGameEventRecordPayload>;
  /** Creates a single `GameState`. */
  createGameState: Maybe<CreateGameStatePayload>;
  /** Creates a single `Group`. */
  createGroup: Maybe<CreateGroupPayload>;
  /** Creates a single `Lineup`. */
  createLineup: Maybe<CreateLineupPayload>;
  /** Creates a single `LineupChange`. */
  createLineupChange: Maybe<CreateLineupChangePayload>;
  /** Creates a single `LineupForGameState`. */
  createLineupForGameState: Maybe<CreateLineupForGameStatePayload>;
  /** Creates a single `LineupSpot`. */
  createLineupSpot: Maybe<CreateLineupSpotPayload>;
  /** Creates a single `OutOnPlayRunner`. */
  createOutOnPlayRunner: Maybe<CreateOutOnPlayRunnerPayload>;
  /** Creates a single `PlateAppearance`. */
  createPlateAppearance: Maybe<CreatePlateAppearancePayload>;
  /** Creates a single `Player`. */
  createPlayer: Maybe<CreatePlayerPayload>;
  /** Creates a single `ScoredRunner`. */
  createScoredRunner: Maybe<CreateScoredRunnerPayload>;
  /** Creates a single `StolenBaseAttempt`. */
  createStolenBaseAttempt: Maybe<CreateStolenBaseAttemptPayload>;
  /** Creates a single `Team`. */
  createTeam: Maybe<CreateTeamPayload>;
  /** Updates a single `BaseRunner` using its globally unique id and a patch. */
  updateBaseRunnerByNodeId: Maybe<UpdateBaseRunnerPayload>;
  /** Updates a single `BaseRunner` using a unique key and a patch. */
  updateBaseRunner: Maybe<UpdateBaseRunnerPayload>;
  /** Updates a single `BasepathMovement` using its globally unique id and a patch. */
  updateBasepathMovementByNodeId: Maybe<UpdateBasepathMovementPayload>;
  /** Updates a single `BasepathMovement` using a unique key and a patch. */
  updateBasepathMovement: Maybe<UpdateBasepathMovementPayload>;
  /** Updates a single `Field` using its globally unique id and a patch. */
  updateFieldByNodeId: Maybe<UpdateFieldPayload>;
  /** Updates a single `Field` using a unique key and a patch. */
  updateField: Maybe<UpdateFieldPayload>;
  /** Updates a single `Game` using its globally unique id and a patch. */
  updateGameByNodeId: Maybe<UpdateGamePayload>;
  /** Updates a single `Game` using a unique key and a patch. */
  updateGame: Maybe<UpdateGamePayload>;
  /** Updates a single `Game` using a unique key and a patch. */
  updateGameByName: Maybe<UpdateGamePayload>;
  /** Updates a single `GameEvent` using its globally unique id and a patch. */
  updateGameEventByNodeId: Maybe<UpdateGameEventPayload>;
  /** Updates a single `GameEvent` using a unique key and a patch. */
  updateGameEvent: Maybe<UpdateGameEventPayload>;
  /** Updates a single `GameEventRecord` using its globally unique id and a patch. */
  updateGameEventRecordByNodeId: Maybe<UpdateGameEventRecordPayload>;
  /** Updates a single `GameEventRecord` using a unique key and a patch. */
  updateGameEventRecord: Maybe<UpdateGameEventRecordPayload>;
  /** Updates a single `GameEventRecord` using a unique key and a patch. */
  updateGameEventRecordByGameIdAndEventIndex: Maybe<UpdateGameEventRecordPayload>;
  /** Updates a single `GameState` using its globally unique id and a patch. */
  updateGameStateByNodeId: Maybe<UpdateGameStatePayload>;
  /** Updates a single `GameState` using a unique key and a patch. */
  updateGameState: Maybe<UpdateGameStatePayload>;
  /** Updates a single `Group` using its globally unique id and a patch. */
  updateGroupByNodeId: Maybe<UpdateGroupPayload>;
  /** Updates a single `Group` using a unique key and a patch. */
  updateGroup: Maybe<UpdateGroupPayload>;
  /** Updates a single `Group` using a unique key and a patch. */
  updateGroupByName: Maybe<UpdateGroupPayload>;
  /** Updates a single `Lineup` using its globally unique id and a patch. */
  updateLineupByNodeId: Maybe<UpdateLineupPayload>;
  /** Updates a single `Lineup` using a unique key and a patch. */
  updateLineup: Maybe<UpdateLineupPayload>;
  /** Updates a single `LineupChange` using its globally unique id and a patch. */
  updateLineupChangeByNodeId: Maybe<UpdateLineupChangePayload>;
  /** Updates a single `LineupChange` using a unique key and a patch. */
  updateLineupChange: Maybe<UpdateLineupChangePayload>;
  /** Updates a single `LineupForGameState` using its globally unique id and a patch. */
  updateLineupForGameStateByNodeId: Maybe<UpdateLineupForGameStatePayload>;
  /** Updates a single `LineupForGameState` using a unique key and a patch. */
  updateLineupForGameState: Maybe<UpdateLineupForGameStatePayload>;
  /** Updates a single `LineupSpot` using its globally unique id and a patch. */
  updateLineupSpotByNodeId: Maybe<UpdateLineupSpotPayload>;
  /** Updates a single `LineupSpot` using a unique key and a patch. */
  updateLineupSpot: Maybe<UpdateLineupSpotPayload>;
  /** Updates a single `LineupSpot` using a unique key and a patch. */
  updateLineupSpotByLineupIdAndBattingOrder: Maybe<UpdateLineupSpotPayload>;
  /** Updates a single `LineupSpot` using a unique key and a patch. */
  updateLineupSpotByLineupIdAndPosition: Maybe<UpdateLineupSpotPayload>;
  /** Updates a single `OutOnPlayRunner` using its globally unique id and a patch. */
  updateOutOnPlayRunnerByNodeId: Maybe<UpdateOutOnPlayRunnerPayload>;
  /** Updates a single `OutOnPlayRunner` using a unique key and a patch. */
  updateOutOnPlayRunner: Maybe<UpdateOutOnPlayRunnerPayload>;
  /** Updates a single `PlateAppearance` using its globally unique id and a patch. */
  updatePlateAppearanceByNodeId: Maybe<UpdatePlateAppearancePayload>;
  /** Updates a single `PlateAppearance` using a unique key and a patch. */
  updatePlateAppearance: Maybe<UpdatePlateAppearancePayload>;
  /** Updates a single `Player` using its globally unique id and a patch. */
  updatePlayerByNodeId: Maybe<UpdatePlayerPayload>;
  /** Updates a single `Player` using a unique key and a patch. */
  updatePlayer: Maybe<UpdatePlayerPayload>;
  /** Updates a single `Player` using a unique key and a patch. */
  updatePlayerByFirstNameAndLastName: Maybe<UpdatePlayerPayload>;
  /** Updates a single `ScoredRunner` using its globally unique id and a patch. */
  updateScoredRunnerByNodeId: Maybe<UpdateScoredRunnerPayload>;
  /** Updates a single `ScoredRunner` using a unique key and a patch. */
  updateScoredRunner: Maybe<UpdateScoredRunnerPayload>;
  /** Updates a single `StolenBaseAttempt` using its globally unique id and a patch. */
  updateStolenBaseAttemptByNodeId: Maybe<UpdateStolenBaseAttemptPayload>;
  /** Updates a single `StolenBaseAttempt` using a unique key and a patch. */
  updateStolenBaseAttempt: Maybe<UpdateStolenBaseAttemptPayload>;
  /** Updates a single `Team` using its globally unique id and a patch. */
  updateTeamByNodeId: Maybe<UpdateTeamPayload>;
  /** Updates a single `Team` using a unique key and a patch. */
  updateTeam: Maybe<UpdateTeamPayload>;
  /** Updates a single `Team` using a unique key and a patch. */
  updateTeamByGameIdAndRole: Maybe<UpdateTeamPayload>;
  /** Deletes a single `BaseRunner` using its globally unique id. */
  deleteBaseRunnerByNodeId: Maybe<DeleteBaseRunnerPayload>;
  /** Deletes a single `BaseRunner` using a unique key. */
  deleteBaseRunner: Maybe<DeleteBaseRunnerPayload>;
  /** Deletes a single `BasepathMovement` using its globally unique id. */
  deleteBasepathMovementByNodeId: Maybe<DeleteBasepathMovementPayload>;
  /** Deletes a single `BasepathMovement` using a unique key. */
  deleteBasepathMovement: Maybe<DeleteBasepathMovementPayload>;
  /** Deletes a single `Field` using its globally unique id. */
  deleteFieldByNodeId: Maybe<DeleteFieldPayload>;
  /** Deletes a single `Field` using a unique key. */
  deleteField: Maybe<DeleteFieldPayload>;
  /** Deletes a single `Game` using its globally unique id. */
  deleteGameByNodeId: Maybe<DeleteGamePayload>;
  /** Deletes a single `Game` using a unique key. */
  deleteGame: Maybe<DeleteGamePayload>;
  /** Deletes a single `Game` using a unique key. */
  deleteGameByName: Maybe<DeleteGamePayload>;
  /** Deletes a single `GameEvent` using its globally unique id. */
  deleteGameEventByNodeId: Maybe<DeleteGameEventPayload>;
  /** Deletes a single `GameEvent` using a unique key. */
  deleteGameEvent: Maybe<DeleteGameEventPayload>;
  /** Deletes a single `GameEventRecord` using its globally unique id. */
  deleteGameEventRecordByNodeId: Maybe<DeleteGameEventRecordPayload>;
  /** Deletes a single `GameEventRecord` using a unique key. */
  deleteGameEventRecord: Maybe<DeleteGameEventRecordPayload>;
  /** Deletes a single `GameEventRecord` using a unique key. */
  deleteGameEventRecordByGameIdAndEventIndex: Maybe<DeleteGameEventRecordPayload>;
  /** Deletes a single `GameState` using its globally unique id. */
  deleteGameStateByNodeId: Maybe<DeleteGameStatePayload>;
  /** Deletes a single `GameState` using a unique key. */
  deleteGameState: Maybe<DeleteGameStatePayload>;
  /** Deletes a single `Group` using its globally unique id. */
  deleteGroupByNodeId: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Group` using a unique key. */
  deleteGroup: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Group` using a unique key. */
  deleteGroupByName: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Lineup` using its globally unique id. */
  deleteLineupByNodeId: Maybe<DeleteLineupPayload>;
  /** Deletes a single `Lineup` using a unique key. */
  deleteLineup: Maybe<DeleteLineupPayload>;
  /** Deletes a single `LineupChange` using its globally unique id. */
  deleteLineupChangeByNodeId: Maybe<DeleteLineupChangePayload>;
  /** Deletes a single `LineupChange` using a unique key. */
  deleteLineupChange: Maybe<DeleteLineupChangePayload>;
  /** Deletes a single `LineupForGameState` using its globally unique id. */
  deleteLineupForGameStateByNodeId: Maybe<DeleteLineupForGameStatePayload>;
  /** Deletes a single `LineupForGameState` using a unique key. */
  deleteLineupForGameState: Maybe<DeleteLineupForGameStatePayload>;
  /** Deletes a single `LineupSpot` using its globally unique id. */
  deleteLineupSpotByNodeId: Maybe<DeleteLineupSpotPayload>;
  /** Deletes a single `LineupSpot` using a unique key. */
  deleteLineupSpot: Maybe<DeleteLineupSpotPayload>;
  /** Deletes a single `LineupSpot` using a unique key. */
  deleteLineupSpotByLineupIdAndBattingOrder: Maybe<DeleteLineupSpotPayload>;
  /** Deletes a single `LineupSpot` using a unique key. */
  deleteLineupSpotByLineupIdAndPosition: Maybe<DeleteLineupSpotPayload>;
  /** Deletes a single `OutOnPlayRunner` using its globally unique id. */
  deleteOutOnPlayRunnerByNodeId: Maybe<DeleteOutOnPlayRunnerPayload>;
  /** Deletes a single `OutOnPlayRunner` using a unique key. */
  deleteOutOnPlayRunner: Maybe<DeleteOutOnPlayRunnerPayload>;
  /** Deletes a single `PlateAppearance` using its globally unique id. */
  deletePlateAppearanceByNodeId: Maybe<DeletePlateAppearancePayload>;
  /** Deletes a single `PlateAppearance` using a unique key. */
  deletePlateAppearance: Maybe<DeletePlateAppearancePayload>;
  /** Deletes a single `Player` using its globally unique id. */
  deletePlayerByNodeId: Maybe<DeletePlayerPayload>;
  /** Deletes a single `Player` using a unique key. */
  deletePlayer: Maybe<DeletePlayerPayload>;
  /** Deletes a single `Player` using a unique key. */
  deletePlayerByFirstNameAndLastName: Maybe<DeletePlayerPayload>;
  /** Deletes a single `ScoredRunner` using its globally unique id. */
  deleteScoredRunnerByNodeId: Maybe<DeleteScoredRunnerPayload>;
  /** Deletes a single `ScoredRunner` using a unique key. */
  deleteScoredRunner: Maybe<DeleteScoredRunnerPayload>;
  /** Deletes a single `StolenBaseAttempt` using its globally unique id. */
  deleteStolenBaseAttemptByNodeId: Maybe<DeleteStolenBaseAttemptPayload>;
  /** Deletes a single `StolenBaseAttempt` using a unique key. */
  deleteStolenBaseAttempt: Maybe<DeleteStolenBaseAttemptPayload>;
  /** Deletes a single `Team` using its globally unique id. */
  deleteTeamByNodeId: Maybe<DeleteTeamPayload>;
  /** Deletes a single `Team` using a unique key. */
  deleteTeam: Maybe<DeleteTeamPayload>;
  /** Deletes a single `Team` using a unique key. */
  deleteTeamByGameIdAndRole: Maybe<DeleteTeamPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateBaseRunnerArgs = {
  input: CreateBaseRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateBasepathMovementArgs = {
  input: CreateBasepathMovementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFieldArgs = {
  input: CreateFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateForeignDbFieldArgs = {
  input: CreateForeignDbFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateForeignDbGameArgs = {
  input: CreateForeignDbGameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateForeignDbPlayerArgs = {
  input: CreateForeignDbPlayerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateForeignDbStatLineArgs = {
  input: CreateForeignDbStatLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateForeignDbTeamArgs = {
  input: CreateForeignDbTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameArgs = {
  input: CreateGameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameEventArgs = {
  input: CreateGameEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameEventRecordArgs = {
  input: CreateGameEventRecordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameStateArgs = {
  input: CreateGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGroupArgs = {
  input: CreateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLineupArgs = {
  input: CreateLineupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLineupChangeArgs = {
  input: CreateLineupChangeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLineupForGameStateArgs = {
  input: CreateLineupForGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLineupSpotArgs = {
  input: CreateLineupSpotInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOutOnPlayRunnerArgs = {
  input: CreateOutOnPlayRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlateAppearanceArgs = {
  input: CreatePlateAppearanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlayerArgs = {
  input: CreatePlayerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateScoredRunnerArgs = {
  input: CreateScoredRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStolenBaseAttemptArgs = {
  input: CreateStolenBaseAttemptInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTeamArgs = {
  input: CreateTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBaseRunnerByNodeIdArgs = {
  input: UpdateBaseRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBaseRunnerArgs = {
  input: UpdateBaseRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBasepathMovementByNodeIdArgs = {
  input: UpdateBasepathMovementByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBasepathMovementArgs = {
  input: UpdateBasepathMovementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldByNodeIdArgs = {
  input: UpdateFieldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldArgs = {
  input: UpdateFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameByNodeIdArgs = {
  input: UpdateGameByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameArgs = {
  input: UpdateGameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameByNameArgs = {
  input: UpdateGameByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameEventByNodeIdArgs = {
  input: UpdateGameEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameEventArgs = {
  input: UpdateGameEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameEventRecordByNodeIdArgs = {
  input: UpdateGameEventRecordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameEventRecordArgs = {
  input: UpdateGameEventRecordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameEventRecordByGameIdAndEventIndexArgs = {
  input: UpdateGameEventRecordByGameIdAndEventIndexInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameStateByNodeIdArgs = {
  input: UpdateGameStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameStateArgs = {
  input: UpdateGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupByNodeIdArgs = {
  input: UpdateGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupArgs = {
  input: UpdateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupByNameArgs = {
  input: UpdateGroupByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupByNodeIdArgs = {
  input: UpdateLineupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupArgs = {
  input: UpdateLineupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupChangeByNodeIdArgs = {
  input: UpdateLineupChangeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupChangeArgs = {
  input: UpdateLineupChangeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupForGameStateByNodeIdArgs = {
  input: UpdateLineupForGameStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupForGameStateArgs = {
  input: UpdateLineupForGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupSpotByNodeIdArgs = {
  input: UpdateLineupSpotByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupSpotArgs = {
  input: UpdateLineupSpotInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupSpotByLineupIdAndBattingOrderArgs = {
  input: UpdateLineupSpotByLineupIdAndBattingOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupSpotByLineupIdAndPositionArgs = {
  input: UpdateLineupSpotByLineupIdAndPositionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOutOnPlayRunnerByNodeIdArgs = {
  input: UpdateOutOnPlayRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOutOnPlayRunnerArgs = {
  input: UpdateOutOnPlayRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlateAppearanceByNodeIdArgs = {
  input: UpdatePlateAppearanceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlateAppearanceArgs = {
  input: UpdatePlateAppearanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerByNodeIdArgs = {
  input: UpdatePlayerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerArgs = {
  input: UpdatePlayerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerByFirstNameAndLastNameArgs = {
  input: UpdatePlayerByFirstNameAndLastNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateScoredRunnerByNodeIdArgs = {
  input: UpdateScoredRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateScoredRunnerArgs = {
  input: UpdateScoredRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStolenBaseAttemptByNodeIdArgs = {
  input: UpdateStolenBaseAttemptByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStolenBaseAttemptArgs = {
  input: UpdateStolenBaseAttemptInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTeamByNodeIdArgs = {
  input: UpdateTeamByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTeamArgs = {
  input: UpdateTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTeamByGameIdAndRoleArgs = {
  input: UpdateTeamByGameIdAndRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBaseRunnerByNodeIdArgs = {
  input: DeleteBaseRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBaseRunnerArgs = {
  input: DeleteBaseRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBasepathMovementByNodeIdArgs = {
  input: DeleteBasepathMovementByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBasepathMovementArgs = {
  input: DeleteBasepathMovementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldByNodeIdArgs = {
  input: DeleteFieldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldArgs = {
  input: DeleteFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameByNodeIdArgs = {
  input: DeleteGameByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameArgs = {
  input: DeleteGameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameByNameArgs = {
  input: DeleteGameByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameEventByNodeIdArgs = {
  input: DeleteGameEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameEventArgs = {
  input: DeleteGameEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameEventRecordByNodeIdArgs = {
  input: DeleteGameEventRecordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameEventRecordArgs = {
  input: DeleteGameEventRecordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameEventRecordByGameIdAndEventIndexArgs = {
  input: DeleteGameEventRecordByGameIdAndEventIndexInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameStateByNodeIdArgs = {
  input: DeleteGameStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameStateArgs = {
  input: DeleteGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupByNodeIdArgs = {
  input: DeleteGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupArgs = {
  input: DeleteGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupByNameArgs = {
  input: DeleteGroupByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupByNodeIdArgs = {
  input: DeleteLineupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupArgs = {
  input: DeleteLineupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupChangeByNodeIdArgs = {
  input: DeleteLineupChangeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupChangeArgs = {
  input: DeleteLineupChangeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupForGameStateByNodeIdArgs = {
  input: DeleteLineupForGameStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupForGameStateArgs = {
  input: DeleteLineupForGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupSpotByNodeIdArgs = {
  input: DeleteLineupSpotByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupSpotArgs = {
  input: DeleteLineupSpotInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupSpotByLineupIdAndBattingOrderArgs = {
  input: DeleteLineupSpotByLineupIdAndBattingOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupSpotByLineupIdAndPositionArgs = {
  input: DeleteLineupSpotByLineupIdAndPositionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOutOnPlayRunnerByNodeIdArgs = {
  input: DeleteOutOnPlayRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOutOnPlayRunnerArgs = {
  input: DeleteOutOnPlayRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlateAppearanceByNodeIdArgs = {
  input: DeletePlateAppearanceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlateAppearanceArgs = {
  input: DeletePlateAppearanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerByNodeIdArgs = {
  input: DeletePlayerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerArgs = {
  input: DeletePlayerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerByFirstNameAndLastNameArgs = {
  input: DeletePlayerByFirstNameAndLastNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteScoredRunnerByNodeIdArgs = {
  input: DeleteScoredRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteScoredRunnerArgs = {
  input: DeleteScoredRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStolenBaseAttemptByNodeIdArgs = {
  input: DeleteStolenBaseAttemptByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStolenBaseAttemptArgs = {
  input: DeleteStolenBaseAttemptInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTeamByNodeIdArgs = {
  input: DeleteTeamByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTeamArgs = {
  input: DeleteTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTeamByGameIdAndRoleArgs = {
  input: DeleteTeamByGameIdAndRoleInput;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type OutOnPlayRunner = Node & {
  __typename?: 'OutOnPlayRunner';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
  /** Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `OutOnPlayRunner`. */
  runner: Maybe<Player>;
};

/**
 * A condition to be used against `OutOnPlayRunner` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OutOnPlayRunnerCondition = {
  /** Checks for equality with the object’s `plateAppearanceId` field. */
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runnerId` field. */
  runnerId?: Maybe<Scalars['UUID']>;
};

/** An input for mutations affecting `OutOnPlayRunner` */
export type OutOnPlayRunnerInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type OutOnPlayRunnerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `outOnPlayRunner` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type OutOnPlayRunnerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `outOnPlayRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** The fields on `outOnPlayRunner` to look up the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingOutOnPlayRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `outOnPlayRunner` to look up the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingOutOnPlayRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The fields on `outOnPlayRunner` to look up the row to connect. */
export type OutOnPlayRunnerOutOnPlayRunnerPkeyConnect = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The fields on `outOnPlayRunner` to look up the row to delete. */
export type OutOnPlayRunnerOutOnPlayRunnerPkeyDelete = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** Represents an update to a `OutOnPlayRunner`. Fields that are set will be updated. */
export type OutOnPlayRunnerPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
};

/** Input for the nested mutation of `plateAppearance` in the `OutOnPlayRunnerInput` mutation. */
export type OutOnPlayRunnerPlateAppearanceIdFkeyInput = {
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectById?: Maybe<PlateAppearancePlateAppearancePkeyConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlateAppearanceNodeIdConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteById?: Maybe<PlateAppearancePlateAppearancePkeyDelete>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlateAppearanceNodeIdDelete>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateById?: Maybe<PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateByNodeId?: Maybe<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate>;
  /** A `PlateAppearanceInput` object that will be created and connected to this object. */
  create?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyPlateAppearanceCreateInput>;
};

/** Input for the nested mutation of `outOnPlayRunner` in the `PlateAppearanceInput` mutation. */
export type OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput = {
  /** Flag indicating whether all other `outOnPlayRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyDelete>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingOutOnPlayRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate>>;
  /** A `OutOnPlayRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<OutOnPlayRunnerPlateAppearanceIdFkeyOutOnPlayRunnerCreateInput>>;
};

/** The `outOnPlayRunner` to be created by this mutation. */
export type OutOnPlayRunnerPlateAppearanceIdFkeyOutOnPlayRunnerCreateInput = {
  runnerId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
};

/** The `plateAppearance` to be created by this mutation. */
export type OutOnPlayRunnerPlateAppearanceIdFkeyPlateAppearanceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** Input for the nested mutation of `player` in the `OutOnPlayRunnerInput` mutation. */
export type OutOnPlayRunnerRunnerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<OutOnPlayRunnerRunnerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `outOnPlayRunner` in the `PlayerInput` mutation. */
export type OutOnPlayRunnerRunnerIdFkeyInverseInput = {
  /** Flag indicating whether all other `outOnPlayRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyDelete>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingOutOnPlayRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate>>;
  /** A `OutOnPlayRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<OutOnPlayRunnerRunnerIdFkeyOutOnPlayRunnerCreateInput>>;
};

/** The `outOnPlayRunner` to be created by this mutation. */
export type OutOnPlayRunnerRunnerIdFkeyOutOnPlayRunnerCreateInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
};

/** The `player` to be created by this mutation. */
export type OutOnPlayRunnerRunnerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** Methods to use when ordering `OutOnPlayRunner`. */
export enum OutOnPlayRunnersOrderBy {
  NATURAL = 'NATURAL',
  PLATE_APPEARANCE_ID_ASC = 'PLATE_APPEARANCE_ID_ASC',
  PLATE_APPEARANCE_ID_DESC = 'PLATE_APPEARANCE_ID_DESC',
  RUNNER_ID_ASC = 'RUNNER_ID_ASC',
  RUNNER_ID_DESC = 'RUNNER_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type PlateAppearance = Node & {
  __typename?: 'PlateAppearance';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  type: PlateAppearanceType;
  contact: Maybe<ContactQuality>;
  fieldedBy: Maybe<FieldingPosition>;
  runsScoredOnSacFly: Maybe<Scalars['Int']>;
  routinePlay: Scalars['Boolean'];
  /** Reads and enables pagination through a set of `BasepathMovement`. */
  basepathMovements: Array<BasepathMovement>;
  /** Reads and enables pagination through a set of `OutOnPlayRunner`. */
  outOnPlayRunners: Array<OutOnPlayRunner>;
};


export type PlateAppearanceBasepathMovementsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BasepathMovementsOrderBy>>;
  condition?: Maybe<BasepathMovementCondition>;
};


export type PlateAppearanceOutOnPlayRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<OutOnPlayRunnersOrderBy>>;
  condition?: Maybe<OutOnPlayRunnerCondition>;
};

/**
 * A condition to be used against `PlateAppearance` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PlateAppearanceCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<PlateAppearanceType>;
  /** Checks for equality with the object’s `contact` field. */
  contact?: Maybe<ContactQuality>;
  /** Checks for equality with the object’s `fieldedBy` field. */
  fieldedBy?: Maybe<FieldingPosition>;
  /** Checks for equality with the object’s `runsScoredOnSacFly` field. */
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `routinePlay` field. */
  routinePlay?: Maybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `PlateAppearance` */
export type PlateAppearanceInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PlateAppearanceNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PlateAppearanceNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `basepathMovement` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: BasepathMovementPatch;
};

/** The fields on `plateAppearance` to look up the row to update. */
export type PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate = {
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: UpdatePlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `plateAppearance` to look up the row to update. */
export type PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate = {
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: UpdatePlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `outOnPlayRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: OutOnPlayRunnerPatch;
};

/** The fields on `plateAppearance` to look up the row to update. */
export type PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate = {
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: UpdatePlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `PlateAppearance`. Fields that are set will be updated. */
export type PlateAppearancePatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** The fields on `plateAppearance` to look up the row to connect. */
export type PlateAppearancePlateAppearancePkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `plateAppearance` to look up the row to delete. */
export type PlateAppearancePlateAppearancePkeyDelete = {
  id: Scalars['UUID'];
};

export enum PlateAppearanceType {
  OUT = 'OUT',
  WALK = 'WALK',
  SINGLE = 'SINGLE',
  DOUBLE = 'DOUBLE',
  TRIPLE = 'TRIPLE',
  HOMERUN = 'HOMERUN',
  SACRIFICE_FLY = 'SACRIFICE_FLY',
  FIELDERS_CHOICE = 'FIELDERS_CHOICE',
  DOUBLE_PLAY = 'DOUBLE_PLAY'
}

/** Methods to use when ordering `PlateAppearance`. */
export enum PlateAppearancesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  TYPE_ASC = 'TYPE_ASC',
  TYPE_DESC = 'TYPE_DESC',
  CONTACT_ASC = 'CONTACT_ASC',
  CONTACT_DESC = 'CONTACT_DESC',
  FIELDED_BY_ASC = 'FIELDED_BY_ASC',
  FIELDED_BY_DESC = 'FIELDED_BY_DESC',
  RUNS_SCORED_ON_SAC_FLY_ASC = 'RUNS_SCORED_ON_SAC_FLY_ASC',
  RUNS_SCORED_ON_SAC_FLY_DESC = 'RUNS_SCORED_ON_SAC_FLY_DESC',
  ROUTINE_PLAY_ASC = 'ROUTINE_PLAY_ASC',
  ROUTINE_PLAY_DESC = 'ROUTINE_PLAY_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type Player = Node & {
  __typename?: 'Player';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  groupId: Scalars['UUID'];
  legacyPlayerId: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName: Maybe<Scalars['String']>;
  nickname: Maybe<Scalars['String']>;
  imageUrl: Maybe<Scalars['String']>;
  timeCreated: Maybe<Scalars['Datetime']>;
  /** Reads a single `Group` that is related to this `Player`. */
  group: Maybe<Group>;
  /** Reads a single `LegacyPlayer` that is related to this `Player`. */
  legacyPlayer: Maybe<LegacyPlayer>;
  /** Reads and enables pagination through a set of `Team`. */
  teamsByCaptainId: Array<Team>;
  /** Reads and enables pagination through a set of `LineupSpot`. */
  lineupSpots: Array<LineupSpot>;
  /** Reads and enables pagination through a set of `BasepathMovement`. */
  basepathMovementsByRunnerId: Array<BasepathMovement>;
  /** Reads and enables pagination through a set of `OutOnPlayRunner`. */
  outOnPlayRunnersByRunnerId: Array<OutOnPlayRunner>;
  /** Reads and enables pagination through a set of `StolenBaseAttempt`. */
  stolenBaseAttemptsByRunnerId: Array<StolenBaseAttempt>;
  /** Reads and enables pagination through a set of `GameState`. */
  gameStatesByPlayerAtBat: Array<GameState>;
  /** Reads and enables pagination through a set of `BaseRunner`. */
  baseRunnersByRunnerId: Array<BaseRunner>;
  /** Reads and enables pagination through a set of `ScoredRunner`. */
  scoredRunnersByRunnerId: Array<ScoredRunner>;
  /** Reads and enables pagination through a set of `CareerStat`. */
  careerStats: Array<CareerStat>;
  /** Reads and enables pagination through a set of `CareerStatsQualifiedBatter`. */
  careerStatsQualifiedBatters: Array<CareerStatsQualifiedBatter>;
  /** Reads and enables pagination through a set of `LegacySeasonStat`. */
  legacySeasonStats: Array<LegacySeasonStat>;
  /** Reads and enables pagination through a set of `SeasonStat`. */
  seasonStats: Array<SeasonStat>;
  /** Reads and enables pagination through a set of `SeasonStatsAllTimeQualifiedBatter`. */
  seasonStatsAllTimeQualifiedBatters: Array<SeasonStatsAllTimeQualifiedBatter>;
  /** Reads and enables pagination through a set of `SeasonStatsQualifiedBatter`. */
  seasonStatsQualifiedBatters: Array<SeasonStatsQualifiedBatter>;
  fullName: Maybe<Scalars['String']>;
  gamesPlayed: Maybe<Scalars['Int']>;
  /** sortable */
  gamesPlayedThisYear: Maybe<Scalars['Int']>;
  traditionalStats: Maybe<TraditionalStatLine>;
};


export type PlayerTeamsByCaptainIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<TeamsOrderBy>>;
  condition?: Maybe<TeamCondition>;
};


export type PlayerLineupSpotsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupSpotsOrderBy>>;
  condition?: Maybe<LineupSpotCondition>;
};


export type PlayerBasepathMovementsByRunnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BasepathMovementsOrderBy>>;
  condition?: Maybe<BasepathMovementCondition>;
};


export type PlayerOutOnPlayRunnersByRunnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<OutOnPlayRunnersOrderBy>>;
  condition?: Maybe<OutOnPlayRunnerCondition>;
};


export type PlayerStolenBaseAttemptsByRunnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<StolenBaseAttemptsOrderBy>>;
  condition?: Maybe<StolenBaseAttemptCondition>;
};


export type PlayerGameStatesByPlayerAtBatArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameStatesOrderBy>>;
  condition?: Maybe<GameStateCondition>;
};


export type PlayerBaseRunnersByRunnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BaseRunnersOrderBy>>;
  condition?: Maybe<BaseRunnerCondition>;
};


export type PlayerScoredRunnersByRunnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ScoredRunnersOrderBy>>;
  condition?: Maybe<ScoredRunnerCondition>;
};


export type PlayerCareerStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsOrderBy>>;
  condition?: Maybe<CareerStatCondition>;
};


export type PlayerCareerStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<CareerStatsQualifiedBatterCondition>;
};


export type PlayerLegacySeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacySeasonStatsOrderBy>>;
  condition?: Maybe<LegacySeasonStatCondition>;
};


export type PlayerSeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsOrderBy>>;
  condition?: Maybe<SeasonStatCondition>;
};


export type PlayerSeasonStatsAllTimeQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsAllTimeQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsAllTimeQualifiedBatterCondition>;
};


export type PlayerSeasonStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsQualifiedBatterCondition>;
};


export type PlayerGamesPlayedArgs = {
  beforeDate?: Maybe<Scalars['Datetime']>;
  afterDate?: Maybe<Scalars['Datetime']>;
};


export type PlayerTraditionalStatsArgs = {
  beforeDate?: Maybe<Scalars['Datetime']>;
  afterDate?: Maybe<Scalars['Datetime']>;
};

/** A condition to be used against `Player` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PlayerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `nickname` field. */
  nickname?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `imageUrl` field. */
  imageUrl?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: Maybe<Scalars['Datetime']>;
};

/** The `group` to be created by this mutation. */
export type PlayerGroupIdFkeyGroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** Input for the nested mutation of `group` in the `PlayerInput` mutation. */
export type PlayerGroupIdFkeyInput = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnPlayerForPlayerGroupIdFkeyUsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnPlayerForPlayerGroupIdFkeyUsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<PlayerOnPlayerForPlayerGroupIdFkeyNodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<PlayerGroupIdFkeyGroupCreateInput>;
};

/** Input for the nested mutation of `player` in the `GroupInput` mutation. */
export type PlayerGroupIdFkeyInverseInput = {
  /** Flag indicating whether all other `player` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<Array<PlayerPlayerPkeyConnect>>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<Array<PlayerPlayerFirstNameLastNameKeyConnect>>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PlayerNodeIdConnect>>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<Array<PlayerPlayerPkeyDelete>>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<Array<PlayerPlayerFirstNameLastNameKeyDelete>>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PlayerNodeIdDelete>>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<Array<PlayerOnPlayerForPlayerGroupIdFkeyUsingPlayerPkeyUpdate>>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<Array<PlayerOnPlayerForPlayerGroupIdFkeyUsingPlayerFirstNameLastNameKeyUpdate>>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GroupOnPlayerForPlayerGroupIdFkeyNodeIdUpdate>>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PlayerGroupIdFkeyPlayerCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type PlayerGroupIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An input for mutations affecting `Player` */
export type PlayerInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PlayerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PlayerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `player` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `baseRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: BaseRunnerPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `basepathMovement` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: BasepathMovementPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnCareerStatForFakePublicCareerStatsForeignKey0UsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnCareerStatForFakePublicCareerStatsForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnCareerStatForFakePublicCareerStatsForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnCareerStatForFakePublicCareerStatsForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0UsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnGameStateForGameStatePlayerAtBatFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnGameStateForGameStatePlayerAtBatFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0UsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupSpot` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: LineupSpotPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnLineupSpotForLineupSpotPlayerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnLineupSpotForLineupSpotPlayerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `outOnPlayRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: OutOnPlayRunnerPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnPlayerForFakePublicPlayerForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: LegacyPlayerPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlayerForFakePublicPlayerForeignKey0UsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlayerForFakePublicPlayerForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlayerForFakePublicPlayerForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlayerForFakePublicPlayerForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnPlayerForPlayerGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlayerForPlayerGroupIdFkeyUsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlayerForPlayerGroupIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlayerForPlayerGroupIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlayerForPlayerGroupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scoredRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: ScoredRunnerPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnSeasonStatForFakePublicSeasonStatsForeignKey0UsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnSeasonStatForFakePublicSeasonStatsForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnSeasonStatForFakePublicSeasonStatsForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnSeasonStatForFakePublicSeasonStatsForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0UsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0UsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `stolenBaseAttempt` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: StolenBaseAttemptPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnTeamForTeamCaptainIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `team` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: TeamPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerFirstNameLastNameKeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnTeamForTeamCaptainIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnTeamForTeamCaptainIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Player`. Fields that are set will be updated. */
export type PlayerPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The fields on `player` to look up the row to connect. */
export type PlayerPlayerFirstNameLastNameKeyConnect = {
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to delete. */
export type PlayerPlayerFirstNameLastNameKeyDelete = {
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to connect. */
export type PlayerPlayerPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `player` to look up the row to delete. */
export type PlayerPlayerPkeyDelete = {
  id: Scalars['UUID'];
};

/** Methods to use when ordering `Player`. */
export enum PlayersOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  FIRST_NAME_ASC = 'FIRST_NAME_ASC',
  FIRST_NAME_DESC = 'FIRST_NAME_DESC',
  LAST_NAME_ASC = 'LAST_NAME_ASC',
  LAST_NAME_DESC = 'LAST_NAME_DESC',
  NICKNAME_ASC = 'NICKNAME_ASC',
  NICKNAME_DESC = 'NICKNAME_DESC',
  IMAGE_URL_ASC = 'IMAGE_URL_ASC',
  IMAGE_URL_DESC = 'IMAGE_URL_DESC',
  TIME_CREATED_ASC = 'TIME_CREATED_ASC',
  TIME_CREATED_DESC = 'TIME_CREATED_DESC',
  FULL_NAME_ASC = 'FULL_NAME_ASC',
  FULL_NAME_DESC = 'FULL_NAME_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. */
  node: Maybe<Node>;
  /** Reads a set of `BaseRunner`. */
  baseRunners: Maybe<Array<BaseRunner>>;
  /** Reads a set of `BasepathMovement`. */
  basepathMovements: Maybe<Array<BasepathMovement>>;
  /** Reads a set of `CareerStat`. */
  careerStats: Maybe<Array<CareerStat>>;
  /** Reads a set of `CareerStatsQualifiedBatter`. */
  careerStatsQualifiedBatters: Maybe<Array<CareerStatsQualifiedBatter>>;
  /** Reads a set of `Field`. */
  fields: Maybe<Array<Field>>;
  /** Reads a set of `ForeignDbField`. */
  foreignDbFields: Maybe<Array<ForeignDbField>>;
  /** Reads a set of `ForeignDbGame`. */
  foreignDbGames: Maybe<Array<ForeignDbGame>>;
  /** Reads a set of `ForeignDbPlayer`. */
  foreignDbPlayers: Maybe<Array<ForeignDbPlayer>>;
  /** Reads a set of `ForeignDbStatLine`. */
  foreignDbStatLines: Maybe<Array<ForeignDbStatLine>>;
  /** Reads a set of `ForeignDbTeam`. */
  foreignDbTeams: Maybe<Array<ForeignDbTeam>>;
  /** Reads a set of `Game`. */
  games: Maybe<Array<Game>>;
  /** Reads a set of `GameEvent`. */
  gameEvents: Maybe<Array<GameEvent>>;
  /** Reads a set of `GameEventRecord`. */
  gameEventRecords: Maybe<Array<GameEventRecord>>;
  /** Reads a set of `GameState`. */
  gameStates: Maybe<Array<GameState>>;
  /** Reads a set of `Group`. */
  groups: Maybe<Array<Group>>;
  /** Reads a set of `LegacyField`. */
  legacyFields: Maybe<Array<LegacyField>>;
  /** Reads a set of `LegacyGame`. */
  legacyGames: Maybe<Array<LegacyGame>>;
  /** Reads a set of `LegacyPlayer`. */
  legacyPlayers: Maybe<Array<LegacyPlayer>>;
  /** Reads a set of `LegacySeason`. */
  legacySeasons: Maybe<Array<LegacySeason>>;
  /** Reads a set of `LegacySeasonStat`. */
  legacySeasonStats: Maybe<Array<LegacySeasonStat>>;
  /** Reads a set of `LegacyStatLine`. */
  legacyStatLines: Maybe<Array<LegacyStatLine>>;
  /** Reads a set of `LegacyTeam`. */
  legacyTeams: Maybe<Array<LegacyTeam>>;
  /** Reads a set of `Lineup`. */
  lineups: Maybe<Array<Lineup>>;
  /** Reads a set of `LineupChange`. */
  lineupChanges: Maybe<Array<LineupChange>>;
  /** Reads a set of `LineupForGameState`. */
  lineupForGameStates: Maybe<Array<LineupForGameState>>;
  /** Reads a set of `LineupSpot`. */
  lineupSpots: Maybe<Array<LineupSpot>>;
  /** Reads a set of `ModernSeasonStat`. */
  modernSeasonStats: Maybe<Array<ModernSeasonStat>>;
  /** Reads a set of `OutOnPlayRunner`. */
  outOnPlayRunners: Maybe<Array<OutOnPlayRunner>>;
  /** Reads a set of `PlateAppearance`. */
  plateAppearances: Maybe<Array<PlateAppearance>>;
  /** Reads a set of `Player`. */
  players: Maybe<Array<Player>>;
  /** Reads a set of `ScoredRunner`. */
  scoredRunners: Maybe<Array<ScoredRunner>>;
  /** Reads a set of `Season`. */
  seasons: Maybe<Array<Season>>;
  /** Reads a set of `SeasonStat`. */
  seasonStats: Maybe<Array<SeasonStat>>;
  /** Reads a set of `SeasonStatsAllTimeQualifiedBatter`. */
  seasonStatsAllTimeQualifiedBatters: Maybe<Array<SeasonStatsAllTimeQualifiedBatter>>;
  /** Reads a set of `SeasonStatsQualifiedBatter`. */
  seasonStatsQualifiedBatters: Maybe<Array<SeasonStatsQualifiedBatter>>;
  /** Reads a set of `StolenBaseAttempt`. */
  stolenBaseAttempts: Maybe<Array<StolenBaseAttempt>>;
  /** Reads a set of `Team`. */
  teams: Maybe<Array<Team>>;
  baseRunner: Maybe<BaseRunner>;
  basepathMovement: Maybe<BasepathMovement>;
  field: Maybe<Field>;
  game: Maybe<Game>;
  gameByName: Maybe<Game>;
  gameEvent: Maybe<GameEvent>;
  gameEventRecord: Maybe<GameEventRecord>;
  gameEventRecordByGameIdAndEventIndex: Maybe<GameEventRecord>;
  gameState: Maybe<GameState>;
  group: Maybe<Group>;
  groupByName: Maybe<Group>;
  legacyField: Maybe<LegacyField>;
  legacyGame: Maybe<LegacyGame>;
  legacyPlayer: Maybe<LegacyPlayer>;
  legacyTeam: Maybe<LegacyTeam>;
  lineup: Maybe<Lineup>;
  lineupChange: Maybe<LineupChange>;
  lineupForGameState: Maybe<LineupForGameState>;
  lineupSpot: Maybe<LineupSpot>;
  lineupSpotByLineupIdAndBattingOrder: Maybe<LineupSpot>;
  lineupSpotByLineupIdAndPosition: Maybe<LineupSpot>;
  outOnPlayRunner: Maybe<OutOnPlayRunner>;
  plateAppearance: Maybe<PlateAppearance>;
  player: Maybe<Player>;
  playerByFirstNameAndLastName: Maybe<Player>;
  scoredRunner: Maybe<ScoredRunner>;
  season: Maybe<Season>;
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  team: Maybe<Team>;
  teamByGameIdAndRole: Maybe<Team>;
  getAvg: Maybe<Scalars['Float']>;
  getObp: Maybe<Scalars['Float']>;
  getOps: Maybe<Scalars['Float']>;
  getPlateAppearances: Maybe<Array<Maybe<GetPlateAppearancesRecord>>>;
  getRunsScored: Maybe<Array<Maybe<GetRunsScoredRecord>>>;
  getSlg: Maybe<Scalars['Float']>;
  getTb: Maybe<Scalars['Int']>;
  /** Reads a single `BaseRunner` using its globally unique `ID`. */
  baseRunnerByNodeId: Maybe<BaseRunner>;
  /** Reads a single `BasepathMovement` using its globally unique `ID`. */
  basepathMovementByNodeId: Maybe<BasepathMovement>;
  /** Reads a single `Field` using its globally unique `ID`. */
  fieldByNodeId: Maybe<Field>;
  /** Reads a single `Game` using its globally unique `ID`. */
  gameByNodeId: Maybe<Game>;
  /** Reads a single `GameEvent` using its globally unique `ID`. */
  gameEventByNodeId: Maybe<GameEvent>;
  /** Reads a single `GameEventRecord` using its globally unique `ID`. */
  gameEventRecordByNodeId: Maybe<GameEventRecord>;
  /** Reads a single `GameState` using its globally unique `ID`. */
  gameStateByNodeId: Maybe<GameState>;
  /** Reads a single `Group` using its globally unique `ID`. */
  groupByNodeId: Maybe<Group>;
  /** Reads a single `LegacyField` using its globally unique `ID`. */
  legacyFieldByNodeId: Maybe<LegacyField>;
  /** Reads a single `LegacyGame` using its globally unique `ID`. */
  legacyGameByNodeId: Maybe<LegacyGame>;
  /** Reads a single `LegacyPlayer` using its globally unique `ID`. */
  legacyPlayerByNodeId: Maybe<LegacyPlayer>;
  /** Reads a single `LegacyTeam` using its globally unique `ID`. */
  legacyTeamByNodeId: Maybe<LegacyTeam>;
  /** Reads a single `Lineup` using its globally unique `ID`. */
  lineupByNodeId: Maybe<Lineup>;
  /** Reads a single `LineupChange` using its globally unique `ID`. */
  lineupChangeByNodeId: Maybe<LineupChange>;
  /** Reads a single `LineupForGameState` using its globally unique `ID`. */
  lineupForGameStateByNodeId: Maybe<LineupForGameState>;
  /** Reads a single `LineupSpot` using its globally unique `ID`. */
  lineupSpotByNodeId: Maybe<LineupSpot>;
  /** Reads a single `OutOnPlayRunner` using its globally unique `ID`. */
  outOnPlayRunnerByNodeId: Maybe<OutOnPlayRunner>;
  /** Reads a single `PlateAppearance` using its globally unique `ID`. */
  plateAppearanceByNodeId: Maybe<PlateAppearance>;
  /** Reads a single `Player` using its globally unique `ID`. */
  playerByNodeId: Maybe<Player>;
  /** Reads a single `ScoredRunner` using its globally unique `ID`. */
  scoredRunnerByNodeId: Maybe<ScoredRunner>;
  /** Reads a single `Season` using its globally unique `ID`. */
  seasonByNodeId: Maybe<Season>;
  /** Reads a single `StolenBaseAttempt` using its globally unique `ID`. */
  stolenBaseAttemptByNodeId: Maybe<StolenBaseAttempt>;
  /** Reads a single `Team` using its globally unique `ID`. */
  teamByNodeId: Maybe<Team>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBaseRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BaseRunnersOrderBy>>;
  condition?: Maybe<BaseRunnerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryBasepathMovementsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BasepathMovementsOrderBy>>;
  condition?: Maybe<BasepathMovementCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCareerStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsOrderBy>>;
  condition?: Maybe<CareerStatCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCareerStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<CareerStatsQualifiedBatterCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<FieldsOrderBy>>;
  condition?: Maybe<FieldCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryForeignDbFieldsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ForeignDbFieldsOrderBy>>;
  condition?: Maybe<ForeignDbFieldCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryForeignDbGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ForeignDbGamesOrderBy>>;
  condition?: Maybe<ForeignDbGameCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryForeignDbPlayersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ForeignDbPlayersOrderBy>>;
  condition?: Maybe<ForeignDbPlayerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryForeignDbStatLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ForeignDbStatLinesOrderBy>>;
  condition?: Maybe<ForeignDbStatLineCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryForeignDbTeamsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ForeignDbTeamsOrderBy>>;
  condition?: Maybe<ForeignDbTeamCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GamesOrderBy>>;
  condition?: Maybe<GameCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventsOrderBy>>;
  condition?: Maybe<GameEventCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventRecordsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventRecordsOrderBy>>;
  condition?: Maybe<GameEventRecordCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameStatesOrderBy>>;
  condition?: Maybe<GameStateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
  condition?: Maybe<GroupCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyFieldsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyFieldsOrderBy>>;
  condition?: Maybe<LegacyFieldCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyGamesOrderBy>>;
  condition?: Maybe<LegacyGameCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyPlayersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyPlayersOrderBy>>;
  condition?: Maybe<LegacyPlayerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacySeasonsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacySeasonsOrderBy>>;
  condition?: Maybe<LegacySeasonCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacySeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacySeasonStatsOrderBy>>;
  condition?: Maybe<LegacySeasonStatCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyStatLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyStatLinesOrderBy>>;
  condition?: Maybe<LegacyStatLineCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyTeamsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyTeamsOrderBy>>;
  condition?: Maybe<LegacyTeamCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupsOrderBy>>;
  condition?: Maybe<LineupCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupChangesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupChangesOrderBy>>;
  condition?: Maybe<LineupChangeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupForGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupForGameStatesOrderBy>>;
  condition?: Maybe<LineupForGameStateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupSpotsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupSpotsOrderBy>>;
  condition?: Maybe<LineupSpotCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryModernSeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ModernSeasonStatsOrderBy>>;
  condition?: Maybe<ModernSeasonStatCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOutOnPlayRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<OutOnPlayRunnersOrderBy>>;
  condition?: Maybe<OutOnPlayRunnerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlateAppearancesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlateAppearancesOrderBy>>;
  condition?: Maybe<PlateAppearanceCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlayersOrderBy>>;
  condition?: Maybe<PlayerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryScoredRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ScoredRunnersOrderBy>>;
  condition?: Maybe<ScoredRunnerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySeasonsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonsOrderBy>>;
  condition?: Maybe<SeasonCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsOrderBy>>;
  condition?: Maybe<SeasonStatCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySeasonStatsAllTimeQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsAllTimeQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsAllTimeQualifiedBatterCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySeasonStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsQualifiedBatterCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryStolenBaseAttemptsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<StolenBaseAttemptsOrderBy>>;
  condition?: Maybe<StolenBaseAttemptCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<TeamsOrderBy>>;
  condition?: Maybe<TeamCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryBaseRunnerArgs = {
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBasepathMovementArgs = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameByNameArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventRecordArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventRecordByGameIdAndEventIndexArgs = {
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameStateArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupByNameArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyFieldArgs = {
  fieldId: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyGameArgs = {
  gameId: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyPlayerArgs = {
  playerId: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyTeamArgs = {
  teamId: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupChangeArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupForGameStateArgs = {
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupSpotArgs = {
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupSpotByLineupIdAndBattingOrderArgs = {
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupSpotByLineupIdAndPositionArgs = {
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};


/** The root query type which gives access points into the data universe. */
export type QueryOutOnPlayRunnerArgs = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlateAppearanceArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerByFirstNameAndLastNameArgs = {
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryScoredRunnerArgs = {
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySeasonArgs = {
  groupId: Scalars['UUID'];
  year: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStolenBaseAttemptArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamByGameIdAndRoleArgs = {
  gameId: Scalars['UUID'];
  role: TeamRole;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetAvgArgs = {
  hits?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetObpArgs = {
  hits?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetOpsArgs = {
  hits?: Maybe<Scalars['Int']>;
  totalBases?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetPlateAppearancesArgs = {
  playerId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  beforeDate?: Maybe<Scalars['Datetime']>;
  afterDate?: Maybe<Scalars['Datetime']>;
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetRunsScoredArgs = {
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  beforeDate?: Maybe<Scalars['Datetime']>;
  afterDate?: Maybe<Scalars['Datetime']>;
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetSlgArgs = {
  totalBases?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetTbArgs = {
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryBaseRunnerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBasepathMovementByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventRecordByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameStateByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyFieldByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyGameByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyPlayerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyTeamByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupChangeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupForGameStateByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupSpotByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOutOnPlayRunnerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlateAppearanceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryScoredRunnerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySeasonByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStolenBaseAttemptByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

export type ScoredRunner = Node & {
  __typename?: 'ScoredRunner';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
  battedIn: Scalars['Boolean'];
  /** Reads a single `GameEventRecord` that is related to this `ScoredRunner`. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Reads a single `Player` that is related to this `ScoredRunner`. */
  runner: Maybe<Player>;
};

/**
 * A condition to be used against `ScoredRunner` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ScoredRunnerCondition = {
  /** Checks for equality with the object’s `gameEventRecordId` field. */
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runnerId` field. */
  runnerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `battedIn` field. */
  battedIn?: Maybe<Scalars['Boolean']>;
};

/** The `gameEventRecord` to be created by this mutation. */
export type ScoredRunnerGameEventRecordIdFkeyGameEventRecordCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** Input for the nested mutation of `gameEventRecord` in the `ScoredRunnerInput` mutation. */
export type ScoredRunnerGameEventRecordIdFkeyInput = {
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectById?: Maybe<GameEventRecordGameEventRecordPkeyConnect>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByGameIdAndEventIndex?: Maybe<GameEventRecordGameEventRecordGameIdEventIndexKeyConnect>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameEventRecordNodeIdConnect>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteById?: Maybe<GameEventRecordGameEventRecordPkeyDelete>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByGameIdAndEventIndex?: Maybe<GameEventRecordGameEventRecordGameIdEventIndexKeyDelete>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameEventRecordNodeIdDelete>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateById?: Maybe<GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordPkeyUpdate>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByGameIdAndEventIndex?: Maybe<GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByNodeId?: Maybe<ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate>;
  /** A `GameEventRecordInput` object that will be created and connected to this object. */
  create?: Maybe<ScoredRunnerGameEventRecordIdFkeyGameEventRecordCreateInput>;
};

/** Input for the nested mutation of `scoredRunner` in the `GameEventRecordInput` mutation. */
export type ScoredRunnerGameEventRecordIdFkeyInverseInput = {
  /** Flag indicating whether all other `scoredRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ScoredRunnerNodeIdConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyDelete>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ScoredRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingScoredRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate>>;
  /** A `ScoredRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ScoredRunnerGameEventRecordIdFkeyScoredRunnerCreateInput>>;
};

/** The `scoredRunner` to be created by this mutation. */
export type ScoredRunnerGameEventRecordIdFkeyScoredRunnerCreateInput = {
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn: Scalars['Boolean'];
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
};

/** An input for mutations affecting `ScoredRunner` */
export type ScoredRunnerInput = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn: Scalars['Boolean'];
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ScoredRunnerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `scoredRunner` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ScoredRunnerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `scoredRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** The fields on `scoredRunner` to look up the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingScoredRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: UpdateScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch;
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `scoredRunner` to look up the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingScoredRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: UpdateScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch;
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** Represents an update to a `ScoredRunner`. Fields that are set will be updated. */
export type ScoredRunnerPatch = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn?: Maybe<Scalars['Boolean']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
};

/** Input for the nested mutation of `player` in the `ScoredRunnerInput` mutation. */
export type ScoredRunnerRunnerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<ScoredRunnerRunnerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `scoredRunner` in the `PlayerInput` mutation. */
export type ScoredRunnerRunnerIdFkeyInverseInput = {
  /** Flag indicating whether all other `scoredRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ScoredRunnerNodeIdConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyDelete>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ScoredRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingScoredRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate>>;
  /** A `ScoredRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ScoredRunnerRunnerIdFkeyScoredRunnerCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type ScoredRunnerRunnerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `scoredRunner` to be created by this mutation. */
export type ScoredRunnerRunnerIdFkeyScoredRunnerCreateInput = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  battedIn: Scalars['Boolean'];
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
};

/** The fields on `scoredRunner` to look up the row to connect. */
export type ScoredRunnerScoredRunnerPkeyConnect = {
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The fields on `scoredRunner` to look up the row to delete. */
export type ScoredRunnerScoredRunnerPkeyDelete = {
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** Methods to use when ordering `ScoredRunner`. */
export enum ScoredRunnersOrderBy {
  NATURAL = 'NATURAL',
  GAME_EVENT_RECORD_ID_ASC = 'GAME_EVENT_RECORD_ID_ASC',
  GAME_EVENT_RECORD_ID_DESC = 'GAME_EVENT_RECORD_ID_DESC',
  RUNNER_ID_ASC = 'RUNNER_ID_ASC',
  RUNNER_ID_DESC = 'RUNNER_ID_DESC',
  BATTED_IN_ASC = 'BATTED_IN_ASC',
  BATTED_IN_DESC = 'BATTED_IN_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type Season = Node & {
  __typename?: 'Season';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  groupId: Scalars['UUID'];
  year: Scalars['Int'];
  totalGames: Maybe<Scalars['BigInt']>;
};

/** A condition to be used against `Season` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SeasonCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `year` field. */
  year?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `totalGames` field. */
  totalGames?: Maybe<Scalars['BigInt']>;
};

export type SeasonStat = {
  __typename?: 'SeasonStat';
  groupId: Maybe<Scalars['UUID']>;
  playerId: Maybe<Scalars['UUID']>;
  legacyPlayerId: Maybe<Scalars['Int']>;
  season: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['BigInt']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
  /** Reads a single `Player` that is related to this `SeasonStat`. */
  player: Maybe<Player>;
  /** Reads a single `LegacyPlayer` that is related to this `SeasonStat`. */
  legacyPlayer: Maybe<LegacyPlayer>;
  /** Reads a single `Group` that is related to this `SeasonStat`. */
  group: Maybe<Group>;
};

/**
 * A condition to be used against `SeasonStat` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type SeasonStatCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatOnSeasonStatForFakePublicSeasonStatsForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatOnSeasonStatForFakePublicSeasonStatsForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: LegacyPlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatOnSeasonStatForFakePublicSeasonStatsForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

export type SeasonStatsAllTimeQualifiedBatter = {
  __typename?: 'SeasonStatsAllTimeQualifiedBatter';
  groupId: Maybe<Scalars['UUID']>;
  playerId: Maybe<Scalars['UUID']>;
  legacyPlayerId: Maybe<Scalars['Int']>;
  season: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['BigInt']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
  /** Reads a single `Player` that is related to this `SeasonStatsAllTimeQualifiedBatter`. */
  player: Maybe<Player>;
  /** Reads a single `LegacyPlayer` that is related to this `SeasonStatsAllTimeQualifiedBatter`. */
  legacyPlayer: Maybe<LegacyPlayer>;
  /** Reads a single `Group` that is related to this `SeasonStatsAllTimeQualifiedBatter`. */
  group: Maybe<Group>;
};

/**
 * A condition to be used against `SeasonStatsAllTimeQualifiedBatter` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type SeasonStatsAllTimeQualifiedBatterCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatsAllTimeQualifiedBatterOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatsAllTimeQualifiedBatterOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: LegacyPlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatsAllTimeQualifiedBatterOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** Methods to use when ordering `SeasonStatsAllTimeQualifiedBatter`. */
export enum SeasonStatsAllTimeQualifiedBattersOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC'
}

/** Methods to use when ordering `SeasonStat`. */
export enum SeasonStatsOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC'
}

export type SeasonStatsQualifiedBatter = {
  __typename?: 'SeasonStatsQualifiedBatter';
  groupId: Maybe<Scalars['UUID']>;
  playerId: Maybe<Scalars['UUID']>;
  legacyPlayerId: Maybe<Scalars['Int']>;
  season: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['BigInt']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
  /** Reads a single `Player` that is related to this `SeasonStatsQualifiedBatter`. */
  player: Maybe<Player>;
  /** Reads a single `LegacyPlayer` that is related to this `SeasonStatsQualifiedBatter`. */
  legacyPlayer: Maybe<LegacyPlayer>;
  /** Reads a single `Group` that is related to this `SeasonStatsQualifiedBatter`. */
  group: Maybe<Group>;
};

/**
 * A condition to be used against `SeasonStatsQualifiedBatter` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type SeasonStatsQualifiedBatterCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['BigInt']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatsQualifiedBatterOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatsQualifiedBatterOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: LegacyPlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatsQualifiedBatterOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** Methods to use when ordering `SeasonStatsQualifiedBatter`. */
export enum SeasonStatsQualifiedBattersOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC'
}

/** Methods to use when ordering `Season`. */
export enum SeasonsOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  YEAR_ASC = 'YEAR_ASC',
  YEAR_DESC = 'YEAR_DESC',
  TOTAL_GAMES_ASC = 'TOTAL_GAMES_ASC',
  TOTAL_GAMES_DESC = 'TOTAL_GAMES_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type StolenBaseAttempt = Node & {
  __typename?: 'StolenBaseAttempt';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  runnerId: Scalars['UUID'];
  success: Scalars['Boolean'];
  /** Reads a single `Player` that is related to this `StolenBaseAttempt`. */
  runner: Maybe<Player>;
};

/**
 * A condition to be used against `StolenBaseAttempt` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type StolenBaseAttemptCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runnerId` field. */
  runnerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `success` field. */
  success?: Maybe<Scalars['Boolean']>;
};

/** An input for mutations affecting `StolenBaseAttempt` */
export type StolenBaseAttemptInput = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success: Scalars['Boolean'];
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type StolenBaseAttemptNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `stolenBaseAttempt` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type StolenBaseAttemptNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `stolenBaseAttempt` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `stolenBaseAttempt` to look up the row to update. */
export type StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingStolenBaseAttemptPkeyUpdate = {
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: UpdateStolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `stolenBaseAttempt` to look up the row to update. */
export type StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingStolenBaseAttemptPkeyUpdate = {
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: UpdateStolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `StolenBaseAttempt`. Fields that are set will be updated. */
export type StolenBaseAttemptPatch = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success?: Maybe<Scalars['Boolean']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** Input for the nested mutation of `player` in the `StolenBaseAttemptInput` mutation. */
export type StolenBaseAttemptRunnerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<StolenBaseAttemptRunnerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `stolenBaseAttempt` in the `PlayerInput` mutation. */
export type StolenBaseAttemptRunnerIdFkeyInverseInput = {
  /** Flag indicating whether all other `stolenBaseAttempt` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectById?: Maybe<Array<StolenBaseAttemptStolenBaseAttemptPkeyConnect>>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<StolenBaseAttemptNodeIdConnect>>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteById?: Maybe<Array<StolenBaseAttemptStolenBaseAttemptPkeyDelete>>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<StolenBaseAttemptNodeIdDelete>>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateById?: Maybe<Array<StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingStolenBaseAttemptPkeyUpdate>>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate>>;
  /** A `StolenBaseAttemptInput` object that will be created and connected to this object. */
  create?: Maybe<Array<StolenBaseAttemptRunnerIdFkeyStolenBaseAttemptCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type StolenBaseAttemptRunnerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `stolenBaseAttempt` to be created by this mutation. */
export type StolenBaseAttemptRunnerIdFkeyStolenBaseAttemptCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  success: Scalars['Boolean'];
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** The fields on `stolenBaseAttempt` to look up the row to connect. */
export type StolenBaseAttemptStolenBaseAttemptPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `stolenBaseAttempt` to look up the row to delete. */
export type StolenBaseAttemptStolenBaseAttemptPkeyDelete = {
  id: Scalars['UUID'];
};

/** Methods to use when ordering `StolenBaseAttempt`. */
export enum StolenBaseAttemptsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  RUNNER_ID_ASC = 'RUNNER_ID_ASC',
  RUNNER_ID_DESC = 'RUNNER_ID_DESC',
  SUCCESS_ASC = 'SUCCESS_ASC',
  SUCCESS_DESC = 'SUCCESS_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type Team = Node & {
  __typename?: 'Team';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  gameId: Scalars['UUID'];
  role: TeamRole;
  name: Maybe<Scalars['String']>;
  captainId: Maybe<Scalars['UUID']>;
  winner: Maybe<Scalars['Boolean']>;
  /** Reads a single `Game` that is related to this `Team`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `Team`. */
  captain: Maybe<Player>;
  /** Reads and enables pagination through a set of `Lineup`. */
  lineups: Array<Lineup>;
  finalLineup: Maybe<Lineup>;
};


export type TeamLineupsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupsOrderBy>>;
  condition?: Maybe<LineupCondition>;
};

/** Input for the nested mutation of `player` in the `TeamInput` mutation. */
export type TeamCaptainIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerFirstNameLastNameKeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerFirstNameLastNameKeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<TeamOnTeamForTeamCaptainIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<TeamCaptainIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `team` in the `PlayerInput` mutation. */
export type TeamCaptainIdFkeyInverseInput = {
  /** Flag indicating whether all other `team` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectById?: Maybe<Array<TeamTeamPkeyConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByGameIdAndRole?: Maybe<Array<TeamTeamGameIdRoleKeyConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TeamNodeIdConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteById?: Maybe<Array<TeamTeamPkeyDelete>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByGameIdAndRole?: Maybe<Array<TeamTeamGameIdRoleKeyDelete>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TeamNodeIdDelete>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateById?: Maybe<Array<TeamOnTeamForTeamCaptainIdFkeyUsingTeamPkeyUpdate>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByGameIdAndRole?: Maybe<Array<TeamOnTeamForTeamCaptainIdFkeyUsingTeamGameIdRoleKeyUpdate>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnTeamForTeamCaptainIdFkeyNodeIdUpdate>>;
  /** A `TeamInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TeamCaptainIdFkeyTeamCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type TeamCaptainIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `team` to be created by this mutation. */
export type TeamCaptainIdFkeyTeamCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role: TeamRole;
  name?: Maybe<Scalars['String']>;
  winner?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

/** A condition to be used against `Team` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TeamCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `role` field. */
  role?: Maybe<TeamRole>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `captainId` field. */
  captainId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `winner` field. */
  winner?: Maybe<Scalars['Boolean']>;
};

/** The `game` to be created by this mutation. */
export type TeamGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
};

/** Input for the nested mutation of `game` in the `TeamInput` mutation. */
export type TeamGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByName?: Maybe<GameGameNameKeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByName?: Maybe<GameGameNameKeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnTeamForTeamGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByName?: Maybe<GameOnTeamForTeamGameIdFkeyUsingGameNameKeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<TeamOnTeamForTeamGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<TeamGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `team` in the `GameInput` mutation. */
export type TeamGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `team` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectById?: Maybe<Array<TeamTeamPkeyConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByGameIdAndRole?: Maybe<Array<TeamTeamGameIdRoleKeyConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TeamNodeIdConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteById?: Maybe<Array<TeamTeamPkeyDelete>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByGameIdAndRole?: Maybe<Array<TeamTeamGameIdRoleKeyDelete>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TeamNodeIdDelete>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateById?: Maybe<Array<TeamOnTeamForTeamGameIdFkeyUsingTeamPkeyUpdate>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByGameIdAndRole?: Maybe<Array<TeamOnTeamForTeamGameIdFkeyUsingTeamGameIdRoleKeyUpdate>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnTeamForTeamGameIdFkeyNodeIdUpdate>>;
  /** A `TeamInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TeamGameIdFkeyTeamCreateInput>>;
};

/** The `team` to be created by this mutation. */
export type TeamGameIdFkeyTeamCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  role: TeamRole;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

/** An input for mutations affecting `Team` */
export type TeamInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role: TeamRole;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TeamNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `team` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TeamNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `team` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TeamOnLineupForLineupTeamIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: LineupPatch;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnLineupForLineupTeamIdFkeyUsingTeamGameIdRoleKeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnLineupForLineupTeamIdFkeyPatch;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnLineupForLineupTeamIdFkeyUsingTeamPkeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnLineupForLineupTeamIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TeamOnTeamForTeamCaptainIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnTeamForTeamCaptainIdFkeyUsingTeamGameIdRoleKeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnTeamForTeamCaptainIdFkeyPatch;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnTeamForTeamCaptainIdFkeyUsingTeamPkeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnTeamForTeamCaptainIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TeamOnTeamForTeamGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnTeamForTeamGameIdFkeyUsingTeamGameIdRoleKeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnTeamForTeamGameIdFkeyPatch;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnTeamForTeamGameIdFkeyUsingTeamPkeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnTeamForTeamGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Team`. Fields that are set will be updated. */
export type TeamPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role?: Maybe<TeamRole>;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

export enum TeamRole {
  AWAY = 'AWAY',
  HOME = 'HOME'
}

/** The fields on `team` to look up the row to connect. */
export type TeamTeamGameIdRoleKeyConnect = {
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to delete. */
export type TeamTeamGameIdRoleKeyDelete = {
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to connect. */
export type TeamTeamPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `team` to look up the row to delete. */
export type TeamTeamPkeyDelete = {
  id: Scalars['UUID'];
};

/** Methods to use when ordering `Team`. */
export enum TeamsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  ROLE_ASC = 'ROLE_ASC',
  ROLE_DESC = 'ROLE_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  CAPTAIN_ID_ASC = 'CAPTAIN_ID_ASC',
  CAPTAIN_ID_DESC = 'CAPTAIN_ID_DESC',
  WINNER_ASC = 'WINNER_ASC',
  WINNER_DESC = 'WINNER_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}


export type TraditionalStatLine = {
  __typename?: 'TraditionalStatLine';
  playerId: Maybe<Scalars['UUID']>;
  games: Maybe<Scalars['Int']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
};


/** All input for the `updateBaseRunnerByNodeId` mutation. */
export type UpdateBaseRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `BaseRunner` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `BaseRunner` being updated. */
  patch: BaseRunnerPatch;
};

/** All input for the `updateBaseRunner` mutation. */
export type UpdateBaseRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `BaseRunner` being updated. */
  patch: BaseRunnerPatch;
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our update `BaseRunner` mutation. */
export type UpdateBaseRunnerPayload = {
  __typename?: 'UpdateBaseRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BaseRunner` that was updated by this mutation. */
  baseRunner: Maybe<BaseRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `BaseRunner`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Player` that is related to this `BaseRunner`. */
  runner: Maybe<Player>;
};

/** All input for the `updateBasepathMovementByNodeId` mutation. */
export type UpdateBasepathMovementByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `BasepathMovement` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `BasepathMovement` being updated. */
  patch: BasepathMovementPatch;
};

/** All input for the `updateBasepathMovement` mutation. */
export type UpdateBasepathMovementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `BasepathMovement` being updated. */
  patch: BasepathMovementPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our update `BasepathMovement` mutation. */
export type UpdateBasepathMovementPayload = {
  __typename?: 'UpdateBasepathMovementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BasepathMovement` that was updated by this mutation. */
  basepathMovement: Maybe<BasepathMovement>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `BasepathMovement`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `BasepathMovement`. */
  runner: Maybe<Player>;
};

/** All input for the `updateFieldByNodeId` mutation. */
export type UpdateFieldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Field` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Field` being updated. */
  patch: FieldPatch;
};

/** All input for the `updateField` mutation. */
export type UpdateFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Field` being updated. */
  patch: FieldPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Field` mutation. */
export type UpdateFieldPayload = {
  __typename?: 'UpdateFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Field` that was updated by this mutation. */
  field: Maybe<Field>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updateGameByName` mutation. */
export type UpdateGameByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Game` being updated. */
  patch: GamePatch;
  name: Scalars['String'];
};

/** All input for the `updateGameByNodeId` mutation. */
export type UpdateGameByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Game` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Game` being updated. */
  patch: GamePatch;
};

/** All input for the `updateGameEventByNodeId` mutation. */
export type UpdateGameEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameEvent` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GameEvent` being updated. */
  patch: GameEventPatch;
};

/** All input for the `updateGameEvent` mutation. */
export type UpdateGameEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GameEvent` being updated. */
  patch: GameEventPatch;
  id: Scalars['UUID'];
};

/** The output of our update `GameEvent` mutation. */
export type UpdateGameEventPayload = {
  __typename?: 'UpdateGameEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEvent` that was updated by this mutation. */
  gameEvent: Maybe<GameEvent>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `GameEvent`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `StolenBaseAttempt` that is related to this `GameEvent`. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Reads a single `LineupChange` that is related to this `GameEvent`. */
  lineupChange: Maybe<LineupChange>;
};

/** All input for the `updateGameEventRecordByGameIdAndEventIndex` mutation. */
export type UpdateGameEventRecordByGameIdAndEventIndexInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GameEventRecord` being updated. */
  patch: GameEventRecordPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** All input for the `updateGameEventRecordByNodeId` mutation. */
export type UpdateGameEventRecordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameEventRecord` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** All input for the `updateGameEventRecord` mutation. */
export type UpdateGameEventRecordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GameEventRecord` being updated. */
  patch: GameEventRecordPatch;
  id: Scalars['UUID'];
};

/** The output of our update `GameEventRecord` mutation. */
export type UpdateGameEventRecordPayload = {
  __typename?: 'UpdateGameEventRecordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEventRecord` that was updated by this mutation. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameEventRecord`. */
  game: Maybe<Game>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateBefore: Maybe<GameState>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateAfter: Maybe<GameState>;
  /** Reads a single `GameEvent` that is related to this `GameEventRecord`. */
  gameEvent: Maybe<GameEvent>;
};

/** All input for the `updateGame` mutation. */
export type UpdateGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Game` being updated. */
  patch: GamePatch;
  id: Scalars['UUID'];
};

/** The output of our update `Game` mutation. */
export type UpdateGamePayload = {
  __typename?: 'UpdateGamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Game` that was updated by this mutation. */
  game: Maybe<Game>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Group` that is related to this `Game`. */
  group: Maybe<Group>;
  /** Reads a single `Field` that is related to this `Game`. */
  field: Maybe<Field>;
};

/** All input for the `updateGameStateByNodeId` mutation. */
export type UpdateGameStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameState` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GameState` being updated. */
  patch: GameStatePatch;
};

/** All input for the `updateGameState` mutation. */
export type UpdateGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GameState` being updated. */
  patch: GameStatePatch;
  id: Scalars['UUID'];
};

/** The output of our update `GameState` mutation. */
export type UpdateGameStatePayload = {
  __typename?: 'UpdateGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameState` that was updated by this mutation. */
  gameState: Maybe<GameState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameState`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `GameState`. */
  playerByPlayerAtBat: Maybe<Player>;
};

/** All input for the `updateGroupByName` mutation. */
export type UpdateGroupByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
  name: Scalars['String'];
};

/** All input for the `updateGroupByNodeId` mutation. */
export type UpdateGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Group` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
};

/** All input for the `updateGroup` mutation. */
export type UpdateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Group` mutation. */
export type UpdateGroupPayload = {
  __typename?: 'UpdateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Group` that was updated by this mutation. */
  group: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updateLineupByNodeId` mutation. */
export type UpdateLineupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Lineup` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Lineup` being updated. */
  patch: LineupPatch;
};

/** All input for the `updateLineupChangeByNodeId` mutation. */
export type UpdateLineupChangeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupChange` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LineupChange` being updated. */
  patch: LineupChangePatch;
};

/** All input for the `updateLineupChange` mutation. */
export type UpdateLineupChangeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LineupChange` being updated. */
  patch: LineupChangePatch;
  id: Scalars['UUID'];
};

/** The output of our update `LineupChange` mutation. */
export type UpdateLineupChangePayload = {
  __typename?: 'UpdateLineupChangePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupChange` that was updated by this mutation. */
  lineupChange: Maybe<LineupChange>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupBefore: Maybe<Lineup>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupAfter: Maybe<Lineup>;
};

/** All input for the `updateLineupForGameStateByNodeId` mutation. */
export type UpdateLineupForGameStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupForGameState` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LineupForGameState` being updated. */
  patch: LineupForGameStatePatch;
};

/** All input for the `updateLineupForGameState` mutation. */
export type UpdateLineupForGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LineupForGameState` being updated. */
  patch: LineupForGameStatePatch;
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** The output of our update `LineupForGameState` mutation. */
export type UpdateLineupForGameStatePayload = {
  __typename?: 'UpdateLineupForGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupForGameState` that was updated by this mutation. */
  lineupForGameState: Maybe<LineupForGameState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `LineupForGameState`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Lineup` that is related to this `LineupForGameState`. */
  lineup: Maybe<Lineup>;
};

/** All input for the `updateLineup` mutation. */
export type UpdateLineupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Lineup` being updated. */
  patch: LineupPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Lineup` mutation. */
export type UpdateLineupPayload = {
  __typename?: 'UpdateLineupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Lineup` that was updated by this mutation. */
  lineup: Maybe<Lineup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Team` that is related to this `Lineup`. */
  team: Maybe<Team>;
};

/** All input for the `updateLineupSpotByLineupIdAndBattingOrder` mutation. */
export type UpdateLineupSpotByLineupIdAndBattingOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LineupSpot` being updated. */
  patch: LineupSpotPatch;
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** All input for the `updateLineupSpotByLineupIdAndPosition` mutation. */
export type UpdateLineupSpotByLineupIdAndPositionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LineupSpot` being updated. */
  patch: LineupSpotPatch;
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** All input for the `updateLineupSpotByNodeId` mutation. */
export type UpdateLineupSpotByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupSpot` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LineupSpot` being updated. */
  patch: LineupSpotPatch;
};

/** All input for the `updateLineupSpot` mutation. */
export type UpdateLineupSpotInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LineupSpot` being updated. */
  patch: LineupSpotPatch;
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The output of our update `LineupSpot` mutation. */
export type UpdateLineupSpotPayload = {
  __typename?: 'UpdateLineupSpotPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupSpot` that was updated by this mutation. */
  lineupSpot: Maybe<LineupSpot>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupSpot`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Player` that is related to this `LineupSpot`. */
  player: Maybe<Player>;
};

/** All input for the `updateOutOnPlayRunnerByNodeId` mutation. */
export type UpdateOutOnPlayRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OutOnPlayRunner` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `OutOnPlayRunner` being updated. */
  patch: OutOnPlayRunnerPatch;
};

/** All input for the `updateOutOnPlayRunner` mutation. */
export type UpdateOutOnPlayRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `OutOnPlayRunner` being updated. */
  patch: OutOnPlayRunnerPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our update `OutOnPlayRunner` mutation. */
export type UpdateOutOnPlayRunnerPayload = {
  __typename?: 'UpdateOutOnPlayRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `OutOnPlayRunner` that was updated by this mutation. */
  outOnPlayRunner: Maybe<OutOnPlayRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `OutOnPlayRunner`. */
  runner: Maybe<Player>;
};

/** All input for the `updatePlateAppearanceByNodeId` mutation. */
export type UpdatePlateAppearanceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlateAppearance` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** All input for the `updatePlateAppearance` mutation. */
export type UpdatePlateAppearanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlateAppearance` being updated. */
  patch: PlateAppearancePatch;
  id: Scalars['UUID'];
};

/** The output of our update `PlateAppearance` mutation. */
export type UpdatePlateAppearancePayload = {
  __typename?: 'UpdatePlateAppearancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlateAppearance` that was updated by this mutation. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updatePlayerByFirstNameAndLastName` mutation. */
export type UpdatePlayerByFirstNameAndLastNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Player` being updated. */
  patch: PlayerPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** All input for the `updatePlayerByNodeId` mutation. */
export type UpdatePlayerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Player` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Player` being updated. */
  patch: PlayerPatch;
};

/** All input for the `updatePlayer` mutation. */
export type UpdatePlayerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Player` being updated. */
  patch: PlayerPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Player` mutation. */
export type UpdatePlayerPayload = {
  __typename?: 'UpdatePlayerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Player` that was updated by this mutation. */
  player: Maybe<Player>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Group` that is related to this `Player`. */
  group: Maybe<Group>;
  /** Reads a single `LegacyPlayer` that is related to this `Player`. */
  legacyPlayer: Maybe<LegacyPlayer>;
};

/** All input for the `updateScoredRunnerByNodeId` mutation. */
export type UpdateScoredRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ScoredRunner` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ScoredRunner` being updated. */
  patch: ScoredRunnerPatch;
};

/** All input for the `updateScoredRunner` mutation. */
export type UpdateScoredRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ScoredRunner` being updated. */
  patch: ScoredRunnerPatch;
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our update `ScoredRunner` mutation. */
export type UpdateScoredRunnerPayload = {
  __typename?: 'UpdateScoredRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ScoredRunner` that was updated by this mutation. */
  scoredRunner: Maybe<ScoredRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameEventRecord` that is related to this `ScoredRunner`. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Reads a single `Player` that is related to this `ScoredRunner`. */
  runner: Maybe<Player>;
};

/** All input for the `updateStolenBaseAttemptByNodeId` mutation. */
export type UpdateStolenBaseAttemptByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StolenBaseAttempt` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `StolenBaseAttempt` being updated. */
  patch: StolenBaseAttemptPatch;
};

/** All input for the `updateStolenBaseAttempt` mutation. */
export type UpdateStolenBaseAttemptInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `StolenBaseAttempt` being updated. */
  patch: StolenBaseAttemptPatch;
  id: Scalars['UUID'];
};

/** The output of our update `StolenBaseAttempt` mutation. */
export type UpdateStolenBaseAttemptPayload = {
  __typename?: 'UpdateStolenBaseAttemptPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `StolenBaseAttempt` that was updated by this mutation. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `StolenBaseAttempt`. */
  runner: Maybe<Player>;
};

/** All input for the `updateTeamByGameIdAndRole` mutation. */
export type UpdateTeamByGameIdAndRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Team` being updated. */
  patch: TeamPatch;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** All input for the `updateTeamByNodeId` mutation. */
export type UpdateTeamByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Team` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Team` being updated. */
  patch: TeamPatch;
};

/** All input for the `updateTeam` mutation. */
export type UpdateTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Team` being updated. */
  patch: TeamPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Team` mutation. */
export type UpdateTeamPayload = {
  __typename?: 'UpdateTeamPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Team` that was updated by this mutation. */
  team: Maybe<Team>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `Team`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `Team`. */
  captain: Maybe<Player>;
};

/** An object where the defined keys will be set on the `baseRunner` being updated. */
export type UpdateBaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch = {
  runnerId?: Maybe<Scalars['UUID']>;
  base?: Maybe<BaseType>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `baseRunner` being updated. */
export type UpdateBaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  base?: Maybe<BaseType>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `basepathMovement` being updated. */
export type UpdateBasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch = {
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe?: Maybe<Scalars['Boolean']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `basepathMovement` being updated. */
export type UpdateBasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe?: Maybe<Scalars['Boolean']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `field` being updated. */
export type UpdateFieldOnGameForGameFieldIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  games?: Maybe<GameFieldIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventLineupChangeIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventPlateAppearanceIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEventRecord` being updated. */
export type UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEventRecord` being updated. */
export type UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEventRecord` being updated. */
export type UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEventRecord` being updated. */
export type UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEventRecord` being updated. */
export type UpdateGameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameEventRecordForGameEventRecordGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameForGameFieldIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameForGameGroupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameStateForGameStateGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnTeamForTeamGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnGameEventRecordForGameEventRecordGameStateAfterFkPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnGameStateForGameStateGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnGameStateForGameStatePlayerAtBatFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnCareerStatForFakePublicCareerStatsForeignKey2Patch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2Patch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnGameForGameGroupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2Patch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnPlayerForPlayerGroupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnSeasonStatForFakePublicSeasonStatsForeignKey2Patch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2Patch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2Patch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  players?: Maybe<PlayerGroupIdFkeyInverseInput>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
};

/** An object where the defined keys will be set on the `legacyPlayer` being updated. */
export type UpdateLegacyPlayerOnCareerStatForFakePublicCareerStatsForeignKey1Patch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `legacyPlayer` being updated. */
export type UpdateLegacyPlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey1Patch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `legacyPlayer` being updated. */
export type UpdateLegacyPlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey1Patch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `legacyPlayer` being updated. */
export type UpdateLegacyPlayerOnPlayerForFakePublicPlayerForeignKey0Patch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `legacyPlayer` being updated. */
export type UpdateLegacyPlayerOnSeasonStatForFakePublicSeasonStatsForeignKey1Patch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `legacyPlayer` being updated. */
export type UpdateLegacyPlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1Patch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `legacyPlayer` being updated. */
export type UpdateLegacyPlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey1Patch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `lineupChange` being updated. */
export type UpdateLineupChangeOnGameEventForGameEventLineupChangeIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineupChange` being updated. */
export type UpdateLineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineupChange` being updated. */
export type UpdateLineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineupForGameState` being updated. */
export type UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch = {
  lineupId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
};

/** An object where the defined keys will be set on the `lineupForGameState` being updated. */
export type UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
};

/** An object where the defined keys will be set on the `lineup` being updated. */
export type UpdateLineupOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineup` being updated. */
export type UpdateLineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineup` being updated. */
export type UpdateLineupOnLineupForLineupTeamIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineup` being updated. */
export type UpdateLineupOnLineupSpotForLineupSpotLineupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineupSpot` being updated. */
export type UpdateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch = {
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder?: Maybe<Scalars['Int']>;
  position?: Maybe<FieldingPosition>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `lineupSpot` being updated. */
export type UpdateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch = {
  lineupId?: Maybe<Scalars['UUID']>;
  battingOrder?: Maybe<Scalars['Int']>;
  position?: Maybe<FieldingPosition>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
export type UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch = {
  runnerId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
export type UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `plateAppearance` being updated. */
export type UpdatePlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `plateAppearance` being updated. */
export type UpdatePlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `plateAppearance` being updated. */
export type UpdatePlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnCareerStatForFakePublicCareerStatsForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnGameStateForGameStatePlayerAtBatFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnLineupSpotForLineupSpotPlayerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnPlayerForFakePublicPlayerForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnPlayerForPlayerGroupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnSeasonStatForFakePublicSeasonStatsForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnTeamForTeamCaptainIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  group?: Maybe<PlayerGroupIdFkeyInput>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `scoredRunner` being updated. */
export type UpdateScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch = {
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn?: Maybe<Scalars['Boolean']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `scoredRunner` being updated. */
export type UpdateScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  battedIn?: Maybe<Scalars['Boolean']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
};

/** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
export type UpdateStolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success?: Maybe<Scalars['Boolean']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
export type UpdateStolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  success?: Maybe<Scalars['Boolean']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `team` being updated. */
export type UpdateTeamOnLineupForLineupTeamIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role?: Maybe<TeamRole>;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `team` being updated. */
export type UpdateTeamOnTeamForTeamCaptainIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role?: Maybe<TeamRole>;
  name?: Maybe<Scalars['String']>;
  winner?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `team` being updated. */
export type UpdateTeamOnTeamForTeamGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  role?: Maybe<TeamRole>;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

export type GameEventRecord_GameStateFragment = (
  { __typename?: 'GameState' }
  & Pick<GameState, 'inning' | 'halfInning' | 'outs' | 'playerAtBat' | 'score'>
  & { lineups: Maybe<Array<Maybe<(
    { __typename?: 'Lineup' }
    & Pick<Lineup, 'id'>
    & { team: Maybe<(
      { __typename?: 'Team' }
      & Pick<Team, 'role'>
    )> }
  )>>>, baseRunners: Array<(
    { __typename?: 'BaseRunner' }
    & Pick<BaseRunner, 'runnerId' | 'base'>
  )> }
);

export type UnpackedGame_GameFragment = (
  { __typename?: 'Game' }
  & Pick<Game, 'id' | 'gameLength' | 'name' | 'score' | 'timeStarted' | 'timeEnded'>
  & { gameStates: Array<(
    { __typename?: 'GameState' }
    & Pick<GameState, 'id' | 'inning' | 'halfInning' | 'outs' | 'playerAtBat' | 'score'>
    & { lineups: Maybe<Array<Maybe<(
      { __typename?: 'Lineup' }
      & Pick<Lineup, 'id'>
      & { team: Maybe<(
        { __typename?: 'Team' }
        & Pick<Team, 'role'>
      )> }
    )>>>, baseRunners: Array<(
      { __typename?: 'BaseRunner' }
      & Pick<BaseRunner, 'runnerId' | 'base'>
    )> }
  )>, gameEventRecords: Array<(
    { __typename?: 'GameEventRecord' }
    & Pick<GameEventRecord, 'eventIndex' | 'gameStateBeforeId' | 'gameStateAfterId'>
    & { gameEvent: Maybe<(
      { __typename?: 'GameEvent' }
      & { lineupChange: Maybe<(
        { __typename?: 'LineupChange' }
        & Pick<LineupChange, 'lineupBeforeId' | 'lineupAfterId'>
      )>, stolenBaseAttempt: Maybe<(
        { __typename?: 'StolenBaseAttempt' }
        & Pick<StolenBaseAttempt, 'runnerId' | 'success'>
      )>, plateAppearance: Maybe<(
        { __typename?: 'PlateAppearance' }
        & Pick<PlateAppearance, 'type' | 'contact' | 'fieldedBy' | 'runsScoredOnSacFly'>
        & { outOnPlayRunners: Array<(
          { __typename?: 'OutOnPlayRunner' }
          & Pick<OutOnPlayRunner, 'runnerId'>
        )>, basepathMovements: Array<(
          { __typename?: 'BasepathMovement' }
          & Pick<BasepathMovement, 'runnerId' | 'endBase' | 'wasSafe'>
        )> }
      )> }
    )>, scoredRunners: Array<(
      { __typename?: 'ScoredRunner' }
      & Pick<ScoredRunner, 'runnerId' | 'battedIn'>
    )> }
  )>, teams: Array<(
    { __typename?: 'Team' }
    & Pick<Team, 'name' | 'role' | 'winner'>
    & { lineups: Array<(
      { __typename?: 'Lineup' }
      & Pick<Lineup, 'id'>
      & { lineupSpots: Array<(
        { __typename?: 'LineupSpot' }
        & Pick<LineupSpot, 'playerId' | 'position'>
      )> }
    )> }
  )> }
);

export type CreateGameMutationVariables = Exact<{
  input: CreateGameInput;
}>;


export type CreateGameMutation = (
  { __typename?: 'Mutation' }
  & { createGame: Maybe<(
    { __typename?: 'CreateGamePayload' }
    & { game: Maybe<(
      { __typename?: 'Game' }
      & UnpackedGame_GameFragment
    )> }
  )> }
);

export type CreatePlayerMutationVariables = Exact<{
  id?: Maybe<Scalars['UUID']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  groupId: Scalars['UUID'];
}>;


export type CreatePlayerMutation = (
  { __typename?: 'Mutation' }
  & { createPlayer: Maybe<(
    { __typename?: 'CreatePlayerPayload' }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'firstName' | 'lastName' | 'groupId'>
    )> }
  )> }
);

export type GetAllGamesQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetAllGamesQuery = (
  { __typename?: 'Query' }
  & { games: Maybe<Array<(
    { __typename?: 'Game' }
    & UnpackedGame_GameFragment
  )>> }
);

export type GetAllGroupsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllGroupsQuery = (
  { __typename?: 'Query' }
  & { groups: Maybe<Array<(
    { __typename?: 'Group' }
    & Pick<Group, 'id' | 'name'>
  )>> }
);

export type GetAllPlayersQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetAllPlayersQuery = (
  { __typename?: 'Query' }
  & { players: Maybe<Array<(
    { __typename?: 'Player' }
    & Pick<Player, 'id' | 'firstName' | 'lastName' | 'groupId'>
  )>> }
);

export type GetGameQueryVariables = Exact<{
  id: Scalars['UUID'];
}>;


export type GetGameQuery = (
  { __typename?: 'Query' }
  & { game: Maybe<(
    { __typename?: 'Game' }
    & UnpackedGame_GameFragment
  )> }
);

export type GetAllAvailableSeasonsQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetAllAvailableSeasonsQuery = (
  { __typename?: 'Query' }
  & { group: Maybe<(
    { __typename?: 'Group' }
    & Pick<Group, 'allSeasons'>
  )> }
);

export type GetAllGameSummariesQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetAllGameSummariesQuery = (
  { __typename?: 'Query' }
  & { games: Maybe<Array<(
    { __typename?: 'Game' }
    & Pick<Game, 'id' | 'name' | 'timeStarted' | 'timeEnded' | 'score'>
  )>> }
);

export type GetBoxScoreQueryVariables = Exact<{
  gameId: Scalars['UUID'];
}>;


export type GetBoxScoreQuery = (
  { __typename?: 'Query' }
  & { game: Maybe<(
    { __typename?: 'Game' }
    & { boxScore: Maybe<Array<Maybe<(
      { __typename?: 'TraditionalStatLine' }
      & Pick<TraditionalStatLine, 'playerId' | 'plateAppearances' | 'atBats' | 'hits' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'runs' | 'rbi'>
    )>>> }
  )> }
);

export type GetCareerStatLeadersQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetCareerStatLeadersQuery = (
  { __typename?: 'Query' }
  & { hitsLeaders: Maybe<Array<(
    { __typename?: 'CareerStat' }
    & { value: CareerStat['hits'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, homerunsLeaders: Maybe<Array<(
    { __typename?: 'CareerStat' }
    & { value: CareerStat['homeruns'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, walksLeaders: Maybe<Array<(
    { __typename?: 'CareerStat' }
    & { value: CareerStat['walks'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, battingAverageLeaders: Maybe<Array<(
    { __typename?: 'CareerStatsQualifiedBatter' }
    & { value: CareerStatsQualifiedBatter['battingAverage'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, onBasePctLeaders: Maybe<Array<(
    { __typename?: 'CareerStatsQualifiedBatter' }
    & { value: CareerStatsQualifiedBatter['onBasePct'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, opsLeaders: Maybe<Array<(
    { __typename?: 'CareerStatsQualifiedBatter' }
    & { value: CareerStatsQualifiedBatter['ops'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>> }
);

export type GetCareerStatsQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetCareerStatsQuery = (
  { __typename?: 'Query' }
  & { careerStats: Maybe<Array<(
    { __typename?: 'CareerStat' }
    & Pick<CareerStat, 'seasons' | 'games' | 'plateAppearances' | 'atBats' | 'hits' | 'doubles' | 'triples' | 'homeruns' | 'xbh' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'runs' | 'rbi' | 'battingAverage' | 'onBasePct' | 'sluggingPct' | 'ops'>
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName' | 'playerImage'>
    )> }
  )>> }
);

export type GetGameDetailsQueryVariables = Exact<{
  gameId: Scalars['UUID'];
}>;


export type GetGameDetailsQuery = (
  { __typename?: 'Query' }
  & { game: Maybe<(
    { __typename?: 'Game' }
    & Pick<Game, 'id' | 'gameLength' | 'name' | 'score' | 'timeStarted' | 'timeEnded'>
    & { lineScore: Maybe<Array<Maybe<(
      { __typename?: 'LineScoreCell' }
      & Pick<LineScoreCell, 'inning' | 'halfInning' | 'runs' | 'hits'>
    )>>>, teams: Array<(
      { __typename?: 'Team' }
      & Pick<Team, 'name' | 'role' | 'winner'>
      & { finalLineup: Maybe<(
        { __typename?: 'Lineup' }
        & { lineupSpots: Array<(
          { __typename?: 'LineupSpot' }
          & Pick<LineupSpot, 'position'>
          & { player: Maybe<(
            { __typename?: 'Player' }
            & Pick<Player, 'id' | 'fullName'>
          )> }
        )> }
      )> }
    )>, boxScore: Maybe<Array<Maybe<(
      { __typename?: 'TraditionalStatLine' }
      & Pick<TraditionalStatLine, 'playerId' | 'plateAppearances' | 'atBats' | 'hits' | 'runs' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'rbi' | 'onBasePct' | 'ops'>
    )>>>, gameStates: Array<(
      { __typename?: 'GameState' }
      & Pick<GameState, 'id' | 'inning' | 'halfInning' | 'outs' | 'score'>
      & { playerByPlayerAtBat: Maybe<(
        { __typename?: 'Player' }
        & Pick<Player, 'id' | 'firstName' | 'lastName'>
      )>, lineups: Maybe<Array<Maybe<(
        { __typename?: 'Lineup' }
        & Pick<Lineup, 'id'>
        & { team: Maybe<(
          { __typename?: 'Team' }
          & Pick<Team, 'role'>
        )> }
      )>>>, baseRunners: Array<(
        { __typename?: 'BaseRunner' }
        & Pick<BaseRunner, 'base'>
        & { runner: Maybe<(
          { __typename?: 'Player' }
          & Pick<Player, 'id' | 'firstName' | 'lastName'>
        )> }
      )> }
    )>, gameEventRecords: Array<(
      { __typename?: 'GameEventRecord' }
      & Pick<GameEventRecord, 'eventIndex' | 'gameStateBeforeId' | 'gameStateAfterId'>
      & { gameEvent: Maybe<(
        { __typename?: 'GameEvent' }
        & { lineupChange: Maybe<(
          { __typename?: 'LineupChange' }
          & Pick<LineupChange, 'lineupBeforeId' | 'lineupAfterId'>
        )>, stolenBaseAttempt: Maybe<(
          { __typename?: 'StolenBaseAttempt' }
          & Pick<StolenBaseAttempt, 'success'>
          & { runner: Maybe<(
            { __typename?: 'Player' }
            & Pick<Player, 'id' | 'firstName' | 'lastName'>
          )> }
        )>, plateAppearance: Maybe<(
          { __typename?: 'PlateAppearance' }
          & Pick<PlateAppearance, 'type' | 'contact' | 'fieldedBy' | 'runsScoredOnSacFly'>
          & { outOnPlayRunners: Array<(
            { __typename?: 'OutOnPlayRunner' }
            & Pick<OutOnPlayRunner, 'runnerId'>
          )>, basepathMovements: Array<(
            { __typename?: 'BasepathMovement' }
            & Pick<BasepathMovement, 'runnerId' | 'endBase' | 'wasSafe'>
          )> }
        )> }
      )>, scoredRunners: Array<(
        { __typename?: 'ScoredRunner' }
        & Pick<ScoredRunner, 'battedIn'>
        & { runner: Maybe<(
          { __typename?: 'Player' }
          & Pick<Player, 'id' | 'firstName' | 'lastName'>
        )> }
      )>, gameStateBefore: Maybe<(
        { __typename?: 'GameState' }
        & Pick<GameState, 'inning' | 'halfInning'>
        & { playerByPlayerAtBat: Maybe<(
          { __typename?: 'Player' }
          & Pick<Player, 'id' | 'firstName' | 'lastName'>
        )> }
      )> }
    )> }
  )> }
);

export type GetGameSummaryQueryVariables = Exact<{
  gameId: Scalars['UUID'];
}>;


export type GetGameSummaryQuery = (
  { __typename?: 'Query' }
  & { game: Maybe<(
    { __typename?: 'Game' }
    & { lineScore: Maybe<Array<Maybe<(
      { __typename?: 'LineScoreCell' }
      & Pick<LineScoreCell, 'inning' | 'halfInning' | 'hits' | 'runs'>
    )>>>, teams: Array<(
      { __typename?: 'Team' }
      & Pick<Team, 'name' | 'role' | 'winner'>
    )> }
  )> }
);

export type GetGameTitleQueryVariables = Exact<{
  gameId: Scalars['UUID'];
}>;


export type GetGameTitleQuery = (
  { __typename?: 'Query' }
  & { game: Maybe<(
    { __typename?: 'Game' }
    & Pick<Game, 'name' | 'timeStarted'>
  )> }
);

export type GetLatestGameSummaryQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetLatestGameSummaryQuery = (
  { __typename?: 'Query' }
  & { games: Maybe<Array<(
    { __typename?: 'Game' }
    & Pick<Game, 'id' | 'timeStarted' | 'timeEnded' | 'score' | 'gameLength'>
  )>> }
);

export type GetPreviewStatsQueryVariables = Exact<{
  groupId: Scalars['UUID'];
  currentSeason: Scalars['Int'];
}>;


export type GetPreviewStatsQuery = (
  { __typename?: 'Query' }
  & { seasonStats: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & Pick<SeasonStat, 'games' | 'plateAppearances' | 'atBats' | 'hits' | 'doubles' | 'triples' | 'homeruns' | 'xbh' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'runs' | 'rbi' | 'battingAverage' | 'onBasePct' | 'sluggingPct' | 'ops'>
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>> }
);

export type GetSingleSeasonStatLeadersQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetSingleSeasonStatLeadersQuery = (
  { __typename?: 'Query' }
  & { hitsLeaders: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & Pick<SeasonStat, 'season'>
    & { value: SeasonStat['hits'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, homerunsLeaders: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & Pick<SeasonStat, 'season'>
    & { value: SeasonStat['homeruns'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, walksLeaders: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & Pick<SeasonStat, 'season'>
    & { value: SeasonStat['walks'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, battingAverageLeaders: Maybe<Array<(
    { __typename?: 'SeasonStatsAllTimeQualifiedBatter' }
    & Pick<SeasonStatsAllTimeQualifiedBatter, 'season'>
    & { value: SeasonStatsAllTimeQualifiedBatter['battingAverage'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, onBasePctLeaders: Maybe<Array<(
    { __typename?: 'SeasonStatsAllTimeQualifiedBatter' }
    & Pick<SeasonStatsAllTimeQualifiedBatter, 'season'>
    & { value: SeasonStatsAllTimeQualifiedBatter['onBasePct'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, opsLeaders: Maybe<Array<(
    { __typename?: 'SeasonStatsAllTimeQualifiedBatter' }
    & Pick<SeasonStatsAllTimeQualifiedBatter, 'season'>
    & { value: SeasonStatsAllTimeQualifiedBatter['ops'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>> }
);

export type GetStatLeadersForSeasonQueryVariables = Exact<{
  groupId: Scalars['UUID'];
  season: Scalars['Int'];
}>;


export type GetStatLeadersForSeasonQuery = (
  { __typename?: 'Query' }
  & { hitsLeaders: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & { value: SeasonStat['hits'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, homerunsLeaders: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & { value: SeasonStat['homeruns'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, walksLeaders: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & { value: SeasonStat['walks'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, battingAverageLeaders: Maybe<Array<(
    { __typename?: 'SeasonStatsQualifiedBatter' }
    & { value: SeasonStatsQualifiedBatter['battingAverage'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, onBasePctLeaders: Maybe<Array<(
    { __typename?: 'SeasonStatsQualifiedBatter' }
    & { value: SeasonStatsQualifiedBatter['onBasePct'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, opsLeaders: Maybe<Array<(
    { __typename?: 'SeasonStatsQualifiedBatter' }
    & { value: SeasonStatsQualifiedBatter['ops'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>> }
);

export type GetStatsForSeasonQueryVariables = Exact<{
  groupId: Scalars['UUID'];
  season: Scalars['Int'];
}>;


export type GetStatsForSeasonQuery = (
  { __typename?: 'Query' }
  & { season: Maybe<(
    { __typename?: 'Season' }
    & Pick<Season, 'totalGames'>
  )>, seasonStats: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & Pick<SeasonStat, 'games' | 'plateAppearances' | 'atBats' | 'hits' | 'doubles' | 'triples' | 'homeruns' | 'xbh' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'runs' | 'rbi' | 'battingAverage' | 'onBasePct' | 'sluggingPct' | 'ops'>
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName' | 'playerImage'>
    )> }
  )>> }
);

export const GameEventRecord_GameStateFragmentDoc = gql`
    fragment GameEventRecord_GameState on GameState {
  inning
  halfInning
  outs
  playerAtBat
  score
  lineups {
    id
    team {
      role
    }
  }
  baseRunners {
    runnerId
    base
  }
}
    `;
export const UnpackedGame_GameFragmentDoc = gql`
    fragment UnpackedGame_Game on Game {
  id
  gameLength
  name
  score
  timeStarted
  timeEnded
  gameStates(orderBy: GAME_STATE_INDEX_ASC) {
    id
    inning
    halfInning
    outs
    playerAtBat
    score
    lineups {
      id
      team {
        role
      }
    }
    baseRunners {
      runnerId
      base
    }
  }
  gameEventRecords(orderBy: EVENT_INDEX_ASC) {
    eventIndex
    gameEvent {
      lineupChange {
        lineupBeforeId
        lineupAfterId
      }
      stolenBaseAttempt {
        runnerId
        success
      }
      plateAppearance {
        type
        contact
        fieldedBy
        outOnPlayRunners {
          runnerId
        }
        basepathMovements {
          runnerId
          endBase
          wasSafe
        }
        runsScoredOnSacFly
      }
    }
    scoredRunners {
      runnerId
      battedIn
    }
    gameStateBeforeId
    gameStateAfterId
  }
  teams {
    name
    role
    lineups {
      id
      lineupSpots(orderBy: BATTING_ORDER_ASC) {
        playerId
        position
      }
    }
    winner
  }
}
    `;
export const CreateGameDocument = gql`
    mutation CreateGame($input: CreateGameInput!) {
  createGame(input: $input) {
    game {
      ...UnpackedGame_Game
    }
  }
}
    ${UnpackedGame_GameFragmentDoc}`;
export type CreateGameMutationFn = Apollo.MutationFunction<CreateGameMutation, CreateGameMutationVariables>;

/**
 * __useCreateGameMutation__
 *
 * To run a mutation, you first call `useCreateGameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGameMutation, { data, loading, error }] = useCreateGameMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateGameMutation(baseOptions?: Apollo.MutationHookOptions<CreateGameMutation, CreateGameMutationVariables>) {
        return Apollo.useMutation<CreateGameMutation, CreateGameMutationVariables>(CreateGameDocument, baseOptions);
      }
export type CreateGameMutationHookResult = ReturnType<typeof useCreateGameMutation>;
export type CreateGameMutationResult = Apollo.MutationResult<CreateGameMutation>;
export type CreateGameMutationOptions = Apollo.BaseMutationOptions<CreateGameMutation, CreateGameMutationVariables>;
export const CreatePlayerDocument = gql`
    mutation CreatePlayer($id: UUID, $firstName: String!, $lastName: String, $groupId: UUID!) {
  createPlayer(
    input: {player: {id: $id, firstName: $firstName, lastName: $lastName, groupId: $groupId}}
  ) {
    player {
      id
      firstName
      lastName
      groupId
    }
  }
}
    `;
export type CreatePlayerMutationFn = Apollo.MutationFunction<CreatePlayerMutation, CreatePlayerMutationVariables>;

/**
 * __useCreatePlayerMutation__
 *
 * To run a mutation, you first call `useCreatePlayerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlayerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlayerMutation, { data, loading, error }] = useCreatePlayerMutation({
 *   variables: {
 *      id: // value for 'id'
 *      firstName: // value for 'firstName'
 *      lastName: // value for 'lastName'
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useCreatePlayerMutation(baseOptions?: Apollo.MutationHookOptions<CreatePlayerMutation, CreatePlayerMutationVariables>) {
        return Apollo.useMutation<CreatePlayerMutation, CreatePlayerMutationVariables>(CreatePlayerDocument, baseOptions);
      }
export type CreatePlayerMutationHookResult = ReturnType<typeof useCreatePlayerMutation>;
export type CreatePlayerMutationResult = Apollo.MutationResult<CreatePlayerMutation>;
export type CreatePlayerMutationOptions = Apollo.BaseMutationOptions<CreatePlayerMutation, CreatePlayerMutationVariables>;
export const GetAllGamesDocument = gql`
    query GetAllGames($groupId: UUID!) {
  games(condition: {groupId: $groupId}) {
    ...UnpackedGame_Game
  }
}
    ${UnpackedGame_GameFragmentDoc}`;

/**
 * __useGetAllGamesQuery__
 *
 * To run a query within a React component, call `useGetAllGamesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllGamesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllGamesQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetAllGamesQuery(baseOptions: Apollo.QueryHookOptions<GetAllGamesQuery, GetAllGamesQueryVariables>) {
        return Apollo.useQuery<GetAllGamesQuery, GetAllGamesQueryVariables>(GetAllGamesDocument, baseOptions);
      }
export function useGetAllGamesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllGamesQuery, GetAllGamesQueryVariables>) {
          return Apollo.useLazyQuery<GetAllGamesQuery, GetAllGamesQueryVariables>(GetAllGamesDocument, baseOptions);
        }
export type GetAllGamesQueryHookResult = ReturnType<typeof useGetAllGamesQuery>;
export type GetAllGamesLazyQueryHookResult = ReturnType<typeof useGetAllGamesLazyQuery>;
export type GetAllGamesQueryResult = Apollo.QueryResult<GetAllGamesQuery, GetAllGamesQueryVariables>;
export const GetAllGroupsDocument = gql`
    query GetAllGroups {
  groups {
    id
    name
  }
}
    `;

/**
 * __useGetAllGroupsQuery__
 *
 * To run a query within a React component, call `useGetAllGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllGroupsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllGroupsQuery(baseOptions?: Apollo.QueryHookOptions<GetAllGroupsQuery, GetAllGroupsQueryVariables>) {
        return Apollo.useQuery<GetAllGroupsQuery, GetAllGroupsQueryVariables>(GetAllGroupsDocument, baseOptions);
      }
export function useGetAllGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllGroupsQuery, GetAllGroupsQueryVariables>) {
          return Apollo.useLazyQuery<GetAllGroupsQuery, GetAllGroupsQueryVariables>(GetAllGroupsDocument, baseOptions);
        }
export type GetAllGroupsQueryHookResult = ReturnType<typeof useGetAllGroupsQuery>;
export type GetAllGroupsLazyQueryHookResult = ReturnType<typeof useGetAllGroupsLazyQuery>;
export type GetAllGroupsQueryResult = Apollo.QueryResult<GetAllGroupsQuery, GetAllGroupsQueryVariables>;
export const GetAllPlayersDocument = gql`
    query GetAllPlayers($groupId: UUID!) {
  players(condition: {groupId: $groupId}) {
    id
    firstName
    lastName
    groupId
  }
}
    `;

/**
 * __useGetAllPlayersQuery__
 *
 * To run a query within a React component, call `useGetAllPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllPlayersQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetAllPlayersQuery(baseOptions: Apollo.QueryHookOptions<GetAllPlayersQuery, GetAllPlayersQueryVariables>) {
        return Apollo.useQuery<GetAllPlayersQuery, GetAllPlayersQueryVariables>(GetAllPlayersDocument, baseOptions);
      }
export function useGetAllPlayersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllPlayersQuery, GetAllPlayersQueryVariables>) {
          return Apollo.useLazyQuery<GetAllPlayersQuery, GetAllPlayersQueryVariables>(GetAllPlayersDocument, baseOptions);
        }
export type GetAllPlayersQueryHookResult = ReturnType<typeof useGetAllPlayersQuery>;
export type GetAllPlayersLazyQueryHookResult = ReturnType<typeof useGetAllPlayersLazyQuery>;
export type GetAllPlayersQueryResult = Apollo.QueryResult<GetAllPlayersQuery, GetAllPlayersQueryVariables>;
export const GetGameDocument = gql`
    query GetGame($id: UUID!) {
  game(id: $id) {
    ...UnpackedGame_Game
  }
}
    ${UnpackedGame_GameFragmentDoc}`;

/**
 * __useGetGameQuery__
 *
 * To run a query within a React component, call `useGetGameQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetGameQuery(baseOptions: Apollo.QueryHookOptions<GetGameQuery, GetGameQueryVariables>) {
        return Apollo.useQuery<GetGameQuery, GetGameQueryVariables>(GetGameDocument, baseOptions);
      }
export function useGetGameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGameQuery, GetGameQueryVariables>) {
          return Apollo.useLazyQuery<GetGameQuery, GetGameQueryVariables>(GetGameDocument, baseOptions);
        }
export type GetGameQueryHookResult = ReturnType<typeof useGetGameQuery>;
export type GetGameLazyQueryHookResult = ReturnType<typeof useGetGameLazyQuery>;
export type GetGameQueryResult = Apollo.QueryResult<GetGameQuery, GetGameQueryVariables>;
export const GetAllAvailableSeasonsDocument = gql`
    query GetAllAvailableSeasons($groupId: UUID!) {
  group(id: $groupId) {
    allSeasons
  }
}
    `;

/**
 * __useGetAllAvailableSeasonsQuery__
 *
 * To run a query within a React component, call `useGetAllAvailableSeasonsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllAvailableSeasonsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllAvailableSeasonsQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetAllAvailableSeasonsQuery(baseOptions: Apollo.QueryHookOptions<GetAllAvailableSeasonsQuery, GetAllAvailableSeasonsQueryVariables>) {
        return Apollo.useQuery<GetAllAvailableSeasonsQuery, GetAllAvailableSeasonsQueryVariables>(GetAllAvailableSeasonsDocument, baseOptions);
      }
export function useGetAllAvailableSeasonsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllAvailableSeasonsQuery, GetAllAvailableSeasonsQueryVariables>) {
          return Apollo.useLazyQuery<GetAllAvailableSeasonsQuery, GetAllAvailableSeasonsQueryVariables>(GetAllAvailableSeasonsDocument, baseOptions);
        }
export type GetAllAvailableSeasonsQueryHookResult = ReturnType<typeof useGetAllAvailableSeasonsQuery>;
export type GetAllAvailableSeasonsLazyQueryHookResult = ReturnType<typeof useGetAllAvailableSeasonsLazyQuery>;
export type GetAllAvailableSeasonsQueryResult = Apollo.QueryResult<GetAllAvailableSeasonsQuery, GetAllAvailableSeasonsQueryVariables>;
export const GetAllGameSummariesDocument = gql`
    query GetAllGameSummaries($groupId: UUID!) {
  games(condition: {groupId: $groupId}, orderBy: TIME_STARTED_DESC) {
    id
    name
    timeStarted
    timeEnded
    score
  }
}
    `;

/**
 * __useGetAllGameSummariesQuery__
 *
 * To run a query within a React component, call `useGetAllGameSummariesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllGameSummariesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllGameSummariesQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetAllGameSummariesQuery(baseOptions: Apollo.QueryHookOptions<GetAllGameSummariesQuery, GetAllGameSummariesQueryVariables>) {
        return Apollo.useQuery<GetAllGameSummariesQuery, GetAllGameSummariesQueryVariables>(GetAllGameSummariesDocument, baseOptions);
      }
export function useGetAllGameSummariesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllGameSummariesQuery, GetAllGameSummariesQueryVariables>) {
          return Apollo.useLazyQuery<GetAllGameSummariesQuery, GetAllGameSummariesQueryVariables>(GetAllGameSummariesDocument, baseOptions);
        }
export type GetAllGameSummariesQueryHookResult = ReturnType<typeof useGetAllGameSummariesQuery>;
export type GetAllGameSummariesLazyQueryHookResult = ReturnType<typeof useGetAllGameSummariesLazyQuery>;
export type GetAllGameSummariesQueryResult = Apollo.QueryResult<GetAllGameSummariesQuery, GetAllGameSummariesQueryVariables>;
export const GetBoxScoreDocument = gql`
    query GetBoxScore($gameId: UUID!) {
  game(id: $gameId) {
    boxScore {
      playerId
      plateAppearances
      atBats
      hits
      doubles
      triples
      homeruns
      walks
      strikeouts
      sacFlies
      gidp
      runs
      rbi
    }
  }
}
    `;

/**
 * __useGetBoxScoreQuery__
 *
 * To run a query within a React component, call `useGetBoxScoreQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBoxScoreQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBoxScoreQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useGetBoxScoreQuery(baseOptions: Apollo.QueryHookOptions<GetBoxScoreQuery, GetBoxScoreQueryVariables>) {
        return Apollo.useQuery<GetBoxScoreQuery, GetBoxScoreQueryVariables>(GetBoxScoreDocument, baseOptions);
      }
export function useGetBoxScoreLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBoxScoreQuery, GetBoxScoreQueryVariables>) {
          return Apollo.useLazyQuery<GetBoxScoreQuery, GetBoxScoreQueryVariables>(GetBoxScoreDocument, baseOptions);
        }
export type GetBoxScoreQueryHookResult = ReturnType<typeof useGetBoxScoreQuery>;
export type GetBoxScoreLazyQueryHookResult = ReturnType<typeof useGetBoxScoreLazyQuery>;
export type GetBoxScoreQueryResult = Apollo.QueryResult<GetBoxScoreQuery, GetBoxScoreQueryVariables>;
export const GetCareerStatLeadersDocument = gql`
    query GetCareerStatLeaders($groupId: UUID!) {
  hitsLeaders: careerStats(
    condition: {groupId: $groupId}
    orderBy: HITS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: hits
  }
  homerunsLeaders: careerStats(
    condition: {groupId: $groupId}
    orderBy: HOMERUNS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: homeruns
  }
  walksLeaders: careerStats(
    condition: {groupId: $groupId}
    orderBy: WALKS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: walks
  }
  battingAverageLeaders: careerStatsQualifiedBatters(
    condition: {groupId: $groupId}
    orderBy: BATTING_AVERAGE_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: battingAverage
  }
  onBasePctLeaders: careerStatsQualifiedBatters(
    condition: {groupId: $groupId}
    orderBy: ON_BASE_PCT_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: onBasePct
  }
  opsLeaders: careerStatsQualifiedBatters(
    condition: {groupId: $groupId}
    orderBy: OPS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: ops
  }
}
    `;

/**
 * __useGetCareerStatLeadersQuery__
 *
 * To run a query within a React component, call `useGetCareerStatLeadersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCareerStatLeadersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCareerStatLeadersQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetCareerStatLeadersQuery(baseOptions: Apollo.QueryHookOptions<GetCareerStatLeadersQuery, GetCareerStatLeadersQueryVariables>) {
        return Apollo.useQuery<GetCareerStatLeadersQuery, GetCareerStatLeadersQueryVariables>(GetCareerStatLeadersDocument, baseOptions);
      }
export function useGetCareerStatLeadersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCareerStatLeadersQuery, GetCareerStatLeadersQueryVariables>) {
          return Apollo.useLazyQuery<GetCareerStatLeadersQuery, GetCareerStatLeadersQueryVariables>(GetCareerStatLeadersDocument, baseOptions);
        }
export type GetCareerStatLeadersQueryHookResult = ReturnType<typeof useGetCareerStatLeadersQuery>;
export type GetCareerStatLeadersLazyQueryHookResult = ReturnType<typeof useGetCareerStatLeadersLazyQuery>;
export type GetCareerStatLeadersQueryResult = Apollo.QueryResult<GetCareerStatLeadersQuery, GetCareerStatLeadersQueryVariables>;
export const GetCareerStatsDocument = gql`
    query GetCareerStats($groupId: UUID!) {
  careerStats(condition: {groupId: $groupId}, orderBy: GAMES_DESC) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
      playerImage
    }
    seasons
    games
    plateAppearances
    atBats
    hits
    doubles
    triples
    homeruns
    xbh
    walks
    strikeouts
    sacFlies
    gidp
    runs
    rbi
    battingAverage
    onBasePct
    sluggingPct
    ops
  }
}
    `;

/**
 * __useGetCareerStatsQuery__
 *
 * To run a query within a React component, call `useGetCareerStatsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCareerStatsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCareerStatsQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetCareerStatsQuery(baseOptions: Apollo.QueryHookOptions<GetCareerStatsQuery, GetCareerStatsQueryVariables>) {
        return Apollo.useQuery<GetCareerStatsQuery, GetCareerStatsQueryVariables>(GetCareerStatsDocument, baseOptions);
      }
export function useGetCareerStatsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCareerStatsQuery, GetCareerStatsQueryVariables>) {
          return Apollo.useLazyQuery<GetCareerStatsQuery, GetCareerStatsQueryVariables>(GetCareerStatsDocument, baseOptions);
        }
export type GetCareerStatsQueryHookResult = ReturnType<typeof useGetCareerStatsQuery>;
export type GetCareerStatsLazyQueryHookResult = ReturnType<typeof useGetCareerStatsLazyQuery>;
export type GetCareerStatsQueryResult = Apollo.QueryResult<GetCareerStatsQuery, GetCareerStatsQueryVariables>;
export const GetGameDetailsDocument = gql`
    query GetGameDetails($gameId: UUID!) {
  game(id: $gameId) {
    id
    gameLength
    name
    score
    timeStarted
    timeEnded
    lineScore {
      inning
      halfInning
      runs
      hits
    }
    teams {
      name
      role
      winner
      finalLineup {
        lineupSpots(orderBy: BATTING_ORDER_ASC) {
          player {
            id
            fullName
          }
          position
        }
      }
    }
    boxScore {
      playerId
      plateAppearances
      atBats
      hits
      runs
      doubles
      triples
      homeruns
      walks
      strikeouts
      sacFlies
      gidp
      rbi
      onBasePct
      ops
    }
    gameStates(orderBy: GAME_STATE_INDEX_ASC) {
      id
      inning
      halfInning
      outs
      playerByPlayerAtBat {
        id
        firstName
        lastName
      }
      score
      lineups {
        id
        team {
          role
        }
      }
      baseRunners {
        runner {
          id
          firstName
          lastName
        }
        base
      }
    }
    gameEventRecords(orderBy: EVENT_INDEX_ASC) {
      eventIndex
      gameEvent {
        lineupChange {
          lineupBeforeId
          lineupAfterId
        }
        stolenBaseAttempt {
          runner {
            id
            firstName
            lastName
          }
          success
        }
        plateAppearance {
          type
          contact
          fieldedBy
          outOnPlayRunners {
            runnerId
          }
          basepathMovements {
            runnerId
            endBase
            wasSafe
          }
          runsScoredOnSacFly
        }
      }
      scoredRunners {
        runner {
          id
          firstName
          lastName
        }
        battedIn
      }
      gameStateBeforeId
      gameStateBefore {
        inning
        halfInning
        playerByPlayerAtBat {
          id
          firstName
          lastName
        }
      }
      gameStateAfterId
    }
  }
}
    `;

/**
 * __useGetGameDetailsQuery__
 *
 * To run a query within a React component, call `useGetGameDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameDetailsQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useGetGameDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetGameDetailsQuery, GetGameDetailsQueryVariables>) {
        return Apollo.useQuery<GetGameDetailsQuery, GetGameDetailsQueryVariables>(GetGameDetailsDocument, baseOptions);
      }
export function useGetGameDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGameDetailsQuery, GetGameDetailsQueryVariables>) {
          return Apollo.useLazyQuery<GetGameDetailsQuery, GetGameDetailsQueryVariables>(GetGameDetailsDocument, baseOptions);
        }
export type GetGameDetailsQueryHookResult = ReturnType<typeof useGetGameDetailsQuery>;
export type GetGameDetailsLazyQueryHookResult = ReturnType<typeof useGetGameDetailsLazyQuery>;
export type GetGameDetailsQueryResult = Apollo.QueryResult<GetGameDetailsQuery, GetGameDetailsQueryVariables>;
export const GetGameSummaryDocument = gql`
    query GetGameSummary($gameId: UUID!) {
  game(id: $gameId) {
    lineScore {
      inning
      halfInning
      hits
      runs
    }
    teams {
      name
      role
      winner
    }
  }
}
    `;

/**
 * __useGetGameSummaryQuery__
 *
 * To run a query within a React component, call `useGetGameSummaryQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameSummaryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameSummaryQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useGetGameSummaryQuery(baseOptions: Apollo.QueryHookOptions<GetGameSummaryQuery, GetGameSummaryQueryVariables>) {
        return Apollo.useQuery<GetGameSummaryQuery, GetGameSummaryQueryVariables>(GetGameSummaryDocument, baseOptions);
      }
export function useGetGameSummaryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGameSummaryQuery, GetGameSummaryQueryVariables>) {
          return Apollo.useLazyQuery<GetGameSummaryQuery, GetGameSummaryQueryVariables>(GetGameSummaryDocument, baseOptions);
        }
export type GetGameSummaryQueryHookResult = ReturnType<typeof useGetGameSummaryQuery>;
export type GetGameSummaryLazyQueryHookResult = ReturnType<typeof useGetGameSummaryLazyQuery>;
export type GetGameSummaryQueryResult = Apollo.QueryResult<GetGameSummaryQuery, GetGameSummaryQueryVariables>;
export const GetGameTitleDocument = gql`
    query GetGameTitle($gameId: UUID!) {
  game(id: $gameId) {
    name
    timeStarted
  }
}
    `;

/**
 * __useGetGameTitleQuery__
 *
 * To run a query within a React component, call `useGetGameTitleQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameTitleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameTitleQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useGetGameTitleQuery(baseOptions: Apollo.QueryHookOptions<GetGameTitleQuery, GetGameTitleQueryVariables>) {
        return Apollo.useQuery<GetGameTitleQuery, GetGameTitleQueryVariables>(GetGameTitleDocument, baseOptions);
      }
export function useGetGameTitleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGameTitleQuery, GetGameTitleQueryVariables>) {
          return Apollo.useLazyQuery<GetGameTitleQuery, GetGameTitleQueryVariables>(GetGameTitleDocument, baseOptions);
        }
export type GetGameTitleQueryHookResult = ReturnType<typeof useGetGameTitleQuery>;
export type GetGameTitleLazyQueryHookResult = ReturnType<typeof useGetGameTitleLazyQuery>;
export type GetGameTitleQueryResult = Apollo.QueryResult<GetGameTitleQuery, GetGameTitleQueryVariables>;
export const GetLatestGameSummaryDocument = gql`
    query GetLatestGameSummary($groupId: UUID!) {
  games(orderBy: TIME_STARTED_DESC, first: 1, condition: {groupId: $groupId}) {
    id
    timeStarted
    timeEnded
    score
    gameLength
  }
}
    `;

/**
 * __useGetLatestGameSummaryQuery__
 *
 * To run a query within a React component, call `useGetLatestGameSummaryQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLatestGameSummaryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLatestGameSummaryQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetLatestGameSummaryQuery(baseOptions: Apollo.QueryHookOptions<GetLatestGameSummaryQuery, GetLatestGameSummaryQueryVariables>) {
        return Apollo.useQuery<GetLatestGameSummaryQuery, GetLatestGameSummaryQueryVariables>(GetLatestGameSummaryDocument, baseOptions);
      }
export function useGetLatestGameSummaryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLatestGameSummaryQuery, GetLatestGameSummaryQueryVariables>) {
          return Apollo.useLazyQuery<GetLatestGameSummaryQuery, GetLatestGameSummaryQueryVariables>(GetLatestGameSummaryDocument, baseOptions);
        }
export type GetLatestGameSummaryQueryHookResult = ReturnType<typeof useGetLatestGameSummaryQuery>;
export type GetLatestGameSummaryLazyQueryHookResult = ReturnType<typeof useGetLatestGameSummaryLazyQuery>;
export type GetLatestGameSummaryQueryResult = Apollo.QueryResult<GetLatestGameSummaryQuery, GetLatestGameSummaryQueryVariables>;
export const GetPreviewStatsDocument = gql`
    query GetPreviewStats($groupId: UUID!, $currentSeason: Int!) {
  seasonStats(
    condition: {groupId: $groupId, season: $currentSeason}
    orderBy: GAMES_DESC
    first: 20
  ) {
    player {
      id
      fullName
    }
    games
    plateAppearances
    atBats
    hits
    doubles
    triples
    homeruns
    xbh
    walks
    strikeouts
    sacFlies
    gidp
    runs
    rbi
    battingAverage
    onBasePct
    sluggingPct
    ops
  }
}
    `;

/**
 * __useGetPreviewStatsQuery__
 *
 * To run a query within a React component, call `useGetPreviewStatsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPreviewStatsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPreviewStatsQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      currentSeason: // value for 'currentSeason'
 *   },
 * });
 */
export function useGetPreviewStatsQuery(baseOptions: Apollo.QueryHookOptions<GetPreviewStatsQuery, GetPreviewStatsQueryVariables>) {
        return Apollo.useQuery<GetPreviewStatsQuery, GetPreviewStatsQueryVariables>(GetPreviewStatsDocument, baseOptions);
      }
export function useGetPreviewStatsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPreviewStatsQuery, GetPreviewStatsQueryVariables>) {
          return Apollo.useLazyQuery<GetPreviewStatsQuery, GetPreviewStatsQueryVariables>(GetPreviewStatsDocument, baseOptions);
        }
export type GetPreviewStatsQueryHookResult = ReturnType<typeof useGetPreviewStatsQuery>;
export type GetPreviewStatsLazyQueryHookResult = ReturnType<typeof useGetPreviewStatsLazyQuery>;
export type GetPreviewStatsQueryResult = Apollo.QueryResult<GetPreviewStatsQuery, GetPreviewStatsQueryVariables>;
export const GetSingleSeasonStatLeadersDocument = gql`
    query GetSingleSeasonStatLeaders($groupId: UUID!) {
  hitsLeaders: seasonStats(
    condition: {groupId: $groupId}
    orderBy: HITS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    season
    value: hits
  }
  homerunsLeaders: seasonStats(
    condition: {groupId: $groupId}
    orderBy: HOMERUNS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    season
    value: homeruns
  }
  walksLeaders: seasonStats(
    condition: {groupId: $groupId}
    orderBy: WALKS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    season
    value: walks
  }
  battingAverageLeaders: seasonStatsAllTimeQualifiedBatters(
    condition: {groupId: $groupId}
    orderBy: BATTING_AVERAGE_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    season
    value: battingAverage
  }
  onBasePctLeaders: seasonStatsAllTimeQualifiedBatters(
    condition: {groupId: $groupId}
    orderBy: ON_BASE_PCT_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    season
    value: onBasePct
  }
  opsLeaders: seasonStatsAllTimeQualifiedBatters(
    condition: {groupId: $groupId}
    orderBy: OPS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    season
    value: ops
  }
}
    `;

/**
 * __useGetSingleSeasonStatLeadersQuery__
 *
 * To run a query within a React component, call `useGetSingleSeasonStatLeadersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleSeasonStatLeadersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleSeasonStatLeadersQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetSingleSeasonStatLeadersQuery(baseOptions: Apollo.QueryHookOptions<GetSingleSeasonStatLeadersQuery, GetSingleSeasonStatLeadersQueryVariables>) {
        return Apollo.useQuery<GetSingleSeasonStatLeadersQuery, GetSingleSeasonStatLeadersQueryVariables>(GetSingleSeasonStatLeadersDocument, baseOptions);
      }
export function useGetSingleSeasonStatLeadersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleSeasonStatLeadersQuery, GetSingleSeasonStatLeadersQueryVariables>) {
          return Apollo.useLazyQuery<GetSingleSeasonStatLeadersQuery, GetSingleSeasonStatLeadersQueryVariables>(GetSingleSeasonStatLeadersDocument, baseOptions);
        }
export type GetSingleSeasonStatLeadersQueryHookResult = ReturnType<typeof useGetSingleSeasonStatLeadersQuery>;
export type GetSingleSeasonStatLeadersLazyQueryHookResult = ReturnType<typeof useGetSingleSeasonStatLeadersLazyQuery>;
export type GetSingleSeasonStatLeadersQueryResult = Apollo.QueryResult<GetSingleSeasonStatLeadersQuery, GetSingleSeasonStatLeadersQueryVariables>;
export const GetStatLeadersForSeasonDocument = gql`
    query GetStatLeadersForSeason($groupId: UUID!, $season: Int!) {
  hitsLeaders: seasonStats(
    condition: {groupId: $groupId, season: $season}
    orderBy: HITS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: hits
  }
  homerunsLeaders: seasonStats(
    condition: {groupId: $groupId, season: $season}
    orderBy: HOMERUNS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: homeruns
  }
  walksLeaders: seasonStats(
    condition: {groupId: $groupId, season: $season}
    orderBy: WALKS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: walks
  }
  battingAverageLeaders: seasonStatsQualifiedBatters(
    condition: {groupId: $groupId, season: $season}
    orderBy: BATTING_AVERAGE_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: battingAverage
  }
  onBasePctLeaders: seasonStatsQualifiedBatters(
    condition: {groupId: $groupId, season: $season}
    orderBy: ON_BASE_PCT_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: onBasePct
  }
  opsLeaders: seasonStatsQualifiedBatters(
    condition: {groupId: $groupId, season: $season}
    orderBy: OPS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: ops
  }
}
    `;

/**
 * __useGetStatLeadersForSeasonQuery__
 *
 * To run a query within a React component, call `useGetStatLeadersForSeasonQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStatLeadersForSeasonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStatLeadersForSeasonQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      season: // value for 'season'
 *   },
 * });
 */
export function useGetStatLeadersForSeasonQuery(baseOptions: Apollo.QueryHookOptions<GetStatLeadersForSeasonQuery, GetStatLeadersForSeasonQueryVariables>) {
        return Apollo.useQuery<GetStatLeadersForSeasonQuery, GetStatLeadersForSeasonQueryVariables>(GetStatLeadersForSeasonDocument, baseOptions);
      }
export function useGetStatLeadersForSeasonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStatLeadersForSeasonQuery, GetStatLeadersForSeasonQueryVariables>) {
          return Apollo.useLazyQuery<GetStatLeadersForSeasonQuery, GetStatLeadersForSeasonQueryVariables>(GetStatLeadersForSeasonDocument, baseOptions);
        }
export type GetStatLeadersForSeasonQueryHookResult = ReturnType<typeof useGetStatLeadersForSeasonQuery>;
export type GetStatLeadersForSeasonLazyQueryHookResult = ReturnType<typeof useGetStatLeadersForSeasonLazyQuery>;
export type GetStatLeadersForSeasonQueryResult = Apollo.QueryResult<GetStatLeadersForSeasonQuery, GetStatLeadersForSeasonQueryVariables>;
export const GetStatsForSeasonDocument = gql`
    query GetStatsForSeason($groupId: UUID!, $season: Int!) {
  season(groupId: $groupId, year: $season) {
    totalGames
  }
  seasonStats(
    condition: {groupId: $groupId, season: $season}
    orderBy: GAMES_DESC
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
      playerImage
    }
    games
    plateAppearances
    atBats
    hits
    doubles
    triples
    homeruns
    xbh
    walks
    strikeouts
    sacFlies
    gidp
    runs
    rbi
    battingAverage
    onBasePct
    sluggingPct
    ops
  }
}
    `;

/**
 * __useGetStatsForSeasonQuery__
 *
 * To run a query within a React component, call `useGetStatsForSeasonQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStatsForSeasonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStatsForSeasonQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      season: // value for 'season'
 *   },
 * });
 */
export function useGetStatsForSeasonQuery(baseOptions: Apollo.QueryHookOptions<GetStatsForSeasonQuery, GetStatsForSeasonQueryVariables>) {
        return Apollo.useQuery<GetStatsForSeasonQuery, GetStatsForSeasonQueryVariables>(GetStatsForSeasonDocument, baseOptions);
      }
export function useGetStatsForSeasonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStatsForSeasonQuery, GetStatsForSeasonQueryVariables>) {
          return Apollo.useLazyQuery<GetStatsForSeasonQuery, GetStatsForSeasonQueryVariables>(GetStatsForSeasonDocument, baseOptions);
        }
export type GetStatsForSeasonQueryHookResult = ReturnType<typeof useGetStatsForSeasonQuery>;
export type GetStatsForSeasonLazyQueryHookResult = ReturnType<typeof useGetStatsForSeasonLazyQuery>;
export type GetStatsForSeasonQueryResult = Apollo.QueryResult<GetStatsForSeasonQuery, GetStatsForSeasonQueryVariables>;
/* DO NOT EDIT! This file is auto-generated by graphql-code-generator - see `codegen.yml` */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * A signed eight-byte integer. The upper big integer values are greater than the
   * max value for a JavaScript number. Therefore all big integers will be output as
   * strings and not numbers.
   */
  BigInt: any;
  /** The day, does not include a time. */
  Date: string;
  /**
   * A point in time as described by the [ISO
   * 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
   */
  Datetime: string;
  /** A JavaScript object encoded in the JSON format as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: any;
  /**
   * A JSON Web Token defined by [RFC 7519](https://tools.ietf.org/html/rfc7519)
   * which securely represents claims between two parties.
   */
  Jwt: any;
  /** The exact time of day, does not include the date. May or may not have a timezone offset. */
  Time: any;
  /** A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122). */
  UUID: string;
};

export type AtBatSkip = Node & {
  __typename?: 'AtBatSkip';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  batterId: Scalars['UUID'];
  gameId: Scalars['UUID'];
  /** Reads a single `Player` that is related to this `AtBatSkip`. */
  batter: Maybe<Player>;
  /** Reads a single `Game` that is related to this `AtBatSkip`. */
  game: Maybe<Game>;
};

/** The fields on `atBatSkip` to look up the row to connect. */
export type AtBatSkipAtBatSkipPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `atBatSkip` to look up the row to delete. */
export type AtBatSkipAtBatSkipPkeyDelete = {
  id: Scalars['UUID'];
};

/** The `atBatSkip` to be created by this mutation. */
export type AtBatSkipBatterIdFkeyAtBatSkipCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** Input for the nested mutation of `player` in the `AtBatSkipInput` mutation. */
export type AtBatSkipBatterIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnAtBatSkipForAtBatSkipBatterIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnAtBatSkipForAtBatSkipBatterIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<AtBatSkipOnAtBatSkipForAtBatSkipBatterIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<AtBatSkipBatterIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `atBatSkip` in the `PlayerInput` mutation. */
export type AtBatSkipBatterIdFkeyInverseInput = {
  /** Flag indicating whether all other `atBatSkip` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  connectById?: Maybe<Array<AtBatSkipAtBatSkipPkeyConnect>>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<AtBatSkipNodeIdConnect>>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  deleteById?: Maybe<Array<AtBatSkipAtBatSkipPkeyDelete>>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<AtBatSkipNodeIdDelete>>;
  /** The primary key(s) and patch data for `atBatSkip` for the far side of the relationship. */
  updateById?: Maybe<Array<AtBatSkipOnAtBatSkipForAtBatSkipBatterIdFkeyUsingAtBatSkipPkeyUpdate>>;
  /** The primary key(s) and patch data for `atBatSkip` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnAtBatSkipForAtBatSkipBatterIdFkeyNodeIdUpdate>>;
  /** A `AtBatSkipInput` object that will be created and connected to this object. */
  create?: Maybe<Array<AtBatSkipBatterIdFkeyAtBatSkipCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type AtBatSkipBatterIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/**
 * A condition to be used against `AtBatSkip` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type AtBatSkipCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `batterId` field. */
  batterId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** The `atBatSkip` to be created by this mutation. */
export type AtBatSkipGameIdFkeyAtBatSkipCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** The `game` to be created by this mutation. */
export type AtBatSkipGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `AtBatSkipInput` mutation. */
export type AtBatSkipGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnAtBatSkipForAtBatSkipGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnAtBatSkipForAtBatSkipGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<AtBatSkipOnAtBatSkipForAtBatSkipGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<AtBatSkipGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `atBatSkip` in the `GameInput` mutation. */
export type AtBatSkipGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `atBatSkip` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  connectById?: Maybe<Array<AtBatSkipAtBatSkipPkeyConnect>>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<AtBatSkipNodeIdConnect>>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  deleteById?: Maybe<Array<AtBatSkipAtBatSkipPkeyDelete>>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<AtBatSkipNodeIdDelete>>;
  /** The primary key(s) and patch data for `atBatSkip` for the far side of the relationship. */
  updateById?: Maybe<Array<AtBatSkipOnAtBatSkipForAtBatSkipGameIdFkeyUsingAtBatSkipPkeyUpdate>>;
  /** The primary key(s) and patch data for `atBatSkip` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnAtBatSkipForAtBatSkipGameIdFkeyNodeIdUpdate>>;
  /** A `AtBatSkipInput` object that will be created and connected to this object. */
  create?: Maybe<Array<AtBatSkipGameIdFkeyAtBatSkipCreateInput>>;
};

/** An input for mutations affecting `AtBatSkip` */
export type AtBatSkipInput = {
  id?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type AtBatSkipNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `atBatSkip` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type AtBatSkipNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `atBatSkip` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type AtBatSkipOnAtBatSkipForAtBatSkipBatterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `atBatSkip` to look up the row to update. */
export type AtBatSkipOnAtBatSkipForAtBatSkipBatterIdFkeyUsingAtBatSkipPkeyUpdate = {
  /** An object where the defined keys will be set on the `atBatSkip` being updated. */
  patch: UpdateAtBatSkipOnAtBatSkipForAtBatSkipBatterIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type AtBatSkipOnAtBatSkipForAtBatSkipGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `atBatSkip` to look up the row to update. */
export type AtBatSkipOnAtBatSkipForAtBatSkipGameIdFkeyUsingAtBatSkipPkeyUpdate = {
  /** An object where the defined keys will be set on the `atBatSkip` being updated. */
  patch: UpdateAtBatSkipOnAtBatSkipForAtBatSkipGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type AtBatSkipOnGameEventForGameEventAtBatSkipIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `atBatSkip` to look up the row to update. */
export type AtBatSkipOnGameEventForGameEventAtBatSkipIdFkeyUsingAtBatSkipPkeyUpdate = {
  /** An object where the defined keys will be set on the `atBatSkip` being updated. */
  patch: UpdateAtBatSkipOnGameEventForGameEventAtBatSkipIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `AtBatSkip`. Fields that are set will be updated. */
export type AtBatSkipPatch = {
  id?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** Methods to use when ordering `AtBatSkip`. */
export enum AtBatSkipsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  BATTER_ID_ASC = 'BATTER_ID_ASC',
  BATTER_ID_DESC = 'BATTER_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type BaseRunner = Node & {
  __typename?: 'BaseRunner';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
  base: BaseType;
  gameId: Scalars['UUID'];
  /** Reads a single `GameState` that is related to this `BaseRunner`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Player` that is related to this `BaseRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BaseRunner`. */
  game: Maybe<Game>;
};

/** The fields on `baseRunner` to look up the row to connect. */
export type BaseRunnerBaseRunnerPkeyConnect = {
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The fields on `baseRunner` to look up the row to delete. */
export type BaseRunnerBaseRunnerPkeyDelete = {
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/**
 * A condition to be used against `BaseRunner` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type BaseRunnerCondition = {
  /** Checks for equality with the object’s `gameStateId` field. */
  gameStateId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runnerId` field. */
  runnerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `base` field. */
  base?: Maybe<BaseType>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** The `baseRunner` to be created by this mutation. */
export type BaseRunnerGameIdFkeyBaseRunnerCreateInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  base: BaseType;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** The `game` to be created by this mutation. */
export type BaseRunnerGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `BaseRunnerInput` mutation. */
export type BaseRunnerGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnBaseRunnerForBaseRunnerGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnBaseRunnerForBaseRunnerGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<BaseRunnerOnBaseRunnerForBaseRunnerGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<BaseRunnerGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `baseRunner` in the `GameInput` mutation. */
export type BaseRunnerGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `baseRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BaseRunnerNodeIdConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyDelete>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BaseRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerOnBaseRunnerForBaseRunnerGameIdFkeyUsingBaseRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnBaseRunnerForBaseRunnerGameIdFkeyNodeIdUpdate>>;
  /** A `BaseRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BaseRunnerGameIdFkeyBaseRunnerCreateInput>>;
};

/** The `baseRunner` to be created by this mutation. */
export type BaseRunnerGameStateIdFkeyBaseRunnerCreateInput = {
  runnerId?: Maybe<Scalars['UUID']>;
  base: BaseType;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** The `gameState` to be created by this mutation. */
export type BaseRunnerGameStateIdFkeyGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `gameState` in the `BaseRunnerInput` mutation. */
export type BaseRunnerGameStateIdFkeyInput = {
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<GameStateGameStatePkeyConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameStateNodeIdConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<GameStateGameStatePkeyDelete>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameStateNodeIdDelete>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingGameStatePkeyUpdate>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<BaseRunnerGameStateIdFkeyGameStateCreateInput>;
};

/** Input for the nested mutation of `baseRunner` in the `GameStateInput` mutation. */
export type BaseRunnerGameStateIdFkeyInverseInput = {
  /** Flag indicating whether all other `baseRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BaseRunnerNodeIdConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyDelete>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BaseRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingBaseRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate>>;
  /** A `BaseRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BaseRunnerGameStateIdFkeyBaseRunnerCreateInput>>;
};

/** An input for mutations affecting `BaseRunner` */
export type BaseRunnerInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  base: BaseType;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type BaseRunnerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `baseRunner` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type BaseRunnerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `baseRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `baseRunner` to look up the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerGameIdFkeyUsingBaseRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: UpdateBaseRunnerOnBaseRunnerForBaseRunnerGameIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `baseRunner` to look up the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingBaseRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: UpdateBaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `baseRunner` to look up the row to update. */
export type BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingBaseRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: UpdateBaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** Represents an update to a `BaseRunner`. Fields that are set will be updated. */
export type BaseRunnerPatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  base?: Maybe<BaseType>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** The `baseRunner` to be created by this mutation. */
export type BaseRunnerRunnerIdFkeyBaseRunnerCreateInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  base: BaseType;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** Input for the nested mutation of `player` in the `BaseRunnerInput` mutation. */
export type BaseRunnerRunnerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<BaseRunnerRunnerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `baseRunner` in the `PlayerInput` mutation. */
export type BaseRunnerRunnerIdFkeyInverseInput = {
  /** Flag indicating whether all other `baseRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BaseRunnerNodeIdConnect>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerBaseRunnerPkeyDelete>>;
  /** The primary key(s) for `baseRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BaseRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByGameStateIdAndRunnerId?: Maybe<Array<BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingBaseRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `baseRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate>>;
  /** A `BaseRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BaseRunnerRunnerIdFkeyBaseRunnerCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type BaseRunnerRunnerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** Methods to use when ordering `BaseRunner`. */
export enum BaseRunnersOrderBy {
  NATURAL = 'NATURAL',
  GAME_STATE_ID_ASC = 'GAME_STATE_ID_ASC',
  GAME_STATE_ID_DESC = 'GAME_STATE_ID_DESC',
  RUNNER_ID_ASC = 'RUNNER_ID_ASC',
  RUNNER_ID_DESC = 'RUNNER_ID_DESC',
  BASE_ASC = 'BASE_ASC',
  BASE_DESC = 'BASE_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export enum BaseType {
  FIRST = 'FIRST',
  SECOND = 'SECOND',
  THIRD = 'THIRD'
}

export type BasepathMovement = Node & {
  __typename?: 'BasepathMovement';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
  endBase: Maybe<BaseType>;
  wasSafe: Scalars['Boolean'];
  gameId: Scalars['UUID'];
  /** Reads a single `PlateAppearance` that is related to this `BasepathMovement`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `BasepathMovement`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BasepathMovement`. */
  game: Maybe<Game>;
};

/** The fields on `basepathMovement` to look up the row to connect. */
export type BasepathMovementBasepathMovementPkeyConnect = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The fields on `basepathMovement` to look up the row to delete. */
export type BasepathMovementBasepathMovementPkeyDelete = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/**
 * A condition to be used against `BasepathMovement` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type BasepathMovementCondition = {
  /** Checks for equality with the object’s `plateAppearanceId` field. */
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runnerId` field. */
  runnerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `endBase` field. */
  endBase?: Maybe<BaseType>;
  /** Checks for equality with the object’s `wasSafe` field. */
  wasSafe?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** The `basepathMovement` to be created by this mutation. */
export type BasepathMovementGameIdFkeyBasepathMovementCreateInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe: Scalars['Boolean'];
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** The `game` to be created by this mutation. */
export type BasepathMovementGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `BasepathMovementInput` mutation. */
export type BasepathMovementGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnBasepathMovementForBasepathMovementGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnBasepathMovementForBasepathMovementGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<BasepathMovementOnBasepathMovementForBasepathMovementGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<BasepathMovementGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `basepathMovement` in the `GameInput` mutation. */
export type BasepathMovementGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `basepathMovement` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BasepathMovementNodeIdConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyDelete>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BasepathMovementNodeIdDelete>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementOnBasepathMovementForBasepathMovementGameIdFkeyUsingBasepathMovementPkeyUpdate>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnBasepathMovementForBasepathMovementGameIdFkeyNodeIdUpdate>>;
  /** A `BasepathMovementInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BasepathMovementGameIdFkeyBasepathMovementCreateInput>>;
};

/** An input for mutations affecting `BasepathMovement` */
export type BasepathMovementInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type BasepathMovementNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `basepathMovement` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type BasepathMovementNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `basepathMovement` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `basepathMovement` to look up the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementGameIdFkeyUsingBasepathMovementPkeyUpdate = {
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: UpdateBasepathMovementOnBasepathMovementForBasepathMovementGameIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** The fields on `basepathMovement` to look up the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingBasepathMovementPkeyUpdate = {
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: UpdateBasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `basepathMovement` to look up the row to update. */
export type BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingBasepathMovementPkeyUpdate = {
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: UpdateBasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** Represents an update to a `BasepathMovement`. Fields that are set will be updated. */
export type BasepathMovementPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** The `basepathMovement` to be created by this mutation. */
export type BasepathMovementPlateAppearanceIdFkeyBasepathMovementCreateInput = {
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** Input for the nested mutation of `plateAppearance` in the `BasepathMovementInput` mutation. */
export type BasepathMovementPlateAppearanceIdFkeyInput = {
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectById?: Maybe<PlateAppearancePlateAppearancePkeyConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlateAppearanceNodeIdConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteById?: Maybe<PlateAppearancePlateAppearancePkeyDelete>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlateAppearanceNodeIdDelete>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateById?: Maybe<PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateByNodeId?: Maybe<BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate>;
  /** A `PlateAppearanceInput` object that will be created and connected to this object. */
  create?: Maybe<BasepathMovementPlateAppearanceIdFkeyPlateAppearanceCreateInput>;
};

/** Input for the nested mutation of `basepathMovement` in the `PlateAppearanceInput` mutation. */
export type BasepathMovementPlateAppearanceIdFkeyInverseInput = {
  /** Flag indicating whether all other `basepathMovement` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BasepathMovementNodeIdConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyDelete>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BasepathMovementNodeIdDelete>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingBasepathMovementPkeyUpdate>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate>>;
  /** A `BasepathMovementInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BasepathMovementPlateAppearanceIdFkeyBasepathMovementCreateInput>>;
};

/** The `plateAppearance` to be created by this mutation. */
export type BasepathMovementPlateAppearanceIdFkeyPlateAppearanceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** The `basepathMovement` to be created by this mutation. */
export type BasepathMovementRunnerIdFkeyBasepathMovementCreateInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** Input for the nested mutation of `player` in the `BasepathMovementInput` mutation. */
export type BasepathMovementRunnerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<BasepathMovementRunnerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `basepathMovement` in the `PlayerInput` mutation. */
export type BasepathMovementRunnerIdFkeyInverseInput = {
  /** Flag indicating whether all other `basepathMovement` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<BasepathMovementNodeIdConnect>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementBasepathMovementPkeyDelete>>;
  /** The primary key(s) for `basepathMovement` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<BasepathMovementNodeIdDelete>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingBasepathMovementPkeyUpdate>>;
  /** The primary key(s) and patch data for `basepathMovement` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate>>;
  /** A `BasepathMovementInput` object that will be created and connected to this object. */
  create?: Maybe<Array<BasepathMovementRunnerIdFkeyBasepathMovementCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type BasepathMovementRunnerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** Methods to use when ordering `BasepathMovement`. */
export enum BasepathMovementsOrderBy {
  NATURAL = 'NATURAL',
  PLATE_APPEARANCE_ID_ASC = 'PLATE_APPEARANCE_ID_ASC',
  PLATE_APPEARANCE_ID_DESC = 'PLATE_APPEARANCE_ID_DESC',
  RUNNER_ID_ASC = 'RUNNER_ID_ASC',
  RUNNER_ID_DESC = 'RUNNER_ID_DESC',
  END_BASE_ASC = 'END_BASE_ASC',
  END_BASE_DESC = 'END_BASE_DESC',
  WAS_SAFE_ASC = 'WAS_SAFE_ASC',
  WAS_SAFE_DESC = 'WAS_SAFE_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}


export type CareerStat = {
  __typename?: 'CareerStat';
  groupId: Maybe<Scalars['UUID']>;
  playerId: Maybe<Scalars['UUID']>;
  legacyPlayerId: Maybe<Scalars['Int']>;
  seasons: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['Int']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
  /** Reads a single `Player` that is related to this `CareerStat`. */
  player: Maybe<Player>;
  /** Reads a single `LegacyPlayer` that is related to this `CareerStat`. */
  legacyPlayer: Maybe<LegacyPlayer>;
  /** Reads a single `Group` that is related to this `CareerStat`. */
  group: Maybe<Group>;
};

/**
 * A condition to be used against `CareerStat` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type CareerStatCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `seasons` field. */
  seasons?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The globally unique `ID` look up for the row to update. */
export type CareerStatOnCareerStatForFakePublicCareerStatsForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CareerStatOnCareerStatForFakePublicCareerStatsForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: LegacyPlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CareerStatOnCareerStatForFakePublicCareerStatsForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** Methods to use when ordering `CareerStat`. */
export enum CareerStatsOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  SEASONS_ASC = 'SEASONS_ASC',
  SEASONS_DESC = 'SEASONS_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC'
}

export type CareerStatsQualifiedBatter = {
  __typename?: 'CareerStatsQualifiedBatter';
  groupId: Maybe<Scalars['UUID']>;
  playerId: Maybe<Scalars['UUID']>;
  legacyPlayerId: Maybe<Scalars['Int']>;
  seasons: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['Int']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
  /** Reads a single `Player` that is related to this `CareerStatsQualifiedBatter`. */
  player: Maybe<Player>;
  /** Reads a single `LegacyPlayer` that is related to this `CareerStatsQualifiedBatter`. */
  legacyPlayer: Maybe<LegacyPlayer>;
  /** Reads a single `Group` that is related to this `CareerStatsQualifiedBatter`. */
  group: Maybe<Group>;
};

/**
 * A condition to be used against `CareerStatsQualifiedBatter` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type CareerStatsQualifiedBatterCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `seasons` field. */
  seasons?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The globally unique `ID` look up for the row to update. */
export type CareerStatsQualifiedBatterOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CareerStatsQualifiedBatterOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: LegacyPlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type CareerStatsQualifiedBatterOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** Methods to use when ordering `CareerStatsQualifiedBatter`. */
export enum CareerStatsQualifiedBattersOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  SEASONS_ASC = 'SEASONS_ASC',
  SEASONS_DESC = 'SEASONS_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC'
}

export enum ContactQuality {
  NONE = 'NONE',
  GROUNDER = 'GROUNDER',
  LINE_DRIVE = 'LINE_DRIVE',
  POPUP = 'POPUP',
  LAZY_FLY = 'LAZY_FLY',
  LONG_FLY = 'LONG_FLY',
  FOUL = 'FOUL',
  DEAD_BALL = 'DEAD_BALL',
  INNING_ENDING_DEAD_BALL = 'INNING_ENDING_DEAD_BALL'
}

/** All input for the create `AtBatSkip` mutation. */
export type CreateAtBatSkipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `AtBatSkip` to be created by this mutation. */
  atBatSkip: AtBatSkipInput;
};

/** The output of our create `AtBatSkip` mutation. */
export type CreateAtBatSkipPayload = {
  __typename?: 'CreateAtBatSkipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `AtBatSkip` that was created by this mutation. */
  atBatSkip: Maybe<AtBatSkip>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `AtBatSkip`. */
  batter: Maybe<Player>;
  /** Reads a single `Game` that is related to this `AtBatSkip`. */
  game: Maybe<Game>;
};

/** All input for the create `BaseRunner` mutation. */
export type CreateBaseRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `BaseRunner` to be created by this mutation. */
  baseRunner: BaseRunnerInput;
};

/** The output of our create `BaseRunner` mutation. */
export type CreateBaseRunnerPayload = {
  __typename?: 'CreateBaseRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BaseRunner` that was created by this mutation. */
  baseRunner: Maybe<BaseRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `BaseRunner`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Player` that is related to this `BaseRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BaseRunner`. */
  game: Maybe<Game>;
};

/** All input for the create `BasepathMovement` mutation. */
export type CreateBasepathMovementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `BasepathMovement` to be created by this mutation. */
  basepathMovement: BasepathMovementInput;
};

/** The output of our create `BasepathMovement` mutation. */
export type CreateBasepathMovementPayload = {
  __typename?: 'CreateBasepathMovementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BasepathMovement` that was created by this mutation. */
  basepathMovement: Maybe<BasepathMovement>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `BasepathMovement`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `BasepathMovement`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BasepathMovement`. */
  game: Maybe<Game>;
};

/** All input for the create `EarlyGameEnd` mutation. */
export type CreateEarlyGameEndInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `EarlyGameEnd` to be created by this mutation. */
  earlyGameEnd: EarlyGameEndInput;
};

/** The output of our create `EarlyGameEnd` mutation. */
export type CreateEarlyGameEndPayload = {
  __typename?: 'CreateEarlyGameEndPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EarlyGameEnd` that was created by this mutation. */
  earlyGameEnd: Maybe<EarlyGameEnd>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `EarlyGameEnd`. */
  game: Maybe<Game>;
};

/** All input for the create `Field` mutation. */
export type CreateFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Field` to be created by this mutation. */
  field: FieldInput;
};

/** The output of our create `Field` mutation. */
export type CreateFieldPayload = {
  __typename?: 'CreateFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Field` that was created by this mutation. */
  field: Maybe<Field>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `ForeignDbField` mutation. */
export type CreateForeignDbFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ForeignDbField` to be created by this mutation. */
  foreignDbField: ForeignDbFieldInput;
};

/** The output of our create `ForeignDbField` mutation. */
export type CreateForeignDbFieldPayload = {
  __typename?: 'CreateForeignDbFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ForeignDbField` that was created by this mutation. */
  foreignDbField: Maybe<ForeignDbField>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `ForeignDbGame` mutation. */
export type CreateForeignDbGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ForeignDbGame` to be created by this mutation. */
  foreignDbGame: ForeignDbGameInput;
};

/** The output of our create `ForeignDbGame` mutation. */
export type CreateForeignDbGamePayload = {
  __typename?: 'CreateForeignDbGamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ForeignDbGame` that was created by this mutation. */
  foreignDbGame: Maybe<ForeignDbGame>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `ForeignDbPlayer` mutation. */
export type CreateForeignDbPlayerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ForeignDbPlayer` to be created by this mutation. */
  foreignDbPlayer: ForeignDbPlayerInput;
};

/** The output of our create `ForeignDbPlayer` mutation. */
export type CreateForeignDbPlayerPayload = {
  __typename?: 'CreateForeignDbPlayerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ForeignDbPlayer` that was created by this mutation. */
  foreignDbPlayer: Maybe<ForeignDbPlayer>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `ForeignDbStatLine` mutation. */
export type CreateForeignDbStatLineInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ForeignDbStatLine` to be created by this mutation. */
  foreignDbStatLine: ForeignDbStatLineInput;
};

/** The output of our create `ForeignDbStatLine` mutation. */
export type CreateForeignDbStatLinePayload = {
  __typename?: 'CreateForeignDbStatLinePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ForeignDbStatLine` that was created by this mutation. */
  foreignDbStatLine: Maybe<ForeignDbStatLine>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `ForeignDbTeam` mutation. */
export type CreateForeignDbTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ForeignDbTeam` to be created by this mutation. */
  foreignDbTeam: ForeignDbTeamInput;
};

/** The output of our create `ForeignDbTeam` mutation. */
export type CreateForeignDbTeamPayload = {
  __typename?: 'CreateForeignDbTeamPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ForeignDbTeam` that was created by this mutation. */
  foreignDbTeam: Maybe<ForeignDbTeam>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `GameEvent` mutation. */
export type CreateGameEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GameEvent` to be created by this mutation. */
  gameEvent: GameEventInput;
};

/** The output of our create `GameEvent` mutation. */
export type CreateGameEventPayload = {
  __typename?: 'CreateGameEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEvent` that was created by this mutation. */
  gameEvent: Maybe<GameEvent>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `GameEvent`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `StolenBaseAttempt` that is related to this `GameEvent`. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Reads a single `LineupChange` that is related to this `GameEvent`. */
  lineupChange: Maybe<LineupChange>;
  /** Reads a single `SoloModeOpponentInning` that is related to this `GameEvent`. */
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  /** Reads a single `AtBatSkip` that is related to this `GameEvent`. */
  atBatSkip: Maybe<AtBatSkip>;
  /** Reads a single `Game` that is related to this `GameEvent`. */
  game: Maybe<Game>;
  /** Reads a single `EarlyGameEnd` that is related to this `GameEvent`. */
  earlyGameEnd: Maybe<EarlyGameEnd>;
};

/** All input for the create `GameEventRecord` mutation. */
export type CreateGameEventRecordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GameEventRecord` to be created by this mutation. */
  gameEventRecord: GameEventRecordInput;
};

/** The output of our create `GameEventRecord` mutation. */
export type CreateGameEventRecordPayload = {
  __typename?: 'CreateGameEventRecordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEventRecord` that was created by this mutation. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameEventRecord`. */
  game: Maybe<Game>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateBefore: Maybe<GameState>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateAfter: Maybe<GameState>;
  /** Reads a single `GameEvent` that is related to this `GameEventRecord`. */
  gameEvent: Maybe<GameEvent>;
};

/** All input for the create `Game` mutation. */
export type CreateGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Game` to be created by this mutation. */
  game: GameInput;
};

/** The output of our create `Game` mutation. */
export type CreateGamePayload = {
  __typename?: 'CreateGamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Game` that was created by this mutation. */
  game: Maybe<Game>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Group` that is related to this `Game`. */
  group: Maybe<Group>;
  /** Reads a single `Field` that is related to this `Game`. */
  field: Maybe<Field>;
};

/** All input for the create `GameState` mutation. */
export type CreateGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GameState` to be created by this mutation. */
  gameState: GameStateInput;
};

/** The output of our create `GameState` mutation. */
export type CreateGameStatePayload = {
  __typename?: 'CreateGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameState` that was created by this mutation. */
  gameState: Maybe<GameState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameState`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `GameState`. */
  playerByPlayerAtBat: Maybe<Player>;
};

/** All input for the create `GameTag` mutation. */
export type CreateGameTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `GameTag` to be created by this mutation. */
  gameTag: GameTagInput;
};

/** The output of our create `GameTag` mutation. */
export type CreateGameTagPayload = {
  __typename?: 'CreateGameTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameTag` that was created by this mutation. */
  gameTag: Maybe<GameTag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameTag`. */
  game: Maybe<Game>;
  /** Reads a single `Tag` that is related to this `GameTag`. */
  tag: Maybe<Tag>;
};

/** All input for the create `Group` mutation. */
export type CreateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Group` to be created by this mutation. */
  group: GroupInput;
};

/** The output of our create `Group` mutation. */
export type CreateGroupPayload = {
  __typename?: 'CreateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Group` that was created by this mutation. */
  group: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `LegacyMeetupFieldRaw` mutation. */
export type CreateLegacyMeetupFieldRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LegacyMeetupFieldRaw` to be created by this mutation. */
  legacyMeetupFieldRaw: LegacyMeetupFieldRawInput;
};

/** The output of our create `LegacyMeetupFieldRaw` mutation. */
export type CreateLegacyMeetupFieldRawPayload = {
  __typename?: 'CreateLegacyMeetupFieldRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LegacyMeetupFieldRaw` that was created by this mutation. */
  legacyMeetupFieldRaw: Maybe<LegacyMeetupFieldRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `LegacyMeetupGameRaw` mutation. */
export type CreateLegacyMeetupGameRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LegacyMeetupGameRaw` to be created by this mutation. */
  legacyMeetupGameRaw: LegacyMeetupGameRawInput;
};

/** The output of our create `LegacyMeetupGameRaw` mutation. */
export type CreateLegacyMeetupGameRawPayload = {
  __typename?: 'CreateLegacyMeetupGameRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LegacyMeetupGameRaw` that was created by this mutation. */
  legacyMeetupGameRaw: Maybe<LegacyMeetupGameRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `LegacyMeetupTeamRaw` that is related to this `LegacyMeetupGameRaw`. */
  winningTeam: Maybe<LegacyMeetupTeamRaw>;
  /** Reads a single `LegacyMeetupTeamRaw` that is related to this `LegacyMeetupGameRaw`. */
  losingTeam: Maybe<LegacyMeetupTeamRaw>;
  /** Reads a single `LegacyMeetupFieldRaw` that is related to this `LegacyMeetupGameRaw`. */
  field: Maybe<LegacyMeetupFieldRaw>;
};

/** All input for the create `LegacyMeetupPlayerRaw` mutation. */
export type CreateLegacyMeetupPlayerRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LegacyMeetupPlayerRaw` to be created by this mutation. */
  legacyMeetupPlayerRaw: LegacyMeetupPlayerRawInput;
};

/** The output of our create `LegacyMeetupPlayerRaw` mutation. */
export type CreateLegacyMeetupPlayerRawPayload = {
  __typename?: 'CreateLegacyMeetupPlayerRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LegacyMeetupPlayerRaw` that was created by this mutation. */
  legacyMeetupPlayerRaw: Maybe<LegacyMeetupPlayerRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `LegacyMeetupStatLineRaw` mutation. */
export type CreateLegacyMeetupStatLineRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LegacyMeetupStatLineRaw` to be created by this mutation. */
  legacyMeetupStatLineRaw: LegacyMeetupStatLineRawInput;
};

/** The output of our create `LegacyMeetupStatLineRaw` mutation. */
export type CreateLegacyMeetupStatLineRawPayload = {
  __typename?: 'CreateLegacyMeetupStatLineRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LegacyMeetupStatLineRaw` that was created by this mutation. */
  legacyMeetupStatLineRaw: Maybe<LegacyMeetupStatLineRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `LegacyMeetupPlayerRaw` that is related to this `LegacyMeetupStatLineRaw`. */
  player: Maybe<LegacyMeetupPlayerRaw>;
  /** Reads a single `LegacyMeetupGameRaw` that is related to this `LegacyMeetupStatLineRaw`. */
  game: Maybe<LegacyMeetupGameRaw>;
  /** Reads a single `LegacyMeetupTeamRaw` that is related to this `LegacyMeetupStatLineRaw`. */
  team: Maybe<LegacyMeetupTeamRaw>;
};

/** All input for the create `LegacyMeetupTeamRaw` mutation. */
export type CreateLegacyMeetupTeamRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LegacyMeetupTeamRaw` to be created by this mutation. */
  legacyMeetupTeamRaw: LegacyMeetupTeamRawInput;
};

/** The output of our create `LegacyMeetupTeamRaw` mutation. */
export type CreateLegacyMeetupTeamRawPayload = {
  __typename?: 'CreateLegacyMeetupTeamRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LegacyMeetupTeamRaw` that was created by this mutation. */
  legacyMeetupTeamRaw: Maybe<LegacyMeetupTeamRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `LineupChange` mutation. */
export type CreateLineupChangeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LineupChange` to be created by this mutation. */
  lineupChange: LineupChangeInput;
};

/** The output of our create `LineupChange` mutation. */
export type CreateLineupChangePayload = {
  __typename?: 'CreateLineupChangePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupChange` that was created by this mutation. */
  lineupChange: Maybe<LineupChange>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupBefore: Maybe<Lineup>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupAfter: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupChange`. */
  game: Maybe<Game>;
};

/** All input for the create `LineupForGameState` mutation. */
export type CreateLineupForGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LineupForGameState` to be created by this mutation. */
  lineupForGameState: LineupForGameStateInput;
};

/** The output of our create `LineupForGameState` mutation. */
export type CreateLineupForGameStatePayload = {
  __typename?: 'CreateLineupForGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupForGameState` that was created by this mutation. */
  lineupForGameState: Maybe<LineupForGameState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `LineupForGameState`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Lineup` that is related to this `LineupForGameState`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupForGameState`. */
  game: Maybe<Game>;
};

/** All input for the create `Lineup` mutation. */
export type CreateLineupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Lineup` to be created by this mutation. */
  lineup: LineupInput;
};

/** The output of our create `Lineup` mutation. */
export type CreateLineupPayload = {
  __typename?: 'CreateLineupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Lineup` that was created by this mutation. */
  lineup: Maybe<Lineup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Team` that is related to this `Lineup`. */
  team: Maybe<Team>;
  /** Reads a single `Game` that is related to this `Lineup`. */
  game: Maybe<Game>;
};

/** All input for the create `LineupSpot` mutation. */
export type CreateLineupSpotInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `LineupSpot` to be created by this mutation. */
  lineupSpot: LineupSpotInput;
};

/** The output of our create `LineupSpot` mutation. */
export type CreateLineupSpotPayload = {
  __typename?: 'CreateLineupSpotPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupSpot` that was created by this mutation. */
  lineupSpot: Maybe<LineupSpot>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupSpot`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Player` that is related to this `LineupSpot`. */
  player: Maybe<Player>;
  /** Reads a single `Game` that is related to this `LineupSpot`. */
  game: Maybe<Game>;
};

/** All input for the create `OutOnPlayRunner` mutation. */
export type CreateOutOnPlayRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `OutOnPlayRunner` to be created by this mutation. */
  outOnPlayRunner: OutOnPlayRunnerInput;
};

/** The output of our create `OutOnPlayRunner` mutation. */
export type CreateOutOnPlayRunnerPayload = {
  __typename?: 'CreateOutOnPlayRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `OutOnPlayRunner` that was created by this mutation. */
  outOnPlayRunner: Maybe<OutOnPlayRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `OutOnPlayRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `OutOnPlayRunner`. */
  game: Maybe<Game>;
};

/** All input for the create `PlateAppearance` mutation. */
export type CreatePlateAppearanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PlateAppearance` to be created by this mutation. */
  plateAppearance: PlateAppearanceInput;
};

/** The output of our create `PlateAppearance` mutation. */
export type CreatePlateAppearancePayload = {
  __typename?: 'CreatePlateAppearancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlateAppearance` that was created by this mutation. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `PlateAppearance`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `PlateAppearance`. */
  batter: Maybe<Player>;
};

/** All input for the create `PlayerGroupMembership` mutation. */
export type CreatePlayerGroupMembershipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PlayerGroupMembership` to be created by this mutation. */
  playerGroupMembership: PlayerGroupMembershipInput;
};

/** The output of our create `PlayerGroupMembership` mutation. */
export type CreatePlayerGroupMembershipPayload = {
  __typename?: 'CreatePlayerGroupMembershipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlayerGroupMembership` that was created by this mutation. */
  playerGroupMembership: Maybe<PlayerGroupMembership>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `PlayerGroupMembership`. */
  player: Maybe<Player>;
  /** Reads a single `Group` that is related to this `PlayerGroupMembership`. */
  group: Maybe<Group>;
};

/** All input for the create `Player` mutation. */
export type CreatePlayerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Player` to be created by this mutation. */
  player: PlayerInput;
};

/** The output of our create `Player` mutation. */
export type CreatePlayerPayload = {
  __typename?: 'CreatePlayerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Player` that was created by this mutation. */
  player: Maybe<Player>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `LegacyPlayer` that is related to this `Player`. */
  legacyPlayer: Maybe<LegacyPlayer>;
};

/** All input for the create `ReduxDump` mutation. */
export type CreateReduxDumpInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReduxDump` to be created by this mutation. */
  reduxDump: ReduxDumpInput;
};

/** The output of our create `ReduxDump` mutation. */
export type CreateReduxDumpPayload = {
  __typename?: 'CreateReduxDumpPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ReduxDump` that was created by this mutation. */
  reduxDump: Maybe<ReduxDump>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `ScoredRunner` mutation. */
export type CreateScoredRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ScoredRunner` to be created by this mutation. */
  scoredRunner: ScoredRunnerInput;
};

/** The output of our create `ScoredRunner` mutation. */
export type CreateScoredRunnerPayload = {
  __typename?: 'CreateScoredRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ScoredRunner` that was created by this mutation. */
  scoredRunner: Maybe<ScoredRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameEventRecord` that is related to this `ScoredRunner`. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Reads a single `Player` that is related to this `ScoredRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `ScoredRunner`. */
  game: Maybe<Game>;
};

/** All input for the create `SoloModeOpponentInning` mutation. */
export type CreateSoloModeOpponentInningInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `SoloModeOpponentInning` to be created by this mutation. */
  soloModeOpponentInning: SoloModeOpponentInningInput;
};

/** The output of our create `SoloModeOpponentInning` mutation. */
export type CreateSoloModeOpponentInningPayload = {
  __typename?: 'CreateSoloModeOpponentInningPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `SoloModeOpponentInning` that was created by this mutation. */
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `SoloModeOpponentInning`. */
  game: Maybe<Game>;
};

/** All input for the create `StolenBaseAttempt` mutation. */
export type CreateStolenBaseAttemptInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `StolenBaseAttempt` to be created by this mutation. */
  stolenBaseAttempt: StolenBaseAttemptInput;
};

/** The output of our create `StolenBaseAttempt` mutation. */
export type CreateStolenBaseAttemptPayload = {
  __typename?: 'CreateStolenBaseAttemptPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `StolenBaseAttempt` that was created by this mutation. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `StolenBaseAttempt`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `StolenBaseAttempt`. */
  game: Maybe<Game>;
};

/** All input for the create `Tag` mutation. */
export type CreateTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Tag` to be created by this mutation. */
  tag: TagInput;
};

/** The output of our create `Tag` mutation. */
export type CreateTagPayload = {
  __typename?: 'CreateTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Tag` that was created by this mutation. */
  tag: Maybe<Tag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the create `Team` mutation. */
export type CreateTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Team` to be created by this mutation. */
  team: TeamInput;
};

/** The output of our create `Team` mutation. */
export type CreateTeamPayload = {
  __typename?: 'CreateTeamPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Team` that was created by this mutation. */
  team: Maybe<Team>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `Team`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `Team`. */
  captain: Maybe<Player>;
};



/** All input for the `deleteAtBatSkipByNodeId` mutation. */
export type DeleteAtBatSkipByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AtBatSkip` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteAtBatSkip` mutation. */
export type DeleteAtBatSkipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `AtBatSkip` mutation. */
export type DeleteAtBatSkipPayload = {
  __typename?: 'DeleteAtBatSkipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `AtBatSkip` that was deleted by this mutation. */
  atBatSkip: Maybe<AtBatSkip>;
  deletedAtBatSkipNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `AtBatSkip`. */
  batter: Maybe<Player>;
  /** Reads a single `Game` that is related to this `AtBatSkip`. */
  game: Maybe<Game>;
};

/** All input for the `deleteBaseRunnerByNodeId` mutation. */
export type DeleteBaseRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `BaseRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteBaseRunner` mutation. */
export type DeleteBaseRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our delete `BaseRunner` mutation. */
export type DeleteBaseRunnerPayload = {
  __typename?: 'DeleteBaseRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BaseRunner` that was deleted by this mutation. */
  baseRunner: Maybe<BaseRunner>;
  deletedBaseRunnerNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `BaseRunner`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Player` that is related to this `BaseRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BaseRunner`. */
  game: Maybe<Game>;
};

/** All input for the `deleteBasepathMovementByNodeId` mutation. */
export type DeleteBasepathMovementByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `BasepathMovement` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteBasepathMovement` mutation. */
export type DeleteBasepathMovementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our delete `BasepathMovement` mutation. */
export type DeleteBasepathMovementPayload = {
  __typename?: 'DeleteBasepathMovementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BasepathMovement` that was deleted by this mutation. */
  basepathMovement: Maybe<BasepathMovement>;
  deletedBasepathMovementNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `BasepathMovement`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `BasepathMovement`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BasepathMovement`. */
  game: Maybe<Game>;
};

/** All input for the `deleteEarlyGameEndByNodeId` mutation. */
export type DeleteEarlyGameEndByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `EarlyGameEnd` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteEarlyGameEnd` mutation. */
export type DeleteEarlyGameEndInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `EarlyGameEnd` mutation. */
export type DeleteEarlyGameEndPayload = {
  __typename?: 'DeleteEarlyGameEndPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EarlyGameEnd` that was deleted by this mutation. */
  earlyGameEnd: Maybe<EarlyGameEnd>;
  deletedEarlyGameEndNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `EarlyGameEnd`. */
  game: Maybe<Game>;
};

/** All input for the `deleteFieldByNodeId` mutation. */
export type DeleteFieldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Field` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteField` mutation. */
export type DeleteFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Field` mutation. */
export type DeleteFieldPayload = {
  __typename?: 'DeleteFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Field` that was deleted by this mutation. */
  field: Maybe<Field>;
  deletedFieldNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteGameByGroupIdAndName` mutation. */
export type DeleteGameByGroupIdAndNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** All input for the `deleteGameByNodeId` mutation. */
export type DeleteGameByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Game` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGameEventByNodeId` mutation. */
export type DeleteGameEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameEvent` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGameEvent` mutation. */
export type DeleteGameEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `GameEvent` mutation. */
export type DeleteGameEventPayload = {
  __typename?: 'DeleteGameEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEvent` that was deleted by this mutation. */
  gameEvent: Maybe<GameEvent>;
  deletedGameEventNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `GameEvent`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `StolenBaseAttempt` that is related to this `GameEvent`. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Reads a single `LineupChange` that is related to this `GameEvent`. */
  lineupChange: Maybe<LineupChange>;
  /** Reads a single `SoloModeOpponentInning` that is related to this `GameEvent`. */
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  /** Reads a single `AtBatSkip` that is related to this `GameEvent`. */
  atBatSkip: Maybe<AtBatSkip>;
  /** Reads a single `Game` that is related to this `GameEvent`. */
  game: Maybe<Game>;
  /** Reads a single `EarlyGameEnd` that is related to this `GameEvent`. */
  earlyGameEnd: Maybe<EarlyGameEnd>;
};

/** All input for the `deleteGameEventRecordByGameIdAndEventIndex` mutation. */
export type DeleteGameEventRecordByGameIdAndEventIndexInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** All input for the `deleteGameEventRecordByNodeId` mutation. */
export type DeleteGameEventRecordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameEventRecord` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGameEventRecord` mutation. */
export type DeleteGameEventRecordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `GameEventRecord` mutation. */
export type DeleteGameEventRecordPayload = {
  __typename?: 'DeleteGameEventRecordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEventRecord` that was deleted by this mutation. */
  gameEventRecord: Maybe<GameEventRecord>;
  deletedGameEventRecordNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameEventRecord`. */
  game: Maybe<Game>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateBefore: Maybe<GameState>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateAfter: Maybe<GameState>;
  /** Reads a single `GameEvent` that is related to this `GameEventRecord`. */
  gameEvent: Maybe<GameEvent>;
};

/** All input for the `deleteGame` mutation. */
export type DeleteGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Game` mutation. */
export type DeleteGamePayload = {
  __typename?: 'DeleteGamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Game` that was deleted by this mutation. */
  game: Maybe<Game>;
  deletedGameNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Group` that is related to this `Game`. */
  group: Maybe<Group>;
  /** Reads a single `Field` that is related to this `Game`. */
  field: Maybe<Field>;
};

/** All input for the `deleteGameStateByNodeId` mutation. */
export type DeleteGameStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameState` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGameState` mutation. */
export type DeleteGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `GameState` mutation. */
export type DeleteGameStatePayload = {
  __typename?: 'DeleteGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameState` that was deleted by this mutation. */
  gameState: Maybe<GameState>;
  deletedGameStateNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameState`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `GameState`. */
  playerByPlayerAtBat: Maybe<Player>;
};

/** All input for the `deleteGroupByName` mutation. */
export type DeleteGroupByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** All input for the `deleteGroupByNodeId` mutation. */
export type DeleteGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Group` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteGroupByUrlSlug` mutation. */
export type DeleteGroupByUrlSlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  urlSlug: Scalars['String'];
};

/** All input for the `deleteGroup` mutation. */
export type DeleteGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Group` mutation. */
export type DeleteGroupPayload = {
  __typename?: 'DeleteGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Group` that was deleted by this mutation. */
  group: Maybe<Group>;
  deletedGroupNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteLegacyMeetupFieldRawByNameAndSubField` mutation. */
export type DeleteLegacyMeetupFieldRawByNameAndSubFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  subField: Scalars['String'];
};

/** All input for the `deleteLegacyMeetupFieldRawByNodeId` mutation. */
export type DeleteLegacyMeetupFieldRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LegacyMeetupFieldRaw` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLegacyMeetupFieldRaw` mutation. */
export type DeleteLegacyMeetupFieldRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `LegacyMeetupFieldRaw` mutation. */
export type DeleteLegacyMeetupFieldRawPayload = {
  __typename?: 'DeleteLegacyMeetupFieldRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LegacyMeetupFieldRaw` that was deleted by this mutation. */
  legacyMeetupFieldRaw: Maybe<LegacyMeetupFieldRaw>;
  deletedLegacyMeetupFieldRawNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteLegacyMeetupGameRawByName` mutation. */
export type DeleteLegacyMeetupGameRawByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** All input for the `deleteLegacyMeetupGameRawByNodeId` mutation. */
export type DeleteLegacyMeetupGameRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LegacyMeetupGameRaw` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLegacyMeetupGameRaw` mutation. */
export type DeleteLegacyMeetupGameRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `LegacyMeetupGameRaw` mutation. */
export type DeleteLegacyMeetupGameRawPayload = {
  __typename?: 'DeleteLegacyMeetupGameRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LegacyMeetupGameRaw` that was deleted by this mutation. */
  legacyMeetupGameRaw: Maybe<LegacyMeetupGameRaw>;
  deletedLegacyMeetupGameRawNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `LegacyMeetupTeamRaw` that is related to this `LegacyMeetupGameRaw`. */
  winningTeam: Maybe<LegacyMeetupTeamRaw>;
  /** Reads a single `LegacyMeetupTeamRaw` that is related to this `LegacyMeetupGameRaw`. */
  losingTeam: Maybe<LegacyMeetupTeamRaw>;
  /** Reads a single `LegacyMeetupFieldRaw` that is related to this `LegacyMeetupGameRaw`. */
  field: Maybe<LegacyMeetupFieldRaw>;
};

/** All input for the `deleteLegacyMeetupPlayerRawByName` mutation. */
export type DeleteLegacyMeetupPlayerRawByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** All input for the `deleteLegacyMeetupPlayerRawByNodeId` mutation. */
export type DeleteLegacyMeetupPlayerRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LegacyMeetupPlayerRaw` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLegacyMeetupPlayerRaw` mutation. */
export type DeleteLegacyMeetupPlayerRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `LegacyMeetupPlayerRaw` mutation. */
export type DeleteLegacyMeetupPlayerRawPayload = {
  __typename?: 'DeleteLegacyMeetupPlayerRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LegacyMeetupPlayerRaw` that was deleted by this mutation. */
  legacyMeetupPlayerRaw: Maybe<LegacyMeetupPlayerRaw>;
  deletedLegacyMeetupPlayerRawNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteLegacyMeetupStatLineRawByNodeId` mutation. */
export type DeleteLegacyMeetupStatLineRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LegacyMeetupStatLineRaw` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLegacyMeetupStatLineRaw` mutation. */
export type DeleteLegacyMeetupStatLineRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `LegacyMeetupStatLineRaw` mutation. */
export type DeleteLegacyMeetupStatLineRawPayload = {
  __typename?: 'DeleteLegacyMeetupStatLineRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LegacyMeetupStatLineRaw` that was deleted by this mutation. */
  legacyMeetupStatLineRaw: Maybe<LegacyMeetupStatLineRaw>;
  deletedLegacyMeetupStatLineRawNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `LegacyMeetupPlayerRaw` that is related to this `LegacyMeetupStatLineRaw`. */
  player: Maybe<LegacyMeetupPlayerRaw>;
  /** Reads a single `LegacyMeetupGameRaw` that is related to this `LegacyMeetupStatLineRaw`. */
  game: Maybe<LegacyMeetupGameRaw>;
  /** Reads a single `LegacyMeetupTeamRaw` that is related to this `LegacyMeetupStatLineRaw`. */
  team: Maybe<LegacyMeetupTeamRaw>;
};

/** All input for the `deleteLegacyMeetupTeamRawByName` mutation. */
export type DeleteLegacyMeetupTeamRawByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** All input for the `deleteLegacyMeetupTeamRawByNodeId` mutation. */
export type DeleteLegacyMeetupTeamRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LegacyMeetupTeamRaw` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLegacyMeetupTeamRaw` mutation. */
export type DeleteLegacyMeetupTeamRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `LegacyMeetupTeamRaw` mutation. */
export type DeleteLegacyMeetupTeamRawPayload = {
  __typename?: 'DeleteLegacyMeetupTeamRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LegacyMeetupTeamRaw` that was deleted by this mutation. */
  legacyMeetupTeamRaw: Maybe<LegacyMeetupTeamRaw>;
  deletedLegacyMeetupTeamRawNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteLineupByNodeId` mutation. */
export type DeleteLineupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Lineup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLineupChangeByNodeId` mutation. */
export type DeleteLineupChangeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupChange` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLineupChange` mutation. */
export type DeleteLineupChangeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `LineupChange` mutation. */
export type DeleteLineupChangePayload = {
  __typename?: 'DeleteLineupChangePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupChange` that was deleted by this mutation. */
  lineupChange: Maybe<LineupChange>;
  deletedLineupChangeNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupBefore: Maybe<Lineup>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupAfter: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupChange`. */
  game: Maybe<Game>;
};

/** All input for the `deleteLineupForGameStateByNodeId` mutation. */
export type DeleteLineupForGameStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupForGameState` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLineupForGameState` mutation. */
export type DeleteLineupForGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** The output of our delete `LineupForGameState` mutation. */
export type DeleteLineupForGameStatePayload = {
  __typename?: 'DeleteLineupForGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupForGameState` that was deleted by this mutation. */
  lineupForGameState: Maybe<LineupForGameState>;
  deletedLineupForGameStateNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `LineupForGameState`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Lineup` that is related to this `LineupForGameState`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupForGameState`. */
  game: Maybe<Game>;
};

/** All input for the `deleteLineup` mutation. */
export type DeleteLineupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Lineup` mutation. */
export type DeleteLineupPayload = {
  __typename?: 'DeleteLineupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Lineup` that was deleted by this mutation. */
  lineup: Maybe<Lineup>;
  deletedLineupNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Team` that is related to this `Lineup`. */
  team: Maybe<Team>;
  /** Reads a single `Game` that is related to this `Lineup`. */
  game: Maybe<Game>;
};

/** All input for the `deleteLineupSpotByLineupIdAndBattingOrder` mutation. */
export type DeleteLineupSpotByLineupIdAndBattingOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** All input for the `deleteLineupSpotByLineupIdAndPosition` mutation. */
export type DeleteLineupSpotByLineupIdAndPositionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** All input for the `deleteLineupSpotByNodeId` mutation. */
export type DeleteLineupSpotByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupSpot` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteLineupSpot` mutation. */
export type DeleteLineupSpotInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The output of our delete `LineupSpot` mutation. */
export type DeleteLineupSpotPayload = {
  __typename?: 'DeleteLineupSpotPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupSpot` that was deleted by this mutation. */
  lineupSpot: Maybe<LineupSpot>;
  deletedLineupSpotNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupSpot`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Player` that is related to this `LineupSpot`. */
  player: Maybe<Player>;
  /** Reads a single `Game` that is related to this `LineupSpot`. */
  game: Maybe<Game>;
};

/** All input for the `deleteOutOnPlayRunnerByNodeId` mutation. */
export type DeleteOutOnPlayRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OutOnPlayRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOutOnPlayRunner` mutation. */
export type DeleteOutOnPlayRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our delete `OutOnPlayRunner` mutation. */
export type DeleteOutOnPlayRunnerPayload = {
  __typename?: 'DeleteOutOnPlayRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `OutOnPlayRunner` that was deleted by this mutation. */
  outOnPlayRunner: Maybe<OutOnPlayRunner>;
  deletedOutOnPlayRunnerNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `OutOnPlayRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `OutOnPlayRunner`. */
  game: Maybe<Game>;
};

/** All input for the `deletePlateAppearanceByNodeId` mutation. */
export type DeletePlateAppearanceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlateAppearance` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlateAppearance` mutation. */
export type DeletePlateAppearanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `PlateAppearance` mutation. */
export type DeletePlateAppearancePayload = {
  __typename?: 'DeletePlateAppearancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlateAppearance` that was deleted by this mutation. */
  plateAppearance: Maybe<PlateAppearance>;
  deletedPlateAppearanceNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `PlateAppearance`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `PlateAppearance`. */
  batter: Maybe<Player>;
};

/** All input for the `deletePlayerByFirstNameAndLastName` mutation. */
export type DeletePlayerByFirstNameAndLastNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** All input for the `deletePlayerByNodeId` mutation. */
export type DeletePlayerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Player` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlayerGroupMembershipByNodeId` mutation. */
export type DeletePlayerGroupMembershipByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlayerGroupMembership` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePlayerGroupMembership` mutation. */
export type DeletePlayerGroupMembershipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
};

/** The output of our delete `PlayerGroupMembership` mutation. */
export type DeletePlayerGroupMembershipPayload = {
  __typename?: 'DeletePlayerGroupMembershipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlayerGroupMembership` that was deleted by this mutation. */
  playerGroupMembership: Maybe<PlayerGroupMembership>;
  deletedPlayerGroupMembershipNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `PlayerGroupMembership`. */
  player: Maybe<Player>;
  /** Reads a single `Group` that is related to this `PlayerGroupMembership`. */
  group: Maybe<Group>;
};

/** All input for the `deletePlayer` mutation. */
export type DeletePlayerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Player` mutation. */
export type DeletePlayerPayload = {
  __typename?: 'DeletePlayerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Player` that was deleted by this mutation. */
  player: Maybe<Player>;
  deletedPlayerNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `LegacyPlayer` that is related to this `Player`. */
  legacyPlayer: Maybe<LegacyPlayer>;
};

/** All input for the `deleteReduxDumpByNodeId` mutation. */
export type DeleteReduxDumpByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ReduxDump` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteReduxDump` mutation. */
export type DeleteReduxDumpInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `ReduxDump` mutation. */
export type DeleteReduxDumpPayload = {
  __typename?: 'DeleteReduxDumpPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ReduxDump` that was deleted by this mutation. */
  reduxDump: Maybe<ReduxDump>;
  deletedReduxDumpNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteScoredRunnerByNodeId` mutation. */
export type DeleteScoredRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ScoredRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteScoredRunner` mutation. */
export type DeleteScoredRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our delete `ScoredRunner` mutation. */
export type DeleteScoredRunnerPayload = {
  __typename?: 'DeleteScoredRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ScoredRunner` that was deleted by this mutation. */
  scoredRunner: Maybe<ScoredRunner>;
  deletedScoredRunnerNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameEventRecord` that is related to this `ScoredRunner`. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Reads a single `Player` that is related to this `ScoredRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `ScoredRunner`. */
  game: Maybe<Game>;
};

/** All input for the `deleteSoloModeOpponentInningByNodeId` mutation. */
export type DeleteSoloModeOpponentInningByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SoloModeOpponentInning` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteSoloModeOpponentInning` mutation. */
export type DeleteSoloModeOpponentInningInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `SoloModeOpponentInning` mutation. */
export type DeleteSoloModeOpponentInningPayload = {
  __typename?: 'DeleteSoloModeOpponentInningPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `SoloModeOpponentInning` that was deleted by this mutation. */
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  deletedSoloModeOpponentInningNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `SoloModeOpponentInning`. */
  game: Maybe<Game>;
};

/** All input for the `deleteStolenBaseAttemptByNodeId` mutation. */
export type DeleteStolenBaseAttemptByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StolenBaseAttempt` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteStolenBaseAttempt` mutation. */
export type DeleteStolenBaseAttemptInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `StolenBaseAttempt` mutation. */
export type DeleteStolenBaseAttemptPayload = {
  __typename?: 'DeleteStolenBaseAttemptPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `StolenBaseAttempt` that was deleted by this mutation. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  deletedStolenBaseAttemptNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `StolenBaseAttempt`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `StolenBaseAttempt`. */
  game: Maybe<Game>;
};

/** All input for the `deleteTagByName` mutation. */
export type DeleteTagByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** All input for the `deleteTagByNodeId` mutation. */
export type DeleteTagByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Tag` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTag` mutation. */
export type DeleteTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Tag` mutation. */
export type DeleteTagPayload = {
  __typename?: 'DeleteTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Tag` that was deleted by this mutation. */
  tag: Maybe<Tag>;
  deletedTagNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `deleteTeamByGameIdAndRole` mutation. */
export type DeleteTeamByGameIdAndRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** All input for the `deleteTeamByNodeId` mutation. */
export type DeleteTeamByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Team` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTeam` mutation. */
export type DeleteTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['UUID'];
};

/** The output of our delete `Team` mutation. */
export type DeleteTeamPayload = {
  __typename?: 'DeleteTeamPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Team` that was deleted by this mutation. */
  team: Maybe<Team>;
  deletedTeamNodeId: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `Team`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `Team`. */
  captain: Maybe<Player>;
};

export type EarlyGameEnd = Node & {
  __typename?: 'EarlyGameEnd';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  reason: EarlyGameEndReason;
  gameId: Scalars['UUID'];
  /** Reads a single `Game` that is related to this `EarlyGameEnd`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `EarlyGameEnd` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type EarlyGameEndCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `reason` field. */
  reason?: Maybe<EarlyGameEndReason>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** The fields on `earlyGameEnd` to look up the row to connect. */
export type EarlyGameEndEarlyGameEndPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `earlyGameEnd` to look up the row to delete. */
export type EarlyGameEndEarlyGameEndPkeyDelete = {
  id: Scalars['UUID'];
};

/** The `earlyGameEnd` to be created by this mutation. */
export type EarlyGameEndGameIdFkeyEarlyGameEndCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  reason: EarlyGameEndReason;
  game?: Maybe<EarlyGameEndGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventEarlyGameEndIdFkeyInverseInput>;
};

/** The `game` to be created by this mutation. */
export type EarlyGameEndGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `EarlyGameEndInput` mutation. */
export type EarlyGameEndGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnEarlyGameEndForEarlyGameEndGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnEarlyGameEndForEarlyGameEndGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<EarlyGameEndOnEarlyGameEndForEarlyGameEndGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<EarlyGameEndGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `earlyGameEnd` in the `GameInput` mutation. */
export type EarlyGameEndGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `earlyGameEnd` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  connectById?: Maybe<Array<EarlyGameEndEarlyGameEndPkeyConnect>>;
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<EarlyGameEndNodeIdConnect>>;
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  deleteById?: Maybe<Array<EarlyGameEndEarlyGameEndPkeyDelete>>;
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<EarlyGameEndNodeIdDelete>>;
  /** The primary key(s) and patch data for `earlyGameEnd` for the far side of the relationship. */
  updateById?: Maybe<Array<EarlyGameEndOnEarlyGameEndForEarlyGameEndGameIdFkeyUsingEarlyGameEndPkeyUpdate>>;
  /** The primary key(s) and patch data for `earlyGameEnd` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnEarlyGameEndForEarlyGameEndGameIdFkeyNodeIdUpdate>>;
  /** A `EarlyGameEndInput` object that will be created and connected to this object. */
  create?: Maybe<Array<EarlyGameEndGameIdFkeyEarlyGameEndCreateInput>>;
};

/** An input for mutations affecting `EarlyGameEnd` */
export type EarlyGameEndInput = {
  id?: Maybe<Scalars['UUID']>;
  reason: EarlyGameEndReason;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<EarlyGameEndGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventEarlyGameEndIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type EarlyGameEndNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `earlyGameEnd` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type EarlyGameEndNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `earlyGameEnd` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type EarlyGameEndOnEarlyGameEndForEarlyGameEndGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `earlyGameEnd` to look up the row to update. */
export type EarlyGameEndOnEarlyGameEndForEarlyGameEndGameIdFkeyUsingEarlyGameEndPkeyUpdate = {
  /** An object where the defined keys will be set on the `earlyGameEnd` being updated. */
  patch: UpdateEarlyGameEndOnEarlyGameEndForEarlyGameEndGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type EarlyGameEndOnGameEventForGameEventEarlyGameEndIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `earlyGameEnd` to look up the row to update. */
export type EarlyGameEndOnGameEventForGameEventEarlyGameEndIdFkeyUsingEarlyGameEndPkeyUpdate = {
  /** An object where the defined keys will be set on the `earlyGameEnd` being updated. */
  patch: UpdateEarlyGameEndOnGameEventForGameEventEarlyGameEndIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `EarlyGameEnd`. Fields that are set will be updated. */
export type EarlyGameEndPatch = {
  id?: Maybe<Scalars['UUID']>;
  reason?: Maybe<EarlyGameEndReason>;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<EarlyGameEndGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventEarlyGameEndIdFkeyInverseInput>;
};

export enum EarlyGameEndReason {
  MERCY_RULE = 'MERCY_RULE',
  TIME_EXPIRED = 'TIME_EXPIRED',
  OTHER = 'OTHER'
}

/** Methods to use when ordering `EarlyGameEnd`. */
export enum EarlyGameEndsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  REASON_ASC = 'REASON_ASC',
  REASON_DESC = 'REASON_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** The `careerStat` to be created by this mutation. */
export type FakePublicCareerStatsForeignKey0CareerStatsCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicCareerStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicCareerStatsForeignKey1Input>;
  group?: Maybe<FakePublicCareerStatsForeignKey2Input>;
};

/** Input for the nested mutation of `player` in the `CareerStatInput` mutation. */
export type FakePublicCareerStatsForeignKey0Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnCareerStatForFakePublicCareerStatsForeignKey0UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnCareerStatForFakePublicCareerStatsForeignKey0UsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<CareerStatOnCareerStatForFakePublicCareerStatsForeignKey0NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicCareerStatsForeignKey0PlayerCreateInput>;
};

/** Input for the nested mutation of `careerStat` in the `PlayerInput` mutation. */
export type FakePublicCareerStatsForeignKey0InverseInput = {
  /** A `CareerStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicCareerStatsForeignKey0CareerStatsCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type FakePublicCareerStatsForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `careerStat` to be created by this mutation. */
export type FakePublicCareerStatsForeignKey1CareerStatsCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicCareerStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicCareerStatsForeignKey1Input>;
  group?: Maybe<FakePublicCareerStatsForeignKey2Input>;
};

/** Input for the nested mutation of `legacyPlayer` in the `CareerStatInput` mutation. */
export type FakePublicCareerStatsForeignKey1Input = {
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyPlayerNodeIdConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyPlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByPlayerId?: Maybe<LegacyPlayerOnCareerStatForFakePublicCareerStatsForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByNodeId?: Maybe<CareerStatOnCareerStatForFakePublicCareerStatsForeignKey1NodeIdUpdate>;
  /** A `LegacyPlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicCareerStatsForeignKey1LegacyPlayerCreateInput>;
};

/** Input for the nested mutation of `careerStat` in the `LegacyPlayerInput` mutation. */
export type FakePublicCareerStatsForeignKey1InverseInput = {
  /** A `CareerStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicCareerStatsForeignKey1CareerStatsCreateInput>>;
};

/** The `legacyPlayer` to be created by this mutation. */
export type FakePublicCareerStatsForeignKey1LegacyPlayerCreateInput = {
  playerId: Scalars['Int'];
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** The `careerStat` to be created by this mutation. */
export type FakePublicCareerStatsForeignKey2CareerStatsCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicCareerStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicCareerStatsForeignKey1Input>;
  group?: Maybe<FakePublicCareerStatsForeignKey2Input>;
};

/** The `group` to be created by this mutation. */
export type FakePublicCareerStatsForeignKey2GroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** Input for the nested mutation of `group` in the `CareerStatInput` mutation. */
export type FakePublicCareerStatsForeignKey2Input = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByUrlSlug?: Maybe<GroupGroupUrlSlugKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByUrlSlug?: Maybe<GroupGroupUrlSlugKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnCareerStatForFakePublicCareerStatsForeignKey2UsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnCareerStatForFakePublicCareerStatsForeignKey2UsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByUrlSlug?: Maybe<GroupOnCareerStatForFakePublicCareerStatsForeignKey2UsingGroupUrlSlugKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<CareerStatOnCareerStatForFakePublicCareerStatsForeignKey2NodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicCareerStatsForeignKey2GroupCreateInput>;
};

/** Input for the nested mutation of `careerStat` in the `GroupInput` mutation. */
export type FakePublicCareerStatsForeignKey2InverseInput = {
  /** A `CareerStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicCareerStatsForeignKey2CareerStatsCreateInput>>;
};

/** The `careerStatsQualifiedBatter` to be created by this mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey0CareerStatsQualifiedBattersCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2Input>;
};

/** Input for the nested mutation of `player` in the `CareerStatsQualifiedBatterInput` mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey0Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0UsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<CareerStatsQualifiedBatterOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0PlayerCreateInput>;
};

/** Input for the nested mutation of `careerStatsQualifiedBatter` in the `PlayerInput` mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput = {
  /** A `CareerStatsQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicCareerStatsQualifiedBattersForeignKey0CareerStatsQualifiedBattersCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `careerStatsQualifiedBatter` to be created by this mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey1CareerStatsQualifiedBattersCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2Input>;
};

/** Input for the nested mutation of `legacyPlayer` in the `CareerStatsQualifiedBatterInput` mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey1Input = {
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyPlayerNodeIdConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyPlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByPlayerId?: Maybe<LegacyPlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByNodeId?: Maybe<CareerStatsQualifiedBatterOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey1NodeIdUpdate>;
  /** A `LegacyPlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1LegacyPlayerCreateInput>;
};

/** Input for the nested mutation of `careerStatsQualifiedBatter` in the `LegacyPlayerInput` mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput = {
  /** A `CareerStatsQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicCareerStatsQualifiedBattersForeignKey1CareerStatsQualifiedBattersCreateInput>>;
};

/** The `legacyPlayer` to be created by this mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey1LegacyPlayerCreateInput = {
  playerId: Scalars['Int'];
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** The `careerStatsQualifiedBatter` to be created by this mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey2CareerStatsQualifiedBattersCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  seasons?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2Input>;
};

/** The `group` to be created by this mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey2GroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** Input for the nested mutation of `group` in the `CareerStatsQualifiedBatterInput` mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey2Input = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByUrlSlug?: Maybe<GroupGroupUrlSlugKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByUrlSlug?: Maybe<GroupGroupUrlSlugKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2UsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2UsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByUrlSlug?: Maybe<GroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2UsingGroupUrlSlugKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<CareerStatsQualifiedBatterOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2NodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2GroupCreateInput>;
};

/** Input for the nested mutation of `careerStatsQualifiedBatter` in the `GroupInput` mutation. */
export type FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput = {
  /** A `CareerStatsQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicCareerStatsQualifiedBattersForeignKey2CareerStatsQualifiedBattersCreateInput>>;
};

/** The `gameBattingLine` to be created by this mutation. */
export type FakePublicGameBattingLinesForeignKey0GameBattingLinesCreateInput = {
  gameId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  teamId?: Maybe<Scalars['UUID']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicGameBattingLinesForeignKey0Input>;
  game?: Maybe<FakePublicGameBattingLinesForeignKey1Input>;
};

/** Input for the nested mutation of `player` in the `GameBattingLineInput` mutation. */
export type FakePublicGameBattingLinesForeignKey0Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnGameBattingLineForFakePublicGameBattingLinesForeignKey0UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnGameBattingLineForFakePublicGameBattingLinesForeignKey0UsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameBattingLineOnGameBattingLineForFakePublicGameBattingLinesForeignKey0NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicGameBattingLinesForeignKey0PlayerCreateInput>;
};

/** Input for the nested mutation of `gameBattingLine` in the `PlayerInput` mutation. */
export type FakePublicGameBattingLinesForeignKey0InverseInput = {
  /** Flag indicating whether all other `gameBattingLine` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameBattingLine` for the far side of the relationship. */
  connectByPlayerIdAndGameId?: Maybe<Array<GameBattingLineFakePublicGameBattingLinesPrimaryKeyConnect>>;
  /** The primary key(s) for `gameBattingLine` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameBattingLineNodeIdConnect>>;
  /** The primary key(s) for `gameBattingLine` for the far side of the relationship. */
  deleteByPlayerIdAndGameId?: Maybe<Array<GameBattingLineFakePublicGameBattingLinesPrimaryKeyDelete>>;
  /** The primary key(s) for `gameBattingLine` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameBattingLineNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameBattingLine` for the far side of the relationship. */
  updateByPlayerIdAndGameId?: Maybe<Array<GameBattingLineOnGameBattingLineForFakePublicGameBattingLinesForeignKey0UsingFakePublicGameBattingLinesPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `gameBattingLine` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnGameBattingLineForFakePublicGameBattingLinesForeignKey0NodeIdUpdate>>;
  /** A `GameBattingLineInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicGameBattingLinesForeignKey0GameBattingLinesCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type FakePublicGameBattingLinesForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `gameBattingLine` to be created by this mutation. */
export type FakePublicGameBattingLinesForeignKey1GameBattingLinesCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  teamId?: Maybe<Scalars['UUID']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicGameBattingLinesForeignKey0Input>;
  game?: Maybe<FakePublicGameBattingLinesForeignKey1Input>;
};

/** The `game` to be created by this mutation. */
export type FakePublicGameBattingLinesForeignKey1GameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `GameBattingLineInput` mutation. */
export type FakePublicGameBattingLinesForeignKey1Input = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnGameBattingLineForFakePublicGameBattingLinesForeignKey1UsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnGameBattingLineForFakePublicGameBattingLinesForeignKey1UsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameBattingLineOnGameBattingLineForFakePublicGameBattingLinesForeignKey1NodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicGameBattingLinesForeignKey1GameCreateInput>;
};

/** Input for the nested mutation of `gameBattingLine` in the `GameInput` mutation. */
export type FakePublicGameBattingLinesForeignKey1InverseInput = {
  /** Flag indicating whether all other `gameBattingLine` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameBattingLine` for the far side of the relationship. */
  connectByPlayerIdAndGameId?: Maybe<Array<GameBattingLineFakePublicGameBattingLinesPrimaryKeyConnect>>;
  /** The primary key(s) for `gameBattingLine` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameBattingLineNodeIdConnect>>;
  /** The primary key(s) for `gameBattingLine` for the far side of the relationship. */
  deleteByPlayerIdAndGameId?: Maybe<Array<GameBattingLineFakePublicGameBattingLinesPrimaryKeyDelete>>;
  /** The primary key(s) for `gameBattingLine` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameBattingLineNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameBattingLine` for the far side of the relationship. */
  updateByPlayerIdAndGameId?: Maybe<Array<GameBattingLineOnGameBattingLineForFakePublicGameBattingLinesForeignKey1UsingFakePublicGameBattingLinesPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `gameBattingLine` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnGameBattingLineForFakePublicGameBattingLinesForeignKey1NodeIdUpdate>>;
  /** A `GameBattingLineInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicGameBattingLinesForeignKey1GameBattingLinesCreateInput>>;
};

/** Input for the nested mutation of `player` in the `LegacyGameBattingLineInput` mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey0Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey0UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey0UsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey0NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0PlayerCreateInput>;
};

/** Input for the nested mutation of `legacyGameBattingLine` in the `PlayerInput` mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey0InverseInput = {
  /** Flag indicating whether all other `legacyGameBattingLine` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  connectByLegacyPlayerIdAndLegacyGameId?: Maybe<Array<LegacyGameBattingLineFakePublicLegacyGameBattingLinesPrimaryKeyConnect>>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LegacyGameBattingLineNodeIdConnect>>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  deleteByLegacyPlayerIdAndLegacyGameId?: Maybe<Array<LegacyGameBattingLineFakePublicLegacyGameBattingLinesPrimaryKeyDelete>>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LegacyGameBattingLineNodeIdDelete>>;
  /** The primary key(s) and patch data for `legacyGameBattingLine` for the far side of the relationship. */
  updateByLegacyPlayerIdAndLegacyGameId?: Maybe<Array<LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey0UsingFakePublicLegacyGameBattingLinesPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `legacyGameBattingLine` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey0NodeIdUpdate>>;
  /** A `LegacyGameBattingLineInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicLegacyGameBattingLinesForeignKey0LegacyGameBattingLinesCreateInput>>;
};

/** The `legacyGameBattingLine` to be created by this mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey0LegacyGameBattingLinesCreateInput = {
  legacyPlayerId?: Maybe<Scalars['Int']>;
  legacyGameId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeamId?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1Input>;
  legacyGame?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2Input>;
  legacyStatLine?: Maybe<FakePublicLegacyGameBattingLinesForeignKey3Input>;
};

/** The `player` to be created by this mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** Input for the nested mutation of `legacyPlayer` in the `LegacyGameBattingLineInput` mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey1Input = {
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyPlayerNodeIdConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyPlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByPlayerId?: Maybe<LegacyPlayerOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey1NodeIdUpdate>;
  /** A `LegacyPlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1LegacyPlayerCreateInput>;
};

/** Input for the nested mutation of `legacyGameBattingLine` in the `LegacyPlayerInput` mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey1InverseInput = {
  /** Flag indicating whether all other `legacyGameBattingLine` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  connectByLegacyPlayerIdAndLegacyGameId?: Maybe<Array<LegacyGameBattingLineFakePublicLegacyGameBattingLinesPrimaryKeyConnect>>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LegacyGameBattingLineNodeIdConnect>>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  deleteByLegacyPlayerIdAndLegacyGameId?: Maybe<Array<LegacyGameBattingLineFakePublicLegacyGameBattingLinesPrimaryKeyDelete>>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LegacyGameBattingLineNodeIdDelete>>;
  /** The primary key(s) and patch data for `legacyGameBattingLine` for the far side of the relationship. */
  updateByLegacyPlayerIdAndLegacyGameId?: Maybe<Array<LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey1UsingFakePublicLegacyGameBattingLinesPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `legacyGameBattingLine` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LegacyPlayerOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey1NodeIdUpdate>>;
  /** A `LegacyGameBattingLineInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicLegacyGameBattingLinesForeignKey1LegacyGameBattingLinesCreateInput>>;
};

/** The `legacyGameBattingLine` to be created by this mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey1LegacyGameBattingLinesCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyGameId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeamId?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1Input>;
  legacyGame?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2Input>;
  legacyStatLine?: Maybe<FakePublicLegacyGameBattingLinesForeignKey3Input>;
};

/** The `legacyPlayer` to be created by this mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey1LegacyPlayerCreateInput = {
  playerId: Scalars['Int'];
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** Input for the nested mutation of `legacyGame` in the `LegacyGameBattingLineInput` mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey2Input = {
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  connectByGameId?: Maybe<LegacyGameFakePublicLegacyGamePrimaryKeyConnect>;
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyGameNodeIdConnect>;
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  deleteByGameId?: Maybe<LegacyGameFakePublicLegacyGamePrimaryKeyDelete>;
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyGameNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyGame` for the far side of the relationship. */
  updateByGameId?: Maybe<LegacyGameOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey2UsingFakePublicLegacyGamePrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyGame` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey2NodeIdUpdate>;
  /** A `LegacyGameInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2LegacyGameCreateInput>;
};

/** Input for the nested mutation of `legacyGameBattingLine` in the `LegacyGameInput` mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey2InverseInput = {
  /** Flag indicating whether all other `legacyGameBattingLine` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  connectByLegacyPlayerIdAndLegacyGameId?: Maybe<Array<LegacyGameBattingLineFakePublicLegacyGameBattingLinesPrimaryKeyConnect>>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LegacyGameBattingLineNodeIdConnect>>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  deleteByLegacyPlayerIdAndLegacyGameId?: Maybe<Array<LegacyGameBattingLineFakePublicLegacyGameBattingLinesPrimaryKeyDelete>>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LegacyGameBattingLineNodeIdDelete>>;
  /** The primary key(s) and patch data for `legacyGameBattingLine` for the far side of the relationship. */
  updateByLegacyPlayerIdAndLegacyGameId?: Maybe<Array<LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey2UsingFakePublicLegacyGameBattingLinesPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `legacyGameBattingLine` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LegacyGameOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey2NodeIdUpdate>>;
  /** A `LegacyGameBattingLineInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicLegacyGameBattingLinesForeignKey2LegacyGameBattingLinesCreateInput>>;
};

/** The `legacyGameBattingLine` to be created by this mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey2LegacyGameBattingLinesCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeamId?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1Input>;
  legacyGame?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2Input>;
  legacyStatLine?: Maybe<FakePublicLegacyGameBattingLinesForeignKey3Input>;
};

/** The `legacyGame` to be created by this mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey2LegacyGameCreateInput = {
  gameId: Scalars['Int'];
  gameTitle?: Maybe<Scalars['String']>;
  gameDate?: Maybe<Scalars['Date']>;
  gameStartTime?: Maybe<Scalars['Time']>;
  gameEndTime?: Maybe<Scalars['Time']>;
  gameTeamId1?: Maybe<Scalars['Int']>;
  gameTeamId2?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeam?: Maybe<FakePublicLegacyGameForeignKey1Input>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey2InverseInput>;
};

/** Input for the nested mutation of `legacyStatLine` in the `LegacyGameBattingLineInput` mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey3Input = {
  /** The primary key(s) for `legacyStatLine` for the far side of the relationship. */
  connectByPlayerIdAndGameIdAndSbStatsTeam?: Maybe<LegacyStatLineFakePublicLegacyStatLinePrimaryKeyConnect>;
  /** The primary key(s) for `legacyStatLine` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyStatLineNodeIdConnect>;
  /** The primary key(s) for `legacyStatLine` for the far side of the relationship. */
  deleteByPlayerIdAndGameIdAndSbStatsTeam?: Maybe<LegacyStatLineFakePublicLegacyStatLinePrimaryKeyDelete>;
  /** The primary key(s) for `legacyStatLine` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyStatLineNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyStatLine` for the far side of the relationship. */
  updateByPlayerIdAndGameIdAndSbStatsTeam?: Maybe<LegacyStatLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey3UsingFakePublicLegacyStatLinePrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyStatLine` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey3NodeIdUpdate>;
  /** A `LegacyStatLineInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicLegacyGameBattingLinesForeignKey3LegacyStatLineCreateInput>;
};

/** Input for the nested mutation of `legacyGameBattingLine` in the `LegacyStatLineInput` mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey3InverseInput = {
  /** Flag indicating whether all other `legacyGameBattingLine` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  connectByLegacyPlayerIdAndLegacyGameId?: Maybe<Array<LegacyGameBattingLineFakePublicLegacyGameBattingLinesPrimaryKeyConnect>>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LegacyGameBattingLineNodeIdConnect>>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  deleteByLegacyPlayerIdAndLegacyGameId?: Maybe<Array<LegacyGameBattingLineFakePublicLegacyGameBattingLinesPrimaryKeyDelete>>;
  /** The primary key(s) for `legacyGameBattingLine` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LegacyGameBattingLineNodeIdDelete>>;
  /** The primary key(s) and patch data for `legacyGameBattingLine` for the far side of the relationship. */
  updateByLegacyPlayerIdAndLegacyGameId?: Maybe<Array<LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey3UsingFakePublicLegacyGameBattingLinesPrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `legacyGameBattingLine` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LegacyStatLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey3NodeIdUpdate>>;
  /** A `LegacyGameBattingLineInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicLegacyGameBattingLinesForeignKey3LegacyGameBattingLinesCreateInput>>;
};

/** The `legacyGameBattingLine` to be created by this mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey3LegacyGameBattingLinesCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1Input>;
  legacyGame?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2Input>;
  legacyStatLine?: Maybe<FakePublicLegacyGameBattingLinesForeignKey3Input>;
};

/** The `legacyStatLine` to be created by this mutation. */
export type FakePublicLegacyGameBattingLinesForeignKey3LegacyStatLineCreateInput = {
  sbStatsId?: Maybe<Scalars['Int']>;
  playerId: Scalars['Int'];
  gameId: Scalars['Int'];
  sbStatsTeam: Scalars['Int'];
  sbStatsAb?: Maybe<Scalars['Int']>;
  sbStatsRuns?: Maybe<Scalars['Int']>;
  sbStatsHits?: Maybe<Scalars['Int']>;
  sbStats1B?: Maybe<Scalars['Int']>;
  sbStats2B?: Maybe<Scalars['Int']>;
  sbStats3B?: Maybe<Scalars['Int']>;
  sbStatsHr?: Maybe<Scalars['Int']>;
  sbStatsRbi?: Maybe<Scalars['Int']>;
  sbStatsBb?: Maybe<Scalars['Int']>;
  sbStatsSo?: Maybe<Scalars['Int']>;
  sbStatsSac?: Maybe<Scalars['Int']>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey3InverseInput>;
};

/** Input for the nested mutation of `legacyGame` in the `LegacyTeamInput` mutation. */
export type FakePublicLegacyGameForeignKey0InverseInput = {
  /** Flag indicating whether all other `legacyGame` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  connectByGameId?: Maybe<Array<LegacyGameFakePublicLegacyGamePrimaryKeyConnect>>;
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LegacyGameNodeIdConnect>>;
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  deleteByGameId?: Maybe<Array<LegacyGameFakePublicLegacyGamePrimaryKeyDelete>>;
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LegacyGameNodeIdDelete>>;
  /** The primary key(s) and patch data for `legacyGame` for the far side of the relationship. */
  updateByGameId?: Maybe<Array<LegacyGameOnLegacyGameForFakePublicLegacyGameForeignKey0UsingFakePublicLegacyGamePrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `legacyGame` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LegacyTeamOnLegacyGameForFakePublicLegacyGameForeignKey0NodeIdUpdate>>;
  /** A `LegacyGameInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicLegacyGameForeignKey0LegacyGameCreateInput>>;
};

/** The `legacyGame` to be created by this mutation. */
export type FakePublicLegacyGameForeignKey0LegacyGameCreateInput = {
  gameId: Scalars['Int'];
  gameTitle?: Maybe<Scalars['String']>;
  gameDate?: Maybe<Scalars['Date']>;
  gameStartTime?: Maybe<Scalars['Time']>;
  gameEndTime?: Maybe<Scalars['Time']>;
  gameTeamId2?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeam?: Maybe<FakePublicLegacyGameForeignKey1Input>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey2InverseInput>;
};

/** Input for the nested mutation of `legacyTeam` in the `LegacyGameInput` mutation. */
export type FakePublicLegacyGameForeignKey1Input = {
  /** The primary key(s) for `legacyTeam` for the far side of the relationship. */
  connectByTeamId?: Maybe<LegacyTeamFakePublicLegacyTeamPrimaryKeyConnect>;
  /** The primary key(s) for `legacyTeam` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyTeamNodeIdConnect>;
  /** The primary key(s) for `legacyTeam` for the far side of the relationship. */
  deleteByTeamId?: Maybe<LegacyTeamFakePublicLegacyTeamPrimaryKeyDelete>;
  /** The primary key(s) for `legacyTeam` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyTeamNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyTeam` for the far side of the relationship. */
  updateByTeamId?: Maybe<LegacyTeamOnLegacyGameForFakePublicLegacyGameForeignKey1UsingFakePublicLegacyTeamPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyTeam` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacyGameOnLegacyGameForFakePublicLegacyGameForeignKey1NodeIdUpdate>;
  /** A `LegacyTeamInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicLegacyGameForeignKey1LegacyTeamCreateInput>;
};

/** Input for the nested mutation of `legacyGame` in the `LegacyTeamInput` mutation. */
export type FakePublicLegacyGameForeignKey1InverseInput = {
  /** Flag indicating whether all other `legacyGame` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  connectByGameId?: Maybe<Array<LegacyGameFakePublicLegacyGamePrimaryKeyConnect>>;
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LegacyGameNodeIdConnect>>;
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  deleteByGameId?: Maybe<Array<LegacyGameFakePublicLegacyGamePrimaryKeyDelete>>;
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LegacyGameNodeIdDelete>>;
  /** The primary key(s) and patch data for `legacyGame` for the far side of the relationship. */
  updateByGameId?: Maybe<Array<LegacyGameOnLegacyGameForFakePublicLegacyGameForeignKey1UsingFakePublicLegacyGamePrimaryKeyUpdate>>;
  /** The primary key(s) and patch data for `legacyGame` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LegacyTeamOnLegacyGameForFakePublicLegacyGameForeignKey1NodeIdUpdate>>;
  /** A `LegacyGameInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicLegacyGameForeignKey1LegacyGameCreateInput>>;
};

/** The `legacyGame` to be created by this mutation. */
export type FakePublicLegacyGameForeignKey1LegacyGameCreateInput = {
  gameId: Scalars['Int'];
  gameTitle?: Maybe<Scalars['String']>;
  gameDate?: Maybe<Scalars['Date']>;
  gameStartTime?: Maybe<Scalars['Time']>;
  gameEndTime?: Maybe<Scalars['Time']>;
  gameTeamId1?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeam?: Maybe<FakePublicLegacyGameForeignKey1Input>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey2InverseInput>;
};

/** The `legacyTeam` to be created by this mutation. */
export type FakePublicLegacyGameForeignKey1LegacyTeamCreateInput = {
  teamId: Scalars['Int'];
  teamName?: Maybe<Scalars['String']>;
  legacyGamesToGameTeamId1UsingTeamId?: Maybe<FakePublicLegacyGameForeignKey0InverseInput>;
  legacyGamesToGameTeamId2UsingTeamId?: Maybe<FakePublicLegacyGameForeignKey1InverseInput>;
};

/** Input for the nested mutation of `player` in the `LegacySeasonStatInput` mutation. */
export type FakePublicLegacySeasonStatsForeignKey0Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0UsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacySeasonStatOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicLegacySeasonStatsForeignKey0PlayerCreateInput>;
};

/** Input for the nested mutation of `legacySeasonStat` in the `PlayerInput` mutation. */
export type FakePublicLegacySeasonStatsForeignKey0InverseInput = {
  /** A `LegacySeasonStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicLegacySeasonStatsForeignKey0LegacySeasonStatsCreateInput>>;
};

/** The `legacySeasonStat` to be created by this mutation. */
export type FakePublicLegacySeasonStatsForeignKey0LegacySeasonStatsCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicLegacySeasonStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicLegacySeasonStatsForeignKey1Input>;
  group?: Maybe<FakePublicLegacySeasonStatsForeignKey2Input>;
};

/** The `player` to be created by this mutation. */
export type FakePublicLegacySeasonStatsForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** Input for the nested mutation of `legacyPlayer` in the `LegacySeasonStatInput` mutation. */
export type FakePublicLegacySeasonStatsForeignKey1Input = {
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyPlayerNodeIdConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyPlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByPlayerId?: Maybe<LegacyPlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacySeasonStatOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey1NodeIdUpdate>;
  /** A `LegacyPlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicLegacySeasonStatsForeignKey1LegacyPlayerCreateInput>;
};

/** Input for the nested mutation of `legacySeasonStat` in the `LegacyPlayerInput` mutation. */
export type FakePublicLegacySeasonStatsForeignKey1InverseInput = {
  /** A `LegacySeasonStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicLegacySeasonStatsForeignKey1LegacySeasonStatsCreateInput>>;
};

/** The `legacyPlayer` to be created by this mutation. */
export type FakePublicLegacySeasonStatsForeignKey1LegacyPlayerCreateInput = {
  playerId: Scalars['Int'];
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** The `legacySeasonStat` to be created by this mutation. */
export type FakePublicLegacySeasonStatsForeignKey1LegacySeasonStatsCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicLegacySeasonStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicLegacySeasonStatsForeignKey1Input>;
  group?: Maybe<FakePublicLegacySeasonStatsForeignKey2Input>;
};

/** The `group` to be created by this mutation. */
export type FakePublicLegacySeasonStatsForeignKey2GroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** Input for the nested mutation of `group` in the `LegacySeasonStatInput` mutation. */
export type FakePublicLegacySeasonStatsForeignKey2Input = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByUrlSlug?: Maybe<GroupGroupUrlSlugKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByUrlSlug?: Maybe<GroupGroupUrlSlugKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2UsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2UsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByUrlSlug?: Maybe<GroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2UsingGroupUrlSlugKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacySeasonStatOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2NodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicLegacySeasonStatsForeignKey2GroupCreateInput>;
};

/** Input for the nested mutation of `legacySeasonStat` in the `GroupInput` mutation. */
export type FakePublicLegacySeasonStatsForeignKey2InverseInput = {
  /** A `LegacySeasonStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicLegacySeasonStatsForeignKey2LegacySeasonStatsCreateInput>>;
};

/** The `legacySeasonStat` to be created by this mutation. */
export type FakePublicLegacySeasonStatsForeignKey2LegacySeasonStatsCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicLegacySeasonStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicLegacySeasonStatsForeignKey1Input>;
  group?: Maybe<FakePublicLegacySeasonStatsForeignKey2Input>;
};

/** Input for the nested mutation of `legacyPlayer` in the `PlayerInput` mutation. */
export type FakePublicPlayerForeignKey0Input = {
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyPlayerNodeIdConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyPlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByPlayerId?: Maybe<LegacyPlayerOnPlayerForFakePublicPlayerForeignKey0UsingFakePublicLegacyPlayerPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByNodeId?: Maybe<PlayerOnPlayerForFakePublicPlayerForeignKey0NodeIdUpdate>;
  /** A `LegacyPlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicPlayerForeignKey0LegacyPlayerCreateInput>;
};

/** Input for the nested mutation of `player` in the `LegacyPlayerInput` mutation. */
export type FakePublicPlayerForeignKey0InverseInput = {
  /** Flag indicating whether all other `player` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<Array<PlayerPlayerPkeyConnect>>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<Array<PlayerPlayerNameUniqueConnect>>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PlayerNodeIdConnect>>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<Array<PlayerPlayerPkeyDelete>>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<Array<PlayerPlayerNameUniqueDelete>>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PlayerNodeIdDelete>>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<Array<PlayerOnPlayerForFakePublicPlayerForeignKey0UsingPlayerPkeyUpdate>>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<Array<PlayerOnPlayerForFakePublicPlayerForeignKey0UsingPlayerNameUniqueUpdate>>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LegacyPlayerOnPlayerForFakePublicPlayerForeignKey0NodeIdUpdate>>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicPlayerForeignKey0PlayerCreateInput>>;
};

/** The `legacyPlayer` to be created by this mutation. */
export type FakePublicPlayerForeignKey0LegacyPlayerCreateInput = {
  playerId: Scalars['Int'];
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** The `player` to be created by this mutation. */
export type FakePublicPlayerForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** Input for the nested mutation of `player` in the `SeasonStatsAllTimeQualifiedBatterInput` mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0UsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatsAllTimeQualifiedBatterOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0PlayerCreateInput>;
};

/** Input for the nested mutation of `seasonStatsAllTimeQualifiedBatter` in the `PlayerInput` mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput = {
  /** A `SeasonStatsAllTimeQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0SeasonStatsAllTimeQualifiedBattersCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `seasonStatsAllTimeQualifiedBatter` to be created by this mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0SeasonStatsAllTimeQualifiedBattersCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2Input>;
};

/** Input for the nested mutation of `legacyPlayer` in the `SeasonStatsAllTimeQualifiedBatterInput` mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1Input = {
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyPlayerNodeIdConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyPlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByPlayerId?: Maybe<LegacyPlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatsAllTimeQualifiedBatterOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1NodeIdUpdate>;
  /** A `LegacyPlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1LegacyPlayerCreateInput>;
};

/** Input for the nested mutation of `seasonStatsAllTimeQualifiedBatter` in the `LegacyPlayerInput` mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput = {
  /** A `SeasonStatsAllTimeQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1SeasonStatsAllTimeQualifiedBattersCreateInput>>;
};

/** The `legacyPlayer` to be created by this mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1LegacyPlayerCreateInput = {
  playerId: Scalars['Int'];
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** The `seasonStatsAllTimeQualifiedBatter` to be created by this mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1SeasonStatsAllTimeQualifiedBattersCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2Input>;
};

/** The `group` to be created by this mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2GroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** Input for the nested mutation of `group` in the `SeasonStatsAllTimeQualifiedBatterInput` mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2Input = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByUrlSlug?: Maybe<GroupGroupUrlSlugKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByUrlSlug?: Maybe<GroupGroupUrlSlugKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2UsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2UsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByUrlSlug?: Maybe<GroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2UsingGroupUrlSlugKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatsAllTimeQualifiedBatterOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2NodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2GroupCreateInput>;
};

/** Input for the nested mutation of `seasonStatsAllTimeQualifiedBatter` in the `GroupInput` mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput = {
  /** A `SeasonStatsAllTimeQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2SeasonStatsAllTimeQualifiedBattersCreateInput>>;
};

/** The `seasonStatsAllTimeQualifiedBatter` to be created by this mutation. */
export type FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2SeasonStatsAllTimeQualifiedBattersCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2Input>;
};

/** Input for the nested mutation of `player` in the `SeasonStatInput` mutation. */
export type FakePublicSeasonStatsForeignKey0Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnSeasonStatForFakePublicSeasonStatsForeignKey0UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnSeasonStatForFakePublicSeasonStatsForeignKey0UsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatOnSeasonStatForFakePublicSeasonStatsForeignKey0NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsForeignKey0PlayerCreateInput>;
};

/** Input for the nested mutation of `seasonStat` in the `PlayerInput` mutation. */
export type FakePublicSeasonStatsForeignKey0InverseInput = {
  /** A `SeasonStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsForeignKey0SeasonStatsCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type FakePublicSeasonStatsForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `seasonStat` to be created by this mutation. */
export type FakePublicSeasonStatsForeignKey0SeasonStatsCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsForeignKey2Input>;
};

/** Input for the nested mutation of `legacyPlayer` in the `SeasonStatInput` mutation. */
export type FakePublicSeasonStatsForeignKey1Input = {
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyPlayerNodeIdConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyPlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByPlayerId?: Maybe<LegacyPlayerOnSeasonStatForFakePublicSeasonStatsForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatOnSeasonStatForFakePublicSeasonStatsForeignKey1NodeIdUpdate>;
  /** A `LegacyPlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsForeignKey1LegacyPlayerCreateInput>;
};

/** Input for the nested mutation of `seasonStat` in the `LegacyPlayerInput` mutation. */
export type FakePublicSeasonStatsForeignKey1InverseInput = {
  /** A `SeasonStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsForeignKey1SeasonStatsCreateInput>>;
};

/** The `legacyPlayer` to be created by this mutation. */
export type FakePublicSeasonStatsForeignKey1LegacyPlayerCreateInput = {
  playerId: Scalars['Int'];
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** The `seasonStat` to be created by this mutation. */
export type FakePublicSeasonStatsForeignKey1SeasonStatsCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsForeignKey2Input>;
};

/** The `group` to be created by this mutation. */
export type FakePublicSeasonStatsForeignKey2GroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** Input for the nested mutation of `group` in the `SeasonStatInput` mutation. */
export type FakePublicSeasonStatsForeignKey2Input = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByUrlSlug?: Maybe<GroupGroupUrlSlugKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByUrlSlug?: Maybe<GroupGroupUrlSlugKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnSeasonStatForFakePublicSeasonStatsForeignKey2UsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnSeasonStatForFakePublicSeasonStatsForeignKey2UsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByUrlSlug?: Maybe<GroupOnSeasonStatForFakePublicSeasonStatsForeignKey2UsingGroupUrlSlugKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatOnSeasonStatForFakePublicSeasonStatsForeignKey2NodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsForeignKey2GroupCreateInput>;
};

/** Input for the nested mutation of `seasonStat` in the `GroupInput` mutation. */
export type FakePublicSeasonStatsForeignKey2InverseInput = {
  /** A `SeasonStatInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsForeignKey2SeasonStatsCreateInput>>;
};

/** The `seasonStat` to be created by this mutation. */
export type FakePublicSeasonStatsForeignKey2SeasonStatsCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsForeignKey2Input>;
};

/** Input for the nested mutation of `player` in the `SeasonStatsQualifiedBatterInput` mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey0Input = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0UsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0UsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatsQualifiedBatterOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0NodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0PlayerCreateInput>;
};

/** Input for the nested mutation of `seasonStatsQualifiedBatter` in the `PlayerInput` mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput = {
  /** A `SeasonStatsQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsQualifiedBattersForeignKey0SeasonStatsQualifiedBattersCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey0PlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `seasonStatsQualifiedBatter` to be created by this mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey0SeasonStatsQualifiedBattersCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2Input>;
};

/** Input for the nested mutation of `legacyPlayer` in the `SeasonStatsQualifiedBatterInput` mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey1Input = {
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyPlayerNodeIdConnect>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByPlayerId?: Maybe<LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete>;
  /** The primary key(s) for `legacyPlayer` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyPlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByPlayerId?: Maybe<LegacyPlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatsQualifiedBatterOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey1NodeIdUpdate>;
  /** A `LegacyPlayerInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1LegacyPlayerCreateInput>;
};

/** Input for the nested mutation of `seasonStatsQualifiedBatter` in the `LegacyPlayerInput` mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput = {
  /** A `SeasonStatsQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsQualifiedBattersForeignKey1SeasonStatsQualifiedBattersCreateInput>>;
};

/** The `legacyPlayer` to be created by this mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey1LegacyPlayerCreateInput = {
  playerId: Scalars['Int'];
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** The `seasonStatsQualifiedBatter` to be created by this mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey1SeasonStatsQualifiedBattersCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2Input>;
};

/** The `group` to be created by this mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey2GroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** Input for the nested mutation of `group` in the `SeasonStatsQualifiedBatterInput` mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey2Input = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByUrlSlug?: Maybe<GroupGroupUrlSlugKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByUrlSlug?: Maybe<GroupGroupUrlSlugKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2UsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2UsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByUrlSlug?: Maybe<GroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2UsingGroupUrlSlugKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<SeasonStatsQualifiedBatterOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2NodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2GroupCreateInput>;
};

/** Input for the nested mutation of `seasonStatsQualifiedBatter` in the `GroupInput` mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput = {
  /** A `SeasonStatsQualifiedBatterInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicSeasonStatsQualifiedBattersForeignKey2SeasonStatsQualifiedBattersCreateInput>>;
};

/** The `seasonStatsQualifiedBatter` to be created by this mutation. */
export type FakePublicSeasonStatsQualifiedBattersForeignKey2SeasonStatsQualifiedBattersCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  games?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1Input>;
  group?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2Input>;
};

/** The `group` to be created by this mutation. */
export type FakePublicUnifiedGamesForeignKey0GroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** Input for the nested mutation of `group` in the `UnifiedGameInput` mutation. */
export type FakePublicUnifiedGamesForeignKey0Input = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByUrlSlug?: Maybe<GroupGroupUrlSlugKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByUrlSlug?: Maybe<GroupGroupUrlSlugKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnUnifiedGameForFakePublicUnifiedGamesForeignKey0UsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnUnifiedGameForFakePublicUnifiedGamesForeignKey0UsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByUrlSlug?: Maybe<GroupOnUnifiedGameForFakePublicUnifiedGamesForeignKey0UsingGroupUrlSlugKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<UnifiedGameOnUnifiedGameForFakePublicUnifiedGamesForeignKey0NodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicUnifiedGamesForeignKey0GroupCreateInput>;
};

/** Input for the nested mutation of `unifiedGame` in the `GroupInput` mutation. */
export type FakePublicUnifiedGamesForeignKey0InverseInput = {
  /** A `UnifiedGameInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicUnifiedGamesForeignKey0UnifiedGamesCreateInput>>;
};

/** The `unifiedGame` to be created by this mutation. */
export type FakePublicUnifiedGamesForeignKey0UnifiedGamesCreateInput = {
  gameId?: Maybe<Scalars['UUID']>;
  legacyGameId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  group?: Maybe<FakePublicUnifiedGamesForeignKey0Input>;
  game?: Maybe<FakePublicUnifiedGamesForeignKey1Input>;
  legacyGame?: Maybe<FakePublicUnifiedGamesForeignKey2Input>;
};

/** The `game` to be created by this mutation. */
export type FakePublicUnifiedGamesForeignKey1GameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `UnifiedGameInput` mutation. */
export type FakePublicUnifiedGamesForeignKey1Input = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnUnifiedGameForFakePublicUnifiedGamesForeignKey1UsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnUnifiedGameForFakePublicUnifiedGamesForeignKey1UsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<UnifiedGameOnUnifiedGameForFakePublicUnifiedGamesForeignKey1NodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicUnifiedGamesForeignKey1GameCreateInput>;
};

/** Input for the nested mutation of `unifiedGame` in the `GameInput` mutation. */
export type FakePublicUnifiedGamesForeignKey1InverseInput = {
  /** A `UnifiedGameInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicUnifiedGamesForeignKey1UnifiedGamesCreateInput>>;
};

/** The `unifiedGame` to be created by this mutation. */
export type FakePublicUnifiedGamesForeignKey1UnifiedGamesCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  legacyGameId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  group?: Maybe<FakePublicUnifiedGamesForeignKey0Input>;
  game?: Maybe<FakePublicUnifiedGamesForeignKey1Input>;
  legacyGame?: Maybe<FakePublicUnifiedGamesForeignKey2Input>;
};

/** Input for the nested mutation of `legacyGame` in the `UnifiedGameInput` mutation. */
export type FakePublicUnifiedGamesForeignKey2Input = {
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  connectByGameId?: Maybe<LegacyGameFakePublicLegacyGamePrimaryKeyConnect>;
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyGameNodeIdConnect>;
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  deleteByGameId?: Maybe<LegacyGameFakePublicLegacyGamePrimaryKeyDelete>;
  /** The primary key(s) for `legacyGame` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyGameNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyGame` for the far side of the relationship. */
  updateByGameId?: Maybe<LegacyGameOnUnifiedGameForFakePublicUnifiedGamesForeignKey2UsingFakePublicLegacyGamePrimaryKeyUpdate>;
  /** The primary key(s) and patch data for `legacyGame` for the far side of the relationship. */
  updateByNodeId?: Maybe<UnifiedGameOnUnifiedGameForFakePublicUnifiedGamesForeignKey2NodeIdUpdate>;
  /** A `LegacyGameInput` object that will be created and connected to this object. */
  create?: Maybe<FakePublicUnifiedGamesForeignKey2LegacyGameCreateInput>;
};

/** Input for the nested mutation of `unifiedGame` in the `LegacyGameInput` mutation. */
export type FakePublicUnifiedGamesForeignKey2InverseInput = {
  /** A `UnifiedGameInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FakePublicUnifiedGamesForeignKey2UnifiedGamesCreateInput>>;
};

/** The `legacyGame` to be created by this mutation. */
export type FakePublicUnifiedGamesForeignKey2LegacyGameCreateInput = {
  gameId: Scalars['Int'];
  gameTitle?: Maybe<Scalars['String']>;
  gameDate?: Maybe<Scalars['Date']>;
  gameStartTime?: Maybe<Scalars['Time']>;
  gameEndTime?: Maybe<Scalars['Time']>;
  gameTeamId1?: Maybe<Scalars['Int']>;
  gameTeamId2?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeam?: Maybe<FakePublicLegacyGameForeignKey1Input>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey2InverseInput>;
};

/** The `unifiedGame` to be created by this mutation. */
export type FakePublicUnifiedGamesForeignKey2UnifiedGamesCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  group?: Maybe<FakePublicUnifiedGamesForeignKey0Input>;
  game?: Maybe<FakePublicUnifiedGamesForeignKey1Input>;
  legacyGame?: Maybe<FakePublicUnifiedGamesForeignKey2Input>;
};

export type Field = Node & {
  __typename?: 'Field';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  name: Scalars['String'];
  notes: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `Game`. */
  games: Array<Game>;
};


export type FieldGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GamesOrderBy>>;
  condition?: Maybe<GameCondition>;
};

/** A condition to be used against `Field` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FieldCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
};

/** The fields on `field` to look up the row to connect. */
export type FieldFieldPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `field` to look up the row to delete. */
export type FieldFieldPkeyDelete = {
  id: Scalars['UUID'];
};

/** An input for mutations affecting `Field` */
export type FieldInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  games?: Maybe<GameFieldIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type FieldNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `field` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type FieldNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `field` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type FieldOnGameForGameFieldIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `field` to look up the row to update. */
export type FieldOnGameForGameFieldIdFkeyUsingFieldPkeyUpdate = {
  /** An object where the defined keys will be set on the `field` being updated. */
  patch: UpdateFieldOnGameForGameFieldIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Field`. Fields that are set will be updated. */
export type FieldPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  games?: Maybe<GameFieldIdFkeyInverseInput>;
};

export enum FieldingPosition {
  PITCHER = 'PITCHER',
  CATCHER = 'CATCHER',
  FIRST_BASE = 'FIRST_BASE',
  SECOND_BASE = 'SECOND_BASE',
  THIRD_BASE = 'THIRD_BASE',
  SHORTSTOP = 'SHORTSTOP',
  LEFT_FIELD = 'LEFT_FIELD',
  CENTER_FIELD = 'CENTER_FIELD',
  LEFT_CENTER = 'LEFT_CENTER',
  RIGHT_CENTER = 'RIGHT_CENTER',
  RIGHT_FIELD = 'RIGHT_FIELD',
  MIDDLE_INFIELD = 'MIDDLE_INFIELD'
}

/** Methods to use when ordering `Field`. */
export enum FieldsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  NOTES_ASC = 'NOTES_ASC',
  NOTES_DESC = 'NOTES_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type ForeignDbField = {
  __typename?: 'ForeignDbField';
  fieldId: Scalars['Int'];
  fieldName: Scalars['String'];
  fieldAddress: Scalars['String'];
  fieldNumber: Maybe<Scalars['String']>;
  fieldRating: Maybe<Scalars['Int']>;
};

/**
 * A condition to be used against `ForeignDbField` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ForeignDbFieldCondition = {
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `fieldName` field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fieldAddress` field. */
  fieldAddress?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fieldNumber` field. */
  fieldNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fieldRating` field. */
  fieldRating?: Maybe<Scalars['Int']>;
};

/** An input for mutations affecting `ForeignDbField` */
export type ForeignDbFieldInput = {
  fieldId: Scalars['Int'];
  fieldName: Scalars['String'];
  fieldAddress: Scalars['String'];
  fieldNumber?: Maybe<Scalars['String']>;
  fieldRating?: Maybe<Scalars['Int']>;
};

/** Methods to use when ordering `ForeignDbField`. */
export enum ForeignDbFieldsOrderBy {
  NATURAL = 'NATURAL',
  FIELD_ID_ASC = 'FIELD_ID_ASC',
  FIELD_ID_DESC = 'FIELD_ID_DESC',
  FIELD_NAME_ASC = 'FIELD_NAME_ASC',
  FIELD_NAME_DESC = 'FIELD_NAME_DESC',
  FIELD_ADDRESS_ASC = 'FIELD_ADDRESS_ASC',
  FIELD_ADDRESS_DESC = 'FIELD_ADDRESS_DESC',
  FIELD_NUMBER_ASC = 'FIELD_NUMBER_ASC',
  FIELD_NUMBER_DESC = 'FIELD_NUMBER_DESC',
  FIELD_RATING_ASC = 'FIELD_RATING_ASC',
  FIELD_RATING_DESC = 'FIELD_RATING_DESC'
}

export type ForeignDbGame = {
  __typename?: 'ForeignDbGame';
  gameId: Scalars['Int'];
  gameTitle: Scalars['String'];
  gameDate: Scalars['Date'];
  gameStartTime: Scalars['Time'];
  gameEndTime: Scalars['Time'];
  gameTeamId1: Scalars['Int'];
  gameTeamId2: Scalars['Int'];
  season: Scalars['Int'];
  fieldId: Maybe<Scalars['Int']>;
  gamePicGallery: Maybe<Scalars['String']>;
  eventId: Maybe<Scalars['String']>;
  gameDateInsert: Maybe<Scalars['Date']>;
  gameDateUpdate: Maybe<Scalars['Date']>;
  gameAdv: Maybe<Scalars['Int']>;
  gameCnt: Maybe<Scalars['Int']>;
};

/**
 * A condition to be used against `ForeignDbGame` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ForeignDbGameCondition = {
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameTitle` field. */
  gameTitle?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `gameDate` field. */
  gameDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `gameStartTime` field. */
  gameStartTime?: Maybe<Scalars['Time']>;
  /** Checks for equality with the object’s `gameEndTime` field. */
  gameEndTime?: Maybe<Scalars['Time']>;
  /** Checks for equality with the object’s `gameTeamId1` field. */
  gameTeamId1?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameTeamId2` field. */
  gameTeamId2?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gamePicGallery` field. */
  gamePicGallery?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `eventId` field. */
  eventId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `gameDateInsert` field. */
  gameDateInsert?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `gameDateUpdate` field. */
  gameDateUpdate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `gameAdv` field. */
  gameAdv?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameCnt` field. */
  gameCnt?: Maybe<Scalars['Int']>;
};

/** An input for mutations affecting `ForeignDbGame` */
export type ForeignDbGameInput = {
  gameId: Scalars['Int'];
  gameTitle: Scalars['String'];
  gameDate: Scalars['Date'];
  gameStartTime: Scalars['Time'];
  gameEndTime: Scalars['Time'];
  gameTeamId1: Scalars['Int'];
  gameTeamId2: Scalars['Int'];
  season: Scalars['Int'];
  fieldId?: Maybe<Scalars['Int']>;
  gamePicGallery?: Maybe<Scalars['String']>;
  eventId?: Maybe<Scalars['String']>;
  gameDateInsert?: Maybe<Scalars['Date']>;
  gameDateUpdate?: Maybe<Scalars['Date']>;
  gameAdv?: Maybe<Scalars['Int']>;
  gameCnt?: Maybe<Scalars['Int']>;
};

/** Methods to use when ordering `ForeignDbGame`. */
export enum ForeignDbGamesOrderBy {
  NATURAL = 'NATURAL',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  GAME_TITLE_ASC = 'GAME_TITLE_ASC',
  GAME_TITLE_DESC = 'GAME_TITLE_DESC',
  GAME_DATE_ASC = 'GAME_DATE_ASC',
  GAME_DATE_DESC = 'GAME_DATE_DESC',
  GAME_START_TIME_ASC = 'GAME_START_TIME_ASC',
  GAME_START_TIME_DESC = 'GAME_START_TIME_DESC',
  GAME_END_TIME_ASC = 'GAME_END_TIME_ASC',
  GAME_END_TIME_DESC = 'GAME_END_TIME_DESC',
  GAME_TEAM_ID_1_ASC = 'GAME_TEAM_ID_1_ASC',
  GAME_TEAM_ID_1_DESC = 'GAME_TEAM_ID_1_DESC',
  GAME_TEAM_ID_2_ASC = 'GAME_TEAM_ID_2_ASC',
  GAME_TEAM_ID_2_DESC = 'GAME_TEAM_ID_2_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  FIELD_ID_ASC = 'FIELD_ID_ASC',
  FIELD_ID_DESC = 'FIELD_ID_DESC',
  GAME_PIC_GALLERY_ASC = 'GAME_PIC_GALLERY_ASC',
  GAME_PIC_GALLERY_DESC = 'GAME_PIC_GALLERY_DESC',
  EVENT_ID_ASC = 'EVENT_ID_ASC',
  EVENT_ID_DESC = 'EVENT_ID_DESC',
  GAME_DATE_INSERT_ASC = 'GAME_DATE_INSERT_ASC',
  GAME_DATE_INSERT_DESC = 'GAME_DATE_INSERT_DESC',
  GAME_DATE_UPDATE_ASC = 'GAME_DATE_UPDATE_ASC',
  GAME_DATE_UPDATE_DESC = 'GAME_DATE_UPDATE_DESC',
  GAME_ADV_ASC = 'GAME_ADV_ASC',
  GAME_ADV_DESC = 'GAME_ADV_DESC',
  GAME_CNT_ASC = 'GAME_CNT_ASC',
  GAME_CNT_DESC = 'GAME_CNT_DESC'
}

export type ForeignDbPlayer = {
  __typename?: 'ForeignDbPlayer';
  playerId: Scalars['Int'];
  playerName: Scalars['String'];
  playerImage: Maybe<Scalars['String']>;
  memberId: Maybe<Scalars['String']>;
  playerNickname: Maybe<Scalars['String']>;
  playerSelfNickname: Maybe<Scalars['String']>;
  playerGender: Maybe<Scalars['Int']>;
  playerBats: Maybe<Scalars['Int']>;
  playerThrows: Maybe<Scalars['Int']>;
  playerPosition1: Maybe<Scalars['Int']>;
  playerPosition2: Maybe<Scalars['Int']>;
  playerPosition3: Maybe<Scalars['Int']>;
  playerAdded: Maybe<Scalars['Datetime']>;
  playerFavTeam: Maybe<Scalars['String']>;
  playerHometown: Maybe<Scalars['String']>;
  playerSchools: Maybe<Scalars['String']>;
  playerSkill: Maybe<Scalars['Int']>;
  groupId: Maybe<Scalars['Int']>;
  playerDebut: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `ForeignDbPlayer` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ForeignDbPlayerCondition = {
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerName` field. */
  playerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `playerImage` field. */
  playerImage?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `playerNickname` field. */
  playerNickname?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `playerSelfNickname` field. */
  playerSelfNickname?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `playerGender` field. */
  playerGender?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerBats` field. */
  playerBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerThrows` field. */
  playerThrows?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerPosition1` field. */
  playerPosition1?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerPosition2` field. */
  playerPosition2?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerPosition3` field. */
  playerPosition3?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerAdded` field. */
  playerAdded?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `playerFavTeam` field. */
  playerFavTeam?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `playerHometown` field. */
  playerHometown?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `playerSchools` field. */
  playerSchools?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `playerSkill` field. */
  playerSkill?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerDebut` field. */
  playerDebut?: Maybe<Scalars['String']>;
};

/** An input for mutations affecting `ForeignDbPlayer` */
export type ForeignDbPlayerInput = {
  playerId: Scalars['Int'];
  playerName: Scalars['String'];
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  playerNickname?: Maybe<Scalars['String']>;
  playerSelfNickname?: Maybe<Scalars['String']>;
  playerGender?: Maybe<Scalars['Int']>;
  playerBats?: Maybe<Scalars['Int']>;
  playerThrows?: Maybe<Scalars['Int']>;
  playerPosition1?: Maybe<Scalars['Int']>;
  playerPosition2?: Maybe<Scalars['Int']>;
  playerPosition3?: Maybe<Scalars['Int']>;
  playerAdded?: Maybe<Scalars['Datetime']>;
  playerFavTeam?: Maybe<Scalars['String']>;
  playerHometown?: Maybe<Scalars['String']>;
  playerSchools?: Maybe<Scalars['String']>;
  playerSkill?: Maybe<Scalars['Int']>;
  groupId?: Maybe<Scalars['Int']>;
  playerDebut?: Maybe<Scalars['String']>;
};

/** Methods to use when ordering `ForeignDbPlayer`. */
export enum ForeignDbPlayersOrderBy {
  NATURAL = 'NATURAL',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  PLAYER_NAME_ASC = 'PLAYER_NAME_ASC',
  PLAYER_NAME_DESC = 'PLAYER_NAME_DESC',
  PLAYER_IMAGE_ASC = 'PLAYER_IMAGE_ASC',
  PLAYER_IMAGE_DESC = 'PLAYER_IMAGE_DESC',
  MEMBER_ID_ASC = 'MEMBER_ID_ASC',
  MEMBER_ID_DESC = 'MEMBER_ID_DESC',
  PLAYER_NICKNAME_ASC = 'PLAYER_NICKNAME_ASC',
  PLAYER_NICKNAME_DESC = 'PLAYER_NICKNAME_DESC',
  PLAYER_SELF_NICKNAME_ASC = 'PLAYER_SELF_NICKNAME_ASC',
  PLAYER_SELF_NICKNAME_DESC = 'PLAYER_SELF_NICKNAME_DESC',
  PLAYER_GENDER_ASC = 'PLAYER_GENDER_ASC',
  PLAYER_GENDER_DESC = 'PLAYER_GENDER_DESC',
  PLAYER_BATS_ASC = 'PLAYER_BATS_ASC',
  PLAYER_BATS_DESC = 'PLAYER_BATS_DESC',
  PLAYER_THROWS_ASC = 'PLAYER_THROWS_ASC',
  PLAYER_THROWS_DESC = 'PLAYER_THROWS_DESC',
  PLAYER_POSITION_1_ASC = 'PLAYER_POSITION_1_ASC',
  PLAYER_POSITION_1_DESC = 'PLAYER_POSITION_1_DESC',
  PLAYER_POSITION_2_ASC = 'PLAYER_POSITION_2_ASC',
  PLAYER_POSITION_2_DESC = 'PLAYER_POSITION_2_DESC',
  PLAYER_POSITION_3_ASC = 'PLAYER_POSITION_3_ASC',
  PLAYER_POSITION_3_DESC = 'PLAYER_POSITION_3_DESC',
  PLAYER_ADDED_ASC = 'PLAYER_ADDED_ASC',
  PLAYER_ADDED_DESC = 'PLAYER_ADDED_DESC',
  PLAYER_FAV_TEAM_ASC = 'PLAYER_FAV_TEAM_ASC',
  PLAYER_FAV_TEAM_DESC = 'PLAYER_FAV_TEAM_DESC',
  PLAYER_HOMETOWN_ASC = 'PLAYER_HOMETOWN_ASC',
  PLAYER_HOMETOWN_DESC = 'PLAYER_HOMETOWN_DESC',
  PLAYER_SCHOOLS_ASC = 'PLAYER_SCHOOLS_ASC',
  PLAYER_SCHOOLS_DESC = 'PLAYER_SCHOOLS_DESC',
  PLAYER_SKILL_ASC = 'PLAYER_SKILL_ASC',
  PLAYER_SKILL_DESC = 'PLAYER_SKILL_DESC',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_DEBUT_ASC = 'PLAYER_DEBUT_ASC',
  PLAYER_DEBUT_DESC = 'PLAYER_DEBUT_DESC'
}

export type ForeignDbStatLine = {
  __typename?: 'ForeignDbStatLine';
  sbStatsId: Scalars['Int'];
  playerId: Scalars['Int'];
  gameId: Scalars['Int'];
  sbStatsTeam: Scalars['Int'];
  sbStatsAb: Scalars['Int'];
  sbStatsRuns: Scalars['Int'];
  sbStatsHits: Scalars['Int'];
  sbStats1B: Scalars['Int'];
  sbStats2B: Scalars['Int'];
  sbStats3B: Scalars['Int'];
  sbStatsHr: Scalars['Int'];
  sbStatsRbi: Scalars['Int'];
  sbStatsBb: Scalars['Int'];
  sbStatsSo: Scalars['Int'];
  sbStatsSac: Scalars['Int'];
  sbStatsS: Maybe<Scalars['Int']>;
  sbStatsP: Maybe<Scalars['Int']>;
  sbStatsPW: Maybe<Scalars['Int']>;
  sbStatsPL: Maybe<Scalars['Int']>;
  sbStatsPSv: Maybe<Scalars['Int']>;
  sbStatsPCg: Maybe<Scalars['Int']>;
  sbStatsPQs: Maybe<Scalars['Int']>;
  sbStatsPInnings: Maybe<Scalars['String']>;
  sbStatsPEr: Maybe<Scalars['String']>;
  sbStatsPTr: Maybe<Scalars['String']>;
  sbStatsPHits: Maybe<Scalars['String']>;
  sbStatsPHr: Maybe<Scalars['String']>;
  sbStatsPK: Maybe<Scalars['String']>;
  sbStatsPBb: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `ForeignDbStatLine` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ForeignDbStatLineCondition = {
  /** Checks for equality with the object’s `sbStatsId` field. */
  sbStatsId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsTeam` field. */
  sbStatsTeam?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsAb` field. */
  sbStatsAb?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsRuns` field. */
  sbStatsRuns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsHits` field. */
  sbStatsHits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStats1B` field. */
  sbStats1B?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStats2B` field. */
  sbStats2B?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStats3B` field. */
  sbStats3B?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsHr` field. */
  sbStatsHr?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsRbi` field. */
  sbStatsRbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsBb` field. */
  sbStatsBb?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsSo` field. */
  sbStatsSo?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsSac` field. */
  sbStatsSac?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsS` field. */
  sbStatsS?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsP` field. */
  sbStatsP?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsPW` field. */
  sbStatsPW?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsPL` field. */
  sbStatsPL?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsPSv` field. */
  sbStatsPSv?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsPCg` field. */
  sbStatsPCg?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsPQs` field. */
  sbStatsPQs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsPInnings` field. */
  sbStatsPInnings?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sbStatsPEr` field. */
  sbStatsPEr?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sbStatsPTr` field. */
  sbStatsPTr?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sbStatsPHits` field. */
  sbStatsPHits?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sbStatsPHr` field. */
  sbStatsPHr?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sbStatsPK` field. */
  sbStatsPK?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `sbStatsPBb` field. */
  sbStatsPBb?: Maybe<Scalars['String']>;
};

/** An input for mutations affecting `ForeignDbStatLine` */
export type ForeignDbStatLineInput = {
  sbStatsId: Scalars['Int'];
  playerId: Scalars['Int'];
  gameId: Scalars['Int'];
  sbStatsTeam: Scalars['Int'];
  sbStatsAb: Scalars['Int'];
  sbStatsRuns: Scalars['Int'];
  sbStatsHits: Scalars['Int'];
  sbStats1B: Scalars['Int'];
  sbStats2B: Scalars['Int'];
  sbStats3B: Scalars['Int'];
  sbStatsHr: Scalars['Int'];
  sbStatsRbi: Scalars['Int'];
  sbStatsBb: Scalars['Int'];
  sbStatsSo: Scalars['Int'];
  sbStatsSac: Scalars['Int'];
  sbStatsS?: Maybe<Scalars['Int']>;
  sbStatsP?: Maybe<Scalars['Int']>;
  sbStatsPW?: Maybe<Scalars['Int']>;
  sbStatsPL?: Maybe<Scalars['Int']>;
  sbStatsPSv?: Maybe<Scalars['Int']>;
  sbStatsPCg?: Maybe<Scalars['Int']>;
  sbStatsPQs?: Maybe<Scalars['Int']>;
  sbStatsPInnings?: Maybe<Scalars['String']>;
  sbStatsPEr?: Maybe<Scalars['String']>;
  sbStatsPTr?: Maybe<Scalars['String']>;
  sbStatsPHits?: Maybe<Scalars['String']>;
  sbStatsPHr?: Maybe<Scalars['String']>;
  sbStatsPK?: Maybe<Scalars['String']>;
  sbStatsPBb?: Maybe<Scalars['String']>;
};

/** Methods to use when ordering `ForeignDbStatLine`. */
export enum ForeignDbStatLinesOrderBy {
  NATURAL = 'NATURAL',
  SB_STATS_ID_ASC = 'SB_STATS_ID_ASC',
  SB_STATS_ID_DESC = 'SB_STATS_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  SB_STATS_TEAM_ASC = 'SB_STATS_TEAM_ASC',
  SB_STATS_TEAM_DESC = 'SB_STATS_TEAM_DESC',
  SB_STATS_AB_ASC = 'SB_STATS_AB_ASC',
  SB_STATS_AB_DESC = 'SB_STATS_AB_DESC',
  SB_STATS_RUNS_ASC = 'SB_STATS_RUNS_ASC',
  SB_STATS_RUNS_DESC = 'SB_STATS_RUNS_DESC',
  SB_STATS_HITS_ASC = 'SB_STATS_HITS_ASC',
  SB_STATS_HITS_DESC = 'SB_STATS_HITS_DESC',
  SB_STATS_1B_ASC = 'SB_STATS_1B_ASC',
  SB_STATS_1B_DESC = 'SB_STATS_1B_DESC',
  SB_STATS_2B_ASC = 'SB_STATS_2B_ASC',
  SB_STATS_2B_DESC = 'SB_STATS_2B_DESC',
  SB_STATS_3B_ASC = 'SB_STATS_3B_ASC',
  SB_STATS_3B_DESC = 'SB_STATS_3B_DESC',
  SB_STATS_HR_ASC = 'SB_STATS_HR_ASC',
  SB_STATS_HR_DESC = 'SB_STATS_HR_DESC',
  SB_STATS_RBI_ASC = 'SB_STATS_RBI_ASC',
  SB_STATS_RBI_DESC = 'SB_STATS_RBI_DESC',
  SB_STATS_BB_ASC = 'SB_STATS_BB_ASC',
  SB_STATS_BB_DESC = 'SB_STATS_BB_DESC',
  SB_STATS_SO_ASC = 'SB_STATS_SO_ASC',
  SB_STATS_SO_DESC = 'SB_STATS_SO_DESC',
  SB_STATS_SAC_ASC = 'SB_STATS_SAC_ASC',
  SB_STATS_SAC_DESC = 'SB_STATS_SAC_DESC',
  SB_STATS_S_ASC = 'SB_STATS_S_ASC',
  SB_STATS_S_DESC = 'SB_STATS_S_DESC',
  SB_STATS_P_ASC = 'SB_STATS_P_ASC',
  SB_STATS_P_DESC = 'SB_STATS_P_DESC',
  SB_STATS_P_W_ASC = 'SB_STATS_P_W_ASC',
  SB_STATS_P_W_DESC = 'SB_STATS_P_W_DESC',
  SB_STATS_P_L_ASC = 'SB_STATS_P_L_ASC',
  SB_STATS_P_L_DESC = 'SB_STATS_P_L_DESC',
  SB_STATS_P_SV_ASC = 'SB_STATS_P_SV_ASC',
  SB_STATS_P_SV_DESC = 'SB_STATS_P_SV_DESC',
  SB_STATS_P_CG_ASC = 'SB_STATS_P_CG_ASC',
  SB_STATS_P_CG_DESC = 'SB_STATS_P_CG_DESC',
  SB_STATS_P_QS_ASC = 'SB_STATS_P_QS_ASC',
  SB_STATS_P_QS_DESC = 'SB_STATS_P_QS_DESC',
  SB_STATS_P_INNINGS_ASC = 'SB_STATS_P_INNINGS_ASC',
  SB_STATS_P_INNINGS_DESC = 'SB_STATS_P_INNINGS_DESC',
  SB_STATS_P_ER_ASC = 'SB_STATS_P_ER_ASC',
  SB_STATS_P_ER_DESC = 'SB_STATS_P_ER_DESC',
  SB_STATS_P_TR_ASC = 'SB_STATS_P_TR_ASC',
  SB_STATS_P_TR_DESC = 'SB_STATS_P_TR_DESC',
  SB_STATS_P_HITS_ASC = 'SB_STATS_P_HITS_ASC',
  SB_STATS_P_HITS_DESC = 'SB_STATS_P_HITS_DESC',
  SB_STATS_P_HR_ASC = 'SB_STATS_P_HR_ASC',
  SB_STATS_P_HR_DESC = 'SB_STATS_P_HR_DESC',
  SB_STATS_P_K_ASC = 'SB_STATS_P_K_ASC',
  SB_STATS_P_K_DESC = 'SB_STATS_P_K_DESC',
  SB_STATS_P_BB_ASC = 'SB_STATS_P_BB_ASC',
  SB_STATS_P_BB_DESC = 'SB_STATS_P_BB_DESC'
}

export type ForeignDbTeam = {
  __typename?: 'ForeignDbTeam';
  teamId: Scalars['Int'];
  teamName: Scalars['String'];
};

/**
 * A condition to be used against `ForeignDbTeam` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ForeignDbTeamCondition = {
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `teamName` field. */
  teamName?: Maybe<Scalars['String']>;
};

/** An input for mutations affecting `ForeignDbTeam` */
export type ForeignDbTeamInput = {
  teamId: Scalars['Int'];
  teamName: Scalars['String'];
};

/** Methods to use when ordering `ForeignDbTeam`. */
export enum ForeignDbTeamsOrderBy {
  NATURAL = 'NATURAL',
  TEAM_ID_ASC = 'TEAM_ID_ASC',
  TEAM_ID_DESC = 'TEAM_ID_DESC',
  TEAM_NAME_ASC = 'TEAM_NAME_ASC',
  TEAM_NAME_DESC = 'TEAM_NAME_DESC'
}

export type Game = Node & {
  __typename?: 'Game';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  groupId: Scalars['UUID'];
  name: Maybe<Scalars['String']>;
  fieldId: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength: Scalars['Int'];
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved: Scalars['Datetime'];
  soloMode: Maybe<Scalars['Boolean']>;
  /** Reads a single `Group` that is related to this `Game`. */
  group: Maybe<Group>;
  /** Reads a single `Field` that is related to this `Game`. */
  field: Maybe<Field>;
  /** Reads and enables pagination through a set of `Team`. */
  teams: Array<Team>;
  /** Reads and enables pagination through a set of `Lineup`. */
  lineups: Array<Lineup>;
  /** Reads and enables pagination through a set of `LineupSpot`. */
  lineupSpots: Array<LineupSpot>;
  /** Reads and enables pagination through a set of `PlateAppearance`. */
  plateAppearances: Array<PlateAppearance>;
  /** Reads and enables pagination through a set of `BasepathMovement`. */
  basepathMovements: Array<BasepathMovement>;
  /** Reads and enables pagination through a set of `OutOnPlayRunner`. */
  outOnPlayRunners: Array<OutOnPlayRunner>;
  /** Reads and enables pagination through a set of `StolenBaseAttempt`. */
  stolenBaseAttempts: Array<StolenBaseAttempt>;
  /** Reads and enables pagination through a set of `LineupChange`. */
  lineupChanges: Array<LineupChange>;
  /** Reads and enables pagination through a set of `GameState`. */
  gameStates: Array<GameState>;
  /** Reads and enables pagination through a set of `BaseRunner`. */
  baseRunners: Array<BaseRunner>;
  /** Reads and enables pagination through a set of `LineupForGameState`. */
  lineupForGameStates: Array<LineupForGameState>;
  /** Reads and enables pagination through a set of `GameEventRecord`. */
  gameEventRecords: Array<GameEventRecord>;
  /** Reads and enables pagination through a set of `ScoredRunner`. */
  scoredRunners: Array<ScoredRunner>;
  /** Reads and enables pagination through a set of `SoloModeOpponentInning`. */
  soloModeOpponentInnings: Array<SoloModeOpponentInning>;
  /** Reads and enables pagination through a set of `AtBatSkip`. */
  atBatSkips: Array<AtBatSkip>;
  /** Reads and enables pagination through a set of `EarlyGameEnd`. */
  earlyGameEnds: Array<EarlyGameEnd>;
  /** Reads and enables pagination through a set of `GameTag`. */
  gameTags: Array<GameTag>;
  /** Reads and enables pagination through a set of `GameBattingLine`. */
  gameBattingLines: Array<GameBattingLine>;
  /** Reads and enables pagination through a set of `UnifiedGame`. */
  unifiedGames: Array<UnifiedGame>;
  /** Reads and enables pagination through a set of `TraditionalStatLine`. */
  boxScore: Maybe<Array<Maybe<TraditionalStatLine>>>;
  /** Reads and enables pagination through a set of `LineScoreCell`. */
  lineScore: Maybe<Array<Maybe<LineScoreCell>>>;
};


export type GameTeamsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<TeamsOrderBy>>;
  condition?: Maybe<TeamCondition>;
};


export type GameLineupsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupsOrderBy>>;
  condition?: Maybe<LineupCondition>;
};


export type GameLineupSpotsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupSpotsOrderBy>>;
  condition?: Maybe<LineupSpotCondition>;
};


export type GamePlateAppearancesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlateAppearancesOrderBy>>;
  condition?: Maybe<PlateAppearanceCondition>;
};


export type GameBasepathMovementsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BasepathMovementsOrderBy>>;
  condition?: Maybe<BasepathMovementCondition>;
};


export type GameOutOnPlayRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<OutOnPlayRunnersOrderBy>>;
  condition?: Maybe<OutOnPlayRunnerCondition>;
};


export type GameStolenBaseAttemptsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<StolenBaseAttemptsOrderBy>>;
  condition?: Maybe<StolenBaseAttemptCondition>;
};


export type GameLineupChangesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupChangesOrderBy>>;
  condition?: Maybe<LineupChangeCondition>;
};


export type GameGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameStatesOrderBy>>;
  condition?: Maybe<GameStateCondition>;
};


export type GameBaseRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BaseRunnersOrderBy>>;
  condition?: Maybe<BaseRunnerCondition>;
};


export type GameLineupForGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupForGameStatesOrderBy>>;
  condition?: Maybe<LineupForGameStateCondition>;
};


export type GameGameEventRecordsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventRecordsOrderBy>>;
  condition?: Maybe<GameEventRecordCondition>;
};


export type GameScoredRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ScoredRunnersOrderBy>>;
  condition?: Maybe<ScoredRunnerCondition>;
};


export type GameSoloModeOpponentInningsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SoloModeOpponentInningsOrderBy>>;
  condition?: Maybe<SoloModeOpponentInningCondition>;
};


export type GameAtBatSkipsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<AtBatSkipsOrderBy>>;
  condition?: Maybe<AtBatSkipCondition>;
};


export type GameEarlyGameEndsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EarlyGameEndsOrderBy>>;
  condition?: Maybe<EarlyGameEndCondition>;
};


export type GameGameTagsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameTagsOrderBy>>;
  condition?: Maybe<GameTagCondition>;
};


export type GameGameBattingLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameBattingLinesOrderBy>>;
  condition?: Maybe<GameBattingLineCondition>;
};


export type GameUnifiedGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UnifiedGamesOrderBy>>;
  condition?: Maybe<UnifiedGameCondition>;
};


export type GameBoxScoreArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};


export type GameLineScoreArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};

export type GameBattingLine = Node & {
  __typename?: 'GameBattingLine';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  playerId: Scalars['UUID'];
  gameId: Scalars['UUID'];
  season: Maybe<Scalars['Int']>;
  teamId: Maybe<Scalars['UUID']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
  /** Reads a single `Player` that is related to this `GameBattingLine`. */
  player: Maybe<Player>;
  /** Reads a single `Game` that is related to this `GameBattingLine`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `GameBattingLine` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type GameBattingLineCondition = {
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The fields on `gameBattingLine` to look up the row to connect. */
export type GameBattingLineFakePublicGameBattingLinesPrimaryKeyConnect = {
  playerId: Scalars['UUID'];
  gameId: Scalars['UUID'];
};

/** The fields on `gameBattingLine` to look up the row to delete. */
export type GameBattingLineFakePublicGameBattingLinesPrimaryKeyDelete = {
  playerId: Scalars['UUID'];
  gameId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type GameBattingLineNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `gameBattingLine` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GameBattingLineNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `gameBattingLine` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameBattingLineOnGameBattingLineForFakePublicGameBattingLinesForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `gameBattingLine` to look up the row to update. */
export type GameBattingLineOnGameBattingLineForFakePublicGameBattingLinesForeignKey0UsingFakePublicGameBattingLinesPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `gameBattingLine` being updated. */
  patch: UpdateGameBattingLineOnGameBattingLineForFakePublicGameBattingLinesForeignKey0Patch;
  playerId: Scalars['UUID'];
  gameId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameBattingLineOnGameBattingLineForFakePublicGameBattingLinesForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `gameBattingLine` to look up the row to update. */
export type GameBattingLineOnGameBattingLineForFakePublicGameBattingLinesForeignKey1UsingFakePublicGameBattingLinesPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `gameBattingLine` being updated. */
  patch: UpdateGameBattingLineOnGameBattingLineForFakePublicGameBattingLinesForeignKey1Patch;
  playerId: Scalars['UUID'];
  gameId: Scalars['UUID'];
};

/** Represents an update to a `GameBattingLine`. Fields that are set will be updated. */
export type GameBattingLinePatch = {
  playerId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  teamId?: Maybe<Scalars['UUID']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicGameBattingLinesForeignKey0Input>;
  game?: Maybe<FakePublicGameBattingLinesForeignKey1Input>;
};

/** Methods to use when ordering `GameBattingLine`. */
export enum GameBattingLinesOrderBy {
  NATURAL = 'NATURAL',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  TEAM_ID_ASC = 'TEAM_ID_ASC',
  TEAM_ID_DESC = 'TEAM_ID_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `Game` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GameCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `score` field. */
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  /** Checks for equality with the object’s `gameLength` field. */
  gameLength?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `timeStarted` field. */
  timeStarted?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `timeEnded` field. */
  timeEnded?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `timeSaved` field. */
  timeSaved?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `soloMode` field. */
  soloMode?: Maybe<Scalars['Boolean']>;
};

export type GameEvent = Node & {
  __typename?: 'GameEvent';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  plateAppearanceId: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId: Maybe<Scalars['UUID']>;
  lineupChangeId: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId: Maybe<Scalars['UUID']>;
  atBatSkipId: Maybe<Scalars['UUID']>;
  gameId: Scalars['UUID'];
  earlyGameEndId: Maybe<Scalars['UUID']>;
  /** Reads a single `PlateAppearance` that is related to this `GameEvent`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `StolenBaseAttempt` that is related to this `GameEvent`. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Reads a single `LineupChange` that is related to this `GameEvent`. */
  lineupChange: Maybe<LineupChange>;
  /** Reads a single `SoloModeOpponentInning` that is related to this `GameEvent`. */
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  /** Reads a single `AtBatSkip` that is related to this `GameEvent`. */
  atBatSkip: Maybe<AtBatSkip>;
  /** Reads a single `Game` that is related to this `GameEvent`. */
  game: Maybe<Game>;
  /** Reads a single `EarlyGameEnd` that is related to this `GameEvent`. */
  earlyGameEnd: Maybe<EarlyGameEnd>;
  /** Reads and enables pagination through a set of `GameEventRecord`. */
  gameEventRecords: Array<GameEventRecord>;
};


export type GameEventGameEventRecordsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventRecordsOrderBy>>;
  condition?: Maybe<GameEventRecordCondition>;
};

/** The `atBatSkip` to be created by this mutation. */
export type GameEventAtBatSkipIdFkeyAtBatSkipCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventAtBatSkipIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `atBatSkip` in the `GameEventInput` mutation. */
export type GameEventAtBatSkipIdFkeyInput = {
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  connectById?: Maybe<AtBatSkipAtBatSkipPkeyConnect>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  connectByNodeId?: Maybe<AtBatSkipNodeIdConnect>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  deleteById?: Maybe<AtBatSkipAtBatSkipPkeyDelete>;
  /** The primary key(s) for `atBatSkip` for the far side of the relationship. */
  deleteByNodeId?: Maybe<AtBatSkipNodeIdDelete>;
  /** The primary key(s) and patch data for `atBatSkip` for the far side of the relationship. */
  updateById?: Maybe<AtBatSkipOnGameEventForGameEventAtBatSkipIdFkeyUsingAtBatSkipPkeyUpdate>;
  /** The primary key(s) and patch data for `atBatSkip` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventAtBatSkipIdFkeyNodeIdUpdate>;
  /** A `AtBatSkipInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventAtBatSkipIdFkeyAtBatSkipCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `AtBatSkipInput` mutation. */
export type GameEventAtBatSkipIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventAtBatSkipIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<AtBatSkipOnGameEventForGameEventAtBatSkipIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventAtBatSkipIdFkeyGameEventCreateInput>>;
};

/**
 * A condition to be used against `GameEvent` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GameEventCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `plateAppearanceId` field. */
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `stolenBaseAttemptId` field. */
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `lineupChangeId` field. */
  lineupChangeId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `soloModeOpponentInningId` field. */
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `atBatSkipId` field. */
  atBatSkipId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `earlyGameEndId` field. */
  earlyGameEndId?: Maybe<Scalars['UUID']>;
};

/** The `earlyGameEnd` to be created by this mutation. */
export type GameEventEarlyGameEndIdFkeyEarlyGameEndCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  reason: EarlyGameEndReason;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<EarlyGameEndGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventEarlyGameEndIdFkeyInverseInput>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventEarlyGameEndIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `earlyGameEnd` in the `GameEventInput` mutation. */
export type GameEventEarlyGameEndIdFkeyInput = {
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  connectById?: Maybe<EarlyGameEndEarlyGameEndPkeyConnect>;
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  connectByNodeId?: Maybe<EarlyGameEndNodeIdConnect>;
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  deleteById?: Maybe<EarlyGameEndEarlyGameEndPkeyDelete>;
  /** The primary key(s) for `earlyGameEnd` for the far side of the relationship. */
  deleteByNodeId?: Maybe<EarlyGameEndNodeIdDelete>;
  /** The primary key(s) and patch data for `earlyGameEnd` for the far side of the relationship. */
  updateById?: Maybe<EarlyGameEndOnGameEventForGameEventEarlyGameEndIdFkeyUsingEarlyGameEndPkeyUpdate>;
  /** The primary key(s) and patch data for `earlyGameEnd` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventEarlyGameEndIdFkeyNodeIdUpdate>;
  /** A `EarlyGameEndInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventEarlyGameEndIdFkeyEarlyGameEndCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `EarlyGameEndInput` mutation. */
export type GameEventEarlyGameEndIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventEarlyGameEndIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<EarlyGameEndOnGameEventForGameEventEarlyGameEndIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventEarlyGameEndIdFkeyGameEventCreateInput>>;
};

/** The fields on `gameEvent` to look up the row to connect. */
export type GameEventGameEventPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `gameEvent` to look up the row to delete. */
export type GameEventGameEventPkeyDelete = {
  id: Scalars['UUID'];
};

/** The `game` to be created by this mutation. */
export type GameEventGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventGameIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `game` in the `GameEventInput` mutation. */
export type GameEventGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnGameEventForGameEventGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnGameEventForGameEventGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `GameInput` mutation. */
export type GameEventGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventGameIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnGameEventForGameEventGameIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventGameIdFkeyGameEventCreateInput>>;
};

/** An input for mutations affecting `GameEvent` */
export type GameEventInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventLineupChangeIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `lineupChange` in the `GameEventInput` mutation. */
export type GameEventLineupChangeIdFkeyInput = {
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectById?: Maybe<LineupChangeLineupChangePkeyConnect>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectByNodeId?: Maybe<LineupChangeNodeIdConnect>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteById?: Maybe<LineupChangeLineupChangePkeyDelete>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LineupChangeNodeIdDelete>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateById?: Maybe<LineupChangeOnGameEventForGameEventLineupChangeIdFkeyUsingLineupChangePkeyUpdate>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate>;
  /** A `LineupChangeInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventLineupChangeIdFkeyLineupChangeCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `LineupChangeInput` mutation. */
export type GameEventLineupChangeIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventLineupChangeIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LineupChangeOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventLineupChangeIdFkeyGameEventCreateInput>>;
};

/** The `lineupChange` to be created by this mutation. */
export type GameEventLineupChangeIdFkeyLineupChangeCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GameEventNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GameEventNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventAtBatSkipIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `atBatSkip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `atBatSkip` being updated. */
  patch: AtBatSkipPatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventAtBatSkipIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventAtBatSkipIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventEarlyGameEndIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `earlyGameEnd` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `earlyGameEnd` being updated. */
  patch: EarlyGameEndPatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventEarlyGameEndIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventEarlyGameEndIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventGameIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: LineupChangePatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventLineupChangeIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventLineupChangeIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventPlateAppearanceIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventPlateAppearanceIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventSoloModeOpponentInningIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `soloModeOpponentInning` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `soloModeOpponentInning` being updated. */
  patch: SoloModeOpponentInningPatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventSoloModeOpponentInningIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventSoloModeOpponentInningIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `stolenBaseAttempt` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: StolenBaseAttemptPatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** The fields on `gameEvent` to look up the row to update. */
export type GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: UpdateGameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `GameEvent`. Fields that are set will be updated. */
export type GameEventPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventPlateAppearanceIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `plateAppearance` in the `GameEventInput` mutation. */
export type GameEventPlateAppearanceIdFkeyInput = {
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectById?: Maybe<PlateAppearancePlateAppearancePkeyConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlateAppearanceNodeIdConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteById?: Maybe<PlateAppearancePlateAppearancePkeyDelete>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlateAppearanceNodeIdDelete>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateById?: Maybe<PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate>;
  /** A `PlateAppearanceInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventPlateAppearanceIdFkeyPlateAppearanceCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `PlateAppearanceInput` mutation. */
export type GameEventPlateAppearanceIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventPlateAppearanceIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventPlateAppearanceIdFkeyGameEventCreateInput>>;
};

/** The `plateAppearance` to be created by this mutation. */
export type GameEventPlateAppearanceIdFkeyPlateAppearanceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

export type GameEventRecord = Node & {
  __typename?: 'GameEventRecord';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
  gameStateBeforeId: Scalars['UUID'];
  gameStateAfterId: Scalars['UUID'];
  gameEventId: Scalars['UUID'];
  notes: Maybe<Scalars['String']>;
  /** Reads a single `Game` that is related to this `GameEventRecord`. */
  game: Maybe<Game>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateBefore: Maybe<GameState>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateAfter: Maybe<GameState>;
  /** Reads a single `GameEvent` that is related to this `GameEventRecord`. */
  gameEvent: Maybe<GameEvent>;
  /** Reads and enables pagination through a set of `ScoredRunner`. */
  scoredRunners: Array<ScoredRunner>;
};


export type GameEventRecordScoredRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ScoredRunnersOrderBy>>;
  condition?: Maybe<ScoredRunnerCondition>;
};

/**
 * A condition to be used against `GameEventRecord` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type GameEventRecordCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `eventIndex` field. */
  eventIndex?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameStateBeforeId` field. */
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameStateAfterId` field. */
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameEventId` field. */
  gameEventId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventRecordGameEventIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** The `gameEventRecord` to be created by this mutation. */
export type GameEventRecordGameEventIdFkeyGameEventRecordCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** Input for the nested mutation of `gameEvent` in the `GameEventRecordInput` mutation. */
export type GameEventRecordGameEventIdFkeyInput = {
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<GameEventGameEventPkeyConnect>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameEventNodeIdConnect>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<GameEventGameEventPkeyDelete>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameEventNodeIdDelete>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventPkeyUpdate>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventRecordGameEventIdFkeyGameEventCreateInput>;
};

/** Input for the nested mutation of `gameEventRecord` in the `GameEventInput` mutation. */
export type GameEventRecordGameEventIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventRecordGameEventRecordPkeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventRecordNodeIdConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventRecordGameEventRecordPkeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventRecordNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByGameIdAndEventIndex?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate>>;
  /** A `GameEventRecordInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventRecordGameEventIdFkeyGameEventRecordCreateInput>>;
};

/** The fields on `gameEventRecord` to look up the row to connect. */
export type GameEventRecordGameEventRecordGameIdEventIndexKeyConnect = {
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to delete. */
export type GameEventRecordGameEventRecordGameIdEventIndexKeyDelete = {
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to connect. */
export type GameEventRecordGameEventRecordPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `gameEventRecord` to look up the row to delete. */
export type GameEventRecordGameEventRecordPkeyDelete = {
  id: Scalars['UUID'];
};

/** The `game` to be created by this mutation. */
export type GameEventRecordGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** The `gameEventRecord` to be created by this mutation. */
export type GameEventRecordGameIdFkeyGameEventRecordCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** Input for the nested mutation of `game` in the `GameEventRecordInput` mutation. */
export type GameEventRecordGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventRecordGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `gameEventRecord` in the `GameInput` mutation. */
export type GameEventRecordGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventRecordGameEventRecordPkeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventRecordNodeIdConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventRecordGameEventRecordPkeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventRecordNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByGameIdAndEventIndex?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate>>;
  /** A `GameEventRecordInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventRecordGameIdFkeyGameEventRecordCreateInput>>;
};

/** The `gameEventRecord` to be created by this mutation. */
export type GameEventRecordGameStateAfterFkGameEventRecordCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** The `gameState` to be created by this mutation. */
export type GameEventRecordGameStateAfterFkGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `gameState` in the `GameEventRecordInput` mutation. */
export type GameEventRecordGameStateAfterFkInput = {
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<GameStateGameStatePkeyConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameStateNodeIdConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<GameStateGameStatePkeyDelete>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameStateNodeIdDelete>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameStatePkeyUpdate>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventRecordGameStateAfterFkGameStateCreateInput>;
};

/** Input for the nested mutation of `gameEventRecord` in the `GameStateInput` mutation. */
export type GameEventRecordGameStateAfterFkInverseInput = {
  /** Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventRecordGameEventRecordPkeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventRecordNodeIdConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventRecordGameEventRecordPkeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventRecordNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByGameIdAndEventIndex?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordGameIdEventIndexKeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate>>;
  /** A `GameEventRecordInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventRecordGameStateAfterFkGameEventRecordCreateInput>>;
};

/** The `gameEventRecord` to be created by this mutation. */
export type GameEventRecordGameStateBeforeFkGameEventRecordCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** The `gameState` to be created by this mutation. */
export type GameEventRecordGameStateBeforeFkGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `gameState` in the `GameEventRecordInput` mutation. */
export type GameEventRecordGameStateBeforeFkInput = {
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<GameStateGameStatePkeyConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameStateNodeIdConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<GameStateGameStatePkeyDelete>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameStateNodeIdDelete>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameStatePkeyUpdate>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventRecordGameStateBeforeFkGameStateCreateInput>;
};

/** Input for the nested mutation of `gameEventRecord` in the `GameStateInput` mutation. */
export type GameEventRecordGameStateBeforeFkInverseInput = {
  /** Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventRecordGameEventRecordPkeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventRecordNodeIdConnect>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventRecordGameEventRecordPkeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByGameIdAndEventIndex?: Maybe<Array<GameEventRecordGameEventRecordGameIdEventIndexKeyDelete>>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventRecordNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByGameIdAndEventIndex?: Maybe<Array<GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordGameIdEventIndexKeyUpdate>>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate>>;
  /** A `GameEventRecordInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventRecordGameStateBeforeFkGameEventRecordCreateInput>>;
};

/** An input for mutations affecting `GameEventRecord` */
export type GameEventRecordInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GameEventRecordNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GameEventRecordNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordGameIdEventIndexKeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordGameIdEventIndexKeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scoredRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: ScoredRunnerPatch;
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** The fields on `gameEventRecord` to look up the row to update. */
export type GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordPkeyUpdate = {
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: UpdateGameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `GameEventRecord`. Fields that are set will be updated. */
export type GameEventRecordPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** Methods to use when ordering `GameEventRecord`. */
export enum GameEventRecordsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  EVENT_INDEX_ASC = 'EVENT_INDEX_ASC',
  EVENT_INDEX_DESC = 'EVENT_INDEX_DESC',
  GAME_STATE_BEFORE_ID_ASC = 'GAME_STATE_BEFORE_ID_ASC',
  GAME_STATE_BEFORE_ID_DESC = 'GAME_STATE_BEFORE_ID_DESC',
  GAME_STATE_AFTER_ID_ASC = 'GAME_STATE_AFTER_ID_ASC',
  GAME_STATE_AFTER_ID_DESC = 'GAME_STATE_AFTER_ID_DESC',
  GAME_EVENT_ID_ASC = 'GAME_EVENT_ID_ASC',
  GAME_EVENT_ID_DESC = 'GAME_EVENT_ID_DESC',
  NOTES_ASC = 'NOTES_ASC',
  NOTES_DESC = 'NOTES_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** The `gameEvent` to be created by this mutation. */
export type GameEventSoloModeOpponentInningIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `soloModeOpponentInning` in the `GameEventInput` mutation. */
export type GameEventSoloModeOpponentInningIdFkeyInput = {
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  connectById?: Maybe<SoloModeOpponentInningSoloModeOpponentInningPkeyConnect>;
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  connectByNodeId?: Maybe<SoloModeOpponentInningNodeIdConnect>;
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  deleteById?: Maybe<SoloModeOpponentInningSoloModeOpponentInningPkeyDelete>;
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  deleteByNodeId?: Maybe<SoloModeOpponentInningNodeIdDelete>;
  /** The primary key(s) and patch data for `soloModeOpponentInning` for the far side of the relationship. */
  updateById?: Maybe<SoloModeOpponentInningOnGameEventForGameEventSoloModeOpponentInningIdFkeyUsingSoloModeOpponentInningPkeyUpdate>;
  /** The primary key(s) and patch data for `soloModeOpponentInning` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventSoloModeOpponentInningIdFkeyNodeIdUpdate>;
  /** A `SoloModeOpponentInningInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventSoloModeOpponentInningIdFkeySoloModeOpponentInningCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `SoloModeOpponentInningInput` mutation. */
export type GameEventSoloModeOpponentInningIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventSoloModeOpponentInningIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<SoloModeOpponentInningOnGameEventForGameEventSoloModeOpponentInningIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventSoloModeOpponentInningIdFkeyGameEventCreateInput>>;
};

/** The `soloModeOpponentInning` to be created by this mutation. */
export type GameEventSoloModeOpponentInningIdFkeySoloModeOpponentInningCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  runsScored: Scalars['Int'];
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<SoloModeOpponentInningGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventSoloModeOpponentInningIdFkeyInverseInput>;
};

/** The `gameEvent` to be created by this mutation. */
export type GameEventStolenBaseAttemptIdFkeyGameEventCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** Input for the nested mutation of `stolenBaseAttempt` in the `GameEventInput` mutation. */
export type GameEventStolenBaseAttemptIdFkeyInput = {
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectById?: Maybe<StolenBaseAttemptStolenBaseAttemptPkeyConnect>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectByNodeId?: Maybe<StolenBaseAttemptNodeIdConnect>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteById?: Maybe<StolenBaseAttemptStolenBaseAttemptPkeyDelete>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteByNodeId?: Maybe<StolenBaseAttemptNodeIdDelete>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateById?: Maybe<StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingStolenBaseAttemptPkeyUpdate>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate>;
  /** A `StolenBaseAttemptInput` object that will be created and connected to this object. */
  create?: Maybe<GameEventStolenBaseAttemptIdFkeyStolenBaseAttemptCreateInput>;
};

/** Input for the nested mutation of `gameEvent` in the `StolenBaseAttemptInput` mutation. */
export type GameEventStolenBaseAttemptIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameEvent` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectById?: Maybe<Array<GameEventGameEventPkeyConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameEventNodeIdConnect>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameEventGameEventPkeyDelete>>;
  /** The primary key(s) for `gameEvent` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameEventNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateById?: Maybe<Array<GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingGameEventPkeyUpdate>>;
  /** The primary key(s) and patch data for `gameEvent` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate>>;
  /** A `GameEventInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameEventStolenBaseAttemptIdFkeyGameEventCreateInput>>;
};

/** The `stolenBaseAttempt` to be created by this mutation. */
export type GameEventStolenBaseAttemptIdFkeyStolenBaseAttemptCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** Methods to use when ordering `GameEvent`. */
export enum GameEventsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  PLATE_APPEARANCE_ID_ASC = 'PLATE_APPEARANCE_ID_ASC',
  PLATE_APPEARANCE_ID_DESC = 'PLATE_APPEARANCE_ID_DESC',
  STOLEN_BASE_ATTEMPT_ID_ASC = 'STOLEN_BASE_ATTEMPT_ID_ASC',
  STOLEN_BASE_ATTEMPT_ID_DESC = 'STOLEN_BASE_ATTEMPT_ID_DESC',
  LINEUP_CHANGE_ID_ASC = 'LINEUP_CHANGE_ID_ASC',
  LINEUP_CHANGE_ID_DESC = 'LINEUP_CHANGE_ID_DESC',
  SOLO_MODE_OPPONENT_INNING_ID_ASC = 'SOLO_MODE_OPPONENT_INNING_ID_ASC',
  SOLO_MODE_OPPONENT_INNING_ID_DESC = 'SOLO_MODE_OPPONENT_INNING_ID_DESC',
  AT_BAT_SKIP_ID_ASC = 'AT_BAT_SKIP_ID_ASC',
  AT_BAT_SKIP_ID_DESC = 'AT_BAT_SKIP_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  EARLY_GAME_END_ID_ASC = 'EARLY_GAME_END_ID_ASC',
  EARLY_GAME_END_ID_DESC = 'EARLY_GAME_END_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** The `field` to be created by this mutation. */
export type GameFieldIdFkeyFieldCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  games?: Maybe<GameFieldIdFkeyInverseInput>;
};

/** The `game` to be created by this mutation. */
export type GameFieldIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `field` in the `GameInput` mutation. */
export type GameFieldIdFkeyInput = {
  /** The primary key(s) for `field` for the far side of the relationship. */
  connectById?: Maybe<FieldFieldPkeyConnect>;
  /** The primary key(s) for `field` for the far side of the relationship. */
  connectByNodeId?: Maybe<FieldNodeIdConnect>;
  /** The primary key(s) for `field` for the far side of the relationship. */
  deleteById?: Maybe<FieldFieldPkeyDelete>;
  /** The primary key(s) for `field` for the far side of the relationship. */
  deleteByNodeId?: Maybe<FieldNodeIdDelete>;
  /** The primary key(s) and patch data for `field` for the far side of the relationship. */
  updateById?: Maybe<FieldOnGameForGameFieldIdFkeyUsingFieldPkeyUpdate>;
  /** The primary key(s) and patch data for `field` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameOnGameForGameFieldIdFkeyNodeIdUpdate>;
  /** A `FieldInput` object that will be created and connected to this object. */
  create?: Maybe<GameFieldIdFkeyFieldCreateInput>;
};

/** Input for the nested mutation of `game` in the `FieldInput` mutation. */
export type GameFieldIdFkeyInverseInput = {
  /** Flag indicating whether all other `game` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<Array<GameGamePkeyConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<Array<GameGameNameUniqPerGroupConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameNodeIdConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameGamePkeyDelete>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<Array<GameGameNameUniqPerGroupDelete>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameNodeIdDelete>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<Array<GameOnGameForGameFieldIdFkeyUsingGamePkeyUpdate>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<Array<GameOnGameForGameFieldIdFkeyUsingGameNameUniqPerGroupUpdate>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<FieldOnGameForGameFieldIdFkeyNodeIdUpdate>>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameFieldIdFkeyGameCreateInput>>;
};

/** The fields on `game` to look up the row to connect. */
export type GameGameNameUniqPerGroupConnect = {
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to delete. */
export type GameGameNameUniqPerGroupDelete = {
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to connect. */
export type GameGamePkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `game` to look up the row to delete. */
export type GameGamePkeyDelete = {
  id: Scalars['UUID'];
};

/** The `game` to be created by this mutation. */
export type GameGroupIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** The `group` to be created by this mutation. */
export type GameGroupIdFkeyGroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** Input for the nested mutation of `group` in the `GameInput` mutation. */
export type GameGroupIdFkeyInput = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByUrlSlug?: Maybe<GroupGroupUrlSlugKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByUrlSlug?: Maybe<GroupGroupUrlSlugKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnGameForGameGroupIdFkeyUsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnGameForGameGroupIdFkeyUsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByUrlSlug?: Maybe<GroupOnGameForGameGroupIdFkeyUsingGroupUrlSlugKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameOnGameForGameGroupIdFkeyNodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<GameGroupIdFkeyGroupCreateInput>;
};

/** Input for the nested mutation of `game` in the `GroupInput` mutation. */
export type GameGroupIdFkeyInverseInput = {
  /** Flag indicating whether all other `game` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<Array<GameGamePkeyConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<Array<GameGameNameUniqPerGroupConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameNodeIdConnect>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameGamePkeyDelete>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<Array<GameGameNameUniqPerGroupDelete>>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameNodeIdDelete>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<Array<GameOnGameForGameGroupIdFkeyUsingGamePkeyUpdate>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<Array<GameOnGameForGameGroupIdFkeyUsingGameNameUniqPerGroupUpdate>>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GroupOnGameForGameGroupIdFkeyNodeIdUpdate>>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameGroupIdFkeyGameCreateInput>>;
};

/** An input for mutations affecting `Game` */
export type GameInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GameNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GameNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `game` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnAtBatSkipForAtBatSkipGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `atBatSkip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `atBatSkip` being updated. */
  patch: AtBatSkipPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnAtBatSkipForAtBatSkipGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnAtBatSkipForAtBatSkipGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnAtBatSkipForAtBatSkipGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnAtBatSkipForAtBatSkipGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnBaseRunnerForBaseRunnerGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `baseRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: BaseRunnerPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnBaseRunnerForBaseRunnerGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnBaseRunnerForBaseRunnerGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnBaseRunnerForBaseRunnerGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnBaseRunnerForBaseRunnerGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnBasepathMovementForBasepathMovementGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `basepathMovement` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: BasepathMovementPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnBasepathMovementForBasepathMovementGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnBasepathMovementForBasepathMovementGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnBasepathMovementForBasepathMovementGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnBasepathMovementForBasepathMovementGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnEarlyGameEndForEarlyGameEndGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `earlyGameEnd` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `earlyGameEnd` being updated. */
  patch: EarlyGameEndPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnEarlyGameEndForEarlyGameEndGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnEarlyGameEndForEarlyGameEndGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnEarlyGameEndForEarlyGameEndGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnEarlyGameEndForEarlyGameEndGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameBattingLineForFakePublicGameBattingLinesForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameBattingLine` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameBattingLine` being updated. */
  patch: GameBattingLinePatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameBattingLineForFakePublicGameBattingLinesForeignKey1UsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameBattingLineForFakePublicGameBattingLinesForeignKey1Patch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameBattingLineForFakePublicGameBattingLinesForeignKey1UsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameBattingLineForFakePublicGameBattingLinesForeignKey1Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameEventForGameEventGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameEventForGameEventGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameEventForGameEventGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameEventForGameEventGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameEventForGameEventGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameEventRecordForGameEventRecordGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameEventRecordForGameEventRecordGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameForGameFieldIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `field` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `field` being updated. */
  patch: FieldPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameForGameFieldIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameForGameFieldIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameForGameFieldIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameForGameFieldIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameForGameGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameForGameGroupIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameForGameGroupIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameForGameGroupIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameForGameGroupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnGameStateForGameStateGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameStateForGameStateGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameStateForGameStateGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameStateForGameStateGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameStateForGameStateGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameTagForGameTagGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameTagForGameTagGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnGameTagForGameTagGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnGameTagForGameTagGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnLineupChangeForLineupChangeGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: LineupChangePatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupChangeForLineupChangeGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupChangeForLineupChangeGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupChangeForLineupChangeGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupChangeForLineupChangeGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnLineupForGameStateForLineupForGameStateGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupForGameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: LineupForGameStatePatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupForGameStateForLineupForGameStateGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupForGameStateForLineupForGameStateGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupForGameStateForLineupForGameStateGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupForGameStateForLineupForGameStateGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnLineupForLineupGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: LineupPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupForLineupGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupForLineupGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupForLineupGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupForLineupGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnLineupSpotForLineupSpotGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupSpot` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: LineupSpotPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupSpotForLineupSpotGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupSpotForLineupSpotGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnLineupSpotForLineupSpotGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnLineupSpotForLineupSpotGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `outOnPlayRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: OutOnPlayRunnerPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnPlateAppearanceForPlateAppearanceGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnPlateAppearanceForPlateAppearanceGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnPlateAppearanceForPlateAppearanceGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnPlateAppearanceForPlateAppearanceGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnPlateAppearanceForPlateAppearanceGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnScoredRunnerForScoredRunnerGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scoredRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: ScoredRunnerPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnScoredRunnerForScoredRunnerGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnScoredRunnerForScoredRunnerGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnScoredRunnerForScoredRunnerGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnScoredRunnerForScoredRunnerGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `soloModeOpponentInning` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `soloModeOpponentInning` being updated. */
  patch: SoloModeOpponentInningPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `stolenBaseAttempt` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: StolenBaseAttemptPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameOnTeamForTeamGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `team` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: TeamPatch;
};

/** The fields on `game` to look up the row to update. */
export type GameOnTeamForTeamGameIdFkeyUsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnTeamForTeamGameIdFkeyPatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnTeamForTeamGameIdFkeyUsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnTeamForTeamGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnUnifiedGameForFakePublicUnifiedGamesForeignKey1UsingGameNameUniqPerGroupUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnUnifiedGameForFakePublicUnifiedGamesForeignKey1Patch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** The fields on `game` to look up the row to update. */
export type GameOnUnifiedGameForFakePublicUnifiedGamesForeignKey1UsingGamePkeyUpdate = {
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: UpdateGameOnUnifiedGameForFakePublicUnifiedGamesForeignKey1Patch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Game`. Fields that are set will be updated. */
export type GamePatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

export type GameState = Node & {
  __typename?: 'GameState';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  gameId: Scalars['UUID'];
  gameStateIndex: Scalars['Int'];
  playerAtBat: Scalars['UUID'];
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  /** Reads a single `Game` that is related to this `GameState`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `GameState`. */
  playerByPlayerAtBat: Maybe<Player>;
  /** Reads and enables pagination through a set of `BaseRunner`. */
  baseRunners: Array<BaseRunner>;
  /** Reads and enables pagination through a set of `LineupForGameState`. */
  lineupForGameStates: Array<LineupForGameState>;
  /** Reads and enables pagination through a set of `GameEventRecord`. */
  gameEventRecordsByGameStateBeforeId: Array<GameEventRecord>;
  /** Reads and enables pagination through a set of `GameEventRecord`. */
  gameEventRecordsByGameStateAfterId: Array<GameEventRecord>;
  /** Reads and enables pagination through a set of `Lineup`. */
  lineups: Maybe<Array<Maybe<Lineup>>>;
};


export type GameStateBaseRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BaseRunnersOrderBy>>;
  condition?: Maybe<BaseRunnerCondition>;
};


export type GameStateLineupForGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupForGameStatesOrderBy>>;
  condition?: Maybe<LineupForGameStateCondition>;
};


export type GameStateGameEventRecordsByGameStateBeforeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventRecordsOrderBy>>;
  condition?: Maybe<GameEventRecordCondition>;
};


export type GameStateGameEventRecordsByGameStateAfterIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventRecordsOrderBy>>;
  condition?: Maybe<GameEventRecordCondition>;
};


export type GameStateLineupsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};

/**
 * A condition to be used against `GameState` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type GameStateCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameStateIndex` field. */
  gameStateIndex?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerAtBat` field. */
  playerAtBat?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `inning` field. */
  inning?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `halfInning` field. */
  halfInning?: Maybe<HalfInning>;
  /** Checks for equality with the object’s `outs` field. */
  outs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `score` field. */
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
};

/** The `game` to be created by this mutation. */
export type GameStateGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** The `gameState` to be created by this mutation. */
export type GameStateGameIdFkeyGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `game` in the `GameStateInput` mutation. */
export type GameStateGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnGameStateForGameStateGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnGameStateForGameStateGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameStateOnGameStateForGameStateGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<GameStateGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `gameState` in the `GameInput` mutation. */
export type GameStateGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `gameState` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<Array<GameStateGameStatePkeyConnect>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameStateNodeIdConnect>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameStateGameStatePkeyDelete>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameStateNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<Array<GameStateOnGameStateForGameStateGameIdFkeyUsingGameStatePkeyUpdate>>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnGameStateForGameStateGameIdFkeyNodeIdUpdate>>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameStateGameIdFkeyGameStateCreateInput>>;
};

/** The fields on `gameState` to look up the row to connect. */
export type GameStateGameStatePkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `gameState` to look up the row to delete. */
export type GameStateGameStatePkeyDelete = {
  id: Scalars['UUID'];
};

/** An input for mutations affecting `GameState` */
export type GameStateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GameStateNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GameStateNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `gameState` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `baseRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: BaseRunnerPatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnGameEventRecordForGameEventRecordGameStateAfterFkPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnGameStateForGameStateGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnGameStateForGameStateGameIdFkeyUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnGameStateForGameStateGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnGameStateForGameStatePlayerAtBatFkeyUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnGameStateForGameStatePlayerAtBatFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupForGameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: LineupForGameStatePatch;
};

/** The fields on `gameState` to look up the row to update. */
export type GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: UpdateGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `GameState`. Fields that are set will be updated. */
export type GameStatePatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** The `gameState` to be created by this mutation. */
export type GameStatePlayerAtBatFkeyGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `player` in the `GameStateInput` mutation. */
export type GameStatePlayerAtBatFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameStateOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<GameStatePlayerAtBatFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `gameState` in the `PlayerInput` mutation. */
export type GameStatePlayerAtBatFkeyInverseInput = {
  /** Flag indicating whether all other `gameState` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<Array<GameStateGameStatePkeyConnect>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<GameStateNodeIdConnect>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<Array<GameStateGameStatePkeyDelete>>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<GameStateNodeIdDelete>>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<Array<GameStateOnGameStateForGameStatePlayerAtBatFkeyUsingGameStatePkeyUpdate>>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate>>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameStatePlayerAtBatFkeyGameStateCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type GameStatePlayerAtBatFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** Methods to use when ordering `GameState`. */
export enum GameStatesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  GAME_STATE_INDEX_ASC = 'GAME_STATE_INDEX_ASC',
  GAME_STATE_INDEX_DESC = 'GAME_STATE_INDEX_DESC',
  PLAYER_AT_BAT_ASC = 'PLAYER_AT_BAT_ASC',
  PLAYER_AT_BAT_DESC = 'PLAYER_AT_BAT_DESC',
  INNING_ASC = 'INNING_ASC',
  INNING_DESC = 'INNING_DESC',
  HALF_INNING_ASC = 'HALF_INNING_ASC',
  HALF_INNING_DESC = 'HALF_INNING_DESC',
  OUTS_ASC = 'OUTS_ASC',
  OUTS_DESC = 'OUTS_DESC',
  SCORE_ASC = 'SCORE_ASC',
  SCORE_DESC = 'SCORE_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type GameTag = {
  __typename?: 'GameTag';
  gameId: Maybe<Scalars['UUID']>;
  tagId: Maybe<Scalars['UUID']>;
  /** Reads a single `Game` that is related to this `GameTag`. */
  game: Maybe<Game>;
  /** Reads a single `Tag` that is related to this `GameTag`. */
  tag: Maybe<Tag>;
};

/** A condition to be used against `GameTag` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GameTagCondition = {
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `tagId` field. */
  tagId?: Maybe<Scalars['UUID']>;
};

/** The `game` to be created by this mutation. */
export type GameTagGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** The `gameTag` to be created by this mutation. */
export type GameTagGameIdFkeyGameTagCreateInput = {
  tagId?: Maybe<Scalars['UUID']>;
  game?: Maybe<GameTagGameIdFkeyInput>;
  tag?: Maybe<GameTagTagIdFkeyInput>;
};

/** Input for the nested mutation of `game` in the `GameTagInput` mutation. */
export type GameTagGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnGameTagForGameTagGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnGameTagForGameTagGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameTagOnGameTagForGameTagGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<GameTagGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `gameTag` in the `GameInput` mutation. */
export type GameTagGameIdFkeyInverseInput = {
  /** A `GameTagInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameTagGameIdFkeyGameTagCreateInput>>;
};

/** An input for mutations affecting `GameTag` */
export type GameTagInput = {
  gameId?: Maybe<Scalars['UUID']>;
  tagId?: Maybe<Scalars['UUID']>;
  game?: Maybe<GameTagGameIdFkeyInput>;
  tag?: Maybe<GameTagTagIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to update. */
export type GameTagOnGameTagForGameTagGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The globally unique `ID` look up for the row to update. */
export type GameTagOnGameTagForGameTagTagIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `tag` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `tag` being updated. */
  patch: TagPatch;
};

/** The `gameTag` to be created by this mutation. */
export type GameTagTagIdFkeyGameTagCreateInput = {
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<GameTagGameIdFkeyInput>;
  tag?: Maybe<GameTagTagIdFkeyInput>;
};

/** Input for the nested mutation of `tag` in the `GameTagInput` mutation. */
export type GameTagTagIdFkeyInput = {
  /** The primary key(s) for `tag` for the far side of the relationship. */
  connectById?: Maybe<TagTagPkeyConnect>;
  /** The primary key(s) for `tag` for the far side of the relationship. */
  connectByName?: Maybe<TagTagNameKeyConnect>;
  /** The primary key(s) for `tag` for the far side of the relationship. */
  connectByNodeId?: Maybe<TagNodeIdConnect>;
  /** The primary key(s) for `tag` for the far side of the relationship. */
  deleteById?: Maybe<TagTagPkeyDelete>;
  /** The primary key(s) for `tag` for the far side of the relationship. */
  deleteByName?: Maybe<TagTagNameKeyDelete>;
  /** The primary key(s) for `tag` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TagNodeIdDelete>;
  /** The primary key(s) and patch data for `tag` for the far side of the relationship. */
  updateById?: Maybe<TagOnGameTagForGameTagTagIdFkeyUsingTagPkeyUpdate>;
  /** The primary key(s) and patch data for `tag` for the far side of the relationship. */
  updateByName?: Maybe<TagOnGameTagForGameTagTagIdFkeyUsingTagNameKeyUpdate>;
  /** The primary key(s) and patch data for `tag` for the far side of the relationship. */
  updateByNodeId?: Maybe<GameTagOnGameTagForGameTagTagIdFkeyNodeIdUpdate>;
  /** A `TagInput` object that will be created and connected to this object. */
  create?: Maybe<GameTagTagIdFkeyTagCreateInput>;
};

/** Input for the nested mutation of `gameTag` in the `TagInput` mutation. */
export type GameTagTagIdFkeyInverseInput = {
  /** A `GameTagInput` object that will be created and connected to this object. */
  create?: Maybe<Array<GameTagTagIdFkeyGameTagCreateInput>>;
};

/** The `tag` to be created by this mutation. */
export type GameTagTagIdFkeyTagCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  type?: Maybe<TagType>;
  gameTags?: Maybe<GameTagTagIdFkeyInverseInput>;
};

/** Methods to use when ordering `GameTag`. */
export enum GameTagsOrderBy {
  NATURAL = 'NATURAL',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  TAG_ID_ASC = 'TAG_ID_ASC',
  TAG_ID_DESC = 'TAG_ID_DESC'
}

/** Methods to use when ordering `Game`. */
export enum GamesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  FIELD_ID_ASC = 'FIELD_ID_ASC',
  FIELD_ID_DESC = 'FIELD_ID_DESC',
  SCORE_ASC = 'SCORE_ASC',
  SCORE_DESC = 'SCORE_DESC',
  GAME_LENGTH_ASC = 'GAME_LENGTH_ASC',
  GAME_LENGTH_DESC = 'GAME_LENGTH_DESC',
  TIME_STARTED_ASC = 'TIME_STARTED_ASC',
  TIME_STARTED_DESC = 'TIME_STARTED_DESC',
  TIME_ENDED_ASC = 'TIME_ENDED_ASC',
  TIME_ENDED_DESC = 'TIME_ENDED_DESC',
  TIME_SAVED_ASC = 'TIME_SAVED_ASC',
  TIME_SAVED_DESC = 'TIME_SAVED_DESC',
  SOLO_MODE_ASC = 'SOLO_MODE_ASC',
  SOLO_MODE_DESC = 'SOLO_MODE_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export enum Gender {
  MALE = 'MALE',
  FEMALE = 'FEMALE'
}

/** The return type of our `getPlateAppearancesConnection` query. */
export type GetPlateAppearancesRecord = {
  __typename?: 'GetPlateAppearancesRecord';
  gameId: Maybe<Scalars['UUID']>;
  gameStartTime: Maybe<Scalars['Datetime']>;
  playerId: Maybe<Scalars['UUID']>;
  type: Maybe<PlateAppearanceType>;
  contact: Maybe<ContactQuality>;
  hitTo: Maybe<FieldingPosition>;
  runsScored: Maybe<Scalars['Int']>;
  inning: Maybe<Scalars['Int']>;
  halfInning: Maybe<HalfInning>;
  gameStateBeforeId: Maybe<Scalars['UUID']>;
  gameEventRecordId: Maybe<Scalars['UUID']>;
};

/** The return type of our `getRunsScoredConnection` query. */
export type GetRunsScoredRecord = {
  __typename?: 'GetRunsScoredRecord';
  batterId: Maybe<Scalars['UUID']>;
  runnerId: Maybe<Scalars['UUID']>;
  battedIn: Maybe<Scalars['Boolean']>;
};

export type Group = Node & {
  __typename?: 'Group';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  name: Scalars['String'];
  notes: Maybe<Scalars['String']>;
  soloMode: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats: Maybe<Scalars['Boolean']>;
  allowSteals: Maybe<Scalars['Boolean']>;
  /** Reads and enables pagination through a set of `Game`. */
  games: Array<Game>;
  /** Reads and enables pagination through a set of `PlayerGroupMembership`. */
  playerGroupMemberships: Array<PlayerGroupMembership>;
  /** Reads and enables pagination through a set of `CareerStat`. */
  careerStats: Array<CareerStat>;
  /** Reads and enables pagination through a set of `CareerStatsQualifiedBatter`. */
  careerStatsQualifiedBatters: Array<CareerStatsQualifiedBatter>;
  /** Reads and enables pagination through a set of `LegacySeasonStat`. */
  legacySeasonStats: Array<LegacySeasonStat>;
  /** Reads and enables pagination through a set of `SeasonStat`. */
  seasonStats: Array<SeasonStat>;
  /** Reads and enables pagination through a set of `SeasonStatsAllTimeQualifiedBatter`. */
  seasonStatsAllTimeQualifiedBatters: Array<SeasonStatsAllTimeQualifiedBatter>;
  /** Reads and enables pagination through a set of `SeasonStatsQualifiedBatter`. */
  seasonStatsQualifiedBatters: Array<SeasonStatsQualifiedBatter>;
  /** Reads and enables pagination through a set of `UnifiedGame`. */
  unifiedGames: Array<UnifiedGame>;
  allSeasons: Maybe<Array<Maybe<Scalars['Int']>>>;
  /** Reads and enables pagination through a set of `Player`. */
  players: Maybe<Array<Maybe<Player>>>;
};


export type GroupGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GamesOrderBy>>;
  condition?: Maybe<GameCondition>;
};


export type GroupPlayerGroupMembershipsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlayerGroupMembershipsOrderBy>>;
  condition?: Maybe<PlayerGroupMembershipCondition>;
};


export type GroupCareerStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsOrderBy>>;
  condition?: Maybe<CareerStatCondition>;
};


export type GroupCareerStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<CareerStatsQualifiedBatterCondition>;
};


export type GroupLegacySeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacySeasonStatsOrderBy>>;
  condition?: Maybe<LegacySeasonStatCondition>;
};


export type GroupSeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsOrderBy>>;
  condition?: Maybe<SeasonStatCondition>;
};


export type GroupSeasonStatsAllTimeQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsAllTimeQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsAllTimeQualifiedBatterCondition>;
};


export type GroupSeasonStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsQualifiedBatterCondition>;
};


export type GroupUnifiedGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UnifiedGamesOrderBy>>;
  condition?: Maybe<UnifiedGameCondition>;
};


export type GroupAllSeasonsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};


export type GroupPlayersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};

/** A condition to be used against `Group` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type GroupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `notes` field. */
  notes?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `soloMode` field. */
  soloMode?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `urlSlug` field. */
  urlSlug?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `allowSkippingAtBats` field. */
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `allowSteals` field. */
  allowSteals?: Maybe<Scalars['Boolean']>;
};

/** The fields on `group` to look up the row to connect. */
export type GroupGroupNameKeyConnect = {
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to delete. */
export type GroupGroupNameKeyDelete = {
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to connect. */
export type GroupGroupPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to delete. */
export type GroupGroupPkeyDelete = {
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to connect. */
export type GroupGroupUrlSlugKeyConnect = {
  urlSlug: Scalars['String'];
};

/** The fields on `group` to look up the row to delete. */
export type GroupGroupUrlSlugKeyDelete = {
  urlSlug: Scalars['String'];
};

/** An input for mutations affecting `Group` */
export type GroupInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type GroupNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type GroupNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `group` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnCareerStatForFakePublicCareerStatsForeignKey2UsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnCareerStatForFakePublicCareerStatsForeignKey2Patch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnCareerStatForFakePublicCareerStatsForeignKey2UsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnCareerStatForFakePublicCareerStatsForeignKey2Patch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnCareerStatForFakePublicCareerStatsForeignKey2UsingGroupUrlSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnCareerStatForFakePublicCareerStatsForeignKey2Patch;
  urlSlug: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2UsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2Patch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2UsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2Patch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2UsingGroupUrlSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2Patch;
  urlSlug: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type GroupOnGameForGameGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `group` to look up the row to update. */
export type GroupOnGameForGameGroupIdFkeyUsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnGameForGameGroupIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnGameForGameGroupIdFkeyUsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnGameForGameGroupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnGameForGameGroupIdFkeyUsingGroupUrlSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnGameForGameGroupIdFkeyPatch;
  urlSlug: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2UsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2Patch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2UsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2Patch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2UsingGroupUrlSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2Patch;
  urlSlug: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `playerGroupMembership` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `playerGroupMembership` being updated. */
  patch: PlayerGroupMembershipPatch;
};

/** The fields on `group` to look up the row to update. */
export type GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingGroupUrlSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyPatch;
  urlSlug: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonStatForFakePublicSeasonStatsForeignKey2UsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonStatForFakePublicSeasonStatsForeignKey2Patch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonStatForFakePublicSeasonStatsForeignKey2UsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonStatForFakePublicSeasonStatsForeignKey2Patch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonStatForFakePublicSeasonStatsForeignKey2UsingGroupUrlSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonStatForFakePublicSeasonStatsForeignKey2Patch;
  urlSlug: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2UsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2Patch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2UsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2Patch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2UsingGroupUrlSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2Patch;
  urlSlug: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2UsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2Patch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2UsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2Patch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2UsingGroupUrlSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2Patch;
  urlSlug: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnUnifiedGameForFakePublicUnifiedGamesForeignKey0UsingGroupNameKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnUnifiedGameForFakePublicUnifiedGamesForeignKey0Patch;
  name: Scalars['String'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnUnifiedGameForFakePublicUnifiedGamesForeignKey0UsingGroupPkeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnUnifiedGameForFakePublicUnifiedGamesForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The fields on `group` to look up the row to update. */
export type GroupOnUnifiedGameForFakePublicUnifiedGamesForeignKey0UsingGroupUrlSlugKeyUpdate = {
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: UpdateGroupOnUnifiedGameForFakePublicUnifiedGamesForeignKey0Patch;
  urlSlug: Scalars['String'];
};

/** Represents an update to a `Group`. Fields that are set will be updated. */
export type GroupPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

export enum GroupPermissionType {
  SAVE_GAMES = 'SAVE_GAMES',
  DRAFT_TEAMS = 'DRAFT_TEAMS',
  ADD_PLAYERS_TO_GROUP = 'ADD_PLAYERS_TO_GROUP'
}

/** Methods to use when ordering `Group`. */
export enum GroupsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  NOTES_ASC = 'NOTES_ASC',
  NOTES_DESC = 'NOTES_DESC',
  SOLO_MODE_ASC = 'SOLO_MODE_ASC',
  SOLO_MODE_DESC = 'SOLO_MODE_DESC',
  URL_SLUG_ASC = 'URL_SLUG_ASC',
  URL_SLUG_DESC = 'URL_SLUG_DESC',
  ALLOW_SKIPPING_AT_BATS_ASC = 'ALLOW_SKIPPING_AT_BATS_ASC',
  ALLOW_SKIPPING_AT_BATS_DESC = 'ALLOW_SKIPPING_AT_BATS_DESC',
  ALLOW_STEALS_ASC = 'ALLOW_STEALS_ASC',
  ALLOW_STEALS_DESC = 'ALLOW_STEALS_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export enum HalfInning {
  TOP = 'TOP',
  BOTTOM = 'BOTTOM'
}

export enum Handedness {
  LEFT = 'LEFT',
  RIGHT = 'RIGHT',
  BOTH = 'BOTH'
}

/** All input for the `initiatePasswordReset` mutation. */
export type InitiatePasswordResetInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  email: Scalars['String'];
};

/** The output of our `initiatePasswordReset` mutation. */
export type InitiatePasswordResetPayload = {
  __typename?: 'InitiatePasswordResetPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `initiatePlayerClaim` mutation. */
export type InitiatePlayerClaimInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  playerId: Scalars['UUID'];
  email: Scalars['String'];
};

/** The output of our `initiatePlayerClaim` mutation. */
export type InitiatePlayerClaimPayload = {
  __typename?: 'InitiatePlayerClaimPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  boolean: Maybe<Scalars['Boolean']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};



export type LegacyField = Node & {
  __typename?: 'LegacyField';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  fieldId: Scalars['Int'];
  fieldName: Maybe<Scalars['String']>;
  fieldAddress: Maybe<Scalars['String']>;
  fieldNumber: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `LegacyField` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LegacyFieldCondition = {
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `fieldName` field. */
  fieldName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fieldAddress` field. */
  fieldAddress?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `fieldNumber` field. */
  fieldNumber?: Maybe<Scalars['String']>;
};

/** Methods to use when ordering `LegacyField`. */
export enum LegacyFieldsOrderBy {
  NATURAL = 'NATURAL',
  FIELD_ID_ASC = 'FIELD_ID_ASC',
  FIELD_ID_DESC = 'FIELD_ID_DESC',
  FIELD_NAME_ASC = 'FIELD_NAME_ASC',
  FIELD_NAME_DESC = 'FIELD_NAME_DESC',
  FIELD_ADDRESS_ASC = 'FIELD_ADDRESS_ASC',
  FIELD_ADDRESS_DESC = 'FIELD_ADDRESS_DESC',
  FIELD_NUMBER_ASC = 'FIELD_NUMBER_ASC',
  FIELD_NUMBER_DESC = 'FIELD_NUMBER_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type LegacyGame = Node & {
  __typename?: 'LegacyGame';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameId: Scalars['Int'];
  gameTitle: Maybe<Scalars['String']>;
  gameDate: Maybe<Scalars['Date']>;
  gameStartTime: Maybe<Scalars['Time']>;
  gameEndTime: Maybe<Scalars['Time']>;
  gameTeamId1: Maybe<Scalars['Int']>;
  gameTeamId2: Maybe<Scalars['Int']>;
  season: Maybe<Scalars['Int']>;
  /** Reads a single `LegacyTeam` that is related to this `LegacyGame`. */
  legacyTeamByGameTeamId1: Maybe<LegacyTeam>;
  /** Reads a single `LegacyTeam` that is related to this `LegacyGame`. */
  legacyTeamByGameTeamId2: Maybe<LegacyTeam>;
  /** Reads and enables pagination through a set of `LegacyGameBattingLine`. */
  legacyGameBattingLines: Array<LegacyGameBattingLine>;
  /** Reads and enables pagination through a set of `UnifiedGame`. */
  unifiedGames: Array<UnifiedGame>;
  score: Maybe<Array<Maybe<Scalars['Int']>>>;
};


export type LegacyGameLegacyGameBattingLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyGameBattingLinesOrderBy>>;
  condition?: Maybe<LegacyGameBattingLineCondition>;
};


export type LegacyGameUnifiedGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UnifiedGamesOrderBy>>;
  condition?: Maybe<UnifiedGameCondition>;
};

export type LegacyGameBattingLine = Node & {
  __typename?: 'LegacyGameBattingLine';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  playerId: Maybe<Scalars['UUID']>;
  legacyPlayerId: Scalars['Int'];
  legacyGameId: Scalars['Int'];
  season: Maybe<Scalars['Int']>;
  legacyTeamId: Maybe<Scalars['Int']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
  /** Reads a single `Player` that is related to this `LegacyGameBattingLine`. */
  player: Maybe<Player>;
  /** Reads a single `LegacyPlayer` that is related to this `LegacyGameBattingLine`. */
  legacyPlayer: Maybe<LegacyPlayer>;
  /** Reads a single `LegacyGame` that is related to this `LegacyGameBattingLine`. */
  legacyGame: Maybe<LegacyGame>;
  /** Reads a single `LegacyStatLine` that is related to this `LegacyGameBattingLine`. */
  legacyPlayerLegacyGameLegacyTeam: Maybe<LegacyStatLine>;
  statLineId: Maybe<Scalars['Int']>;
};

/**
 * A condition to be used against `LegacyGameBattingLine` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type LegacyGameBattingLineCondition = {
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `legacyGameId` field. */
  legacyGameId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `legacyTeamId` field. */
  legacyTeamId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The fields on `legacyGameBattingLine` to look up the row to connect. */
export type LegacyGameBattingLineFakePublicLegacyGameBattingLinesPrimaryKeyConnect = {
  legacyPlayerId: Scalars['Int'];
  legacyGameId: Scalars['Int'];
};

/** The fields on `legacyGameBattingLine` to look up the row to delete. */
export type LegacyGameBattingLineFakePublicLegacyGameBattingLinesPrimaryKeyDelete = {
  legacyPlayerId: Scalars['Int'];
  legacyGameId: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LegacyGameBattingLineNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `legacyGameBattingLine` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LegacyGameBattingLineNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `legacyGameBattingLine` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `legacyGameBattingLine` to look up the row to update. */
export type LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey0UsingFakePublicLegacyGameBattingLinesPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyGameBattingLine` being updated. */
  patch: UpdateLegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey0Patch;
  legacyPlayerId: Scalars['Int'];
  legacyGameId: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: LegacyPlayerPatch;
};

/** The fields on `legacyGameBattingLine` to look up the row to update. */
export type LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey1UsingFakePublicLegacyGameBattingLinesPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyGameBattingLine` being updated. */
  patch: UpdateLegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey1Patch;
  legacyPlayerId: Scalars['Int'];
  legacyGameId: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyGame` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyGame` being updated. */
  patch: LegacyGamePatch;
};

/** The fields on `legacyGameBattingLine` to look up the row to update. */
export type LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey2UsingFakePublicLegacyGameBattingLinesPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyGameBattingLine` being updated. */
  patch: UpdateLegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey2Patch;
  legacyPlayerId: Scalars['Int'];
  legacyGameId: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey3NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyStatLine` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyStatLine` being updated. */
  patch: LegacyStatLinePatch;
};

/** The fields on `legacyGameBattingLine` to look up the row to update. */
export type LegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey3UsingFakePublicLegacyGameBattingLinesPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyGameBattingLine` being updated. */
  patch: UpdateLegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey3Patch;
  legacyPlayerId: Scalars['Int'];
  legacyGameId: Scalars['Int'];
};

/** Represents an update to a `LegacyGameBattingLine`. Fields that are set will be updated. */
export type LegacyGameBattingLinePatch = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  legacyGameId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeamId?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1Input>;
  legacyGame?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2Input>;
  legacyStatLine?: Maybe<FakePublicLegacyGameBattingLinesForeignKey3Input>;
};

/** Methods to use when ordering `LegacyGameBattingLine`. */
export enum LegacyGameBattingLinesOrderBy {
  NATURAL = 'NATURAL',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  LEGACY_GAME_ID_ASC = 'LEGACY_GAME_ID_ASC',
  LEGACY_GAME_ID_DESC = 'LEGACY_GAME_ID_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  LEGACY_TEAM_ID_ASC = 'LEGACY_TEAM_ID_ASC',
  LEGACY_TEAM_ID_DESC = 'LEGACY_TEAM_ID_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `LegacyGame` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LegacyGameCondition = {
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameTitle` field. */
  gameTitle?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `gameDate` field. */
  gameDate?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `gameStartTime` field. */
  gameStartTime?: Maybe<Scalars['Time']>;
  /** Checks for equality with the object’s `gameEndTime` field. */
  gameEndTime?: Maybe<Scalars['Time']>;
  /** Checks for equality with the object’s `gameTeamId1` field. */
  gameTeamId1?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameTeamId2` field. */
  gameTeamId2?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
};

/** The fields on `legacyGame` to look up the row to connect. */
export type LegacyGameFakePublicLegacyGamePrimaryKeyConnect = {
  gameId: Scalars['Int'];
};

/** The fields on `legacyGame` to look up the row to delete. */
export type LegacyGameFakePublicLegacyGamePrimaryKeyDelete = {
  gameId: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LegacyGameNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `legacyGame` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LegacyGameNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `legacyGame` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyGameOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyGameBattingLine` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyGameBattingLine` being updated. */
  patch: LegacyGameBattingLinePatch;
};

/** The fields on `legacyGame` to look up the row to update. */
export type LegacyGameOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey2UsingFakePublicLegacyGamePrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyGame` being updated. */
  patch: UpdateLegacyGameOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey2Patch;
  gameId: Scalars['Int'];
};

/** The fields on `legacyGame` to look up the row to update. */
export type LegacyGameOnLegacyGameForFakePublicLegacyGameForeignKey0UsingFakePublicLegacyGamePrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyGame` being updated. */
  patch: UpdateLegacyGameOnLegacyGameForFakePublicLegacyGameForeignKey0Patch;
  gameId: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyGameOnLegacyGameForFakePublicLegacyGameForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyTeam` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyTeam` being updated. */
  patch: LegacyTeamPatch;
};

/** The fields on `legacyGame` to look up the row to update. */
export type LegacyGameOnLegacyGameForFakePublicLegacyGameForeignKey1UsingFakePublicLegacyGamePrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyGame` being updated. */
  patch: UpdateLegacyGameOnLegacyGameForFakePublicLegacyGameForeignKey1Patch;
  gameId: Scalars['Int'];
};

/** The fields on `legacyGame` to look up the row to update. */
export type LegacyGameOnUnifiedGameForFakePublicUnifiedGamesForeignKey2UsingFakePublicLegacyGamePrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyGame` being updated. */
  patch: UpdateLegacyGameOnUnifiedGameForFakePublicUnifiedGamesForeignKey2Patch;
  gameId: Scalars['Int'];
};

/** Represents an update to a `LegacyGame`. Fields that are set will be updated. */
export type LegacyGamePatch = {
  gameId?: Maybe<Scalars['Int']>;
  gameTitle?: Maybe<Scalars['String']>;
  gameDate?: Maybe<Scalars['Date']>;
  gameStartTime?: Maybe<Scalars['Time']>;
  gameEndTime?: Maybe<Scalars['Time']>;
  gameTeamId1?: Maybe<Scalars['Int']>;
  gameTeamId2?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeam?: Maybe<FakePublicLegacyGameForeignKey1Input>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey2InverseInput>;
};

/** Methods to use when ordering `LegacyGame`. */
export enum LegacyGamesOrderBy {
  NATURAL = 'NATURAL',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  GAME_TITLE_ASC = 'GAME_TITLE_ASC',
  GAME_TITLE_DESC = 'GAME_TITLE_DESC',
  GAME_DATE_ASC = 'GAME_DATE_ASC',
  GAME_DATE_DESC = 'GAME_DATE_DESC',
  GAME_START_TIME_ASC = 'GAME_START_TIME_ASC',
  GAME_START_TIME_DESC = 'GAME_START_TIME_DESC',
  GAME_END_TIME_ASC = 'GAME_END_TIME_ASC',
  GAME_END_TIME_DESC = 'GAME_END_TIME_DESC',
  GAME_TEAM_ID_1_ASC = 'GAME_TEAM_ID_1_ASC',
  GAME_TEAM_ID_1_DESC = 'GAME_TEAM_ID_1_DESC',
  GAME_TEAM_ID_2_ASC = 'GAME_TEAM_ID_2_ASC',
  GAME_TEAM_ID_2_DESC = 'GAME_TEAM_ID_2_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type LegacyMeetupFieldRaw = Node & {
  __typename?: 'LegacyMeetupFieldRaw';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  subField: Maybe<Scalars['String']>;
  address: Scalars['String'];
  rating: Scalars['Int'];
  /** Reads and enables pagination through a set of `LegacyMeetupGameRaw`. */
  legacyMeetupGameRawsByFieldId: Array<LegacyMeetupGameRaw>;
};


export type LegacyMeetupFieldRawLegacyMeetupGameRawsByFieldIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyMeetupGameRawsOrderBy>>;
  condition?: Maybe<LegacyMeetupGameRawCondition>;
};

/**
 * A condition to be used against `LegacyMeetupFieldRaw` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type LegacyMeetupFieldRawCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `subField` field. */
  subField?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address` field. */
  address?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `rating` field. */
  rating?: Maybe<Scalars['Int']>;
};

/** An input for mutations affecting `LegacyMeetupFieldRaw` */
export type LegacyMeetupFieldRawInput = {
  id: Scalars['Int'];
  name: Scalars['String'];
  subField?: Maybe<Scalars['String']>;
  address: Scalars['String'];
  rating: Scalars['Int'];
  legacyMeetupGameRaws?: Maybe<LegacyMeetupGameRawFieldIdFkeyInverseInput>;
};

/** The fields on `legacyMeetupFieldRaw` to look up the row to connect. */
export type LegacyMeetupFieldRawLegacyMeetupFieldRawNameSubFieldKeyConnect = {
  name: Scalars['String'];
  subField: Scalars['String'];
};

/** The fields on `legacyMeetupFieldRaw` to look up the row to delete. */
export type LegacyMeetupFieldRawLegacyMeetupFieldRawNameSubFieldKeyDelete = {
  name: Scalars['String'];
  subField: Scalars['String'];
};

/** The fields on `legacyMeetupFieldRaw` to look up the row to connect. */
export type LegacyMeetupFieldRawLegacyMeetupFieldRawPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `legacyMeetupFieldRaw` to look up the row to delete. */
export type LegacyMeetupFieldRawLegacyMeetupFieldRawPkeyDelete = {
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LegacyMeetupFieldRawNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `legacyMeetupFieldRaw` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LegacyMeetupFieldRawNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `legacyMeetupFieldRaw` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyMeetupFieldRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyMeetupGameRaw` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
  patch: LegacyMeetupGameRawPatch;
};

/** The fields on `legacyMeetupFieldRaw` to look up the row to update. */
export type LegacyMeetupFieldRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyUsingLegacyMeetupFieldRawNameSubFieldKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupFieldRaw` being updated. */
  patch: UpdateLegacyMeetupFieldRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyPatch;
  name: Scalars['String'];
  subField: Scalars['String'];
};

/** The fields on `legacyMeetupFieldRaw` to look up the row to update. */
export type LegacyMeetupFieldRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyUsingLegacyMeetupFieldRawPkeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupFieldRaw` being updated. */
  patch: UpdateLegacyMeetupFieldRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `LegacyMeetupFieldRaw`. Fields that are set will be updated. */
export type LegacyMeetupFieldRawPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  subField?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  rating?: Maybe<Scalars['Int']>;
  legacyMeetupGameRaws?: Maybe<LegacyMeetupGameRawFieldIdFkeyInverseInput>;
};

/** Methods to use when ordering `LegacyMeetupFieldRaw`. */
export enum LegacyMeetupFieldRawsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  SUB_FIELD_ASC = 'SUB_FIELD_ASC',
  SUB_FIELD_DESC = 'SUB_FIELD_DESC',
  ADDRESS_ASC = 'ADDRESS_ASC',
  ADDRESS_DESC = 'ADDRESS_DESC',
  RATING_ASC = 'RATING_ASC',
  RATING_DESC = 'RATING_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type LegacyMeetupGameRaw = Node & {
  __typename?: 'LegacyMeetupGameRaw';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  season: Scalars['Int'];
  date: Scalars['Date'];
  timeStarted: Scalars['Time'];
  timeEnded: Scalars['Time'];
  winningTeamId: Scalars['Int'];
  losingTeamId: Scalars['Int'];
  fieldId: Scalars['Int'];
  imageGalleryUrl: Maybe<Scalars['String']>;
  meetupEventId: Maybe<Scalars['String']>;
  dateInserted: Maybe<Scalars['Date']>;
  dateUpdated: Maybe<Scalars['Date']>;
  advanced: Scalars['Boolean'];
  /** Reads a single `LegacyMeetupTeamRaw` that is related to this `LegacyMeetupGameRaw`. */
  winningTeam: Maybe<LegacyMeetupTeamRaw>;
  /** Reads a single `LegacyMeetupTeamRaw` that is related to this `LegacyMeetupGameRaw`. */
  losingTeam: Maybe<LegacyMeetupTeamRaw>;
  /** Reads a single `LegacyMeetupFieldRaw` that is related to this `LegacyMeetupGameRaw`. */
  field: Maybe<LegacyMeetupFieldRaw>;
  /** Reads and enables pagination through a set of `LegacyMeetupStatLineRaw`. */
  legacyMeetupStatLineRawsByGameId: Array<LegacyMeetupStatLineRaw>;
};


export type LegacyMeetupGameRawLegacyMeetupStatLineRawsByGameIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyMeetupStatLineRawsOrderBy>>;
  condition?: Maybe<LegacyMeetupStatLineRawCondition>;
};

/**
 * A condition to be used against `LegacyMeetupGameRaw` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type LegacyMeetupGameRawCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `date` field. */
  date?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `timeStarted` field. */
  timeStarted?: Maybe<Scalars['Time']>;
  /** Checks for equality with the object’s `timeEnded` field. */
  timeEnded?: Maybe<Scalars['Time']>;
  /** Checks for equality with the object’s `winningTeamId` field. */
  winningTeamId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `losingTeamId` field. */
  losingTeamId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `fieldId` field. */
  fieldId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `imageGalleryUrl` field. */
  imageGalleryUrl?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `meetupEventId` field. */
  meetupEventId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dateInserted` field. */
  dateInserted?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `dateUpdated` field. */
  dateUpdated?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `advanced` field. */
  advanced?: Maybe<Scalars['Boolean']>;
};

/** Input for the nested mutation of `legacyMeetupFieldRaw` in the `LegacyMeetupGameRawInput` mutation. */
export type LegacyMeetupGameRawFieldIdFkeyInput = {
  /** The primary key(s) for `legacyMeetupFieldRaw` for the far side of the relationship. */
  connectById?: Maybe<LegacyMeetupFieldRawLegacyMeetupFieldRawPkeyConnect>;
  /** The primary key(s) for `legacyMeetupFieldRaw` for the far side of the relationship. */
  connectByNameAndSubField?: Maybe<LegacyMeetupFieldRawLegacyMeetupFieldRawNameSubFieldKeyConnect>;
  /** The primary key(s) for `legacyMeetupFieldRaw` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyMeetupFieldRawNodeIdConnect>;
  /** The primary key(s) for `legacyMeetupFieldRaw` for the far side of the relationship. */
  deleteById?: Maybe<LegacyMeetupFieldRawLegacyMeetupFieldRawPkeyDelete>;
  /** The primary key(s) for `legacyMeetupFieldRaw` for the far side of the relationship. */
  deleteByNameAndSubField?: Maybe<LegacyMeetupFieldRawLegacyMeetupFieldRawNameSubFieldKeyDelete>;
  /** The primary key(s) for `legacyMeetupFieldRaw` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyMeetupFieldRawNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyMeetupFieldRaw` for the far side of the relationship. */
  updateById?: Maybe<LegacyMeetupFieldRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyUsingLegacyMeetupFieldRawPkeyUpdate>;
  /** The primary key(s) and patch data for `legacyMeetupFieldRaw` for the far side of the relationship. */
  updateByNameAndSubField?: Maybe<LegacyMeetupFieldRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyUsingLegacyMeetupFieldRawNameSubFieldKeyUpdate>;
  /** The primary key(s) and patch data for `legacyMeetupFieldRaw` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyNodeIdUpdate>;
  /** A `LegacyMeetupFieldRawInput` object that will be created and connected to this object. */
  create?: Maybe<LegacyMeetupGameRawFieldIdFkeyLegacyMeetupFieldRawCreateInput>;
};

/** Input for the nested mutation of `legacyMeetupGameRaw` in the `LegacyMeetupFieldRawInput` mutation. */
export type LegacyMeetupGameRawFieldIdFkeyInverseInput = {
  /** Flag indicating whether all other `legacyMeetupGameRaw` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  connectById?: Maybe<Array<LegacyMeetupGameRawLegacyMeetupGameRawPkeyConnect>>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  connectByName?: Maybe<Array<LegacyMeetupGameRawLegacyMeetupGameRawNameKeyConnect>>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LegacyMeetupGameRawNodeIdConnect>>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  deleteById?: Maybe<Array<LegacyMeetupGameRawLegacyMeetupGameRawPkeyDelete>>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  deleteByName?: Maybe<Array<LegacyMeetupGameRawLegacyMeetupGameRawNameKeyDelete>>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LegacyMeetupGameRawNodeIdDelete>>;
  /** The primary key(s) and patch data for `legacyMeetupGameRaw` for the far side of the relationship. */
  updateById?: Maybe<Array<LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyUsingLegacyMeetupGameRawPkeyUpdate>>;
  /** The primary key(s) and patch data for `legacyMeetupGameRaw` for the far side of the relationship. */
  updateByName?: Maybe<Array<LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyUsingLegacyMeetupGameRawNameKeyUpdate>>;
  /** The primary key(s) and patch data for `legacyMeetupGameRaw` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LegacyMeetupFieldRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyNodeIdUpdate>>;
  /** A `LegacyMeetupGameRawInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LegacyMeetupGameRawFieldIdFkeyLegacyMeetupGameRawCreateInput>>;
};

/** The `legacyMeetupFieldRaw` to be created by this mutation. */
export type LegacyMeetupGameRawFieldIdFkeyLegacyMeetupFieldRawCreateInput = {
  id: Scalars['Int'];
  name: Scalars['String'];
  subField?: Maybe<Scalars['String']>;
  address: Scalars['String'];
  rating: Scalars['Int'];
  legacyMeetupGameRaws?: Maybe<LegacyMeetupGameRawFieldIdFkeyInverseInput>;
};

/** The `legacyMeetupGameRaw` to be created by this mutation. */
export type LegacyMeetupGameRawFieldIdFkeyLegacyMeetupGameRawCreateInput = {
  id: Scalars['Int'];
  name: Scalars['String'];
  season: Scalars['Int'];
  date: Scalars['Date'];
  timeStarted: Scalars['Time'];
  timeEnded: Scalars['Time'];
  winningTeamId?: Maybe<Scalars['Int']>;
  losingTeamId?: Maybe<Scalars['Int']>;
  imageGalleryUrl?: Maybe<Scalars['String']>;
  meetupEventId?: Maybe<Scalars['String']>;
  dateInserted?: Maybe<Scalars['Date']>;
  dateUpdated?: Maybe<Scalars['Date']>;
  advanced: Scalars['Boolean'];
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInput>;
  legacyMeetupFieldRaw?: Maybe<LegacyMeetupGameRawFieldIdFkeyInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInverseInput>;
};

/** An input for mutations affecting `LegacyMeetupGameRaw` */
export type LegacyMeetupGameRawInput = {
  id: Scalars['Int'];
  name: Scalars['String'];
  season: Scalars['Int'];
  date: Scalars['Date'];
  timeStarted: Scalars['Time'];
  timeEnded: Scalars['Time'];
  winningTeamId?: Maybe<Scalars['Int']>;
  losingTeamId?: Maybe<Scalars['Int']>;
  fieldId?: Maybe<Scalars['Int']>;
  imageGalleryUrl?: Maybe<Scalars['String']>;
  meetupEventId?: Maybe<Scalars['String']>;
  dateInserted?: Maybe<Scalars['Date']>;
  dateUpdated?: Maybe<Scalars['Date']>;
  advanced: Scalars['Boolean'];
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInput>;
  legacyMeetupFieldRaw?: Maybe<LegacyMeetupGameRawFieldIdFkeyInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInverseInput>;
};

/** The fields on `legacyMeetupGameRaw` to look up the row to connect. */
export type LegacyMeetupGameRawLegacyMeetupGameRawNameKeyConnect = {
  name: Scalars['String'];
};

/** The fields on `legacyMeetupGameRaw` to look up the row to delete. */
export type LegacyMeetupGameRawLegacyMeetupGameRawNameKeyDelete = {
  name: Scalars['String'];
};

/** The fields on `legacyMeetupGameRaw` to look up the row to connect. */
export type LegacyMeetupGameRawLegacyMeetupGameRawPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `legacyMeetupGameRaw` to look up the row to delete. */
export type LegacyMeetupGameRawLegacyMeetupGameRawPkeyDelete = {
  id: Scalars['Int'];
};

/** Input for the nested mutation of `legacyMeetupTeamRaw` in the `LegacyMeetupGameRawInput` mutation. */
export type LegacyMeetupGameRawLosingTeamIdFkeyInput = {
  /** The primary key(s) for `legacyMeetupTeamRaw` for the far side of the relationship. */
  connectById?: Maybe<LegacyMeetupTeamRawLegacyMeetupTeamRawPkeyConnect>;
  /** The primary key(s) for `legacyMeetupTeamRaw` for the far side of the relationship. */
  connectByName?: Maybe<LegacyMeetupTeamRawLegacyMeetupTeamRawNameKeyConnect>;
  /** The primary key(s) for `legacyMeetupTeamRaw` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyMeetupTeamRawNodeIdConnect>;
  /** The primary key(s) for `legacyMeetupTeamRaw` for the far side of the relationship. */
  deleteById?: Maybe<LegacyMeetupTeamRawLegacyMeetupTeamRawPkeyDelete>;
  /** The primary key(s) for `legacyMeetupTeamRaw` for the far side of the relationship. */
  deleteByName?: Maybe<LegacyMeetupTeamRawLegacyMeetupTeamRawNameKeyDelete>;
  /** The primary key(s) for `legacyMeetupTeamRaw` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyMeetupTeamRawNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyMeetupTeamRaw` for the far side of the relationship. */
  updateById?: Maybe<LegacyMeetupTeamRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyUsingLegacyMeetupTeamRawPkeyUpdate>;
  /** The primary key(s) and patch data for `legacyMeetupTeamRaw` for the far side of the relationship. */
  updateByName?: Maybe<LegacyMeetupTeamRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyUsingLegacyMeetupTeamRawNameKeyUpdate>;
  /** The primary key(s) and patch data for `legacyMeetupTeamRaw` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyNodeIdUpdate>;
  /** A `LegacyMeetupTeamRawInput` object that will be created and connected to this object. */
  create?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyLegacyMeetupTeamRawCreateInput>;
};

/** Input for the nested mutation of `legacyMeetupGameRaw` in the `LegacyMeetupTeamRawInput` mutation. */
export type LegacyMeetupGameRawLosingTeamIdFkeyInverseInput = {
  /** Flag indicating whether all other `legacyMeetupGameRaw` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  connectById?: Maybe<Array<LegacyMeetupGameRawLegacyMeetupGameRawPkeyConnect>>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  connectByName?: Maybe<Array<LegacyMeetupGameRawLegacyMeetupGameRawNameKeyConnect>>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LegacyMeetupGameRawNodeIdConnect>>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  deleteById?: Maybe<Array<LegacyMeetupGameRawLegacyMeetupGameRawPkeyDelete>>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  deleteByName?: Maybe<Array<LegacyMeetupGameRawLegacyMeetupGameRawNameKeyDelete>>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LegacyMeetupGameRawNodeIdDelete>>;
  /** The primary key(s) and patch data for `legacyMeetupGameRaw` for the far side of the relationship. */
  updateById?: Maybe<Array<LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyUsingLegacyMeetupGameRawPkeyUpdate>>;
  /** The primary key(s) and patch data for `legacyMeetupGameRaw` for the far side of the relationship. */
  updateByName?: Maybe<Array<LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyUsingLegacyMeetupGameRawNameKeyUpdate>>;
  /** The primary key(s) and patch data for `legacyMeetupGameRaw` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LegacyMeetupTeamRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyNodeIdUpdate>>;
  /** A `LegacyMeetupGameRawInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LegacyMeetupGameRawLosingTeamIdFkeyLegacyMeetupGameRawCreateInput>>;
};

/** The `legacyMeetupGameRaw` to be created by this mutation. */
export type LegacyMeetupGameRawLosingTeamIdFkeyLegacyMeetupGameRawCreateInput = {
  id: Scalars['Int'];
  name: Scalars['String'];
  season: Scalars['Int'];
  date: Scalars['Date'];
  timeStarted: Scalars['Time'];
  timeEnded: Scalars['Time'];
  winningTeamId?: Maybe<Scalars['Int']>;
  fieldId?: Maybe<Scalars['Int']>;
  imageGalleryUrl?: Maybe<Scalars['String']>;
  meetupEventId?: Maybe<Scalars['String']>;
  dateInserted?: Maybe<Scalars['Date']>;
  dateUpdated?: Maybe<Scalars['Date']>;
  advanced: Scalars['Boolean'];
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInput>;
  legacyMeetupFieldRaw?: Maybe<LegacyMeetupGameRawFieldIdFkeyInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInverseInput>;
};

/** The `legacyMeetupTeamRaw` to be created by this mutation. */
export type LegacyMeetupGameRawLosingTeamIdFkeyLegacyMeetupTeamRawCreateInput = {
  id: Scalars['Int'];
  name: Scalars['String'];
  legacyMeetupGameRawsToWinningTeamIdUsingId?: Maybe<LegacyMeetupGameRawWinningTeamIdFkeyInverseInput>;
  legacyMeetupGameRawsToLosingTeamIdUsingId?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInverseInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawTeamIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type LegacyMeetupGameRawNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `legacyMeetupGameRaw` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LegacyMeetupGameRawNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `legacyMeetupGameRaw` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyMeetupFieldRaw` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyMeetupFieldRaw` being updated. */
  patch: LegacyMeetupFieldRawPatch;
};

/** The fields on `legacyMeetupGameRaw` to look up the row to update. */
export type LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyUsingLegacyMeetupGameRawNameKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
  patch: UpdateLegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `legacyMeetupGameRaw` to look up the row to update. */
export type LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyUsingLegacyMeetupGameRawPkeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
  patch: UpdateLegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyMeetupTeamRaw` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyMeetupTeamRaw` being updated. */
  patch: LegacyMeetupTeamRawPatch;
};

/** The fields on `legacyMeetupGameRaw` to look up the row to update. */
export type LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyUsingLegacyMeetupGameRawNameKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
  patch: UpdateLegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `legacyMeetupGameRaw` to look up the row to update. */
export type LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyUsingLegacyMeetupGameRawPkeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
  patch: UpdateLegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `legacyMeetupGameRaw` to look up the row to update. */
export type LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawWinningTeamIdFkeyUsingLegacyMeetupGameRawNameKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
  patch: UpdateLegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawWinningTeamIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `legacyMeetupGameRaw` to look up the row to update. */
export type LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawWinningTeamIdFkeyUsingLegacyMeetupGameRawPkeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
  patch: UpdateLegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawWinningTeamIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyMeetupGameRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyMeetupStatLineRaw` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyMeetupStatLineRaw` being updated. */
  patch: LegacyMeetupStatLineRawPatch;
};

/** The fields on `legacyMeetupGameRaw` to look up the row to update. */
export type LegacyMeetupGameRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawGameIdFkeyUsingLegacyMeetupGameRawNameKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
  patch: UpdateLegacyMeetupGameRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawGameIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `legacyMeetupGameRaw` to look up the row to update. */
export type LegacyMeetupGameRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawGameIdFkeyUsingLegacyMeetupGameRawPkeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
  patch: UpdateLegacyMeetupGameRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawGameIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `LegacyMeetupGameRaw`. Fields that are set will be updated. */
export type LegacyMeetupGameRawPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  season?: Maybe<Scalars['Int']>;
  date?: Maybe<Scalars['Date']>;
  timeStarted?: Maybe<Scalars['Time']>;
  timeEnded?: Maybe<Scalars['Time']>;
  winningTeamId?: Maybe<Scalars['Int']>;
  losingTeamId?: Maybe<Scalars['Int']>;
  fieldId?: Maybe<Scalars['Int']>;
  imageGalleryUrl?: Maybe<Scalars['String']>;
  meetupEventId?: Maybe<Scalars['String']>;
  dateInserted?: Maybe<Scalars['Date']>;
  dateUpdated?: Maybe<Scalars['Date']>;
  advanced?: Maybe<Scalars['Boolean']>;
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInput>;
  legacyMeetupFieldRaw?: Maybe<LegacyMeetupGameRawFieldIdFkeyInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInverseInput>;
};

/** Input for the nested mutation of `legacyMeetupGameRaw` in the `LegacyMeetupTeamRawInput` mutation. */
export type LegacyMeetupGameRawWinningTeamIdFkeyInverseInput = {
  /** Flag indicating whether all other `legacyMeetupGameRaw` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  connectById?: Maybe<Array<LegacyMeetupGameRawLegacyMeetupGameRawPkeyConnect>>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  connectByName?: Maybe<Array<LegacyMeetupGameRawLegacyMeetupGameRawNameKeyConnect>>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LegacyMeetupGameRawNodeIdConnect>>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  deleteById?: Maybe<Array<LegacyMeetupGameRawLegacyMeetupGameRawPkeyDelete>>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  deleteByName?: Maybe<Array<LegacyMeetupGameRawLegacyMeetupGameRawNameKeyDelete>>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LegacyMeetupGameRawNodeIdDelete>>;
  /** The primary key(s) and patch data for `legacyMeetupGameRaw` for the far side of the relationship. */
  updateById?: Maybe<Array<LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawWinningTeamIdFkeyUsingLegacyMeetupGameRawPkeyUpdate>>;
  /** The primary key(s) and patch data for `legacyMeetupGameRaw` for the far side of the relationship. */
  updateByName?: Maybe<Array<LegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawWinningTeamIdFkeyUsingLegacyMeetupGameRawNameKeyUpdate>>;
  /** The primary key(s) and patch data for `legacyMeetupGameRaw` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LegacyMeetupTeamRawOnLegacyMeetupGameRawForLegacyMeetupGameRawWinningTeamIdFkeyNodeIdUpdate>>;
  /** A `LegacyMeetupGameRawInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LegacyMeetupGameRawWinningTeamIdFkeyLegacyMeetupGameRawCreateInput>>;
};

/** The `legacyMeetupGameRaw` to be created by this mutation. */
export type LegacyMeetupGameRawWinningTeamIdFkeyLegacyMeetupGameRawCreateInput = {
  id: Scalars['Int'];
  name: Scalars['String'];
  season: Scalars['Int'];
  date: Scalars['Date'];
  timeStarted: Scalars['Time'];
  timeEnded: Scalars['Time'];
  losingTeamId?: Maybe<Scalars['Int']>;
  fieldId?: Maybe<Scalars['Int']>;
  imageGalleryUrl?: Maybe<Scalars['String']>;
  meetupEventId?: Maybe<Scalars['String']>;
  dateInserted?: Maybe<Scalars['Date']>;
  dateUpdated?: Maybe<Scalars['Date']>;
  advanced: Scalars['Boolean'];
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInput>;
  legacyMeetupFieldRaw?: Maybe<LegacyMeetupGameRawFieldIdFkeyInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInverseInput>;
};

/** Methods to use when ordering `LegacyMeetupGameRaw`. */
export enum LegacyMeetupGameRawsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  DATE_ASC = 'DATE_ASC',
  DATE_DESC = 'DATE_DESC',
  TIME_STARTED_ASC = 'TIME_STARTED_ASC',
  TIME_STARTED_DESC = 'TIME_STARTED_DESC',
  TIME_ENDED_ASC = 'TIME_ENDED_ASC',
  TIME_ENDED_DESC = 'TIME_ENDED_DESC',
  WINNING_TEAM_ID_ASC = 'WINNING_TEAM_ID_ASC',
  WINNING_TEAM_ID_DESC = 'WINNING_TEAM_ID_DESC',
  LOSING_TEAM_ID_ASC = 'LOSING_TEAM_ID_ASC',
  LOSING_TEAM_ID_DESC = 'LOSING_TEAM_ID_DESC',
  FIELD_ID_ASC = 'FIELD_ID_ASC',
  FIELD_ID_DESC = 'FIELD_ID_DESC',
  IMAGE_GALLERY_URL_ASC = 'IMAGE_GALLERY_URL_ASC',
  IMAGE_GALLERY_URL_DESC = 'IMAGE_GALLERY_URL_DESC',
  MEETUP_EVENT_ID_ASC = 'MEETUP_EVENT_ID_ASC',
  MEETUP_EVENT_ID_DESC = 'MEETUP_EVENT_ID_DESC',
  DATE_INSERTED_ASC = 'DATE_INSERTED_ASC',
  DATE_INSERTED_DESC = 'DATE_INSERTED_DESC',
  DATE_UPDATED_ASC = 'DATE_UPDATED_ASC',
  DATE_UPDATED_DESC = 'DATE_UPDATED_DESC',
  ADVANCED_ASC = 'ADVANCED_ASC',
  ADVANCED_DESC = 'ADVANCED_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type LegacyMeetupPlayerRaw = Node & {
  __typename?: 'LegacyMeetupPlayerRaw';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  gender: Gender;
  nickname: Maybe<Scalars['String']>;
  selfNickname: Maybe<Scalars['String']>;
  bats: Handedness;
  throws: Handedness;
  imageUrl: Maybe<Scalars['String']>;
  meetupMemberId: Maybe<Scalars['String']>;
  skillLevel: Maybe<Scalars['Int']>;
  preferredPositionFirst: FieldingPosition;
  preferredPositionSecond: FieldingPosition;
  preferredPositionThird: FieldingPosition;
  favoriteTeam: Maybe<Scalars['String']>;
  hometown: Maybe<Scalars['String']>;
  school: Maybe<Scalars['String']>;
  timeAdded: Scalars['Datetime'];
  dateDebuted: Maybe<Scalars['Date']>;
  /** Reads and enables pagination through a set of `LegacyMeetupStatLineRaw`. */
  legacyMeetupStatLineRawsByPlayerId: Array<LegacyMeetupStatLineRaw>;
};


export type LegacyMeetupPlayerRawLegacyMeetupStatLineRawsByPlayerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyMeetupStatLineRawsOrderBy>>;
  condition?: Maybe<LegacyMeetupStatLineRawCondition>;
};

/**
 * A condition to be used against `LegacyMeetupPlayerRaw` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type LegacyMeetupPlayerRawCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `gender` field. */
  gender?: Maybe<Gender>;
  /** Checks for equality with the object’s `nickname` field. */
  nickname?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `selfNickname` field. */
  selfNickname?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `bats` field. */
  bats?: Maybe<Handedness>;
  /** Checks for equality with the object’s `throws` field. */
  throws?: Maybe<Handedness>;
  /** Checks for equality with the object’s `imageUrl` field. */
  imageUrl?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `meetupMemberId` field. */
  meetupMemberId?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `skillLevel` field. */
  skillLevel?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `preferredPositionFirst` field. */
  preferredPositionFirst?: Maybe<FieldingPosition>;
  /** Checks for equality with the object’s `preferredPositionSecond` field. */
  preferredPositionSecond?: Maybe<FieldingPosition>;
  /** Checks for equality with the object’s `preferredPositionThird` field. */
  preferredPositionThird?: Maybe<FieldingPosition>;
  /** Checks for equality with the object’s `favoriteTeam` field. */
  favoriteTeam?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `hometown` field. */
  hometown?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `school` field. */
  school?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `timeAdded` field. */
  timeAdded?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `dateDebuted` field. */
  dateDebuted?: Maybe<Scalars['Date']>;
};

/** An input for mutations affecting `LegacyMeetupPlayerRaw` */
export type LegacyMeetupPlayerRawInput = {
  id: Scalars['Int'];
  name: Scalars['String'];
  gender: Gender;
  nickname?: Maybe<Scalars['String']>;
  selfNickname?: Maybe<Scalars['String']>;
  bats: Handedness;
  throws: Handedness;
  imageUrl?: Maybe<Scalars['String']>;
  meetupMemberId?: Maybe<Scalars['String']>;
  skillLevel?: Maybe<Scalars['Int']>;
  preferredPositionFirst: FieldingPosition;
  preferredPositionSecond: FieldingPosition;
  preferredPositionThird: FieldingPosition;
  favoriteTeam?: Maybe<Scalars['String']>;
  hometown?: Maybe<Scalars['String']>;
  school?: Maybe<Scalars['String']>;
  timeAdded: Scalars['Datetime'];
  dateDebuted?: Maybe<Scalars['Date']>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawPlayerIdFkeyInverseInput>;
};

/** The fields on `legacyMeetupPlayerRaw` to look up the row to connect. */
export type LegacyMeetupPlayerRawLegacyMeetupPlayerRawNameKeyConnect = {
  name: Scalars['String'];
};

/** The fields on `legacyMeetupPlayerRaw` to look up the row to delete. */
export type LegacyMeetupPlayerRawLegacyMeetupPlayerRawNameKeyDelete = {
  name: Scalars['String'];
};

/** The fields on `legacyMeetupPlayerRaw` to look up the row to connect. */
export type LegacyMeetupPlayerRawLegacyMeetupPlayerRawPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `legacyMeetupPlayerRaw` to look up the row to delete. */
export type LegacyMeetupPlayerRawLegacyMeetupPlayerRawPkeyDelete = {
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LegacyMeetupPlayerRawNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `legacyMeetupPlayerRaw` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LegacyMeetupPlayerRawNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `legacyMeetupPlayerRaw` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyMeetupPlayerRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawPlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyMeetupStatLineRaw` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyMeetupStatLineRaw` being updated. */
  patch: LegacyMeetupStatLineRawPatch;
};

/** The fields on `legacyMeetupPlayerRaw` to look up the row to update. */
export type LegacyMeetupPlayerRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawPlayerIdFkeyUsingLegacyMeetupPlayerRawNameKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupPlayerRaw` being updated. */
  patch: UpdateLegacyMeetupPlayerRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawPlayerIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `legacyMeetupPlayerRaw` to look up the row to update. */
export type LegacyMeetupPlayerRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawPlayerIdFkeyUsingLegacyMeetupPlayerRawPkeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupPlayerRaw` being updated. */
  patch: UpdateLegacyMeetupPlayerRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawPlayerIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `LegacyMeetupPlayerRaw`. Fields that are set will be updated. */
export type LegacyMeetupPlayerRawPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  gender?: Maybe<Gender>;
  nickname?: Maybe<Scalars['String']>;
  selfNickname?: Maybe<Scalars['String']>;
  bats?: Maybe<Handedness>;
  throws?: Maybe<Handedness>;
  imageUrl?: Maybe<Scalars['String']>;
  meetupMemberId?: Maybe<Scalars['String']>;
  skillLevel?: Maybe<Scalars['Int']>;
  preferredPositionFirst?: Maybe<FieldingPosition>;
  preferredPositionSecond?: Maybe<FieldingPosition>;
  preferredPositionThird?: Maybe<FieldingPosition>;
  favoriteTeam?: Maybe<Scalars['String']>;
  hometown?: Maybe<Scalars['String']>;
  school?: Maybe<Scalars['String']>;
  timeAdded?: Maybe<Scalars['Datetime']>;
  dateDebuted?: Maybe<Scalars['Date']>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawPlayerIdFkeyInverseInput>;
};

/** Methods to use when ordering `LegacyMeetupPlayerRaw`. */
export enum LegacyMeetupPlayerRawsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  GENDER_ASC = 'GENDER_ASC',
  GENDER_DESC = 'GENDER_DESC',
  NICKNAME_ASC = 'NICKNAME_ASC',
  NICKNAME_DESC = 'NICKNAME_DESC',
  SELF_NICKNAME_ASC = 'SELF_NICKNAME_ASC',
  SELF_NICKNAME_DESC = 'SELF_NICKNAME_DESC',
  BATS_ASC = 'BATS_ASC',
  BATS_DESC = 'BATS_DESC',
  THROWS_ASC = 'THROWS_ASC',
  THROWS_DESC = 'THROWS_DESC',
  IMAGE_URL_ASC = 'IMAGE_URL_ASC',
  IMAGE_URL_DESC = 'IMAGE_URL_DESC',
  MEETUP_MEMBER_ID_ASC = 'MEETUP_MEMBER_ID_ASC',
  MEETUP_MEMBER_ID_DESC = 'MEETUP_MEMBER_ID_DESC',
  SKILL_LEVEL_ASC = 'SKILL_LEVEL_ASC',
  SKILL_LEVEL_DESC = 'SKILL_LEVEL_DESC',
  PREFERRED_POSITION_FIRST_ASC = 'PREFERRED_POSITION_FIRST_ASC',
  PREFERRED_POSITION_FIRST_DESC = 'PREFERRED_POSITION_FIRST_DESC',
  PREFERRED_POSITION_SECOND_ASC = 'PREFERRED_POSITION_SECOND_ASC',
  PREFERRED_POSITION_SECOND_DESC = 'PREFERRED_POSITION_SECOND_DESC',
  PREFERRED_POSITION_THIRD_ASC = 'PREFERRED_POSITION_THIRD_ASC',
  PREFERRED_POSITION_THIRD_DESC = 'PREFERRED_POSITION_THIRD_DESC',
  FAVORITE_TEAM_ASC = 'FAVORITE_TEAM_ASC',
  FAVORITE_TEAM_DESC = 'FAVORITE_TEAM_DESC',
  HOMETOWN_ASC = 'HOMETOWN_ASC',
  HOMETOWN_DESC = 'HOMETOWN_DESC',
  SCHOOL_ASC = 'SCHOOL_ASC',
  SCHOOL_DESC = 'SCHOOL_DESC',
  TIME_ADDED_ASC = 'TIME_ADDED_ASC',
  TIME_ADDED_DESC = 'TIME_ADDED_DESC',
  DATE_DEBUTED_ASC = 'DATE_DEBUTED_ASC',
  DATE_DEBUTED_DESC = 'DATE_DEBUTED_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type LegacyMeetupStatLineRaw = Node & {
  __typename?: 'LegacyMeetupStatLineRaw';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  playerId: Scalars['Int'];
  gameId: Scalars['Int'];
  teamId: Scalars['Int'];
  atBats: Scalars['Int'];
  runs: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  rbi: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  stolenBases: Scalars['Int'];
  pitched: Scalars['Boolean'];
  pitcherWon: Scalars['Boolean'];
  pitcherLost: Scalars['Boolean'];
  pitcherSave: Scalars['Boolean'];
  pitcherCompleteGame: Scalars['Boolean'];
  pitcherQualityStart: Scalars['Boolean'];
  inningsPitched: Scalars['Int'];
  runsAllowed: Scalars['Int'];
  earnedRunsAllowed: Scalars['Int'];
  hitsAllowed: Scalars['Int'];
  homerunsAllowed: Scalars['Int'];
  pitcherStrikeouts: Scalars['Int'];
  pitcherWalks: Scalars['Int'];
  /** Reads a single `LegacyMeetupPlayerRaw` that is related to this `LegacyMeetupStatLineRaw`. */
  player: Maybe<LegacyMeetupPlayerRaw>;
  /** Reads a single `LegacyMeetupGameRaw` that is related to this `LegacyMeetupStatLineRaw`. */
  game: Maybe<LegacyMeetupGameRaw>;
  /** Reads a single `LegacyMeetupTeamRaw` that is related to this `LegacyMeetupStatLineRaw`. */
  team: Maybe<LegacyMeetupTeamRaw>;
};

/**
 * A condition to be used against `LegacyMeetupStatLineRaw` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type LegacyMeetupStatLineRawCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stolenBases` field. */
  stolenBases?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pitched` field. */
  pitched?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pitcherWon` field. */
  pitcherWon?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pitcherLost` field. */
  pitcherLost?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pitcherSave` field. */
  pitcherSave?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pitcherCompleteGame` field. */
  pitcherCompleteGame?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `pitcherQualityStart` field. */
  pitcherQualityStart?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `inningsPitched` field. */
  inningsPitched?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runsAllowed` field. */
  runsAllowed?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `earnedRunsAllowed` field. */
  earnedRunsAllowed?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hitsAllowed` field. */
  hitsAllowed?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homerunsAllowed` field. */
  homerunsAllowed?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pitcherStrikeouts` field. */
  pitcherStrikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `pitcherWalks` field. */
  pitcherWalks?: Maybe<Scalars['Int']>;
};

/** Input for the nested mutation of `legacyMeetupGameRaw` in the `LegacyMeetupStatLineRawInput` mutation. */
export type LegacyMeetupStatLineRawGameIdFkeyInput = {
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  connectById?: Maybe<LegacyMeetupGameRawLegacyMeetupGameRawPkeyConnect>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  connectByName?: Maybe<LegacyMeetupGameRawLegacyMeetupGameRawNameKeyConnect>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyMeetupGameRawNodeIdConnect>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  deleteById?: Maybe<LegacyMeetupGameRawLegacyMeetupGameRawPkeyDelete>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  deleteByName?: Maybe<LegacyMeetupGameRawLegacyMeetupGameRawNameKeyDelete>;
  /** The primary key(s) for `legacyMeetupGameRaw` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyMeetupGameRawNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyMeetupGameRaw` for the far side of the relationship. */
  updateById?: Maybe<LegacyMeetupGameRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawGameIdFkeyUsingLegacyMeetupGameRawPkeyUpdate>;
  /** The primary key(s) and patch data for `legacyMeetupGameRaw` for the far side of the relationship. */
  updateByName?: Maybe<LegacyMeetupGameRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawGameIdFkeyUsingLegacyMeetupGameRawNameKeyUpdate>;
  /** The primary key(s) and patch data for `legacyMeetupGameRaw` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawGameIdFkeyNodeIdUpdate>;
  /** A `LegacyMeetupGameRawInput` object that will be created and connected to this object. */
  create?: Maybe<LegacyMeetupStatLineRawGameIdFkeyLegacyMeetupGameRawCreateInput>;
};

/** Input for the nested mutation of `legacyMeetupStatLineRaw` in the `LegacyMeetupGameRawInput` mutation. */
export type LegacyMeetupStatLineRawGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `legacyMeetupStatLineRaw` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  connectById?: Maybe<Array<LegacyMeetupStatLineRawLegacyMeetupStatLineRawPkeyConnect>>;
  /** The primary key(s) for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LegacyMeetupStatLineRawNodeIdConnect>>;
  /** The primary key(s) for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  deleteById?: Maybe<Array<LegacyMeetupStatLineRawLegacyMeetupStatLineRawPkeyDelete>>;
  /** The primary key(s) for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LegacyMeetupStatLineRawNodeIdDelete>>;
  /** The primary key(s) and patch data for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  updateById?: Maybe<Array<LegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawGameIdFkeyUsingLegacyMeetupStatLineRawPkeyUpdate>>;
  /** The primary key(s) and patch data for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LegacyMeetupGameRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawGameIdFkeyNodeIdUpdate>>;
  /** A `LegacyMeetupStatLineRawInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LegacyMeetupStatLineRawGameIdFkeyLegacyMeetupStatLineRawCreateInput>>;
};

/** The `legacyMeetupGameRaw` to be created by this mutation. */
export type LegacyMeetupStatLineRawGameIdFkeyLegacyMeetupGameRawCreateInput = {
  id: Scalars['Int'];
  name: Scalars['String'];
  season: Scalars['Int'];
  date: Scalars['Date'];
  timeStarted: Scalars['Time'];
  timeEnded: Scalars['Time'];
  winningTeamId?: Maybe<Scalars['Int']>;
  losingTeamId?: Maybe<Scalars['Int']>;
  fieldId?: Maybe<Scalars['Int']>;
  imageGalleryUrl?: Maybe<Scalars['String']>;
  meetupEventId?: Maybe<Scalars['String']>;
  dateInserted?: Maybe<Scalars['Date']>;
  dateUpdated?: Maybe<Scalars['Date']>;
  advanced: Scalars['Boolean'];
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInput>;
  legacyMeetupFieldRaw?: Maybe<LegacyMeetupGameRawFieldIdFkeyInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInverseInput>;
};

/** The `legacyMeetupStatLineRaw` to be created by this mutation. */
export type LegacyMeetupStatLineRawGameIdFkeyLegacyMeetupStatLineRawCreateInput = {
  id: Scalars['Int'];
  playerId?: Maybe<Scalars['Int']>;
  teamId?: Maybe<Scalars['Int']>;
  atBats: Scalars['Int'];
  runs: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  rbi: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  stolenBases: Scalars['Int'];
  pitched: Scalars['Boolean'];
  pitcherWon: Scalars['Boolean'];
  pitcherLost: Scalars['Boolean'];
  pitcherSave: Scalars['Boolean'];
  pitcherCompleteGame: Scalars['Boolean'];
  pitcherQualityStart: Scalars['Boolean'];
  inningsPitched: Scalars['Int'];
  runsAllowed: Scalars['Int'];
  earnedRunsAllowed: Scalars['Int'];
  hitsAllowed: Scalars['Int'];
  homerunsAllowed: Scalars['Int'];
  pitcherStrikeouts: Scalars['Int'];
  pitcherWalks: Scalars['Int'];
  legacyMeetupPlayerRaw?: Maybe<LegacyMeetupStatLineRawPlayerIdFkeyInput>;
  legacyMeetupGameRaw?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInput>;
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupStatLineRawTeamIdFkeyInput>;
};

/** An input for mutations affecting `LegacyMeetupStatLineRaw` */
export type LegacyMeetupStatLineRawInput = {
  id: Scalars['Int'];
  playerId?: Maybe<Scalars['Int']>;
  gameId?: Maybe<Scalars['Int']>;
  teamId?: Maybe<Scalars['Int']>;
  atBats: Scalars['Int'];
  runs: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  rbi: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  stolenBases: Scalars['Int'];
  pitched: Scalars['Boolean'];
  pitcherWon: Scalars['Boolean'];
  pitcherLost: Scalars['Boolean'];
  pitcherSave: Scalars['Boolean'];
  pitcherCompleteGame: Scalars['Boolean'];
  pitcherQualityStart: Scalars['Boolean'];
  inningsPitched: Scalars['Int'];
  runsAllowed: Scalars['Int'];
  earnedRunsAllowed: Scalars['Int'];
  hitsAllowed: Scalars['Int'];
  homerunsAllowed: Scalars['Int'];
  pitcherStrikeouts: Scalars['Int'];
  pitcherWalks: Scalars['Int'];
  legacyMeetupPlayerRaw?: Maybe<LegacyMeetupStatLineRawPlayerIdFkeyInput>;
  legacyMeetupGameRaw?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInput>;
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupStatLineRawTeamIdFkeyInput>;
};

/** The fields on `legacyMeetupStatLineRaw` to look up the row to connect. */
export type LegacyMeetupStatLineRawLegacyMeetupStatLineRawPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `legacyMeetupStatLineRaw` to look up the row to delete. */
export type LegacyMeetupStatLineRawLegacyMeetupStatLineRawPkeyDelete = {
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LegacyMeetupStatLineRawNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `legacyMeetupStatLineRaw` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LegacyMeetupStatLineRawNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `legacyMeetupStatLineRaw` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyMeetupGameRaw` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
  patch: LegacyMeetupGameRawPatch;
};

/** The fields on `legacyMeetupStatLineRaw` to look up the row to update. */
export type LegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawGameIdFkeyUsingLegacyMeetupStatLineRawPkeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupStatLineRaw` being updated. */
  patch: UpdateLegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawGameIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawPlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyMeetupPlayerRaw` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyMeetupPlayerRaw` being updated. */
  patch: LegacyMeetupPlayerRawPatch;
};

/** The fields on `legacyMeetupStatLineRaw` to look up the row to update. */
export type LegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawPlayerIdFkeyUsingLegacyMeetupStatLineRawPkeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupStatLineRaw` being updated. */
  patch: UpdateLegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawPlayerIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawTeamIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyMeetupTeamRaw` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyMeetupTeamRaw` being updated. */
  patch: LegacyMeetupTeamRawPatch;
};

/** The fields on `legacyMeetupStatLineRaw` to look up the row to update. */
export type LegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawTeamIdFkeyUsingLegacyMeetupStatLineRawPkeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupStatLineRaw` being updated. */
  patch: UpdateLegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawTeamIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `LegacyMeetupStatLineRaw`. Fields that are set will be updated. */
export type LegacyMeetupStatLineRawPatch = {
  id?: Maybe<Scalars['Int']>;
  playerId?: Maybe<Scalars['Int']>;
  gameId?: Maybe<Scalars['Int']>;
  teamId?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  pitched?: Maybe<Scalars['Boolean']>;
  pitcherWon?: Maybe<Scalars['Boolean']>;
  pitcherLost?: Maybe<Scalars['Boolean']>;
  pitcherSave?: Maybe<Scalars['Boolean']>;
  pitcherCompleteGame?: Maybe<Scalars['Boolean']>;
  pitcherQualityStart?: Maybe<Scalars['Boolean']>;
  inningsPitched?: Maybe<Scalars['Int']>;
  runsAllowed?: Maybe<Scalars['Int']>;
  earnedRunsAllowed?: Maybe<Scalars['Int']>;
  hitsAllowed?: Maybe<Scalars['Int']>;
  homerunsAllowed?: Maybe<Scalars['Int']>;
  pitcherStrikeouts?: Maybe<Scalars['Int']>;
  pitcherWalks?: Maybe<Scalars['Int']>;
  legacyMeetupPlayerRaw?: Maybe<LegacyMeetupStatLineRawPlayerIdFkeyInput>;
  legacyMeetupGameRaw?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInput>;
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupStatLineRawTeamIdFkeyInput>;
};

/** Input for the nested mutation of `legacyMeetupPlayerRaw` in the `LegacyMeetupStatLineRawInput` mutation. */
export type LegacyMeetupStatLineRawPlayerIdFkeyInput = {
  /** The primary key(s) for `legacyMeetupPlayerRaw` for the far side of the relationship. */
  connectById?: Maybe<LegacyMeetupPlayerRawLegacyMeetupPlayerRawPkeyConnect>;
  /** The primary key(s) for `legacyMeetupPlayerRaw` for the far side of the relationship. */
  connectByName?: Maybe<LegacyMeetupPlayerRawLegacyMeetupPlayerRawNameKeyConnect>;
  /** The primary key(s) for `legacyMeetupPlayerRaw` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyMeetupPlayerRawNodeIdConnect>;
  /** The primary key(s) for `legacyMeetupPlayerRaw` for the far side of the relationship. */
  deleteById?: Maybe<LegacyMeetupPlayerRawLegacyMeetupPlayerRawPkeyDelete>;
  /** The primary key(s) for `legacyMeetupPlayerRaw` for the far side of the relationship. */
  deleteByName?: Maybe<LegacyMeetupPlayerRawLegacyMeetupPlayerRawNameKeyDelete>;
  /** The primary key(s) for `legacyMeetupPlayerRaw` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyMeetupPlayerRawNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyMeetupPlayerRaw` for the far side of the relationship. */
  updateById?: Maybe<LegacyMeetupPlayerRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawPlayerIdFkeyUsingLegacyMeetupPlayerRawPkeyUpdate>;
  /** The primary key(s) and patch data for `legacyMeetupPlayerRaw` for the far side of the relationship. */
  updateByName?: Maybe<LegacyMeetupPlayerRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawPlayerIdFkeyUsingLegacyMeetupPlayerRawNameKeyUpdate>;
  /** The primary key(s) and patch data for `legacyMeetupPlayerRaw` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawPlayerIdFkeyNodeIdUpdate>;
  /** A `LegacyMeetupPlayerRawInput` object that will be created and connected to this object. */
  create?: Maybe<LegacyMeetupStatLineRawPlayerIdFkeyLegacyMeetupPlayerRawCreateInput>;
};

/** Input for the nested mutation of `legacyMeetupStatLineRaw` in the `LegacyMeetupPlayerRawInput` mutation. */
export type LegacyMeetupStatLineRawPlayerIdFkeyInverseInput = {
  /** Flag indicating whether all other `legacyMeetupStatLineRaw` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  connectById?: Maybe<Array<LegacyMeetupStatLineRawLegacyMeetupStatLineRawPkeyConnect>>;
  /** The primary key(s) for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LegacyMeetupStatLineRawNodeIdConnect>>;
  /** The primary key(s) for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  deleteById?: Maybe<Array<LegacyMeetupStatLineRawLegacyMeetupStatLineRawPkeyDelete>>;
  /** The primary key(s) for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LegacyMeetupStatLineRawNodeIdDelete>>;
  /** The primary key(s) and patch data for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  updateById?: Maybe<Array<LegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawPlayerIdFkeyUsingLegacyMeetupStatLineRawPkeyUpdate>>;
  /** The primary key(s) and patch data for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LegacyMeetupPlayerRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawPlayerIdFkeyNodeIdUpdate>>;
  /** A `LegacyMeetupStatLineRawInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LegacyMeetupStatLineRawPlayerIdFkeyLegacyMeetupStatLineRawCreateInput>>;
};

/** The `legacyMeetupPlayerRaw` to be created by this mutation. */
export type LegacyMeetupStatLineRawPlayerIdFkeyLegacyMeetupPlayerRawCreateInput = {
  id: Scalars['Int'];
  name: Scalars['String'];
  gender: Gender;
  nickname?: Maybe<Scalars['String']>;
  selfNickname?: Maybe<Scalars['String']>;
  bats: Handedness;
  throws: Handedness;
  imageUrl?: Maybe<Scalars['String']>;
  meetupMemberId?: Maybe<Scalars['String']>;
  skillLevel?: Maybe<Scalars['Int']>;
  preferredPositionFirst: FieldingPosition;
  preferredPositionSecond: FieldingPosition;
  preferredPositionThird: FieldingPosition;
  favoriteTeam?: Maybe<Scalars['String']>;
  hometown?: Maybe<Scalars['String']>;
  school?: Maybe<Scalars['String']>;
  timeAdded: Scalars['Datetime'];
  dateDebuted?: Maybe<Scalars['Date']>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawPlayerIdFkeyInverseInput>;
};

/** The `legacyMeetupStatLineRaw` to be created by this mutation. */
export type LegacyMeetupStatLineRawPlayerIdFkeyLegacyMeetupStatLineRawCreateInput = {
  id: Scalars['Int'];
  gameId?: Maybe<Scalars['Int']>;
  teamId?: Maybe<Scalars['Int']>;
  atBats: Scalars['Int'];
  runs: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  rbi: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  stolenBases: Scalars['Int'];
  pitched: Scalars['Boolean'];
  pitcherWon: Scalars['Boolean'];
  pitcherLost: Scalars['Boolean'];
  pitcherSave: Scalars['Boolean'];
  pitcherCompleteGame: Scalars['Boolean'];
  pitcherQualityStart: Scalars['Boolean'];
  inningsPitched: Scalars['Int'];
  runsAllowed: Scalars['Int'];
  earnedRunsAllowed: Scalars['Int'];
  hitsAllowed: Scalars['Int'];
  homerunsAllowed: Scalars['Int'];
  pitcherStrikeouts: Scalars['Int'];
  pitcherWalks: Scalars['Int'];
  legacyMeetupPlayerRaw?: Maybe<LegacyMeetupStatLineRawPlayerIdFkeyInput>;
  legacyMeetupGameRaw?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInput>;
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupStatLineRawTeamIdFkeyInput>;
};

/** Input for the nested mutation of `legacyMeetupTeamRaw` in the `LegacyMeetupStatLineRawInput` mutation. */
export type LegacyMeetupStatLineRawTeamIdFkeyInput = {
  /** The primary key(s) for `legacyMeetupTeamRaw` for the far side of the relationship. */
  connectById?: Maybe<LegacyMeetupTeamRawLegacyMeetupTeamRawPkeyConnect>;
  /** The primary key(s) for `legacyMeetupTeamRaw` for the far side of the relationship. */
  connectByName?: Maybe<LegacyMeetupTeamRawLegacyMeetupTeamRawNameKeyConnect>;
  /** The primary key(s) for `legacyMeetupTeamRaw` for the far side of the relationship. */
  connectByNodeId?: Maybe<LegacyMeetupTeamRawNodeIdConnect>;
  /** The primary key(s) for `legacyMeetupTeamRaw` for the far side of the relationship. */
  deleteById?: Maybe<LegacyMeetupTeamRawLegacyMeetupTeamRawPkeyDelete>;
  /** The primary key(s) for `legacyMeetupTeamRaw` for the far side of the relationship. */
  deleteByName?: Maybe<LegacyMeetupTeamRawLegacyMeetupTeamRawNameKeyDelete>;
  /** The primary key(s) for `legacyMeetupTeamRaw` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LegacyMeetupTeamRawNodeIdDelete>;
  /** The primary key(s) and patch data for `legacyMeetupTeamRaw` for the far side of the relationship. */
  updateById?: Maybe<LegacyMeetupTeamRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawTeamIdFkeyUsingLegacyMeetupTeamRawPkeyUpdate>;
  /** The primary key(s) and patch data for `legacyMeetupTeamRaw` for the far side of the relationship. */
  updateByName?: Maybe<LegacyMeetupTeamRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawTeamIdFkeyUsingLegacyMeetupTeamRawNameKeyUpdate>;
  /** The primary key(s) and patch data for `legacyMeetupTeamRaw` for the far side of the relationship. */
  updateByNodeId?: Maybe<LegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawTeamIdFkeyNodeIdUpdate>;
  /** A `LegacyMeetupTeamRawInput` object that will be created and connected to this object. */
  create?: Maybe<LegacyMeetupStatLineRawTeamIdFkeyLegacyMeetupTeamRawCreateInput>;
};

/** Input for the nested mutation of `legacyMeetupStatLineRaw` in the `LegacyMeetupTeamRawInput` mutation. */
export type LegacyMeetupStatLineRawTeamIdFkeyInverseInput = {
  /** Flag indicating whether all other `legacyMeetupStatLineRaw` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  connectById?: Maybe<Array<LegacyMeetupStatLineRawLegacyMeetupStatLineRawPkeyConnect>>;
  /** The primary key(s) for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LegacyMeetupStatLineRawNodeIdConnect>>;
  /** The primary key(s) for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  deleteById?: Maybe<Array<LegacyMeetupStatLineRawLegacyMeetupStatLineRawPkeyDelete>>;
  /** The primary key(s) for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LegacyMeetupStatLineRawNodeIdDelete>>;
  /** The primary key(s) and patch data for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  updateById?: Maybe<Array<LegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawTeamIdFkeyUsingLegacyMeetupStatLineRawPkeyUpdate>>;
  /** The primary key(s) and patch data for `legacyMeetupStatLineRaw` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LegacyMeetupTeamRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawTeamIdFkeyNodeIdUpdate>>;
  /** A `LegacyMeetupStatLineRawInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LegacyMeetupStatLineRawTeamIdFkeyLegacyMeetupStatLineRawCreateInput>>;
};

/** The `legacyMeetupStatLineRaw` to be created by this mutation. */
export type LegacyMeetupStatLineRawTeamIdFkeyLegacyMeetupStatLineRawCreateInput = {
  id: Scalars['Int'];
  playerId?: Maybe<Scalars['Int']>;
  gameId?: Maybe<Scalars['Int']>;
  atBats: Scalars['Int'];
  runs: Scalars['Int'];
  hits: Scalars['Int'];
  singles: Scalars['Int'];
  doubles: Scalars['Int'];
  triples: Scalars['Int'];
  homeruns: Scalars['Int'];
  rbi: Scalars['Int'];
  walks: Scalars['Int'];
  strikeouts: Scalars['Int'];
  sacFlies: Scalars['Int'];
  stolenBases: Scalars['Int'];
  pitched: Scalars['Boolean'];
  pitcherWon: Scalars['Boolean'];
  pitcherLost: Scalars['Boolean'];
  pitcherSave: Scalars['Boolean'];
  pitcherCompleteGame: Scalars['Boolean'];
  pitcherQualityStart: Scalars['Boolean'];
  inningsPitched: Scalars['Int'];
  runsAllowed: Scalars['Int'];
  earnedRunsAllowed: Scalars['Int'];
  hitsAllowed: Scalars['Int'];
  homerunsAllowed: Scalars['Int'];
  pitcherStrikeouts: Scalars['Int'];
  pitcherWalks: Scalars['Int'];
  legacyMeetupPlayerRaw?: Maybe<LegacyMeetupStatLineRawPlayerIdFkeyInput>;
  legacyMeetupGameRaw?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInput>;
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupStatLineRawTeamIdFkeyInput>;
};

/** The `legacyMeetupTeamRaw` to be created by this mutation. */
export type LegacyMeetupStatLineRawTeamIdFkeyLegacyMeetupTeamRawCreateInput = {
  id: Scalars['Int'];
  name: Scalars['String'];
  legacyMeetupGameRawsToWinningTeamIdUsingId?: Maybe<LegacyMeetupGameRawWinningTeamIdFkeyInverseInput>;
  legacyMeetupGameRawsToLosingTeamIdUsingId?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInverseInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawTeamIdFkeyInverseInput>;
};

/** Methods to use when ordering `LegacyMeetupStatLineRaw`. */
export enum LegacyMeetupStatLineRawsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  TEAM_ID_ASC = 'TEAM_ID_ASC',
  TEAM_ID_DESC = 'TEAM_ID_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  STOLEN_BASES_ASC = 'STOLEN_BASES_ASC',
  STOLEN_BASES_DESC = 'STOLEN_BASES_DESC',
  PITCHED_ASC = 'PITCHED_ASC',
  PITCHED_DESC = 'PITCHED_DESC',
  PITCHER_WON_ASC = 'PITCHER_WON_ASC',
  PITCHER_WON_DESC = 'PITCHER_WON_DESC',
  PITCHER_LOST_ASC = 'PITCHER_LOST_ASC',
  PITCHER_LOST_DESC = 'PITCHER_LOST_DESC',
  PITCHER_SAVE_ASC = 'PITCHER_SAVE_ASC',
  PITCHER_SAVE_DESC = 'PITCHER_SAVE_DESC',
  PITCHER_COMPLETE_GAME_ASC = 'PITCHER_COMPLETE_GAME_ASC',
  PITCHER_COMPLETE_GAME_DESC = 'PITCHER_COMPLETE_GAME_DESC',
  PITCHER_QUALITY_START_ASC = 'PITCHER_QUALITY_START_ASC',
  PITCHER_QUALITY_START_DESC = 'PITCHER_QUALITY_START_DESC',
  INNINGS_PITCHED_ASC = 'INNINGS_PITCHED_ASC',
  INNINGS_PITCHED_DESC = 'INNINGS_PITCHED_DESC',
  RUNS_ALLOWED_ASC = 'RUNS_ALLOWED_ASC',
  RUNS_ALLOWED_DESC = 'RUNS_ALLOWED_DESC',
  EARNED_RUNS_ALLOWED_ASC = 'EARNED_RUNS_ALLOWED_ASC',
  EARNED_RUNS_ALLOWED_DESC = 'EARNED_RUNS_ALLOWED_DESC',
  HITS_ALLOWED_ASC = 'HITS_ALLOWED_ASC',
  HITS_ALLOWED_DESC = 'HITS_ALLOWED_DESC',
  HOMERUNS_ALLOWED_ASC = 'HOMERUNS_ALLOWED_ASC',
  HOMERUNS_ALLOWED_DESC = 'HOMERUNS_ALLOWED_DESC',
  PITCHER_STRIKEOUTS_ASC = 'PITCHER_STRIKEOUTS_ASC',
  PITCHER_STRIKEOUTS_DESC = 'PITCHER_STRIKEOUTS_DESC',
  PITCHER_WALKS_ASC = 'PITCHER_WALKS_ASC',
  PITCHER_WALKS_DESC = 'PITCHER_WALKS_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type LegacyMeetupTeamRaw = Node & {
  __typename?: 'LegacyMeetupTeamRaw';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name: Scalars['String'];
  /** Reads and enables pagination through a set of `LegacyMeetupGameRaw`. */
  legacyMeetupGameRawsByWinningTeamId: Array<LegacyMeetupGameRaw>;
  /** Reads and enables pagination through a set of `LegacyMeetupGameRaw`. */
  legacyMeetupGameRawsByLosingTeamId: Array<LegacyMeetupGameRaw>;
  /** Reads and enables pagination through a set of `LegacyMeetupStatLineRaw`. */
  legacyMeetupStatLineRawsByTeamId: Array<LegacyMeetupStatLineRaw>;
};


export type LegacyMeetupTeamRawLegacyMeetupGameRawsByWinningTeamIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyMeetupGameRawsOrderBy>>;
  condition?: Maybe<LegacyMeetupGameRawCondition>;
};


export type LegacyMeetupTeamRawLegacyMeetupGameRawsByLosingTeamIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyMeetupGameRawsOrderBy>>;
  condition?: Maybe<LegacyMeetupGameRawCondition>;
};


export type LegacyMeetupTeamRawLegacyMeetupStatLineRawsByTeamIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyMeetupStatLineRawsOrderBy>>;
  condition?: Maybe<LegacyMeetupStatLineRawCondition>;
};

/**
 * A condition to be used against `LegacyMeetupTeamRaw` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type LegacyMeetupTeamRawCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
};

/** An input for mutations affecting `LegacyMeetupTeamRaw` */
export type LegacyMeetupTeamRawInput = {
  id: Scalars['Int'];
  name: Scalars['String'];
  legacyMeetupGameRawsToWinningTeamIdUsingId?: Maybe<LegacyMeetupGameRawWinningTeamIdFkeyInverseInput>;
  legacyMeetupGameRawsToLosingTeamIdUsingId?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInverseInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawTeamIdFkeyInverseInput>;
};

/** The fields on `legacyMeetupTeamRaw` to look up the row to connect. */
export type LegacyMeetupTeamRawLegacyMeetupTeamRawNameKeyConnect = {
  name: Scalars['String'];
};

/** The fields on `legacyMeetupTeamRaw` to look up the row to delete. */
export type LegacyMeetupTeamRawLegacyMeetupTeamRawNameKeyDelete = {
  name: Scalars['String'];
};

/** The fields on `legacyMeetupTeamRaw` to look up the row to connect. */
export type LegacyMeetupTeamRawLegacyMeetupTeamRawPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `legacyMeetupTeamRaw` to look up the row to delete. */
export type LegacyMeetupTeamRawLegacyMeetupTeamRawPkeyDelete = {
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LegacyMeetupTeamRawNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `legacyMeetupTeamRaw` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LegacyMeetupTeamRawNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `legacyMeetupTeamRaw` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyMeetupTeamRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyMeetupGameRaw` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
  patch: LegacyMeetupGameRawPatch;
};

/** The fields on `legacyMeetupTeamRaw` to look up the row to update. */
export type LegacyMeetupTeamRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyUsingLegacyMeetupTeamRawNameKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupTeamRaw` being updated. */
  patch: UpdateLegacyMeetupTeamRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `legacyMeetupTeamRaw` to look up the row to update. */
export type LegacyMeetupTeamRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyUsingLegacyMeetupTeamRawPkeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupTeamRaw` being updated. */
  patch: UpdateLegacyMeetupTeamRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyMeetupTeamRawOnLegacyMeetupGameRawForLegacyMeetupGameRawWinningTeamIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyMeetupGameRaw` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
  patch: LegacyMeetupGameRawPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyMeetupTeamRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawTeamIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyMeetupStatLineRaw` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyMeetupStatLineRaw` being updated. */
  patch: LegacyMeetupStatLineRawPatch;
};

/** The fields on `legacyMeetupTeamRaw` to look up the row to update. */
export type LegacyMeetupTeamRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawTeamIdFkeyUsingLegacyMeetupTeamRawNameKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupTeamRaw` being updated. */
  patch: UpdateLegacyMeetupTeamRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawTeamIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `legacyMeetupTeamRaw` to look up the row to update. */
export type LegacyMeetupTeamRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawTeamIdFkeyUsingLegacyMeetupTeamRawPkeyUpdate = {
  /** An object where the defined keys will be set on the `legacyMeetupTeamRaw` being updated. */
  patch: UpdateLegacyMeetupTeamRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawTeamIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `LegacyMeetupTeamRaw`. Fields that are set will be updated. */
export type LegacyMeetupTeamRawPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  legacyMeetupGameRawsToWinningTeamIdUsingId?: Maybe<LegacyMeetupGameRawWinningTeamIdFkeyInverseInput>;
  legacyMeetupGameRawsToLosingTeamIdUsingId?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInverseInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawTeamIdFkeyInverseInput>;
};

/** Methods to use when ordering `LegacyMeetupTeamRaw`. */
export enum LegacyMeetupTeamRawsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type LegacyPlayer = Node & {
  __typename?: 'LegacyPlayer';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  playerId: Scalars['Int'];
  playerName: Maybe<Scalars['String']>;
  playerImage: Maybe<Scalars['String']>;
  memberId: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `CareerStat`. */
  careerStats: Array<CareerStat>;
  /** Reads and enables pagination through a set of `CareerStatsQualifiedBatter`. */
  careerStatsQualifiedBatters: Array<CareerStatsQualifiedBatter>;
  /** Reads and enables pagination through a set of `LegacyGameBattingLine`. */
  legacyGameBattingLines: Array<LegacyGameBattingLine>;
  /** Reads and enables pagination through a set of `LegacySeasonStat`. */
  legacySeasonStats: Array<LegacySeasonStat>;
  /** Reads and enables pagination through a set of `Player`. */
  players: Array<Player>;
  /** Reads and enables pagination through a set of `SeasonStat`. */
  seasonStats: Array<SeasonStat>;
  /** Reads and enables pagination through a set of `SeasonStatsAllTimeQualifiedBatter`. */
  seasonStatsAllTimeQualifiedBatters: Array<SeasonStatsAllTimeQualifiedBatter>;
  /** Reads and enables pagination through a set of `SeasonStatsQualifiedBatter`. */
  seasonStatsQualifiedBatters: Array<SeasonStatsQualifiedBatter>;
};


export type LegacyPlayerCareerStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsOrderBy>>;
  condition?: Maybe<CareerStatCondition>;
};


export type LegacyPlayerCareerStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<CareerStatsQualifiedBatterCondition>;
};


export type LegacyPlayerLegacyGameBattingLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyGameBattingLinesOrderBy>>;
  condition?: Maybe<LegacyGameBattingLineCondition>;
};


export type LegacyPlayerLegacySeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacySeasonStatsOrderBy>>;
  condition?: Maybe<LegacySeasonStatCondition>;
};


export type LegacyPlayerPlayersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlayersOrderBy>>;
  condition?: Maybe<PlayerCondition>;
};


export type LegacyPlayerSeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsOrderBy>>;
  condition?: Maybe<SeasonStatCondition>;
};


export type LegacyPlayerSeasonStatsAllTimeQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsAllTimeQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsAllTimeQualifiedBatterCondition>;
};


export type LegacyPlayerSeasonStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsQualifiedBatterCondition>;
};

/**
 * A condition to be used against `LegacyPlayer` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LegacyPlayerCondition = {
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerName` field. */
  playerName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `playerImage` field. */
  playerImage?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `memberId` field. */
  memberId?: Maybe<Scalars['String']>;
};

/** The fields on `legacyPlayer` to look up the row to connect. */
export type LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect = {
  playerId: Scalars['Int'];
};

/** The fields on `legacyPlayer` to look up the row to delete. */
export type LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete = {
  playerId: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LegacyPlayerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LegacyPlayerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `legacyPlayer` to look up the row to update. */
export type LegacyPlayerOnCareerStatForFakePublicCareerStatsForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: UpdateLegacyPlayerOnCareerStatForFakePublicCareerStatsForeignKey1Patch;
  playerId: Scalars['Int'];
};

/** The fields on `legacyPlayer` to look up the row to update. */
export type LegacyPlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: UpdateLegacyPlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey1Patch;
  playerId: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyPlayerOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyGameBattingLine` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyGameBattingLine` being updated. */
  patch: LegacyGameBattingLinePatch;
};

/** The fields on `legacyPlayer` to look up the row to update. */
export type LegacyPlayerOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: UpdateLegacyPlayerOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey1Patch;
  playerId: Scalars['Int'];
};

/** The fields on `legacyPlayer` to look up the row to update. */
export type LegacyPlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: UpdateLegacyPlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey1Patch;
  playerId: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyPlayerOnPlayerForFakePublicPlayerForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `legacyPlayer` to look up the row to update. */
export type LegacyPlayerOnPlayerForFakePublicPlayerForeignKey0UsingFakePublicLegacyPlayerPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: UpdateLegacyPlayerOnPlayerForFakePublicPlayerForeignKey0Patch;
  playerId: Scalars['Int'];
};

/** The fields on `legacyPlayer` to look up the row to update. */
export type LegacyPlayerOnSeasonStatForFakePublicSeasonStatsForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: UpdateLegacyPlayerOnSeasonStatForFakePublicSeasonStatsForeignKey1Patch;
  playerId: Scalars['Int'];
};

/** The fields on `legacyPlayer` to look up the row to update. */
export type LegacyPlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: UpdateLegacyPlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1Patch;
  playerId: Scalars['Int'];
};

/** The fields on `legacyPlayer` to look up the row to update. */
export type LegacyPlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey1UsingFakePublicLegacyPlayerPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: UpdateLegacyPlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey1Patch;
  playerId: Scalars['Int'];
};

/** Represents an update to a `LegacyPlayer`. Fields that are set will be updated. */
export type LegacyPlayerPatch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** Methods to use when ordering `LegacyPlayer`. */
export enum LegacyPlayersOrderBy {
  NATURAL = 'NATURAL',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  PLAYER_NAME_ASC = 'PLAYER_NAME_ASC',
  PLAYER_NAME_DESC = 'PLAYER_NAME_DESC',
  PLAYER_IMAGE_ASC = 'PLAYER_IMAGE_ASC',
  PLAYER_IMAGE_DESC = 'PLAYER_IMAGE_DESC',
  MEMBER_ID_ASC = 'MEMBER_ID_ASC',
  MEMBER_ID_DESC = 'MEMBER_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type LegacySeason = {
  __typename?: 'LegacySeason';
  groupId: Maybe<Scalars['UUID']>;
  year: Maybe<Scalars['Int']>;
  totalGames: Maybe<Scalars['BigInt']>;
};

/**
 * A condition to be used against `LegacySeason` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LegacySeasonCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `year` field. */
  year?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `totalGames` field. */
  totalGames?: Maybe<Scalars['BigInt']>;
};

export type LegacySeasonStat = {
  __typename?: 'LegacySeasonStat';
  groupId: Maybe<Scalars['UUID']>;
  playerId: Maybe<Scalars['UUID']>;
  legacyPlayerId: Maybe<Scalars['Int']>;
  season: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['Int']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
  /** Reads a single `Player` that is related to this `LegacySeasonStat`. */
  player: Maybe<Player>;
  /** Reads a single `LegacyPlayer` that is related to this `LegacySeasonStat`. */
  legacyPlayer: Maybe<LegacyPlayer>;
  /** Reads a single `Group` that is related to this `LegacySeasonStat`. */
  group: Maybe<Group>;
};

/**
 * A condition to be used against `LegacySeasonStat` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LegacySeasonStatCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The globally unique `ID` look up for the row to update. */
export type LegacySeasonStatOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type LegacySeasonStatOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: LegacyPlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type LegacySeasonStatOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** Methods to use when ordering `LegacySeasonStat`. */
export enum LegacySeasonStatsOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC'
}

/** Methods to use when ordering `LegacySeason`. */
export enum LegacySeasonsOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  YEAR_ASC = 'YEAR_ASC',
  YEAR_DESC = 'YEAR_DESC',
  TOTAL_GAMES_ASC = 'TOTAL_GAMES_ASC',
  TOTAL_GAMES_DESC = 'TOTAL_GAMES_DESC'
}

export type LegacyStatLine = Node & {
  __typename?: 'LegacyStatLine';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  sbStatsId: Maybe<Scalars['Int']>;
  playerId: Scalars['Int'];
  gameId: Scalars['Int'];
  sbStatsTeam: Scalars['Int'];
  sbStatsAb: Maybe<Scalars['Int']>;
  sbStatsRuns: Maybe<Scalars['Int']>;
  sbStatsHits: Maybe<Scalars['Int']>;
  sbStats1B: Maybe<Scalars['Int']>;
  sbStats2B: Maybe<Scalars['Int']>;
  sbStats3B: Maybe<Scalars['Int']>;
  sbStatsHr: Maybe<Scalars['Int']>;
  sbStatsRbi: Maybe<Scalars['Int']>;
  sbStatsBb: Maybe<Scalars['Int']>;
  sbStatsSo: Maybe<Scalars['Int']>;
  sbStatsSac: Maybe<Scalars['Int']>;
  /** Reads and enables pagination through a set of `LegacyGameBattingLine`. */
  legacyGameBattingLinesByLegacyPlayerIdAndLegacyGameIdAndLegacyTeamId: Array<LegacyGameBattingLine>;
};


export type LegacyStatLineLegacyGameBattingLinesByLegacyPlayerIdAndLegacyGameIdAndLegacyTeamIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyGameBattingLinesOrderBy>>;
  condition?: Maybe<LegacyGameBattingLineCondition>;
};

/**
 * A condition to be used against `LegacyStatLine` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LegacyStatLineCondition = {
  /** Checks for equality with the object’s `sbStatsId` field. */
  sbStatsId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsTeam` field. */
  sbStatsTeam?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsAb` field. */
  sbStatsAb?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsRuns` field. */
  sbStatsRuns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsHits` field. */
  sbStatsHits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStats1B` field. */
  sbStats1B?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStats2B` field. */
  sbStats2B?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStats3B` field. */
  sbStats3B?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsHr` field. */
  sbStatsHr?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsRbi` field. */
  sbStatsRbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsBb` field. */
  sbStatsBb?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsSo` field. */
  sbStatsSo?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sbStatsSac` field. */
  sbStatsSac?: Maybe<Scalars['Int']>;
};

/** The fields on `legacyStatLine` to look up the row to connect. */
export type LegacyStatLineFakePublicLegacyStatLinePrimaryKeyConnect = {
  playerId: Scalars['Int'];
  gameId: Scalars['Int'];
  sbStatsTeam: Scalars['Int'];
};

/** The fields on `legacyStatLine` to look up the row to delete. */
export type LegacyStatLineFakePublicLegacyStatLinePrimaryKeyDelete = {
  playerId: Scalars['Int'];
  gameId: Scalars['Int'];
  sbStatsTeam: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LegacyStatLineNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `legacyStatLine` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LegacyStatLineNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `legacyStatLine` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyStatLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey3NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyGameBattingLine` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyGameBattingLine` being updated. */
  patch: LegacyGameBattingLinePatch;
};

/** The fields on `legacyStatLine` to look up the row to update. */
export type LegacyStatLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey3UsingFakePublicLegacyStatLinePrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyStatLine` being updated. */
  patch: UpdateLegacyStatLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey3Patch;
  playerId: Scalars['Int'];
  gameId: Scalars['Int'];
  sbStatsTeam: Scalars['Int'];
};

/** Represents an update to a `LegacyStatLine`. Fields that are set will be updated. */
export type LegacyStatLinePatch = {
  sbStatsId?: Maybe<Scalars['Int']>;
  playerId?: Maybe<Scalars['Int']>;
  gameId?: Maybe<Scalars['Int']>;
  sbStatsTeam?: Maybe<Scalars['Int']>;
  sbStatsAb?: Maybe<Scalars['Int']>;
  sbStatsRuns?: Maybe<Scalars['Int']>;
  sbStatsHits?: Maybe<Scalars['Int']>;
  sbStats1B?: Maybe<Scalars['Int']>;
  sbStats2B?: Maybe<Scalars['Int']>;
  sbStats3B?: Maybe<Scalars['Int']>;
  sbStatsHr?: Maybe<Scalars['Int']>;
  sbStatsRbi?: Maybe<Scalars['Int']>;
  sbStatsBb?: Maybe<Scalars['Int']>;
  sbStatsSo?: Maybe<Scalars['Int']>;
  sbStatsSac?: Maybe<Scalars['Int']>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey3InverseInput>;
};

/** Methods to use when ordering `LegacyStatLine`. */
export enum LegacyStatLinesOrderBy {
  NATURAL = 'NATURAL',
  SB_STATS_ID_ASC = 'SB_STATS_ID_ASC',
  SB_STATS_ID_DESC = 'SB_STATS_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  SB_STATS_TEAM_ASC = 'SB_STATS_TEAM_ASC',
  SB_STATS_TEAM_DESC = 'SB_STATS_TEAM_DESC',
  SB_STATS_AB_ASC = 'SB_STATS_AB_ASC',
  SB_STATS_AB_DESC = 'SB_STATS_AB_DESC',
  SB_STATS_RUNS_ASC = 'SB_STATS_RUNS_ASC',
  SB_STATS_RUNS_DESC = 'SB_STATS_RUNS_DESC',
  SB_STATS_HITS_ASC = 'SB_STATS_HITS_ASC',
  SB_STATS_HITS_DESC = 'SB_STATS_HITS_DESC',
  SB_STATS_1B_ASC = 'SB_STATS_1B_ASC',
  SB_STATS_1B_DESC = 'SB_STATS_1B_DESC',
  SB_STATS_2B_ASC = 'SB_STATS_2B_ASC',
  SB_STATS_2B_DESC = 'SB_STATS_2B_DESC',
  SB_STATS_3B_ASC = 'SB_STATS_3B_ASC',
  SB_STATS_3B_DESC = 'SB_STATS_3B_DESC',
  SB_STATS_HR_ASC = 'SB_STATS_HR_ASC',
  SB_STATS_HR_DESC = 'SB_STATS_HR_DESC',
  SB_STATS_RBI_ASC = 'SB_STATS_RBI_ASC',
  SB_STATS_RBI_DESC = 'SB_STATS_RBI_DESC',
  SB_STATS_BB_ASC = 'SB_STATS_BB_ASC',
  SB_STATS_BB_DESC = 'SB_STATS_BB_DESC',
  SB_STATS_SO_ASC = 'SB_STATS_SO_ASC',
  SB_STATS_SO_DESC = 'SB_STATS_SO_DESC',
  SB_STATS_SAC_ASC = 'SB_STATS_SAC_ASC',
  SB_STATS_SAC_DESC = 'SB_STATS_SAC_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type LegacyTeam = Node & {
  __typename?: 'LegacyTeam';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  teamId: Scalars['Int'];
  teamName: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `LegacyGame`. */
  legacyGamesByGameTeamId1: Array<LegacyGame>;
  /** Reads and enables pagination through a set of `LegacyGame`. */
  legacyGamesByGameTeamId2: Array<LegacyGame>;
};


export type LegacyTeamLegacyGamesByGameTeamId1Args = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyGamesOrderBy>>;
  condition?: Maybe<LegacyGameCondition>;
};


export type LegacyTeamLegacyGamesByGameTeamId2Args = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyGamesOrderBy>>;
  condition?: Maybe<LegacyGameCondition>;
};

/**
 * A condition to be used against `LegacyTeam` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LegacyTeamCondition = {
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `teamName` field. */
  teamName?: Maybe<Scalars['String']>;
};

/** The fields on `legacyTeam` to look up the row to connect. */
export type LegacyTeamFakePublicLegacyTeamPrimaryKeyConnect = {
  teamId: Scalars['Int'];
};

/** The fields on `legacyTeam` to look up the row to delete. */
export type LegacyTeamFakePublicLegacyTeamPrimaryKeyDelete = {
  teamId: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LegacyTeamNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `legacyTeam` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LegacyTeamNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `legacyTeam` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyTeamOnLegacyGameForFakePublicLegacyGameForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyGame` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyGame` being updated. */
  patch: LegacyGamePatch;
};

/** The globally unique `ID` look up for the row to update. */
export type LegacyTeamOnLegacyGameForFakePublicLegacyGameForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyGame` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyGame` being updated. */
  patch: LegacyGamePatch;
};

/** The fields on `legacyTeam` to look up the row to update. */
export type LegacyTeamOnLegacyGameForFakePublicLegacyGameForeignKey1UsingFakePublicLegacyTeamPrimaryKeyUpdate = {
  /** An object where the defined keys will be set on the `legacyTeam` being updated. */
  patch: UpdateLegacyTeamOnLegacyGameForFakePublicLegacyGameForeignKey1Patch;
  teamId: Scalars['Int'];
};

/** Represents an update to a `LegacyTeam`. Fields that are set will be updated. */
export type LegacyTeamPatch = {
  teamId?: Maybe<Scalars['Int']>;
  teamName?: Maybe<Scalars['String']>;
  legacyGamesToGameTeamId1UsingTeamId?: Maybe<FakePublicLegacyGameForeignKey0InverseInput>;
  legacyGamesToGameTeamId2UsingTeamId?: Maybe<FakePublicLegacyGameForeignKey1InverseInput>;
};

/** Methods to use when ordering `LegacyTeam`. */
export enum LegacyTeamsOrderBy {
  NATURAL = 'NATURAL',
  TEAM_ID_ASC = 'TEAM_ID_ASC',
  TEAM_ID_DESC = 'TEAM_ID_DESC',
  TEAM_NAME_ASC = 'TEAM_NAME_ASC',
  TEAM_NAME_DESC = 'TEAM_NAME_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type LineScoreCell = {
  __typename?: 'LineScoreCell';
  inning: Maybe<Scalars['Int']>;
  halfInning: Maybe<HalfInning>;
  runs: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
};

export type Lineup = Node & {
  __typename?: 'Lineup';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  teamId: Scalars['UUID'];
  gameId: Scalars['UUID'];
  /** Reads a single `Team` that is related to this `Lineup`. */
  team: Maybe<Team>;
  /** Reads a single `Game` that is related to this `Lineup`. */
  game: Maybe<Game>;
  /** Reads and enables pagination through a set of `LineupSpot`. */
  lineupSpots: Array<LineupSpot>;
  /** Reads and enables pagination through a set of `LineupChange`. */
  lineupChangesByLineupBeforeId: Array<LineupChange>;
  /** Reads and enables pagination through a set of `LineupChange`. */
  lineupChangesByLineupAfterId: Array<LineupChange>;
  /** Reads and enables pagination through a set of `LineupForGameState`. */
  lineupForGameStates: Array<LineupForGameState>;
};


export type LineupLineupSpotsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupSpotsOrderBy>>;
  condition?: Maybe<LineupSpotCondition>;
};


export type LineupLineupChangesByLineupBeforeIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupChangesOrderBy>>;
  condition?: Maybe<LineupChangeCondition>;
};


export type LineupLineupChangesByLineupAfterIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupChangesOrderBy>>;
  condition?: Maybe<LineupChangeCondition>;
};


export type LineupLineupForGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupForGameStatesOrderBy>>;
  condition?: Maybe<LineupForGameStateCondition>;
};

export type LineupChange = Node & {
  __typename?: 'LineupChange';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  lineupBeforeId: Scalars['UUID'];
  lineupAfterId: Scalars['UUID'];
  gameId: Scalars['UUID'];
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupBefore: Maybe<Lineup>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupAfter: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupChange`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `LineupChange` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LineupChangeCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `lineupBeforeId` field. */
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `lineupAfterId` field. */
  lineupAfterId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** The `game` to be created by this mutation. */
export type LineupChangeGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `LineupChangeInput` mutation. */
export type LineupChangeGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnLineupChangeForLineupChangeGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnLineupChangeForLineupChangeGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupChangeOnLineupChangeForLineupChangeGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<LineupChangeGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `lineupChange` in the `GameInput` mutation. */
export type LineupChangeGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupChange` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectById?: Maybe<Array<LineupChangeLineupChangePkeyConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupChangeNodeIdConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteById?: Maybe<Array<LineupChangeLineupChangePkeyDelete>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupChangeNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateById?: Maybe<Array<LineupChangeOnLineupChangeForLineupChangeGameIdFkeyUsingLineupChangePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnLineupChangeForLineupChangeGameIdFkeyNodeIdUpdate>>;
  /** A `LineupChangeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupChangeGameIdFkeyLineupChangeCreateInput>>;
};

/** The `lineupChange` to be created by this mutation. */
export type LineupChangeGameIdFkeyLineupChangeCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** An input for mutations affecting `LineupChange` */
export type LineupChangeInput = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** Input for the nested mutation of `lineup` in the `LineupChangeInput` mutation. */
export type LineupChangeLineupAfterIdFkeyInput = {
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectById?: Maybe<LineupLineupPkeyConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectByNodeId?: Maybe<LineupNodeIdConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteById?: Maybe<LineupLineupPkeyDelete>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LineupNodeIdDelete>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateById?: Maybe<LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupPkeyUpdate>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate>;
  /** A `LineupInput` object that will be created and connected to this object. */
  create?: Maybe<LineupChangeLineupAfterIdFkeyLineupCreateInput>;
};

/** Input for the nested mutation of `lineupChange` in the `LineupInput` mutation. */
export type LineupChangeLineupAfterIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupChange` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectById?: Maybe<Array<LineupChangeLineupChangePkeyConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupChangeNodeIdConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteById?: Maybe<Array<LineupChangeLineupChangePkeyDelete>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupChangeNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateById?: Maybe<Array<LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupChangePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate>>;
  /** A `LineupChangeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupChangeLineupAfterIdFkeyLineupChangeCreateInput>>;
};

/** The `lineupChange` to be created by this mutation. */
export type LineupChangeLineupAfterIdFkeyLineupChangeCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** The `lineup` to be created by this mutation. */
export type LineupChangeLineupAfterIdFkeyLineupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** Input for the nested mutation of `lineupChange` in the `LineupInput` mutation. */
export type LineupChangeLineupBeforeIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupChange` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectById?: Maybe<Array<LineupChangeLineupChangePkeyConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupChangeNodeIdConnect>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteById?: Maybe<Array<LineupChangeLineupChangePkeyDelete>>;
  /** The primary key(s) for `lineupChange` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupChangeNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateById?: Maybe<Array<LineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyUsingLineupChangePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupChange` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LineupOnLineupChangeForLineupChangeLineupBeforeIdFkeyNodeIdUpdate>>;
  /** A `LineupChangeInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupChangeLineupBeforeIdFkeyLineupChangeCreateInput>>;
};

/** The `lineupChange` to be created by this mutation. */
export type LineupChangeLineupBeforeIdFkeyLineupChangeCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** The fields on `lineupChange` to look up the row to connect. */
export type LineupChangeLineupChangePkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `lineupChange` to look up the row to delete. */
export type LineupChangeLineupChangePkeyDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LineupChangeNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LineupChangeNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupChangeOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `lineupChange` to look up the row to update. */
export type LineupChangeOnGameEventForGameEventLineupChangeIdFkeyUsingLineupChangePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: UpdateLineupChangeOnGameEventForGameEventLineupChangeIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupChangeOnLineupChangeForLineupChangeGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `lineupChange` to look up the row to update. */
export type LineupChangeOnLineupChangeForLineupChangeGameIdFkeyUsingLineupChangePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: UpdateLineupChangeOnLineupChangeForLineupChangeGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: LineupPatch;
};

/** The fields on `lineupChange` to look up the row to update. */
export type LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupChangePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: UpdateLineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `lineupChange` to look up the row to update. */
export type LineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyUsingLineupChangePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: UpdateLineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `LineupChange`. Fields that are set will be updated. */
export type LineupChangePatch = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** Methods to use when ordering `LineupChange`. */
export enum LineupChangesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  LINEUP_BEFORE_ID_ASC = 'LINEUP_BEFORE_ID_ASC',
  LINEUP_BEFORE_ID_DESC = 'LINEUP_BEFORE_ID_DESC',
  LINEUP_AFTER_ID_ASC = 'LINEUP_AFTER_ID_ASC',
  LINEUP_AFTER_ID_DESC = 'LINEUP_AFTER_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** A condition to be used against `Lineup` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type LineupCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `teamId` field. */
  teamId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

export type LineupForGameState = Node & {
  __typename?: 'LineupForGameState';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
  gameId: Scalars['UUID'];
  /** Reads a single `GameState` that is related to this `LineupForGameState`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Lineup` that is related to this `LineupForGameState`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupForGameState`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `LineupForGameState` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type LineupForGameStateCondition = {
  /** Checks for equality with the object’s `gameStateId` field. */
  gameStateId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `lineupId` field. */
  lineupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** The `game` to be created by this mutation. */
export type LineupForGameStateGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `LineupForGameStateInput` mutation. */
export type LineupForGameStateGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnLineupForGameStateForLineupForGameStateGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnLineupForGameStateForLineupForGameStateGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupForGameStateOnLineupForGameStateForLineupForGameStateGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<LineupForGameStateGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `lineupForGameState` in the `GameInput` mutation. */
export type LineupForGameStateGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupForGameState` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupForGameStateNodeIdConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyDelete>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupForGameStateNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateOnLineupForGameStateForLineupForGameStateGameIdFkeyUsingLineupForGameStatePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnLineupForGameStateForLineupForGameStateGameIdFkeyNodeIdUpdate>>;
  /** A `LineupForGameStateInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupForGameStateGameIdFkeyLineupForGameStateCreateInput>>;
};

/** The `lineupForGameState` to be created by this mutation. */
export type LineupForGameStateGameIdFkeyLineupForGameStateCreateInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  lineupId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** The `gameState` to be created by this mutation. */
export type LineupForGameStateGameStateIdFkeyGameStateCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex: Scalars['Int'];
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning: Scalars['Int'];
  halfInning: HalfInning;
  outs: Scalars['Int'];
  score: Array<Maybe<Scalars['Int']>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** Input for the nested mutation of `gameState` in the `LineupForGameStateInput` mutation. */
export type LineupForGameStateGameStateIdFkeyInput = {
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectById?: Maybe<GameStateGameStatePkeyConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameStateNodeIdConnect>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteById?: Maybe<GameStateGameStatePkeyDelete>;
  /** The primary key(s) for `gameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameStateNodeIdDelete>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateById?: Maybe<GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingGameStatePkeyUpdate>;
  /** The primary key(s) and patch data for `gameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate>;
  /** A `GameStateInput` object that will be created and connected to this object. */
  create?: Maybe<LineupForGameStateGameStateIdFkeyGameStateCreateInput>;
};

/** Input for the nested mutation of `lineupForGameState` in the `GameStateInput` mutation. */
export type LineupForGameStateGameStateIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupForGameState` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupForGameStateNodeIdConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyDelete>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupForGameStateNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingLineupForGameStatePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate>>;
  /** A `LineupForGameStateInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupForGameStateGameStateIdFkeyLineupForGameStateCreateInput>>;
};

/** The `lineupForGameState` to be created by this mutation. */
export type LineupForGameStateGameStateIdFkeyLineupForGameStateCreateInput = {
  lineupId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** An input for mutations affecting `LineupForGameState` */
export type LineupForGameStateInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  lineupId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** The fields on `lineupForGameState` to look up the row to connect. */
export type LineupForGameStateLineupForGameStatePkeyConnect = {
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** The fields on `lineupForGameState` to look up the row to delete. */
export type LineupForGameStateLineupForGameStatePkeyDelete = {
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** Input for the nested mutation of `lineup` in the `LineupForGameStateInput` mutation. */
export type LineupForGameStateLineupIdFkeyInput = {
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectById?: Maybe<LineupLineupPkeyConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectByNodeId?: Maybe<LineupNodeIdConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteById?: Maybe<LineupLineupPkeyDelete>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LineupNodeIdDelete>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateById?: Maybe<LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupPkeyUpdate>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate>;
  /** A `LineupInput` object that will be created and connected to this object. */
  create?: Maybe<LineupForGameStateLineupIdFkeyLineupCreateInput>;
};

/** Input for the nested mutation of `lineupForGameState` in the `LineupInput` mutation. */
export type LineupForGameStateLineupIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupForGameState` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupForGameStateNodeIdConnect>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateLineupForGameStatePkeyDelete>>;
  /** The primary key(s) for `lineupForGameState` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupForGameStateNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByGameStateIdAndLineupId?: Maybe<Array<LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupForGameStatePkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate>>;
  /** A `LineupForGameStateInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupForGameStateLineupIdFkeyLineupForGameStateCreateInput>>;
};

/** The `lineup` to be created by this mutation. */
export type LineupForGameStateLineupIdFkeyLineupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** The `lineupForGameState` to be created by this mutation. */
export type LineupForGameStateLineupIdFkeyLineupForGameStateCreateInput = {
  gameStateId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type LineupForGameStateNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `lineupForGameState` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LineupForGameStateNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `lineupForGameState` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `lineupForGameState` to look up the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateGameIdFkeyUsingLineupForGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateGameIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `lineupForGameState` to look up the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingLineupForGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: LineupPatch;
};

/** The fields on `lineupForGameState` to look up the row to update. */
export type LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupForGameStatePkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch;
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** Represents an update to a `LineupForGameState`. Fields that are set will be updated. */
export type LineupForGameStatePatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  lineupId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** Methods to use when ordering `LineupForGameState`. */
export enum LineupForGameStatesOrderBy {
  NATURAL = 'NATURAL',
  GAME_STATE_ID_ASC = 'GAME_STATE_ID_ASC',
  GAME_STATE_ID_DESC = 'GAME_STATE_ID_DESC',
  LINEUP_ID_ASC = 'LINEUP_ID_ASC',
  LINEUP_ID_DESC = 'LINEUP_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** The `game` to be created by this mutation. */
export type LineupGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `LineupInput` mutation. */
export type LineupGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnLineupForLineupGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnLineupForLineupGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupOnLineupForLineupGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<LineupGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `lineup` in the `GameInput` mutation. */
export type LineupGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineup` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectById?: Maybe<Array<LineupLineupPkeyConnect>>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupNodeIdConnect>>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteById?: Maybe<Array<LineupLineupPkeyDelete>>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateById?: Maybe<Array<LineupOnLineupForLineupGameIdFkeyUsingLineupPkeyUpdate>>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnLineupForLineupGameIdFkeyNodeIdUpdate>>;
  /** A `LineupInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupGameIdFkeyLineupCreateInput>>;
};

/** The `lineup` to be created by this mutation. */
export type LineupGameIdFkeyLineupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An input for mutations affecting `Lineup` */
export type LineupInput = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** The fields on `lineup` to look up the row to connect. */
export type LineupLineupPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `lineup` to look up the row to delete. */
export type LineupLineupPkeyDelete = {
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LineupNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LineupNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `lineup` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: LineupChangePatch;
};

/** The fields on `lineup` to look up the row to update. */
export type LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: UpdateLineupOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupChangeForLineupChangeLineupBeforeIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupChange` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupChange` being updated. */
  patch: LineupChangePatch;
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupForGameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupForGameState` being updated. */
  patch: LineupForGameStatePatch;
};

/** The fields on `lineup` to look up the row to update. */
export type LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: UpdateLineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupForLineupGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `lineup` to look up the row to update. */
export type LineupOnLineupForLineupGameIdFkeyUsingLineupPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: UpdateLineupOnLineupForLineupGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupForLineupTeamIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `team` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: TeamPatch;
};

/** The fields on `lineup` to look up the row to update. */
export type LineupOnLineupForLineupTeamIdFkeyUsingLineupPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: UpdateLineupOnLineupForLineupTeamIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupSpot` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: LineupSpotPatch;
};

/** The fields on `lineup` to look up the row to update. */
export type LineupOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: UpdateLineupOnLineupSpotForLineupSpotLineupIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Lineup`. Fields that are set will be updated. */
export type LineupPatch = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

export type LineupSpot = Node & {
  __typename?: 'LineupSpot';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
  position: Maybe<FieldingPosition>;
  gameId: Scalars['UUID'];
  /** Reads a single `Lineup` that is related to this `LineupSpot`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Player` that is related to this `LineupSpot`. */
  player: Maybe<Player>;
  /** Reads a single `Game` that is related to this `LineupSpot`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `LineupSpot` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type LineupSpotCondition = {
  /** Checks for equality with the object’s `lineupId` field. */
  lineupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `battingOrder` field. */
  battingOrder?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `position` field. */
  position?: Maybe<FieldingPosition>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** The `game` to be created by this mutation. */
export type LineupSpotGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `LineupSpotInput` mutation. */
export type LineupSpotGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnLineupSpotForLineupSpotGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnLineupSpotForLineupSpotGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupSpotOnLineupSpotForLineupSpotGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<LineupSpotGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `lineupSpot` in the `GameInput` mutation. */
export type LineupSpotGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupSpot` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupSpotNodeIdConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupSpotNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPlayerId?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotGameIdFkeyUsingLineupSpotPkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotGameIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPosition?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotGameIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnLineupSpotForLineupSpotGameIdFkeyNodeIdUpdate>>;
  /** A `LineupSpotInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupSpotGameIdFkeyLineupSpotCreateInput>>;
};

/** The `lineupSpot` to be created by this mutation. */
export type LineupSpotGameIdFkeyLineupSpotCreateInput = {
  lineupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder: Scalars['Int'];
  position?: Maybe<FieldingPosition>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** An input for mutations affecting `LineupSpot` */
export type LineupSpotInput = {
  lineupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder: Scalars['Int'];
  position?: Maybe<FieldingPosition>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** Input for the nested mutation of `lineup` in the `LineupSpotInput` mutation. */
export type LineupSpotLineupIdFkeyInput = {
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectById?: Maybe<LineupLineupPkeyConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectByNodeId?: Maybe<LineupNodeIdConnect>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteById?: Maybe<LineupLineupPkeyDelete>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<LineupNodeIdDelete>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateById?: Maybe<LineupOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupPkeyUpdate>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate>;
  /** A `LineupInput` object that will be created and connected to this object. */
  create?: Maybe<LineupSpotLineupIdFkeyLineupCreateInput>;
};

/** Input for the nested mutation of `lineupSpot` in the `LineupInput` mutation. */
export type LineupSpotLineupIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupSpot` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupSpotNodeIdConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupSpotNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPlayerId?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotPkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPosition?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<LineupOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate>>;
  /** A `LineupSpotInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupSpotLineupIdFkeyLineupSpotCreateInput>>;
};

/** The `lineup` to be created by this mutation. */
export type LineupSpotLineupIdFkeyLineupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** The `lineupSpot` to be created by this mutation. */
export type LineupSpotLineupIdFkeyLineupSpotCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder: Scalars['Int'];
  position?: Maybe<FieldingPosition>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** The fields on `lineupSpot` to look up the row to connect. */
export type LineupSpotLineupSpotLineupIdBattingOrderKeyConnect = {
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** The fields on `lineupSpot` to look up the row to delete. */
export type LineupSpotLineupSpotLineupIdBattingOrderKeyDelete = {
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** The fields on `lineupSpot` to look up the row to connect. */
export type LineupSpotLineupSpotLineupIdPositionKeyConnect = {
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** The fields on `lineupSpot` to look up the row to delete. */
export type LineupSpotLineupSpotLineupIdPositionKeyDelete = {
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** The fields on `lineupSpot` to look up the row to connect. */
export type LineupSpotLineupSpotPkeyConnect = {
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The fields on `lineupSpot` to look up the row to delete. */
export type LineupSpotLineupSpotPkeyDelete = {
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to connect. */
export type LineupSpotNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `lineupSpot` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type LineupSpotNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `lineupSpot` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotGameIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotGameIdFkeyPatch;
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotGameIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotGameIdFkeyPatch;
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotGameIdFkeyUsingLineupSpotPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotGameIdFkeyPatch;
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: LineupPatch;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch;
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch;
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch;
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch;
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch;
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** The fields on `lineupSpot` to look up the row to update. */
export type LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotPkeyUpdate = {
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: UpdateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch;
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** Represents an update to a `LineupSpot`. Fields that are set will be updated. */
export type LineupSpotPatch = {
  lineupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder?: Maybe<Scalars['Int']>;
  position?: Maybe<FieldingPosition>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** Input for the nested mutation of `player` in the `LineupSpotInput` mutation. */
export type LineupSpotPlayerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<LineupSpotPlayerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `lineupSpot` in the `PlayerInput` mutation. */
export type LineupSpotPlayerIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineupSpot` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupSpotNodeIdConnect>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPlayerId?: Maybe<Array<LineupSpotLineupSpotPkeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotLineupSpotLineupIdBattingOrderKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByLineupIdAndPosition?: Maybe<Array<LineupSpotLineupSpotLineupIdPositionKeyDelete>>;
  /** The primary key(s) for `lineupSpot` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupSpotNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPlayerId?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotPkeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndBattingOrder?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByLineupIdAndPosition?: Maybe<Array<LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate>>;
  /** The primary key(s) and patch data for `lineupSpot` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate>>;
  /** A `LineupSpotInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupSpotPlayerIdFkeyLineupSpotCreateInput>>;
};

/** The `lineupSpot` to be created by this mutation. */
export type LineupSpotPlayerIdFkeyLineupSpotCreateInput = {
  lineupId?: Maybe<Scalars['UUID']>;
  battingOrder: Scalars['Int'];
  position?: Maybe<FieldingPosition>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** The `player` to be created by this mutation. */
export type LineupSpotPlayerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** Methods to use when ordering `LineupSpot`. */
export enum LineupSpotsOrderBy {
  NATURAL = 'NATURAL',
  LINEUP_ID_ASC = 'LINEUP_ID_ASC',
  LINEUP_ID_DESC = 'LINEUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  BATTING_ORDER_ASC = 'BATTING_ORDER_ASC',
  BATTING_ORDER_DESC = 'BATTING_ORDER_DESC',
  POSITION_ASC = 'POSITION_ASC',
  POSITION_DESC = 'POSITION_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** Input for the nested mutation of `team` in the `LineupInput` mutation. */
export type LineupTeamIdFkeyInput = {
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectById?: Maybe<TeamTeamPkeyConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByGameIdAndRole?: Maybe<TeamTeamGameIdRoleKeyConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByNodeId?: Maybe<TeamNodeIdConnect>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteById?: Maybe<TeamTeamPkeyDelete>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByGameIdAndRole?: Maybe<TeamTeamGameIdRoleKeyDelete>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TeamNodeIdDelete>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateById?: Maybe<TeamOnLineupForLineupTeamIdFkeyUsingTeamPkeyUpdate>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByGameIdAndRole?: Maybe<TeamOnLineupForLineupTeamIdFkeyUsingTeamGameIdRoleKeyUpdate>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByNodeId?: Maybe<LineupOnLineupForLineupTeamIdFkeyNodeIdUpdate>;
  /** A `TeamInput` object that will be created and connected to this object. */
  create?: Maybe<LineupTeamIdFkeyTeamCreateInput>;
};

/** Input for the nested mutation of `lineup` in the `TeamInput` mutation. */
export type LineupTeamIdFkeyInverseInput = {
  /** Flag indicating whether all other `lineup` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectById?: Maybe<Array<LineupLineupPkeyConnect>>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<LineupNodeIdConnect>>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteById?: Maybe<Array<LineupLineupPkeyDelete>>;
  /** The primary key(s) for `lineup` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<LineupNodeIdDelete>>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateById?: Maybe<Array<LineupOnLineupForLineupTeamIdFkeyUsingLineupPkeyUpdate>>;
  /** The primary key(s) and patch data for `lineup` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TeamOnLineupForLineupTeamIdFkeyNodeIdUpdate>>;
  /** A `LineupInput` object that will be created and connected to this object. */
  create?: Maybe<Array<LineupTeamIdFkeyLineupCreateInput>>;
};

/** The `lineup` to be created by this mutation. */
export type LineupTeamIdFkeyLineupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** The `team` to be created by this mutation. */
export type LineupTeamIdFkeyTeamCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role: TeamRole;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

/** Methods to use when ordering `Lineup`. */
export enum LineupsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  TEAM_ID_ASC = 'TEAM_ID_ASC',
  TEAM_ID_DESC = 'TEAM_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** All input for the `login` mutation. */
export type LoginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  email: Scalars['String'];
  password: Scalars['String'];
};

/** The output of our `login` mutation. */
export type LoginPayload = {
  __typename?: 'LoginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  jwt: Maybe<Scalars['Jwt']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type ModernSeasonStat = {
  __typename?: 'ModernSeasonStat';
  groupId: Maybe<Scalars['UUID']>;
  playerId: Maybe<Scalars['UUID']>;
  legacyPlayerId: Maybe<Scalars['Int']>;
  season: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['Int']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
};

/**
 * A condition to be used against `ModernSeasonStat` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ModernSeasonStatCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** Methods to use when ordering `ModernSeasonStat`. */
export enum ModernSeasonStatsOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC'
}

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a single `AtBatSkip`. */
  createAtBatSkip: Maybe<CreateAtBatSkipPayload>;
  /** Creates a single `BaseRunner`. */
  createBaseRunner: Maybe<CreateBaseRunnerPayload>;
  /** Creates a single `BasepathMovement`. */
  createBasepathMovement: Maybe<CreateBasepathMovementPayload>;
  /** Creates a single `EarlyGameEnd`. */
  createEarlyGameEnd: Maybe<CreateEarlyGameEndPayload>;
  /** Creates a single `Field`. */
  createField: Maybe<CreateFieldPayload>;
  /** Creates a single `ForeignDbField`. */
  createForeignDbField: Maybe<CreateForeignDbFieldPayload>;
  /** Creates a single `ForeignDbGame`. */
  createForeignDbGame: Maybe<CreateForeignDbGamePayload>;
  /** Creates a single `ForeignDbPlayer`. */
  createForeignDbPlayer: Maybe<CreateForeignDbPlayerPayload>;
  /** Creates a single `ForeignDbStatLine`. */
  createForeignDbStatLine: Maybe<CreateForeignDbStatLinePayload>;
  /** Creates a single `ForeignDbTeam`. */
  createForeignDbTeam: Maybe<CreateForeignDbTeamPayload>;
  /** Creates a single `Game`. */
  createGame: Maybe<CreateGamePayload>;
  /** Creates a single `GameEvent`. */
  createGameEvent: Maybe<CreateGameEventPayload>;
  /** Creates a single `GameEventRecord`. */
  createGameEventRecord: Maybe<CreateGameEventRecordPayload>;
  /** Creates a single `GameState`. */
  createGameState: Maybe<CreateGameStatePayload>;
  /** Creates a single `GameTag`. */
  createGameTag: Maybe<CreateGameTagPayload>;
  /** Creates a single `Group`. */
  createGroup: Maybe<CreateGroupPayload>;
  /** Creates a single `LegacyMeetupFieldRaw`. */
  createLegacyMeetupFieldRaw: Maybe<CreateLegacyMeetupFieldRawPayload>;
  /** Creates a single `LegacyMeetupGameRaw`. */
  createLegacyMeetupGameRaw: Maybe<CreateLegacyMeetupGameRawPayload>;
  /** Creates a single `LegacyMeetupPlayerRaw`. */
  createLegacyMeetupPlayerRaw: Maybe<CreateLegacyMeetupPlayerRawPayload>;
  /** Creates a single `LegacyMeetupStatLineRaw`. */
  createLegacyMeetupStatLineRaw: Maybe<CreateLegacyMeetupStatLineRawPayload>;
  /** Creates a single `LegacyMeetupTeamRaw`. */
  createLegacyMeetupTeamRaw: Maybe<CreateLegacyMeetupTeamRawPayload>;
  /** Creates a single `Lineup`. */
  createLineup: Maybe<CreateLineupPayload>;
  /** Creates a single `LineupChange`. */
  createLineupChange: Maybe<CreateLineupChangePayload>;
  /** Creates a single `LineupForGameState`. */
  createLineupForGameState: Maybe<CreateLineupForGameStatePayload>;
  /** Creates a single `LineupSpot`. */
  createLineupSpot: Maybe<CreateLineupSpotPayload>;
  /** Creates a single `OutOnPlayRunner`. */
  createOutOnPlayRunner: Maybe<CreateOutOnPlayRunnerPayload>;
  /** Creates a single `PlateAppearance`. */
  createPlateAppearance: Maybe<CreatePlateAppearancePayload>;
  /** Creates a single `Player`. */
  createPlayer: Maybe<CreatePlayerPayload>;
  /** Creates a single `PlayerGroupMembership`. */
  createPlayerGroupMembership: Maybe<CreatePlayerGroupMembershipPayload>;
  /** Creates a single `ReduxDump`. */
  createReduxDump: Maybe<CreateReduxDumpPayload>;
  /** Creates a single `ScoredRunner`. */
  createScoredRunner: Maybe<CreateScoredRunnerPayload>;
  /** Creates a single `SoloModeOpponentInning`. */
  createSoloModeOpponentInning: Maybe<CreateSoloModeOpponentInningPayload>;
  /** Creates a single `StolenBaseAttempt`. */
  createStolenBaseAttempt: Maybe<CreateStolenBaseAttemptPayload>;
  /** Creates a single `Tag`. */
  createTag: Maybe<CreateTagPayload>;
  /** Creates a single `Team`. */
  createTeam: Maybe<CreateTeamPayload>;
  /** Updates a single `AtBatSkip` using its globally unique id and a patch. */
  updateAtBatSkipByNodeId: Maybe<UpdateAtBatSkipPayload>;
  /** Updates a single `AtBatSkip` using a unique key and a patch. */
  updateAtBatSkip: Maybe<UpdateAtBatSkipPayload>;
  /** Updates a single `BaseRunner` using its globally unique id and a patch. */
  updateBaseRunnerByNodeId: Maybe<UpdateBaseRunnerPayload>;
  /** Updates a single `BaseRunner` using a unique key and a patch. */
  updateBaseRunner: Maybe<UpdateBaseRunnerPayload>;
  /** Updates a single `BasepathMovement` using its globally unique id and a patch. */
  updateBasepathMovementByNodeId: Maybe<UpdateBasepathMovementPayload>;
  /** Updates a single `BasepathMovement` using a unique key and a patch. */
  updateBasepathMovement: Maybe<UpdateBasepathMovementPayload>;
  /** Updates a single `EarlyGameEnd` using its globally unique id and a patch. */
  updateEarlyGameEndByNodeId: Maybe<UpdateEarlyGameEndPayload>;
  /** Updates a single `EarlyGameEnd` using a unique key and a patch. */
  updateEarlyGameEnd: Maybe<UpdateEarlyGameEndPayload>;
  /** Updates a single `Field` using its globally unique id and a patch. */
  updateFieldByNodeId: Maybe<UpdateFieldPayload>;
  /** Updates a single `Field` using a unique key and a patch. */
  updateField: Maybe<UpdateFieldPayload>;
  /** Updates a single `Game` using its globally unique id and a patch. */
  updateGameByNodeId: Maybe<UpdateGamePayload>;
  /** Updates a single `Game` using a unique key and a patch. */
  updateGame: Maybe<UpdateGamePayload>;
  /** Updates a single `Game` using a unique key and a patch. */
  updateGameByGroupIdAndName: Maybe<UpdateGamePayload>;
  /** Updates a single `GameEvent` using its globally unique id and a patch. */
  updateGameEventByNodeId: Maybe<UpdateGameEventPayload>;
  /** Updates a single `GameEvent` using a unique key and a patch. */
  updateGameEvent: Maybe<UpdateGameEventPayload>;
  /** Updates a single `GameEventRecord` using its globally unique id and a patch. */
  updateGameEventRecordByNodeId: Maybe<UpdateGameEventRecordPayload>;
  /** Updates a single `GameEventRecord` using a unique key and a patch. */
  updateGameEventRecord: Maybe<UpdateGameEventRecordPayload>;
  /** Updates a single `GameEventRecord` using a unique key and a patch. */
  updateGameEventRecordByGameIdAndEventIndex: Maybe<UpdateGameEventRecordPayload>;
  /** Updates a single `GameState` using its globally unique id and a patch. */
  updateGameStateByNodeId: Maybe<UpdateGameStatePayload>;
  /** Updates a single `GameState` using a unique key and a patch. */
  updateGameState: Maybe<UpdateGameStatePayload>;
  /** Updates a single `Group` using its globally unique id and a patch. */
  updateGroupByNodeId: Maybe<UpdateGroupPayload>;
  /** Updates a single `Group` using a unique key and a patch. */
  updateGroup: Maybe<UpdateGroupPayload>;
  /** Updates a single `Group` using a unique key and a patch. */
  updateGroupByName: Maybe<UpdateGroupPayload>;
  /** Updates a single `Group` using a unique key and a patch. */
  updateGroupByUrlSlug: Maybe<UpdateGroupPayload>;
  /** Updates a single `LegacyMeetupFieldRaw` using its globally unique id and a patch. */
  updateLegacyMeetupFieldRawByNodeId: Maybe<UpdateLegacyMeetupFieldRawPayload>;
  /** Updates a single `LegacyMeetupFieldRaw` using a unique key and a patch. */
  updateLegacyMeetupFieldRaw: Maybe<UpdateLegacyMeetupFieldRawPayload>;
  /** Updates a single `LegacyMeetupFieldRaw` using a unique key and a patch. */
  updateLegacyMeetupFieldRawByNameAndSubField: Maybe<UpdateLegacyMeetupFieldRawPayload>;
  /** Updates a single `LegacyMeetupGameRaw` using its globally unique id and a patch. */
  updateLegacyMeetupGameRawByNodeId: Maybe<UpdateLegacyMeetupGameRawPayload>;
  /** Updates a single `LegacyMeetupGameRaw` using a unique key and a patch. */
  updateLegacyMeetupGameRaw: Maybe<UpdateLegacyMeetupGameRawPayload>;
  /** Updates a single `LegacyMeetupGameRaw` using a unique key and a patch. */
  updateLegacyMeetupGameRawByName: Maybe<UpdateLegacyMeetupGameRawPayload>;
  /** Updates a single `LegacyMeetupPlayerRaw` using its globally unique id and a patch. */
  updateLegacyMeetupPlayerRawByNodeId: Maybe<UpdateLegacyMeetupPlayerRawPayload>;
  /** Updates a single `LegacyMeetupPlayerRaw` using a unique key and a patch. */
  updateLegacyMeetupPlayerRaw: Maybe<UpdateLegacyMeetupPlayerRawPayload>;
  /** Updates a single `LegacyMeetupPlayerRaw` using a unique key and a patch. */
  updateLegacyMeetupPlayerRawByName: Maybe<UpdateLegacyMeetupPlayerRawPayload>;
  /** Updates a single `LegacyMeetupStatLineRaw` using its globally unique id and a patch. */
  updateLegacyMeetupStatLineRawByNodeId: Maybe<UpdateLegacyMeetupStatLineRawPayload>;
  /** Updates a single `LegacyMeetupStatLineRaw` using a unique key and a patch. */
  updateLegacyMeetupStatLineRaw: Maybe<UpdateLegacyMeetupStatLineRawPayload>;
  /** Updates a single `LegacyMeetupTeamRaw` using its globally unique id and a patch. */
  updateLegacyMeetupTeamRawByNodeId: Maybe<UpdateLegacyMeetupTeamRawPayload>;
  /** Updates a single `LegacyMeetupTeamRaw` using a unique key and a patch. */
  updateLegacyMeetupTeamRaw: Maybe<UpdateLegacyMeetupTeamRawPayload>;
  /** Updates a single `LegacyMeetupTeamRaw` using a unique key and a patch. */
  updateLegacyMeetupTeamRawByName: Maybe<UpdateLegacyMeetupTeamRawPayload>;
  /** Updates a single `Lineup` using its globally unique id and a patch. */
  updateLineupByNodeId: Maybe<UpdateLineupPayload>;
  /** Updates a single `Lineup` using a unique key and a patch. */
  updateLineup: Maybe<UpdateLineupPayload>;
  /** Updates a single `LineupChange` using its globally unique id and a patch. */
  updateLineupChangeByNodeId: Maybe<UpdateLineupChangePayload>;
  /** Updates a single `LineupChange` using a unique key and a patch. */
  updateLineupChange: Maybe<UpdateLineupChangePayload>;
  /** Updates a single `LineupForGameState` using its globally unique id and a patch. */
  updateLineupForGameStateByNodeId: Maybe<UpdateLineupForGameStatePayload>;
  /** Updates a single `LineupForGameState` using a unique key and a patch. */
  updateLineupForGameState: Maybe<UpdateLineupForGameStatePayload>;
  /** Updates a single `LineupSpot` using its globally unique id and a patch. */
  updateLineupSpotByNodeId: Maybe<UpdateLineupSpotPayload>;
  /** Updates a single `LineupSpot` using a unique key and a patch. */
  updateLineupSpot: Maybe<UpdateLineupSpotPayload>;
  /** Updates a single `LineupSpot` using a unique key and a patch. */
  updateLineupSpotByLineupIdAndBattingOrder: Maybe<UpdateLineupSpotPayload>;
  /** Updates a single `LineupSpot` using a unique key and a patch. */
  updateLineupSpotByLineupIdAndPosition: Maybe<UpdateLineupSpotPayload>;
  /** Updates a single `OutOnPlayRunner` using its globally unique id and a patch. */
  updateOutOnPlayRunnerByNodeId: Maybe<UpdateOutOnPlayRunnerPayload>;
  /** Updates a single `OutOnPlayRunner` using a unique key and a patch. */
  updateOutOnPlayRunner: Maybe<UpdateOutOnPlayRunnerPayload>;
  /** Updates a single `PlateAppearance` using its globally unique id and a patch. */
  updatePlateAppearanceByNodeId: Maybe<UpdatePlateAppearancePayload>;
  /** Updates a single `PlateAppearance` using a unique key and a patch. */
  updatePlateAppearance: Maybe<UpdatePlateAppearancePayload>;
  /** Updates a single `Player` using its globally unique id and a patch. */
  updatePlayerByNodeId: Maybe<UpdatePlayerPayload>;
  /** Updates a single `Player` using a unique key and a patch. */
  updatePlayer: Maybe<UpdatePlayerPayload>;
  /** Updates a single `Player` using a unique key and a patch. */
  updatePlayerByFirstNameAndLastName: Maybe<UpdatePlayerPayload>;
  /** Updates a single `PlayerGroupMembership` using its globally unique id and a patch. */
  updatePlayerGroupMembershipByNodeId: Maybe<UpdatePlayerGroupMembershipPayload>;
  /** Updates a single `PlayerGroupMembership` using a unique key and a patch. */
  updatePlayerGroupMembership: Maybe<UpdatePlayerGroupMembershipPayload>;
  /** Updates a single `ReduxDump` using its globally unique id and a patch. */
  updateReduxDumpByNodeId: Maybe<UpdateReduxDumpPayload>;
  /** Updates a single `ReduxDump` using a unique key and a patch. */
  updateReduxDump: Maybe<UpdateReduxDumpPayload>;
  /** Updates a single `ScoredRunner` using its globally unique id and a patch. */
  updateScoredRunnerByNodeId: Maybe<UpdateScoredRunnerPayload>;
  /** Updates a single `ScoredRunner` using a unique key and a patch. */
  updateScoredRunner: Maybe<UpdateScoredRunnerPayload>;
  /** Updates a single `SoloModeOpponentInning` using its globally unique id and a patch. */
  updateSoloModeOpponentInningByNodeId: Maybe<UpdateSoloModeOpponentInningPayload>;
  /** Updates a single `SoloModeOpponentInning` using a unique key and a patch. */
  updateSoloModeOpponentInning: Maybe<UpdateSoloModeOpponentInningPayload>;
  /** Updates a single `StolenBaseAttempt` using its globally unique id and a patch. */
  updateStolenBaseAttemptByNodeId: Maybe<UpdateStolenBaseAttemptPayload>;
  /** Updates a single `StolenBaseAttempt` using a unique key and a patch. */
  updateStolenBaseAttempt: Maybe<UpdateStolenBaseAttemptPayload>;
  /** Updates a single `Tag` using its globally unique id and a patch. */
  updateTagByNodeId: Maybe<UpdateTagPayload>;
  /** Updates a single `Tag` using a unique key and a patch. */
  updateTag: Maybe<UpdateTagPayload>;
  /** Updates a single `Tag` using a unique key and a patch. */
  updateTagByName: Maybe<UpdateTagPayload>;
  /** Updates a single `Team` using its globally unique id and a patch. */
  updateTeamByNodeId: Maybe<UpdateTeamPayload>;
  /** Updates a single `Team` using a unique key and a patch. */
  updateTeam: Maybe<UpdateTeamPayload>;
  /** Updates a single `Team` using a unique key and a patch. */
  updateTeamByGameIdAndRole: Maybe<UpdateTeamPayload>;
  /** Deletes a single `AtBatSkip` using its globally unique id. */
  deleteAtBatSkipByNodeId: Maybe<DeleteAtBatSkipPayload>;
  /** Deletes a single `AtBatSkip` using a unique key. */
  deleteAtBatSkip: Maybe<DeleteAtBatSkipPayload>;
  /** Deletes a single `BaseRunner` using its globally unique id. */
  deleteBaseRunnerByNodeId: Maybe<DeleteBaseRunnerPayload>;
  /** Deletes a single `BaseRunner` using a unique key. */
  deleteBaseRunner: Maybe<DeleteBaseRunnerPayload>;
  /** Deletes a single `BasepathMovement` using its globally unique id. */
  deleteBasepathMovementByNodeId: Maybe<DeleteBasepathMovementPayload>;
  /** Deletes a single `BasepathMovement` using a unique key. */
  deleteBasepathMovement: Maybe<DeleteBasepathMovementPayload>;
  /** Deletes a single `EarlyGameEnd` using its globally unique id. */
  deleteEarlyGameEndByNodeId: Maybe<DeleteEarlyGameEndPayload>;
  /** Deletes a single `EarlyGameEnd` using a unique key. */
  deleteEarlyGameEnd: Maybe<DeleteEarlyGameEndPayload>;
  /** Deletes a single `Field` using its globally unique id. */
  deleteFieldByNodeId: Maybe<DeleteFieldPayload>;
  /** Deletes a single `Field` using a unique key. */
  deleteField: Maybe<DeleteFieldPayload>;
  /** Deletes a single `Game` using its globally unique id. */
  deleteGameByNodeId: Maybe<DeleteGamePayload>;
  /** Deletes a single `Game` using a unique key. */
  deleteGame: Maybe<DeleteGamePayload>;
  /** Deletes a single `Game` using a unique key. */
  deleteGameByGroupIdAndName: Maybe<DeleteGamePayload>;
  /** Deletes a single `GameEvent` using its globally unique id. */
  deleteGameEventByNodeId: Maybe<DeleteGameEventPayload>;
  /** Deletes a single `GameEvent` using a unique key. */
  deleteGameEvent: Maybe<DeleteGameEventPayload>;
  /** Deletes a single `GameEventRecord` using its globally unique id. */
  deleteGameEventRecordByNodeId: Maybe<DeleteGameEventRecordPayload>;
  /** Deletes a single `GameEventRecord` using a unique key. */
  deleteGameEventRecord: Maybe<DeleteGameEventRecordPayload>;
  /** Deletes a single `GameEventRecord` using a unique key. */
  deleteGameEventRecordByGameIdAndEventIndex: Maybe<DeleteGameEventRecordPayload>;
  /** Deletes a single `GameState` using its globally unique id. */
  deleteGameStateByNodeId: Maybe<DeleteGameStatePayload>;
  /** Deletes a single `GameState` using a unique key. */
  deleteGameState: Maybe<DeleteGameStatePayload>;
  /** Deletes a single `Group` using its globally unique id. */
  deleteGroupByNodeId: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Group` using a unique key. */
  deleteGroup: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Group` using a unique key. */
  deleteGroupByName: Maybe<DeleteGroupPayload>;
  /** Deletes a single `Group` using a unique key. */
  deleteGroupByUrlSlug: Maybe<DeleteGroupPayload>;
  /** Deletes a single `LegacyMeetupFieldRaw` using its globally unique id. */
  deleteLegacyMeetupFieldRawByNodeId: Maybe<DeleteLegacyMeetupFieldRawPayload>;
  /** Deletes a single `LegacyMeetupFieldRaw` using a unique key. */
  deleteLegacyMeetupFieldRaw: Maybe<DeleteLegacyMeetupFieldRawPayload>;
  /** Deletes a single `LegacyMeetupFieldRaw` using a unique key. */
  deleteLegacyMeetupFieldRawByNameAndSubField: Maybe<DeleteLegacyMeetupFieldRawPayload>;
  /** Deletes a single `LegacyMeetupGameRaw` using its globally unique id. */
  deleteLegacyMeetupGameRawByNodeId: Maybe<DeleteLegacyMeetupGameRawPayload>;
  /** Deletes a single `LegacyMeetupGameRaw` using a unique key. */
  deleteLegacyMeetupGameRaw: Maybe<DeleteLegacyMeetupGameRawPayload>;
  /** Deletes a single `LegacyMeetupGameRaw` using a unique key. */
  deleteLegacyMeetupGameRawByName: Maybe<DeleteLegacyMeetupGameRawPayload>;
  /** Deletes a single `LegacyMeetupPlayerRaw` using its globally unique id. */
  deleteLegacyMeetupPlayerRawByNodeId: Maybe<DeleteLegacyMeetupPlayerRawPayload>;
  /** Deletes a single `LegacyMeetupPlayerRaw` using a unique key. */
  deleteLegacyMeetupPlayerRaw: Maybe<DeleteLegacyMeetupPlayerRawPayload>;
  /** Deletes a single `LegacyMeetupPlayerRaw` using a unique key. */
  deleteLegacyMeetupPlayerRawByName: Maybe<DeleteLegacyMeetupPlayerRawPayload>;
  /** Deletes a single `LegacyMeetupStatLineRaw` using its globally unique id. */
  deleteLegacyMeetupStatLineRawByNodeId: Maybe<DeleteLegacyMeetupStatLineRawPayload>;
  /** Deletes a single `LegacyMeetupStatLineRaw` using a unique key. */
  deleteLegacyMeetupStatLineRaw: Maybe<DeleteLegacyMeetupStatLineRawPayload>;
  /** Deletes a single `LegacyMeetupTeamRaw` using its globally unique id. */
  deleteLegacyMeetupTeamRawByNodeId: Maybe<DeleteLegacyMeetupTeamRawPayload>;
  /** Deletes a single `LegacyMeetupTeamRaw` using a unique key. */
  deleteLegacyMeetupTeamRaw: Maybe<DeleteLegacyMeetupTeamRawPayload>;
  /** Deletes a single `LegacyMeetupTeamRaw` using a unique key. */
  deleteLegacyMeetupTeamRawByName: Maybe<DeleteLegacyMeetupTeamRawPayload>;
  /** Deletes a single `Lineup` using its globally unique id. */
  deleteLineupByNodeId: Maybe<DeleteLineupPayload>;
  /** Deletes a single `Lineup` using a unique key. */
  deleteLineup: Maybe<DeleteLineupPayload>;
  /** Deletes a single `LineupChange` using its globally unique id. */
  deleteLineupChangeByNodeId: Maybe<DeleteLineupChangePayload>;
  /** Deletes a single `LineupChange` using a unique key. */
  deleteLineupChange: Maybe<DeleteLineupChangePayload>;
  /** Deletes a single `LineupForGameState` using its globally unique id. */
  deleteLineupForGameStateByNodeId: Maybe<DeleteLineupForGameStatePayload>;
  /** Deletes a single `LineupForGameState` using a unique key. */
  deleteLineupForGameState: Maybe<DeleteLineupForGameStatePayload>;
  /** Deletes a single `LineupSpot` using its globally unique id. */
  deleteLineupSpotByNodeId: Maybe<DeleteLineupSpotPayload>;
  /** Deletes a single `LineupSpot` using a unique key. */
  deleteLineupSpot: Maybe<DeleteLineupSpotPayload>;
  /** Deletes a single `LineupSpot` using a unique key. */
  deleteLineupSpotByLineupIdAndBattingOrder: Maybe<DeleteLineupSpotPayload>;
  /** Deletes a single `LineupSpot` using a unique key. */
  deleteLineupSpotByLineupIdAndPosition: Maybe<DeleteLineupSpotPayload>;
  /** Deletes a single `OutOnPlayRunner` using its globally unique id. */
  deleteOutOnPlayRunnerByNodeId: Maybe<DeleteOutOnPlayRunnerPayload>;
  /** Deletes a single `OutOnPlayRunner` using a unique key. */
  deleteOutOnPlayRunner: Maybe<DeleteOutOnPlayRunnerPayload>;
  /** Deletes a single `PlateAppearance` using its globally unique id. */
  deletePlateAppearanceByNodeId: Maybe<DeletePlateAppearancePayload>;
  /** Deletes a single `PlateAppearance` using a unique key. */
  deletePlateAppearance: Maybe<DeletePlateAppearancePayload>;
  /** Deletes a single `Player` using its globally unique id. */
  deletePlayerByNodeId: Maybe<DeletePlayerPayload>;
  /** Deletes a single `Player` using a unique key. */
  deletePlayer: Maybe<DeletePlayerPayload>;
  /** Deletes a single `Player` using a unique key. */
  deletePlayerByFirstNameAndLastName: Maybe<DeletePlayerPayload>;
  /** Deletes a single `PlayerGroupMembership` using its globally unique id. */
  deletePlayerGroupMembershipByNodeId: Maybe<DeletePlayerGroupMembershipPayload>;
  /** Deletes a single `PlayerGroupMembership` using a unique key. */
  deletePlayerGroupMembership: Maybe<DeletePlayerGroupMembershipPayload>;
  /** Deletes a single `ReduxDump` using its globally unique id. */
  deleteReduxDumpByNodeId: Maybe<DeleteReduxDumpPayload>;
  /** Deletes a single `ReduxDump` using a unique key. */
  deleteReduxDump: Maybe<DeleteReduxDumpPayload>;
  /** Deletes a single `ScoredRunner` using its globally unique id. */
  deleteScoredRunnerByNodeId: Maybe<DeleteScoredRunnerPayload>;
  /** Deletes a single `ScoredRunner` using a unique key. */
  deleteScoredRunner: Maybe<DeleteScoredRunnerPayload>;
  /** Deletes a single `SoloModeOpponentInning` using its globally unique id. */
  deleteSoloModeOpponentInningByNodeId: Maybe<DeleteSoloModeOpponentInningPayload>;
  /** Deletes a single `SoloModeOpponentInning` using a unique key. */
  deleteSoloModeOpponentInning: Maybe<DeleteSoloModeOpponentInningPayload>;
  /** Deletes a single `StolenBaseAttempt` using its globally unique id. */
  deleteStolenBaseAttemptByNodeId: Maybe<DeleteStolenBaseAttemptPayload>;
  /** Deletes a single `StolenBaseAttempt` using a unique key. */
  deleteStolenBaseAttempt: Maybe<DeleteStolenBaseAttemptPayload>;
  /** Deletes a single `Tag` using its globally unique id. */
  deleteTagByNodeId: Maybe<DeleteTagPayload>;
  /** Deletes a single `Tag` using a unique key. */
  deleteTag: Maybe<DeleteTagPayload>;
  /** Deletes a single `Tag` using a unique key. */
  deleteTagByName: Maybe<DeleteTagPayload>;
  /** Deletes a single `Team` using its globally unique id. */
  deleteTeamByNodeId: Maybe<DeleteTeamPayload>;
  /** Deletes a single `Team` using a unique key. */
  deleteTeam: Maybe<DeleteTeamPayload>;
  /** Deletes a single `Team` using a unique key. */
  deleteTeamByGameIdAndRole: Maybe<DeleteTeamPayload>;
  initiatePasswordReset: Maybe<InitiatePasswordResetPayload>;
  initiatePlayerClaim: Maybe<InitiatePlayerClaimPayload>;
  login: Maybe<LoginPayload>;
  resetPassword: Maybe<ResetPasswordPayload>;
  verifyEmail: Maybe<VerifyEmailPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAtBatSkipArgs = {
  input: CreateAtBatSkipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateBaseRunnerArgs = {
  input: CreateBaseRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateBasepathMovementArgs = {
  input: CreateBasepathMovementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateEarlyGameEndArgs = {
  input: CreateEarlyGameEndInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFieldArgs = {
  input: CreateFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateForeignDbFieldArgs = {
  input: CreateForeignDbFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateForeignDbGameArgs = {
  input: CreateForeignDbGameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateForeignDbPlayerArgs = {
  input: CreateForeignDbPlayerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateForeignDbStatLineArgs = {
  input: CreateForeignDbStatLineInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateForeignDbTeamArgs = {
  input: CreateForeignDbTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameArgs = {
  input: CreateGameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameEventArgs = {
  input: CreateGameEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameEventRecordArgs = {
  input: CreateGameEventRecordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameStateArgs = {
  input: CreateGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGameTagArgs = {
  input: CreateGameTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGroupArgs = {
  input: CreateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLegacyMeetupFieldRawArgs = {
  input: CreateLegacyMeetupFieldRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLegacyMeetupGameRawArgs = {
  input: CreateLegacyMeetupGameRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLegacyMeetupPlayerRawArgs = {
  input: CreateLegacyMeetupPlayerRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLegacyMeetupStatLineRawArgs = {
  input: CreateLegacyMeetupStatLineRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLegacyMeetupTeamRawArgs = {
  input: CreateLegacyMeetupTeamRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLineupArgs = {
  input: CreateLineupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLineupChangeArgs = {
  input: CreateLineupChangeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLineupForGameStateArgs = {
  input: CreateLineupForGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateLineupSpotArgs = {
  input: CreateLineupSpotInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOutOnPlayRunnerArgs = {
  input: CreateOutOnPlayRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlateAppearanceArgs = {
  input: CreatePlateAppearanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlayerArgs = {
  input: CreatePlayerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePlayerGroupMembershipArgs = {
  input: CreatePlayerGroupMembershipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReduxDumpArgs = {
  input: CreateReduxDumpInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateScoredRunnerArgs = {
  input: CreateScoredRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSoloModeOpponentInningArgs = {
  input: CreateSoloModeOpponentInningInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateStolenBaseAttemptArgs = {
  input: CreateStolenBaseAttemptInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTagArgs = {
  input: CreateTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTeamArgs = {
  input: CreateTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAtBatSkipByNodeIdArgs = {
  input: UpdateAtBatSkipByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateAtBatSkipArgs = {
  input: UpdateAtBatSkipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBaseRunnerByNodeIdArgs = {
  input: UpdateBaseRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBaseRunnerArgs = {
  input: UpdateBaseRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBasepathMovementByNodeIdArgs = {
  input: UpdateBasepathMovementByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateBasepathMovementArgs = {
  input: UpdateBasepathMovementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEarlyGameEndByNodeIdArgs = {
  input: UpdateEarlyGameEndByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateEarlyGameEndArgs = {
  input: UpdateEarlyGameEndInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldByNodeIdArgs = {
  input: UpdateFieldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFieldArgs = {
  input: UpdateFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameByNodeIdArgs = {
  input: UpdateGameByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameArgs = {
  input: UpdateGameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameByGroupIdAndNameArgs = {
  input: UpdateGameByGroupIdAndNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameEventByNodeIdArgs = {
  input: UpdateGameEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameEventArgs = {
  input: UpdateGameEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameEventRecordByNodeIdArgs = {
  input: UpdateGameEventRecordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameEventRecordArgs = {
  input: UpdateGameEventRecordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameEventRecordByGameIdAndEventIndexArgs = {
  input: UpdateGameEventRecordByGameIdAndEventIndexInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameStateByNodeIdArgs = {
  input: UpdateGameStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGameStateArgs = {
  input: UpdateGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupByNodeIdArgs = {
  input: UpdateGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupArgs = {
  input: UpdateGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupByNameArgs = {
  input: UpdateGroupByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGroupByUrlSlugArgs = {
  input: UpdateGroupByUrlSlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegacyMeetupFieldRawByNodeIdArgs = {
  input: UpdateLegacyMeetupFieldRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegacyMeetupFieldRawArgs = {
  input: UpdateLegacyMeetupFieldRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegacyMeetupFieldRawByNameAndSubFieldArgs = {
  input: UpdateLegacyMeetupFieldRawByNameAndSubFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegacyMeetupGameRawByNodeIdArgs = {
  input: UpdateLegacyMeetupGameRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegacyMeetupGameRawArgs = {
  input: UpdateLegacyMeetupGameRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegacyMeetupGameRawByNameArgs = {
  input: UpdateLegacyMeetupGameRawByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegacyMeetupPlayerRawByNodeIdArgs = {
  input: UpdateLegacyMeetupPlayerRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegacyMeetupPlayerRawArgs = {
  input: UpdateLegacyMeetupPlayerRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegacyMeetupPlayerRawByNameArgs = {
  input: UpdateLegacyMeetupPlayerRawByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegacyMeetupStatLineRawByNodeIdArgs = {
  input: UpdateLegacyMeetupStatLineRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegacyMeetupStatLineRawArgs = {
  input: UpdateLegacyMeetupStatLineRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegacyMeetupTeamRawByNodeIdArgs = {
  input: UpdateLegacyMeetupTeamRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegacyMeetupTeamRawArgs = {
  input: UpdateLegacyMeetupTeamRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLegacyMeetupTeamRawByNameArgs = {
  input: UpdateLegacyMeetupTeamRawByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupByNodeIdArgs = {
  input: UpdateLineupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupArgs = {
  input: UpdateLineupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupChangeByNodeIdArgs = {
  input: UpdateLineupChangeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupChangeArgs = {
  input: UpdateLineupChangeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupForGameStateByNodeIdArgs = {
  input: UpdateLineupForGameStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupForGameStateArgs = {
  input: UpdateLineupForGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupSpotByNodeIdArgs = {
  input: UpdateLineupSpotByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupSpotArgs = {
  input: UpdateLineupSpotInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupSpotByLineupIdAndBattingOrderArgs = {
  input: UpdateLineupSpotByLineupIdAndBattingOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateLineupSpotByLineupIdAndPositionArgs = {
  input: UpdateLineupSpotByLineupIdAndPositionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOutOnPlayRunnerByNodeIdArgs = {
  input: UpdateOutOnPlayRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOutOnPlayRunnerArgs = {
  input: UpdateOutOnPlayRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlateAppearanceByNodeIdArgs = {
  input: UpdatePlateAppearanceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlateAppearanceArgs = {
  input: UpdatePlateAppearanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerByNodeIdArgs = {
  input: UpdatePlayerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerArgs = {
  input: UpdatePlayerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerByFirstNameAndLastNameArgs = {
  input: UpdatePlayerByFirstNameAndLastNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerGroupMembershipByNodeIdArgs = {
  input: UpdatePlayerGroupMembershipByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePlayerGroupMembershipArgs = {
  input: UpdatePlayerGroupMembershipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReduxDumpByNodeIdArgs = {
  input: UpdateReduxDumpByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReduxDumpArgs = {
  input: UpdateReduxDumpInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateScoredRunnerByNodeIdArgs = {
  input: UpdateScoredRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateScoredRunnerArgs = {
  input: UpdateScoredRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSoloModeOpponentInningByNodeIdArgs = {
  input: UpdateSoloModeOpponentInningByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSoloModeOpponentInningArgs = {
  input: UpdateSoloModeOpponentInningInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStolenBaseAttemptByNodeIdArgs = {
  input: UpdateStolenBaseAttemptByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateStolenBaseAttemptArgs = {
  input: UpdateStolenBaseAttemptInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTagByNodeIdArgs = {
  input: UpdateTagByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTagArgs = {
  input: UpdateTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTagByNameArgs = {
  input: UpdateTagByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTeamByNodeIdArgs = {
  input: UpdateTeamByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTeamArgs = {
  input: UpdateTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTeamByGameIdAndRoleArgs = {
  input: UpdateTeamByGameIdAndRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAtBatSkipByNodeIdArgs = {
  input: DeleteAtBatSkipByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteAtBatSkipArgs = {
  input: DeleteAtBatSkipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBaseRunnerByNodeIdArgs = {
  input: DeleteBaseRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBaseRunnerArgs = {
  input: DeleteBaseRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBasepathMovementByNodeIdArgs = {
  input: DeleteBasepathMovementByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteBasepathMovementArgs = {
  input: DeleteBasepathMovementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEarlyGameEndByNodeIdArgs = {
  input: DeleteEarlyGameEndByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteEarlyGameEndArgs = {
  input: DeleteEarlyGameEndInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldByNodeIdArgs = {
  input: DeleteFieldByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFieldArgs = {
  input: DeleteFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameByNodeIdArgs = {
  input: DeleteGameByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameArgs = {
  input: DeleteGameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameByGroupIdAndNameArgs = {
  input: DeleteGameByGroupIdAndNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameEventByNodeIdArgs = {
  input: DeleteGameEventByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameEventArgs = {
  input: DeleteGameEventInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameEventRecordByNodeIdArgs = {
  input: DeleteGameEventRecordByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameEventRecordArgs = {
  input: DeleteGameEventRecordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameEventRecordByGameIdAndEventIndexArgs = {
  input: DeleteGameEventRecordByGameIdAndEventIndexInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameStateByNodeIdArgs = {
  input: DeleteGameStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGameStateArgs = {
  input: DeleteGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupByNodeIdArgs = {
  input: DeleteGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupArgs = {
  input: DeleteGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupByNameArgs = {
  input: DeleteGroupByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGroupByUrlSlugArgs = {
  input: DeleteGroupByUrlSlugInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegacyMeetupFieldRawByNodeIdArgs = {
  input: DeleteLegacyMeetupFieldRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegacyMeetupFieldRawArgs = {
  input: DeleteLegacyMeetupFieldRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegacyMeetupFieldRawByNameAndSubFieldArgs = {
  input: DeleteLegacyMeetupFieldRawByNameAndSubFieldInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegacyMeetupGameRawByNodeIdArgs = {
  input: DeleteLegacyMeetupGameRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegacyMeetupGameRawArgs = {
  input: DeleteLegacyMeetupGameRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegacyMeetupGameRawByNameArgs = {
  input: DeleteLegacyMeetupGameRawByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegacyMeetupPlayerRawByNodeIdArgs = {
  input: DeleteLegacyMeetupPlayerRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegacyMeetupPlayerRawArgs = {
  input: DeleteLegacyMeetupPlayerRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegacyMeetupPlayerRawByNameArgs = {
  input: DeleteLegacyMeetupPlayerRawByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegacyMeetupStatLineRawByNodeIdArgs = {
  input: DeleteLegacyMeetupStatLineRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegacyMeetupStatLineRawArgs = {
  input: DeleteLegacyMeetupStatLineRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegacyMeetupTeamRawByNodeIdArgs = {
  input: DeleteLegacyMeetupTeamRawByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegacyMeetupTeamRawArgs = {
  input: DeleteLegacyMeetupTeamRawInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLegacyMeetupTeamRawByNameArgs = {
  input: DeleteLegacyMeetupTeamRawByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupByNodeIdArgs = {
  input: DeleteLineupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupArgs = {
  input: DeleteLineupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupChangeByNodeIdArgs = {
  input: DeleteLineupChangeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupChangeArgs = {
  input: DeleteLineupChangeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupForGameStateByNodeIdArgs = {
  input: DeleteLineupForGameStateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupForGameStateArgs = {
  input: DeleteLineupForGameStateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupSpotByNodeIdArgs = {
  input: DeleteLineupSpotByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupSpotArgs = {
  input: DeleteLineupSpotInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupSpotByLineupIdAndBattingOrderArgs = {
  input: DeleteLineupSpotByLineupIdAndBattingOrderInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteLineupSpotByLineupIdAndPositionArgs = {
  input: DeleteLineupSpotByLineupIdAndPositionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOutOnPlayRunnerByNodeIdArgs = {
  input: DeleteOutOnPlayRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOutOnPlayRunnerArgs = {
  input: DeleteOutOnPlayRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlateAppearanceByNodeIdArgs = {
  input: DeletePlateAppearanceByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlateAppearanceArgs = {
  input: DeletePlateAppearanceInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerByNodeIdArgs = {
  input: DeletePlayerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerArgs = {
  input: DeletePlayerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerByFirstNameAndLastNameArgs = {
  input: DeletePlayerByFirstNameAndLastNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerGroupMembershipByNodeIdArgs = {
  input: DeletePlayerGroupMembershipByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePlayerGroupMembershipArgs = {
  input: DeletePlayerGroupMembershipInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReduxDumpByNodeIdArgs = {
  input: DeleteReduxDumpByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReduxDumpArgs = {
  input: DeleteReduxDumpInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteScoredRunnerByNodeIdArgs = {
  input: DeleteScoredRunnerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteScoredRunnerArgs = {
  input: DeleteScoredRunnerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSoloModeOpponentInningByNodeIdArgs = {
  input: DeleteSoloModeOpponentInningByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSoloModeOpponentInningArgs = {
  input: DeleteSoloModeOpponentInningInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStolenBaseAttemptByNodeIdArgs = {
  input: DeleteStolenBaseAttemptByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteStolenBaseAttemptArgs = {
  input: DeleteStolenBaseAttemptInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTagByNodeIdArgs = {
  input: DeleteTagByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTagArgs = {
  input: DeleteTagInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTagByNameArgs = {
  input: DeleteTagByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTeamByNodeIdArgs = {
  input: DeleteTeamByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTeamArgs = {
  input: DeleteTeamInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTeamByGameIdAndRoleArgs = {
  input: DeleteTeamByGameIdAndRoleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationInitiatePasswordResetArgs = {
  input: InitiatePasswordResetInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationInitiatePlayerClaimArgs = {
  input: InitiatePlayerClaimInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationLoginArgs = {
  input: LoginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationResetPasswordArgs = {
  input: ResetPasswordInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationVerifyEmailArgs = {
  input: VerifyEmailInput;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type OutOnPlayRunner = Node & {
  __typename?: 'OutOnPlayRunner';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
  gameId: Scalars['UUID'];
  /** Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `OutOnPlayRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `OutOnPlayRunner`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `OutOnPlayRunner` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OutOnPlayRunnerCondition = {
  /** Checks for equality with the object’s `plateAppearanceId` field. */
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runnerId` field. */
  runnerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** The `game` to be created by this mutation. */
export type OutOnPlayRunnerGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `OutOnPlayRunnerInput` mutation. */
export type OutOnPlayRunnerGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<OutOnPlayRunnerGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `outOnPlayRunner` in the `GameInput` mutation. */
export type OutOnPlayRunnerGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `outOnPlayRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyDelete>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyUsingOutOnPlayRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyNodeIdUpdate>>;
  /** A `OutOnPlayRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<OutOnPlayRunnerGameIdFkeyOutOnPlayRunnerCreateInput>>;
};

/** The `outOnPlayRunner` to be created by this mutation. */
export type OutOnPlayRunnerGameIdFkeyOutOnPlayRunnerCreateInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** An input for mutations affecting `OutOnPlayRunner` */
export type OutOnPlayRunnerInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type OutOnPlayRunnerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `outOnPlayRunner` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type OutOnPlayRunnerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `outOnPlayRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `outOnPlayRunner` to look up the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyUsingOutOnPlayRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** The fields on `outOnPlayRunner` to look up the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingOutOnPlayRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `outOnPlayRunner` to look up the row to update. */
export type OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingOutOnPlayRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The fields on `outOnPlayRunner` to look up the row to connect. */
export type OutOnPlayRunnerOutOnPlayRunnerPkeyConnect = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The fields on `outOnPlayRunner` to look up the row to delete. */
export type OutOnPlayRunnerOutOnPlayRunnerPkeyDelete = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** Represents an update to a `OutOnPlayRunner`. Fields that are set will be updated. */
export type OutOnPlayRunnerPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** Input for the nested mutation of `plateAppearance` in the `OutOnPlayRunnerInput` mutation. */
export type OutOnPlayRunnerPlateAppearanceIdFkeyInput = {
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectById?: Maybe<PlateAppearancePlateAppearancePkeyConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlateAppearanceNodeIdConnect>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteById?: Maybe<PlateAppearancePlateAppearancePkeyDelete>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlateAppearanceNodeIdDelete>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateById?: Maybe<PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateByNodeId?: Maybe<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate>;
  /** A `PlateAppearanceInput` object that will be created and connected to this object. */
  create?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyPlateAppearanceCreateInput>;
};

/** Input for the nested mutation of `outOnPlayRunner` in the `PlateAppearanceInput` mutation. */
export type OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput = {
  /** Flag indicating whether all other `outOnPlayRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyDelete>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingOutOnPlayRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate>>;
  /** A `OutOnPlayRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<OutOnPlayRunnerPlateAppearanceIdFkeyOutOnPlayRunnerCreateInput>>;
};

/** The `outOnPlayRunner` to be created by this mutation. */
export type OutOnPlayRunnerPlateAppearanceIdFkeyOutOnPlayRunnerCreateInput = {
  runnerId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** The `plateAppearance` to be created by this mutation. */
export type OutOnPlayRunnerPlateAppearanceIdFkeyPlateAppearanceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** Input for the nested mutation of `player` in the `OutOnPlayRunnerInput` mutation. */
export type OutOnPlayRunnerRunnerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<OutOnPlayRunnerRunnerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `outOnPlayRunner` in the `PlayerInput` mutation. */
export type OutOnPlayRunnerRunnerIdFkeyInverseInput = {
  /** Flag indicating whether all other `outOnPlayRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdConnect>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOutOnPlayRunnerPkeyDelete>>;
  /** The primary key(s) for `outOnPlayRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<OutOnPlayRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByPlateAppearanceIdAndRunnerId?: Maybe<Array<OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingOutOnPlayRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate>>;
  /** A `OutOnPlayRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<OutOnPlayRunnerRunnerIdFkeyOutOnPlayRunnerCreateInput>>;
};

/** The `outOnPlayRunner` to be created by this mutation. */
export type OutOnPlayRunnerRunnerIdFkeyOutOnPlayRunnerCreateInput = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** The `player` to be created by this mutation. */
export type OutOnPlayRunnerRunnerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** Methods to use when ordering `OutOnPlayRunner`. */
export enum OutOnPlayRunnersOrderBy {
  NATURAL = 'NATURAL',
  PLATE_APPEARANCE_ID_ASC = 'PLATE_APPEARANCE_ID_ASC',
  PLATE_APPEARANCE_ID_DESC = 'PLATE_APPEARANCE_ID_DESC',
  RUNNER_ID_ASC = 'RUNNER_ID_ASC',
  RUNNER_ID_DESC = 'RUNNER_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export enum PermissionType {
  ADD_NEW_PLAYERS = 'ADD_NEW_PLAYERS',
  SAVE_DEBUG_DATA = 'SAVE_DEBUG_DATA'
}

export type PlateAppearance = Node & {
  __typename?: 'PlateAppearance';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  type: PlateAppearanceType;
  contact: Maybe<ContactQuality>;
  fieldedBy: Maybe<FieldingPosition>;
  runsScoredOnSacFly: Maybe<Scalars['Int']>;
  routinePlay: Scalars['Boolean'];
  gameId: Scalars['UUID'];
  batterId: Scalars['UUID'];
  /** Reads a single `Game` that is related to this `PlateAppearance`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `PlateAppearance`. */
  batter: Maybe<Player>;
  /** Reads and enables pagination through a set of `BasepathMovement`. */
  basepathMovements: Array<BasepathMovement>;
  /** Reads and enables pagination through a set of `OutOnPlayRunner`. */
  outOnPlayRunners: Array<OutOnPlayRunner>;
};


export type PlateAppearanceBasepathMovementsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BasepathMovementsOrderBy>>;
  condition?: Maybe<BasepathMovementCondition>;
};


export type PlateAppearanceOutOnPlayRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<OutOnPlayRunnersOrderBy>>;
  condition?: Maybe<OutOnPlayRunnerCondition>;
};

/** Input for the nested mutation of `player` in the `PlateAppearanceInput` mutation. */
export type PlateAppearanceBatterIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<PlateAppearanceOnPlateAppearanceForPlateAppearanceBatterIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<PlateAppearanceBatterIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `plateAppearance` in the `PlayerInput` mutation. */
export type PlateAppearanceBatterIdFkeyInverseInput = {
  /** Flag indicating whether all other `plateAppearance` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectById?: Maybe<Array<PlateAppearancePlateAppearancePkeyConnect>>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PlateAppearanceNodeIdConnect>>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteById?: Maybe<Array<PlateAppearancePlateAppearancePkeyDelete>>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PlateAppearanceNodeIdDelete>>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateById?: Maybe<Array<PlateAppearanceOnPlateAppearanceForPlateAppearanceBatterIdFkeyUsingPlateAppearancePkeyUpdate>>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyNodeIdUpdate>>;
  /** A `PlateAppearanceInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PlateAppearanceBatterIdFkeyPlateAppearanceCreateInput>>;
};

/** The `plateAppearance` to be created by this mutation. */
export type PlateAppearanceBatterIdFkeyPlateAppearanceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** The `player` to be created by this mutation. */
export type PlateAppearanceBatterIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/**
 * A condition to be used against `PlateAppearance` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PlateAppearanceCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<PlateAppearanceType>;
  /** Checks for equality with the object’s `contact` field. */
  contact?: Maybe<ContactQuality>;
  /** Checks for equality with the object’s `fieldedBy` field. */
  fieldedBy?: Maybe<FieldingPosition>;
  /** Checks for equality with the object’s `runsScoredOnSacFly` field. */
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `routinePlay` field. */
  routinePlay?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `batterId` field. */
  batterId?: Maybe<Scalars['UUID']>;
};

/** The `game` to be created by this mutation. */
export type PlateAppearanceGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `PlateAppearanceInput` mutation. */
export type PlateAppearanceGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnPlateAppearanceForPlateAppearanceGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnPlateAppearanceForPlateAppearanceGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<PlateAppearanceOnPlateAppearanceForPlateAppearanceGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<PlateAppearanceGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `plateAppearance` in the `GameInput` mutation. */
export type PlateAppearanceGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `plateAppearance` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectById?: Maybe<Array<PlateAppearancePlateAppearancePkeyConnect>>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PlateAppearanceNodeIdConnect>>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteById?: Maybe<Array<PlateAppearancePlateAppearancePkeyDelete>>;
  /** The primary key(s) for `plateAppearance` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PlateAppearanceNodeIdDelete>>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateById?: Maybe<Array<PlateAppearanceOnPlateAppearanceForPlateAppearanceGameIdFkeyUsingPlateAppearancePkeyUpdate>>;
  /** The primary key(s) and patch data for `plateAppearance` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnPlateAppearanceForPlateAppearanceGameIdFkeyNodeIdUpdate>>;
  /** A `PlateAppearanceInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PlateAppearanceGameIdFkeyPlateAppearanceCreateInput>>;
};

/** The `plateAppearance` to be created by this mutation. */
export type PlateAppearanceGameIdFkeyPlateAppearanceCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** An input for mutations affecting `PlateAppearance` */
export type PlateAppearanceInput = {
  id?: Maybe<Scalars['UUID']>;
  type: PlateAppearanceType;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PlateAppearanceNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PlateAppearanceNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `basepathMovement` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: BasepathMovementPatch;
};

/** The fields on `plateAppearance` to look up the row to update. */
export type PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate = {
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: UpdatePlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `plateAppearance` to look up the row to update. */
export type PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate = {
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: UpdatePlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `outOnPlayRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: OutOnPlayRunnerPatch;
};

/** The fields on `plateAppearance` to look up the row to update. */
export type PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate = {
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: UpdatePlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlateAppearanceOnPlateAppearanceForPlateAppearanceBatterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `plateAppearance` to look up the row to update. */
export type PlateAppearanceOnPlateAppearanceForPlateAppearanceBatterIdFkeyUsingPlateAppearancePkeyUpdate = {
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: UpdatePlateAppearanceOnPlateAppearanceForPlateAppearanceBatterIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlateAppearanceOnPlateAppearanceForPlateAppearanceGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `plateAppearance` to look up the row to update. */
export type PlateAppearanceOnPlateAppearanceForPlateAppearanceGameIdFkeyUsingPlateAppearancePkeyUpdate = {
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: UpdatePlateAppearanceOnPlateAppearanceForPlateAppearanceGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `PlateAppearance`. Fields that are set will be updated. */
export type PlateAppearancePatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** The fields on `plateAppearance` to look up the row to connect. */
export type PlateAppearancePlateAppearancePkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `plateAppearance` to look up the row to delete. */
export type PlateAppearancePlateAppearancePkeyDelete = {
  id: Scalars['UUID'];
};

export enum PlateAppearanceType {
  OUT = 'OUT',
  WALK = 'WALK',
  SINGLE = 'SINGLE',
  DOUBLE = 'DOUBLE',
  TRIPLE = 'TRIPLE',
  HOMERUN = 'HOMERUN',
  SACRIFICE_FLY = 'SACRIFICE_FLY',
  FIELDERS_CHOICE = 'FIELDERS_CHOICE',
  DOUBLE_PLAY = 'DOUBLE_PLAY'
}

/** Methods to use when ordering `PlateAppearance`. */
export enum PlateAppearancesOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  TYPE_ASC = 'TYPE_ASC',
  TYPE_DESC = 'TYPE_DESC',
  CONTACT_ASC = 'CONTACT_ASC',
  CONTACT_DESC = 'CONTACT_DESC',
  FIELDED_BY_ASC = 'FIELDED_BY_ASC',
  FIELDED_BY_DESC = 'FIELDED_BY_DESC',
  RUNS_SCORED_ON_SAC_FLY_ASC = 'RUNS_SCORED_ON_SAC_FLY_ASC',
  RUNS_SCORED_ON_SAC_FLY_DESC = 'RUNS_SCORED_ON_SAC_FLY_DESC',
  ROUTINE_PLAY_ASC = 'ROUTINE_PLAY_ASC',
  ROUTINE_PLAY_DESC = 'ROUTINE_PLAY_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  BATTER_ID_ASC = 'BATTER_ID_ASC',
  BATTER_ID_DESC = 'BATTER_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type Player = Node & {
  __typename?: 'Player';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  legacyPlayerId: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName: Maybe<Scalars['String']>;
  nickname: Maybe<Scalars['String']>;
  imageUrl: Maybe<Scalars['String']>;
  timeCreated: Scalars['Datetime'];
  claimed: Scalars['Boolean'];
  timeUpdated: Scalars['Datetime'];
  timeClaimed: Maybe<Scalars['Datetime']>;
  /** Reads a single `LegacyPlayer` that is related to this `Player`. */
  legacyPlayer: Maybe<LegacyPlayer>;
  /** Reads and enables pagination through a set of `Team`. */
  teamsByCaptainId: Array<Team>;
  /** Reads and enables pagination through a set of `LineupSpot`. */
  lineupSpots: Array<LineupSpot>;
  /** Reads and enables pagination through a set of `PlateAppearance`. */
  plateAppearancesByBatterId: Array<PlateAppearance>;
  /** Reads and enables pagination through a set of `BasepathMovement`. */
  basepathMovementsByRunnerId: Array<BasepathMovement>;
  /** Reads and enables pagination through a set of `OutOnPlayRunner`. */
  outOnPlayRunnersByRunnerId: Array<OutOnPlayRunner>;
  /** Reads and enables pagination through a set of `StolenBaseAttempt`. */
  stolenBaseAttemptsByRunnerId: Array<StolenBaseAttempt>;
  /** Reads and enables pagination through a set of `GameState`. */
  gameStatesByPlayerAtBat: Array<GameState>;
  /** Reads and enables pagination through a set of `BaseRunner`. */
  baseRunnersByRunnerId: Array<BaseRunner>;
  /** Reads and enables pagination through a set of `ScoredRunner`. */
  scoredRunnersByRunnerId: Array<ScoredRunner>;
  /** Reads and enables pagination through a set of `PlayerGroupMembership`. */
  playerGroupMemberships: Array<PlayerGroupMembership>;
  /** Reads and enables pagination through a set of `AtBatSkip`. */
  atBatSkipsByBatterId: Array<AtBatSkip>;
  /** Reads and enables pagination through a set of `CareerStat`. */
  careerStats: Array<CareerStat>;
  /** Reads and enables pagination through a set of `CareerStatsQualifiedBatter`. */
  careerStatsQualifiedBatters: Array<CareerStatsQualifiedBatter>;
  /** Reads and enables pagination through a set of `GameBattingLine`. */
  gameBattingLines: Array<GameBattingLine>;
  /** Reads and enables pagination through a set of `LegacyGameBattingLine`. */
  legacyGameBattingLines: Array<LegacyGameBattingLine>;
  /** Reads and enables pagination through a set of `LegacySeasonStat`. */
  legacySeasonStats: Array<LegacySeasonStat>;
  /** Reads and enables pagination through a set of `SeasonStat`. */
  seasonStats: Array<SeasonStat>;
  /** Reads and enables pagination through a set of `SeasonStatsAllTimeQualifiedBatter`. */
  seasonStatsAllTimeQualifiedBatters: Array<SeasonStatsAllTimeQualifiedBatter>;
  /** Reads and enables pagination through a set of `SeasonStatsQualifiedBatter`. */
  seasonStatsQualifiedBatters: Array<SeasonStatsQualifiedBatter>;
  debut: Maybe<Scalars['Date']>;
  fullName: Maybe<Scalars['String']>;
  gamesPlayed: Maybe<Scalars['Int']>;
  /** sortable */
  gamesPlayedThisYear: Maybe<Scalars['Int']>;
};


export type PlayerTeamsByCaptainIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<TeamsOrderBy>>;
  condition?: Maybe<TeamCondition>;
};


export type PlayerLineupSpotsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupSpotsOrderBy>>;
  condition?: Maybe<LineupSpotCondition>;
};


export type PlayerPlateAppearancesByBatterIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlateAppearancesOrderBy>>;
  condition?: Maybe<PlateAppearanceCondition>;
};


export type PlayerBasepathMovementsByRunnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BasepathMovementsOrderBy>>;
  condition?: Maybe<BasepathMovementCondition>;
};


export type PlayerOutOnPlayRunnersByRunnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<OutOnPlayRunnersOrderBy>>;
  condition?: Maybe<OutOnPlayRunnerCondition>;
};


export type PlayerStolenBaseAttemptsByRunnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<StolenBaseAttemptsOrderBy>>;
  condition?: Maybe<StolenBaseAttemptCondition>;
};


export type PlayerGameStatesByPlayerAtBatArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameStatesOrderBy>>;
  condition?: Maybe<GameStateCondition>;
};


export type PlayerBaseRunnersByRunnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BaseRunnersOrderBy>>;
  condition?: Maybe<BaseRunnerCondition>;
};


export type PlayerScoredRunnersByRunnerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ScoredRunnersOrderBy>>;
  condition?: Maybe<ScoredRunnerCondition>;
};


export type PlayerPlayerGroupMembershipsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlayerGroupMembershipsOrderBy>>;
  condition?: Maybe<PlayerGroupMembershipCondition>;
};


export type PlayerAtBatSkipsByBatterIdArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<AtBatSkipsOrderBy>>;
  condition?: Maybe<AtBatSkipCondition>;
};


export type PlayerCareerStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsOrderBy>>;
  condition?: Maybe<CareerStatCondition>;
};


export type PlayerCareerStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<CareerStatsQualifiedBatterCondition>;
};


export type PlayerGameBattingLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameBattingLinesOrderBy>>;
  condition?: Maybe<GameBattingLineCondition>;
};


export type PlayerLegacyGameBattingLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyGameBattingLinesOrderBy>>;
  condition?: Maybe<LegacyGameBattingLineCondition>;
};


export type PlayerLegacySeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacySeasonStatsOrderBy>>;
  condition?: Maybe<LegacySeasonStatCondition>;
};


export type PlayerSeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsOrderBy>>;
  condition?: Maybe<SeasonStatCondition>;
};


export type PlayerSeasonStatsAllTimeQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsAllTimeQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsAllTimeQualifiedBatterCondition>;
};


export type PlayerSeasonStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsQualifiedBatterCondition>;
};


export type PlayerGamesPlayedArgs = {
  beforeDate?: Maybe<Scalars['Datetime']>;
  afterDate?: Maybe<Scalars['Datetime']>;
};

/** A condition to be used against `Player` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type PlayerCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `nickname` field. */
  nickname?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `imageUrl` field. */
  imageUrl?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `claimed` field. */
  claimed?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `timeUpdated` field. */
  timeUpdated?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `timeClaimed` field. */
  timeClaimed?: Maybe<Scalars['Datetime']>;
};

export type PlayerGroupMembership = Node & {
  __typename?: 'PlayerGroupMembership';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
  /** Reads a single `Player` that is related to this `PlayerGroupMembership`. */
  player: Maybe<Player>;
  /** Reads a single `Group` that is related to this `PlayerGroupMembership`. */
  group: Maybe<Group>;
};

/**
 * A condition to be used against `PlayerGroupMembership` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type PlayerGroupMembershipCondition = {
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
};

/** The `group` to be created by this mutation. */
export type PlayerGroupMembershipGroupIdFkeyGroupCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug: Scalars['String'];
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** Input for the nested mutation of `group` in the `PlayerGroupMembershipInput` mutation. */
export type PlayerGroupMembershipGroupIdFkeyInput = {
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectById?: Maybe<GroupGroupPkeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByName?: Maybe<GroupGroupNameKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByUrlSlug?: Maybe<GroupGroupUrlSlugKeyConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  connectByNodeId?: Maybe<GroupNodeIdConnect>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteById?: Maybe<GroupGroupPkeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByName?: Maybe<GroupGroupNameKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByUrlSlug?: Maybe<GroupGroupUrlSlugKeyDelete>;
  /** The primary key(s) for `group` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GroupNodeIdDelete>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateById?: Maybe<GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingGroupPkeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByName?: Maybe<GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingGroupNameKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByUrlSlug?: Maybe<GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingGroupUrlSlugKeyUpdate>;
  /** The primary key(s) and patch data for `group` for the far side of the relationship. */
  updateByNodeId?: Maybe<PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyNodeIdUpdate>;
  /** A `GroupInput` object that will be created and connected to this object. */
  create?: Maybe<PlayerGroupMembershipGroupIdFkeyGroupCreateInput>;
};

/** Input for the nested mutation of `playerGroupMembership` in the `GroupInput` mutation. */
export type PlayerGroupMembershipGroupIdFkeyInverseInput = {
  /** Flag indicating whether all other `playerGroupMembership` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  connectByPlayerIdAndGroupId?: Maybe<Array<PlayerGroupMembershipPlayerGroupMembershipPkeyConnect>>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PlayerGroupMembershipNodeIdConnect>>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  deleteByPlayerIdAndGroupId?: Maybe<Array<PlayerGroupMembershipPlayerGroupMembershipPkeyDelete>>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PlayerGroupMembershipNodeIdDelete>>;
  /** The primary key(s) and patch data for `playerGroupMembership` for the far side of the relationship. */
  updateByPlayerIdAndGroupId?: Maybe<Array<PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingPlayerGroupMembershipPkeyUpdate>>;
  /** The primary key(s) and patch data for `playerGroupMembership` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyNodeIdUpdate>>;
  /** A `PlayerGroupMembershipInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PlayerGroupMembershipGroupIdFkeyPlayerGroupMembershipCreateInput>>;
};

/** The `playerGroupMembership` to be created by this mutation. */
export type PlayerGroupMembershipGroupIdFkeyPlayerGroupMembershipCreateInput = {
  playerId?: Maybe<Scalars['UUID']>;
  player?: Maybe<PlayerGroupMembershipPlayerIdFkeyInput>;
  group?: Maybe<PlayerGroupMembershipGroupIdFkeyInput>;
};

/** An input for mutations affecting `PlayerGroupMembership` */
export type PlayerGroupMembershipInput = {
  playerId?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  player?: Maybe<PlayerGroupMembershipPlayerIdFkeyInput>;
  group?: Maybe<PlayerGroupMembershipGroupIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PlayerGroupMembershipNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `playerGroupMembership` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PlayerGroupMembershipNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `playerGroupMembership` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** The fields on `playerGroupMembership` to look up the row to update. */
export type PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyUsingPlayerGroupMembershipPkeyUpdate = {
  /** An object where the defined keys will be set on the `playerGroupMembership` being updated. */
  patch: UpdatePlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyPatch;
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `playerGroupMembership` to look up the row to update. */
export type PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyUsingPlayerGroupMembershipPkeyUpdate = {
  /** An object where the defined keys will be set on the `playerGroupMembership` being updated. */
  patch: UpdatePlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyPatch;
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
};

/** Represents an update to a `PlayerGroupMembership`. Fields that are set will be updated. */
export type PlayerGroupMembershipPatch = {
  playerId?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  player?: Maybe<PlayerGroupMembershipPlayerIdFkeyInput>;
  group?: Maybe<PlayerGroupMembershipGroupIdFkeyInput>;
};

/** The fields on `playerGroupMembership` to look up the row to connect. */
export type PlayerGroupMembershipPlayerGroupMembershipPkeyConnect = {
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
};

/** The fields on `playerGroupMembership` to look up the row to delete. */
export type PlayerGroupMembershipPlayerGroupMembershipPkeyDelete = {
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
};

/** Input for the nested mutation of `player` in the `PlayerGroupMembershipInput` mutation. */
export type PlayerGroupMembershipPlayerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<PlayerGroupMembershipPlayerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `playerGroupMembership` in the `PlayerInput` mutation. */
export type PlayerGroupMembershipPlayerIdFkeyInverseInput = {
  /** Flag indicating whether all other `playerGroupMembership` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  connectByPlayerIdAndGroupId?: Maybe<Array<PlayerGroupMembershipPlayerGroupMembershipPkeyConnect>>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PlayerGroupMembershipNodeIdConnect>>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  deleteByPlayerIdAndGroupId?: Maybe<Array<PlayerGroupMembershipPlayerGroupMembershipPkeyDelete>>;
  /** The primary key(s) for `playerGroupMembership` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PlayerGroupMembershipNodeIdDelete>>;
  /** The primary key(s) and patch data for `playerGroupMembership` for the far side of the relationship. */
  updateByPlayerIdAndGroupId?: Maybe<Array<PlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyUsingPlayerGroupMembershipPkeyUpdate>>;
  /** The primary key(s) and patch data for `playerGroupMembership` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyNodeIdUpdate>>;
  /** A `PlayerGroupMembershipInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PlayerGroupMembershipPlayerIdFkeyPlayerGroupMembershipCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type PlayerGroupMembershipPlayerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `playerGroupMembership` to be created by this mutation. */
export type PlayerGroupMembershipPlayerIdFkeyPlayerGroupMembershipCreateInput = {
  groupId?: Maybe<Scalars['UUID']>;
  player?: Maybe<PlayerGroupMembershipPlayerIdFkeyInput>;
  group?: Maybe<PlayerGroupMembershipGroupIdFkeyInput>;
};

/** Methods to use when ordering `PlayerGroupMembership`. */
export enum PlayerGroupMembershipsOrderBy {
  NATURAL = 'NATURAL',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** An input for mutations affecting `Player` */
export type PlayerInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PlayerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PlayerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `player` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnAtBatSkipForAtBatSkipBatterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `atBatSkip` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `atBatSkip` being updated. */
  patch: AtBatSkipPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnAtBatSkipForAtBatSkipBatterIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnAtBatSkipForAtBatSkipBatterIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnAtBatSkipForAtBatSkipBatterIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnAtBatSkipForAtBatSkipBatterIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `baseRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `baseRunner` being updated. */
  patch: BaseRunnerPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `basepathMovement` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `basepathMovement` being updated. */
  patch: BasepathMovementPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnCareerStatForFakePublicCareerStatsForeignKey0UsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnCareerStatForFakePublicCareerStatsForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnCareerStatForFakePublicCareerStatsForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnCareerStatForFakePublicCareerStatsForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0UsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnGameBattingLineForFakePublicGameBattingLinesForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameBattingLine` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameBattingLine` being updated. */
  patch: GameBattingLinePatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnGameBattingLineForFakePublicGameBattingLinesForeignKey0UsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnGameBattingLineForFakePublicGameBattingLinesForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnGameBattingLineForFakePublicGameBattingLinesForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnGameBattingLineForFakePublicGameBattingLinesForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameState` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameState` being updated. */
  patch: GameStatePatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnGameStateForGameStatePlayerAtBatFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnGameStateForGameStatePlayerAtBatFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyGameBattingLine` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyGameBattingLine` being updated. */
  patch: LegacyGameBattingLinePatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey0UsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0UsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineupSpot` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineupSpot` being updated. */
  patch: LineupSpotPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnLineupSpotForLineupSpotPlayerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnLineupSpotForLineupSpotPlayerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `outOnPlayRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
  patch: OutOnPlayRunnerPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `plateAppearance` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `plateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnPlayerForFakePublicPlayerForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: LegacyPlayerPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlayerForFakePublicPlayerForeignKey0UsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlayerForFakePublicPlayerForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlayerForFakePublicPlayerForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlayerForFakePublicPlayerForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `playerGroupMembership` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `playerGroupMembership` being updated. */
  patch: PlayerGroupMembershipPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `scoredRunner` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: ScoredRunnerPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnSeasonStatForFakePublicSeasonStatsForeignKey0UsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnSeasonStatForFakePublicSeasonStatsForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnSeasonStatForFakePublicSeasonStatsForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnSeasonStatForFakePublicSeasonStatsForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0UsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0UsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0Patch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0UsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0Patch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `stolenBaseAttempt` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: StolenBaseAttemptPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PlayerOnTeamForTeamCaptainIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `team` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: TeamPatch;
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerNameUniqueUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnTeamForTeamCaptainIdFkeyPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to update. */
export type PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerPkeyUpdate = {
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: UpdatePlayerOnTeamForTeamCaptainIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Player`. Fields that are set will be updated. */
export type PlayerPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The fields on `player` to look up the row to connect. */
export type PlayerPlayerNameUniqueConnect = {
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to delete. */
export type PlayerPlayerNameUniqueDelete = {
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** The fields on `player` to look up the row to connect. */
export type PlayerPlayerPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `player` to look up the row to delete. */
export type PlayerPlayerPkeyDelete = {
  id: Scalars['UUID'];
};

/** Methods to use when ordering `Player`. */
export enum PlayersOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  FIRST_NAME_ASC = 'FIRST_NAME_ASC',
  FIRST_NAME_DESC = 'FIRST_NAME_DESC',
  LAST_NAME_ASC = 'LAST_NAME_ASC',
  LAST_NAME_DESC = 'LAST_NAME_DESC',
  NICKNAME_ASC = 'NICKNAME_ASC',
  NICKNAME_DESC = 'NICKNAME_DESC',
  IMAGE_URL_ASC = 'IMAGE_URL_ASC',
  IMAGE_URL_DESC = 'IMAGE_URL_DESC',
  TIME_CREATED_ASC = 'TIME_CREATED_ASC',
  TIME_CREATED_DESC = 'TIME_CREATED_DESC',
  CLAIMED_ASC = 'CLAIMED_ASC',
  CLAIMED_DESC = 'CLAIMED_DESC',
  TIME_UPDATED_ASC = 'TIME_UPDATED_ASC',
  TIME_UPDATED_DESC = 'TIME_UPDATED_DESC',
  TIME_CLAIMED_ASC = 'TIME_CLAIMED_ASC',
  TIME_CLAIMED_DESC = 'TIME_CLAIMED_DESC',
  FULL_NAME_ASC = 'FULL_NAME_ASC',
  FULL_NAME_DESC = 'FULL_NAME_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. */
  node: Maybe<Node>;
  /** Reads a set of `AtBatSkip`. */
  atBatSkips: Maybe<Array<AtBatSkip>>;
  /** Reads a set of `BaseRunner`. */
  baseRunners: Maybe<Array<BaseRunner>>;
  /** Reads a set of `BasepathMovement`. */
  basepathMovements: Maybe<Array<BasepathMovement>>;
  /** Reads a set of `CareerStat`. */
  careerStats: Maybe<Array<CareerStat>>;
  /** Reads a set of `CareerStatsQualifiedBatter`. */
  careerStatsQualifiedBatters: Maybe<Array<CareerStatsQualifiedBatter>>;
  /** Reads a set of `EarlyGameEnd`. */
  earlyGameEnds: Maybe<Array<EarlyGameEnd>>;
  /** Reads a set of `Field`. */
  fields: Maybe<Array<Field>>;
  /** Reads a set of `ForeignDbField`. */
  foreignDbFields: Maybe<Array<ForeignDbField>>;
  /** Reads a set of `ForeignDbGame`. */
  foreignDbGames: Maybe<Array<ForeignDbGame>>;
  /** Reads a set of `ForeignDbPlayer`. */
  foreignDbPlayers: Maybe<Array<ForeignDbPlayer>>;
  /** Reads a set of `ForeignDbStatLine`. */
  foreignDbStatLines: Maybe<Array<ForeignDbStatLine>>;
  /** Reads a set of `ForeignDbTeam`. */
  foreignDbTeams: Maybe<Array<ForeignDbTeam>>;
  /** Reads a set of `Game`. */
  games: Maybe<Array<Game>>;
  /** Reads a set of `GameBattingLine`. */
  gameBattingLines: Maybe<Array<GameBattingLine>>;
  /** Reads a set of `GameEvent`. */
  gameEvents: Maybe<Array<GameEvent>>;
  /** Reads a set of `GameEventRecord`. */
  gameEventRecords: Maybe<Array<GameEventRecord>>;
  /** Reads a set of `GameState`. */
  gameStates: Maybe<Array<GameState>>;
  /** Reads a set of `GameTag`. */
  gameTags: Maybe<Array<GameTag>>;
  /** Reads a set of `Group`. */
  groups: Maybe<Array<Group>>;
  /** Reads a set of `LegacyField`. */
  legacyFields: Maybe<Array<LegacyField>>;
  /** Reads a set of `LegacyGame`. */
  legacyGames: Maybe<Array<LegacyGame>>;
  /** Reads a set of `LegacyGameBattingLine`. */
  legacyGameBattingLines: Maybe<Array<LegacyGameBattingLine>>;
  /** Reads a set of `LegacyMeetupFieldRaw`. */
  legacyMeetupFieldRaws: Maybe<Array<LegacyMeetupFieldRaw>>;
  /** Reads a set of `LegacyMeetupGameRaw`. */
  legacyMeetupGameRaws: Maybe<Array<LegacyMeetupGameRaw>>;
  /** Reads a set of `LegacyMeetupPlayerRaw`. */
  legacyMeetupPlayerRaws: Maybe<Array<LegacyMeetupPlayerRaw>>;
  /** Reads a set of `LegacyMeetupStatLineRaw`. */
  legacyMeetupStatLineRaws: Maybe<Array<LegacyMeetupStatLineRaw>>;
  /** Reads a set of `LegacyMeetupTeamRaw`. */
  legacyMeetupTeamRaws: Maybe<Array<LegacyMeetupTeamRaw>>;
  /** Reads a set of `LegacyPlayer`. */
  legacyPlayers: Maybe<Array<LegacyPlayer>>;
  /** Reads a set of `LegacySeason`. */
  legacySeasons: Maybe<Array<LegacySeason>>;
  /** Reads a set of `LegacySeasonStat`. */
  legacySeasonStats: Maybe<Array<LegacySeasonStat>>;
  /** Reads a set of `LegacyStatLine`. */
  legacyStatLines: Maybe<Array<LegacyStatLine>>;
  /** Reads a set of `LegacyTeam`. */
  legacyTeams: Maybe<Array<LegacyTeam>>;
  /** Reads a set of `Lineup`. */
  lineups: Maybe<Array<Lineup>>;
  /** Reads a set of `LineupChange`. */
  lineupChanges: Maybe<Array<LineupChange>>;
  /** Reads a set of `LineupForGameState`. */
  lineupForGameStates: Maybe<Array<LineupForGameState>>;
  /** Reads a set of `LineupSpot`. */
  lineupSpots: Maybe<Array<LineupSpot>>;
  /** Reads a set of `ModernSeasonStat`. */
  modernSeasonStats: Maybe<Array<ModernSeasonStat>>;
  /** Reads a set of `OutOnPlayRunner`. */
  outOnPlayRunners: Maybe<Array<OutOnPlayRunner>>;
  /** Reads a set of `PlateAppearance`. */
  plateAppearances: Maybe<Array<PlateAppearance>>;
  /** Reads a set of `Player`. */
  players: Maybe<Array<Player>>;
  /** Reads a set of `PlayerGroupMembership`. */
  playerGroupMemberships: Maybe<Array<PlayerGroupMembership>>;
  /** Reads a set of `ReduxDump`. */
  reduxDumps: Maybe<Array<ReduxDump>>;
  /** Reads a set of `ScoredRunner`. */
  scoredRunners: Maybe<Array<ScoredRunner>>;
  /** Reads a set of `Season`. */
  seasons: Maybe<Array<Season>>;
  /** Reads a set of `SeasonStat`. */
  seasonStats: Maybe<Array<SeasonStat>>;
  /** Reads a set of `SeasonStatsAllTimeQualifiedBatter`. */
  seasonStatsAllTimeQualifiedBatters: Maybe<Array<SeasonStatsAllTimeQualifiedBatter>>;
  /** Reads a set of `SeasonStatsQualifiedBatter`. */
  seasonStatsQualifiedBatters: Maybe<Array<SeasonStatsQualifiedBatter>>;
  /** Reads a set of `SoloModeOpponentInning`. */
  soloModeOpponentInnings: Maybe<Array<SoloModeOpponentInning>>;
  /** Reads a set of `StolenBaseAttempt`. */
  stolenBaseAttempts: Maybe<Array<StolenBaseAttempt>>;
  /** Reads a set of `Tag`. */
  tags: Maybe<Array<Tag>>;
  /** Reads a set of `Team`. */
  teams: Maybe<Array<Team>>;
  /** Reads a set of `UnifiedGame`. */
  unifiedGames: Maybe<Array<UnifiedGame>>;
  atBatSkip: Maybe<AtBatSkip>;
  baseRunner: Maybe<BaseRunner>;
  basepathMovement: Maybe<BasepathMovement>;
  earlyGameEnd: Maybe<EarlyGameEnd>;
  field: Maybe<Field>;
  game: Maybe<Game>;
  gameByGroupIdAndName: Maybe<Game>;
  gameBattingLine: Maybe<GameBattingLine>;
  gameEvent: Maybe<GameEvent>;
  gameEventRecord: Maybe<GameEventRecord>;
  gameEventRecordByGameIdAndEventIndex: Maybe<GameEventRecord>;
  gameState: Maybe<GameState>;
  group: Maybe<Group>;
  groupByName: Maybe<Group>;
  groupByUrlSlug: Maybe<Group>;
  legacyField: Maybe<LegacyField>;
  legacyGame: Maybe<LegacyGame>;
  legacyGameBattingLine: Maybe<LegacyGameBattingLine>;
  legacyMeetupFieldRaw: Maybe<LegacyMeetupFieldRaw>;
  legacyMeetupFieldRawByNameAndSubField: Maybe<LegacyMeetupFieldRaw>;
  legacyMeetupGameRaw: Maybe<LegacyMeetupGameRaw>;
  legacyMeetupGameRawByName: Maybe<LegacyMeetupGameRaw>;
  legacyMeetupPlayerRaw: Maybe<LegacyMeetupPlayerRaw>;
  legacyMeetupPlayerRawByName: Maybe<LegacyMeetupPlayerRaw>;
  legacyMeetupStatLineRaw: Maybe<LegacyMeetupStatLineRaw>;
  legacyMeetupTeamRaw: Maybe<LegacyMeetupTeamRaw>;
  legacyMeetupTeamRawByName: Maybe<LegacyMeetupTeamRaw>;
  legacyPlayer: Maybe<LegacyPlayer>;
  legacyStatLine: Maybe<LegacyStatLine>;
  legacyTeam: Maybe<LegacyTeam>;
  lineup: Maybe<Lineup>;
  lineupChange: Maybe<LineupChange>;
  lineupForGameState: Maybe<LineupForGameState>;
  lineupSpot: Maybe<LineupSpot>;
  lineupSpotByLineupIdAndBattingOrder: Maybe<LineupSpot>;
  lineupSpotByLineupIdAndPosition: Maybe<LineupSpot>;
  outOnPlayRunner: Maybe<OutOnPlayRunner>;
  plateAppearance: Maybe<PlateAppearance>;
  player: Maybe<Player>;
  playerByFirstNameAndLastName: Maybe<Player>;
  playerGroupMembership: Maybe<PlayerGroupMembership>;
  reduxDump: Maybe<ReduxDump>;
  scoredRunner: Maybe<ScoredRunner>;
  season: Maybe<Season>;
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  tag: Maybe<Tag>;
  tagByName: Maybe<Tag>;
  team: Maybe<Team>;
  teamByGameIdAndRole: Maybe<Team>;
  canUserSaveGameData: Maybe<Scalars['Boolean']>;
  /** Reads and enables pagination through a set of `UserGroupPermission`. */
  currentUserGroupPermissions: Maybe<Array<Maybe<UserGroupPermission>>>;
  currentUserPermissions: Maybe<Array<Maybe<PermissionType>>>;
  doesUserHaveGroupPermission: Maybe<Scalars['Boolean']>;
  doesUserHavePermission: Maybe<Scalars['Boolean']>;
  firstDateOfYear: Maybe<Scalars['Datetime']>;
  getAvg: Maybe<Scalars['Float']>;
  getCurrentUser: Maybe<Player>;
  getCurrentUserId: Maybe<Scalars['UUID']>;
  getObp: Maybe<Scalars['Float']>;
  getOps: Maybe<Scalars['Float']>;
  getPlateAppearances: Maybe<Array<Maybe<GetPlateAppearancesRecord>>>;
  getRunsScored: Maybe<Array<Maybe<GetRunsScoredRecord>>>;
  getSlg: Maybe<Scalars['Float']>;
  getTb: Maybe<Scalars['Int']>;
  getTeamForPlayer: Maybe<Scalars['UUID']>;
  lastDateOfYear: Maybe<Scalars['Datetime']>;
  /** Reads a single `AtBatSkip` using its globally unique `ID`. */
  atBatSkipByNodeId: Maybe<AtBatSkip>;
  /** Reads a single `BaseRunner` using its globally unique `ID`. */
  baseRunnerByNodeId: Maybe<BaseRunner>;
  /** Reads a single `BasepathMovement` using its globally unique `ID`. */
  basepathMovementByNodeId: Maybe<BasepathMovement>;
  /** Reads a single `EarlyGameEnd` using its globally unique `ID`. */
  earlyGameEndByNodeId: Maybe<EarlyGameEnd>;
  /** Reads a single `Field` using its globally unique `ID`. */
  fieldByNodeId: Maybe<Field>;
  /** Reads a single `Game` using its globally unique `ID`. */
  gameByNodeId: Maybe<Game>;
  /** Reads a single `GameBattingLine` using its globally unique `ID`. */
  gameBattingLineByNodeId: Maybe<GameBattingLine>;
  /** Reads a single `GameEvent` using its globally unique `ID`. */
  gameEventByNodeId: Maybe<GameEvent>;
  /** Reads a single `GameEventRecord` using its globally unique `ID`. */
  gameEventRecordByNodeId: Maybe<GameEventRecord>;
  /** Reads a single `GameState` using its globally unique `ID`. */
  gameStateByNodeId: Maybe<GameState>;
  /** Reads a single `Group` using its globally unique `ID`. */
  groupByNodeId: Maybe<Group>;
  /** Reads a single `LegacyField` using its globally unique `ID`. */
  legacyFieldByNodeId: Maybe<LegacyField>;
  /** Reads a single `LegacyGame` using its globally unique `ID`. */
  legacyGameByNodeId: Maybe<LegacyGame>;
  /** Reads a single `LegacyGameBattingLine` using its globally unique `ID`. */
  legacyGameBattingLineByNodeId: Maybe<LegacyGameBattingLine>;
  /** Reads a single `LegacyMeetupFieldRaw` using its globally unique `ID`. */
  legacyMeetupFieldRawByNodeId: Maybe<LegacyMeetupFieldRaw>;
  /** Reads a single `LegacyMeetupGameRaw` using its globally unique `ID`. */
  legacyMeetupGameRawByNodeId: Maybe<LegacyMeetupGameRaw>;
  /** Reads a single `LegacyMeetupPlayerRaw` using its globally unique `ID`. */
  legacyMeetupPlayerRawByNodeId: Maybe<LegacyMeetupPlayerRaw>;
  /** Reads a single `LegacyMeetupStatLineRaw` using its globally unique `ID`. */
  legacyMeetupStatLineRawByNodeId: Maybe<LegacyMeetupStatLineRaw>;
  /** Reads a single `LegacyMeetupTeamRaw` using its globally unique `ID`. */
  legacyMeetupTeamRawByNodeId: Maybe<LegacyMeetupTeamRaw>;
  /** Reads a single `LegacyPlayer` using its globally unique `ID`. */
  legacyPlayerByNodeId: Maybe<LegacyPlayer>;
  /** Reads a single `LegacyStatLine` using its globally unique `ID`. */
  legacyStatLineByNodeId: Maybe<LegacyStatLine>;
  /** Reads a single `LegacyTeam` using its globally unique `ID`. */
  legacyTeamByNodeId: Maybe<LegacyTeam>;
  /** Reads a single `Lineup` using its globally unique `ID`. */
  lineupByNodeId: Maybe<Lineup>;
  /** Reads a single `LineupChange` using its globally unique `ID`. */
  lineupChangeByNodeId: Maybe<LineupChange>;
  /** Reads a single `LineupForGameState` using its globally unique `ID`. */
  lineupForGameStateByNodeId: Maybe<LineupForGameState>;
  /** Reads a single `LineupSpot` using its globally unique `ID`. */
  lineupSpotByNodeId: Maybe<LineupSpot>;
  /** Reads a single `OutOnPlayRunner` using its globally unique `ID`. */
  outOnPlayRunnerByNodeId: Maybe<OutOnPlayRunner>;
  /** Reads a single `PlateAppearance` using its globally unique `ID`. */
  plateAppearanceByNodeId: Maybe<PlateAppearance>;
  /** Reads a single `Player` using its globally unique `ID`. */
  playerByNodeId: Maybe<Player>;
  /** Reads a single `PlayerGroupMembership` using its globally unique `ID`. */
  playerGroupMembershipByNodeId: Maybe<PlayerGroupMembership>;
  /** Reads a single `ReduxDump` using its globally unique `ID`. */
  reduxDumpByNodeId: Maybe<ReduxDump>;
  /** Reads a single `ScoredRunner` using its globally unique `ID`. */
  scoredRunnerByNodeId: Maybe<ScoredRunner>;
  /** Reads a single `Season` using its globally unique `ID`. */
  seasonByNodeId: Maybe<Season>;
  /** Reads a single `SoloModeOpponentInning` using its globally unique `ID`. */
  soloModeOpponentInningByNodeId: Maybe<SoloModeOpponentInning>;
  /** Reads a single `StolenBaseAttempt` using its globally unique `ID`. */
  stolenBaseAttemptByNodeId: Maybe<StolenBaseAttempt>;
  /** Reads a single `Tag` using its globally unique `ID`. */
  tagByNodeId: Maybe<Tag>;
  /** Reads a single `Team` using its globally unique `ID`. */
  teamByNodeId: Maybe<Team>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryAtBatSkipsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<AtBatSkipsOrderBy>>;
  condition?: Maybe<AtBatSkipCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryBaseRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BaseRunnersOrderBy>>;
  condition?: Maybe<BaseRunnerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryBasepathMovementsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<BasepathMovementsOrderBy>>;
  condition?: Maybe<BasepathMovementCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCareerStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsOrderBy>>;
  condition?: Maybe<CareerStatCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCareerStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<CareerStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<CareerStatsQualifiedBatterCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryEarlyGameEndsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<EarlyGameEndsOrderBy>>;
  condition?: Maybe<EarlyGameEndCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<FieldsOrderBy>>;
  condition?: Maybe<FieldCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryForeignDbFieldsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ForeignDbFieldsOrderBy>>;
  condition?: Maybe<ForeignDbFieldCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryForeignDbGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ForeignDbGamesOrderBy>>;
  condition?: Maybe<ForeignDbGameCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryForeignDbPlayersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ForeignDbPlayersOrderBy>>;
  condition?: Maybe<ForeignDbPlayerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryForeignDbStatLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ForeignDbStatLinesOrderBy>>;
  condition?: Maybe<ForeignDbStatLineCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryForeignDbTeamsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ForeignDbTeamsOrderBy>>;
  condition?: Maybe<ForeignDbTeamCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GamesOrderBy>>;
  condition?: Maybe<GameCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGameBattingLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameBattingLinesOrderBy>>;
  condition?: Maybe<GameBattingLineCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventsOrderBy>>;
  condition?: Maybe<GameEventCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventRecordsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameEventRecordsOrderBy>>;
  condition?: Maybe<GameEventRecordCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameStatesOrderBy>>;
  condition?: Maybe<GameStateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGameTagsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameTagsOrderBy>>;
  condition?: Maybe<GameTagCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GroupsOrderBy>>;
  condition?: Maybe<GroupCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyFieldsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyFieldsOrderBy>>;
  condition?: Maybe<LegacyFieldCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyGamesOrderBy>>;
  condition?: Maybe<LegacyGameCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyGameBattingLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyGameBattingLinesOrderBy>>;
  condition?: Maybe<LegacyGameBattingLineCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupFieldRawsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyMeetupFieldRawsOrderBy>>;
  condition?: Maybe<LegacyMeetupFieldRawCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupGameRawsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyMeetupGameRawsOrderBy>>;
  condition?: Maybe<LegacyMeetupGameRawCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupPlayerRawsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyMeetupPlayerRawsOrderBy>>;
  condition?: Maybe<LegacyMeetupPlayerRawCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupStatLineRawsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyMeetupStatLineRawsOrderBy>>;
  condition?: Maybe<LegacyMeetupStatLineRawCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupTeamRawsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyMeetupTeamRawsOrderBy>>;
  condition?: Maybe<LegacyMeetupTeamRawCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyPlayersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyPlayersOrderBy>>;
  condition?: Maybe<LegacyPlayerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacySeasonsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacySeasonsOrderBy>>;
  condition?: Maybe<LegacySeasonCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacySeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacySeasonStatsOrderBy>>;
  condition?: Maybe<LegacySeasonStatCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyStatLinesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyStatLinesOrderBy>>;
  condition?: Maybe<LegacyStatLineCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyTeamsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LegacyTeamsOrderBy>>;
  condition?: Maybe<LegacyTeamCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupsOrderBy>>;
  condition?: Maybe<LineupCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupChangesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupChangesOrderBy>>;
  condition?: Maybe<LineupChangeCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupForGameStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupForGameStatesOrderBy>>;
  condition?: Maybe<LineupForGameStateCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupSpotsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupSpotsOrderBy>>;
  condition?: Maybe<LineupSpotCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryModernSeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ModernSeasonStatsOrderBy>>;
  condition?: Maybe<ModernSeasonStatCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOutOnPlayRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<OutOnPlayRunnersOrderBy>>;
  condition?: Maybe<OutOnPlayRunnerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlateAppearancesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlateAppearancesOrderBy>>;
  condition?: Maybe<PlateAppearanceCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlayersOrderBy>>;
  condition?: Maybe<PlayerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerGroupMembershipsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<PlayerGroupMembershipsOrderBy>>;
  condition?: Maybe<PlayerGroupMembershipCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReduxDumpsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ReduxDumpsOrderBy>>;
  condition?: Maybe<ReduxDumpCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryScoredRunnersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<ScoredRunnersOrderBy>>;
  condition?: Maybe<ScoredRunnerCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySeasonsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonsOrderBy>>;
  condition?: Maybe<SeasonCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySeasonStatsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsOrderBy>>;
  condition?: Maybe<SeasonStatCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySeasonStatsAllTimeQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsAllTimeQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsAllTimeQualifiedBatterCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySeasonStatsQualifiedBattersArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SeasonStatsQualifiedBattersOrderBy>>;
  condition?: Maybe<SeasonStatsQualifiedBatterCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySoloModeOpponentInningsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<SoloModeOpponentInningsOrderBy>>;
  condition?: Maybe<SoloModeOpponentInningCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryStolenBaseAttemptsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<StolenBaseAttemptsOrderBy>>;
  condition?: Maybe<StolenBaseAttemptCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTagsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<TagsOrderBy>>;
  condition?: Maybe<TagCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<TeamsOrderBy>>;
  condition?: Maybe<TeamCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUnifiedGamesArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<UnifiedGamesOrderBy>>;
  condition?: Maybe<UnifiedGameCondition>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAtBatSkipArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBaseRunnerArgs = {
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBasepathMovementArgs = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEarlyGameEndArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameByGroupIdAndNameArgs = {
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameBattingLineArgs = {
  playerId: Scalars['UUID'];
  gameId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventRecordArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventRecordByGameIdAndEventIndexArgs = {
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameStateArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupByNameArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupByUrlSlugArgs = {
  urlSlug: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyFieldArgs = {
  fieldId: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyGameArgs = {
  gameId: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyGameBattingLineArgs = {
  legacyPlayerId: Scalars['Int'];
  legacyGameId: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupFieldRawArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupFieldRawByNameAndSubFieldArgs = {
  name: Scalars['String'];
  subField: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupGameRawArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupGameRawByNameArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupPlayerRawArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupPlayerRawByNameArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupStatLineRawArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupTeamRawArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupTeamRawByNameArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyPlayerArgs = {
  playerId: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyStatLineArgs = {
  playerId: Scalars['Int'];
  gameId: Scalars['Int'];
  sbStatsTeam: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyTeamArgs = {
  teamId: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupChangeArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupForGameStateArgs = {
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupSpotArgs = {
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupSpotByLineupIdAndBattingOrderArgs = {
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupSpotByLineupIdAndPositionArgs = {
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};


/** The root query type which gives access points into the data universe. */
export type QueryOutOnPlayRunnerArgs = {
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlateAppearanceArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerByFirstNameAndLastNameArgs = {
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerGroupMembershipArgs = {
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReduxDumpArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryScoredRunnerArgs = {
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySeasonArgs = {
  groupId: Scalars['UUID'];
  year: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySoloModeOpponentInningArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStolenBaseAttemptArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTagArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTagByNameArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamArgs = {
  id: Scalars['UUID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamByGameIdAndRoleArgs = {
  gameId: Scalars['UUID'];
  role: TeamRole;
};


/** The root query type which gives access points into the data universe. */
export type QueryCanUserSaveGameDataArgs = {
  gameId?: Maybe<Scalars['UUID']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentUserGroupPermissionsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCurrentUserPermissionsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDoesUserHaveGroupPermissionArgs = {
  groupId?: Maybe<Scalars['UUID']>;
  permission?: Maybe<GroupPermissionType>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDoesUserHavePermissionArgs = {
  permission?: Maybe<PermissionType>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFirstDateOfYearArgs = {
  year?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetAvgArgs = {
  hits?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetObpArgs = {
  hits?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetOpsArgs = {
  hits?: Maybe<Scalars['Int']>;
  totalBases?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetPlateAppearancesArgs = {
  playerId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  beforeDate?: Maybe<Scalars['Datetime']>;
  afterDate?: Maybe<Scalars['Datetime']>;
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetRunsScoredArgs = {
  groupId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  beforeDate?: Maybe<Scalars['Datetime']>;
  afterDate?: Maybe<Scalars['Datetime']>;
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetSlgArgs = {
  totalBases?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetTbArgs = {
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGetTeamForPlayerArgs = {
  playerId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryLastDateOfYearArgs = {
  year?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAtBatSkipByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBaseRunnerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryBasepathMovementByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryEarlyGameEndByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFieldByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameBattingLineByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameEventRecordByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGameStateByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGroupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyFieldByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyGameByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyGameBattingLineByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupFieldRawByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupGameRawByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupPlayerRawByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupStatLineRawByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyMeetupTeamRawByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyPlayerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyStatLineByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLegacyTeamByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupChangeByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupForGameStateByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryLineupSpotByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOutOnPlayRunnerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlateAppearanceByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPlayerGroupMembershipByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReduxDumpByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryScoredRunnerByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySeasonByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySoloModeOpponentInningByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryStolenBaseAttemptByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTagByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTeamByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

export type ReduxDump = Node & {
  __typename?: 'ReduxDump';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  storeData: Scalars['JSON'];
  timeCreated: Maybe<Scalars['Datetime']>;
};

/**
 * A condition to be used against `ReduxDump` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ReduxDumpCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `storeData` field. */
  storeData?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: Maybe<Scalars['Datetime']>;
};

/** An input for mutations affecting `ReduxDump` */
export type ReduxDumpInput = {
  id?: Maybe<Scalars['UUID']>;
  storeData: Scalars['JSON'];
  timeCreated?: Maybe<Scalars['Datetime']>;
};

/** Represents an update to a `ReduxDump`. Fields that are set will be updated. */
export type ReduxDumpPatch = {
  id?: Maybe<Scalars['UUID']>;
  storeData?: Maybe<Scalars['JSON']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
};

/** Methods to use when ordering `ReduxDump`. */
export enum ReduxDumpsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  STORE_DATA_ASC = 'STORE_DATA_ASC',
  STORE_DATA_DESC = 'STORE_DATA_DESC',
  TIME_CREATED_ASC = 'TIME_CREATED_ASC',
  TIME_CREATED_DESC = 'TIME_CREATED_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

/** All input for the `resetPassword` mutation. */
export type ResetPasswordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  playerId: Scalars['UUID'];
  resetToken: Scalars['String'];
  newPassword: Scalars['String'];
};

/** The output of our `resetPassword` mutation. */
export type ResetPasswordPayload = {
  __typename?: 'ResetPasswordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  boolean: Maybe<Scalars['Boolean']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

export type ScoredRunner = Node & {
  __typename?: 'ScoredRunner';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
  battedIn: Scalars['Boolean'];
  gameId: Scalars['UUID'];
  /** Reads a single `GameEventRecord` that is related to this `ScoredRunner`. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Reads a single `Player` that is related to this `ScoredRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `ScoredRunner`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `ScoredRunner` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ScoredRunnerCondition = {
  /** Checks for equality with the object’s `gameEventRecordId` field. */
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runnerId` field. */
  runnerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `battedIn` field. */
  battedIn?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** The `gameEventRecord` to be created by this mutation. */
export type ScoredRunnerGameEventRecordIdFkeyGameEventRecordCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex: Scalars['Int'];
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** Input for the nested mutation of `gameEventRecord` in the `ScoredRunnerInput` mutation. */
export type ScoredRunnerGameEventRecordIdFkeyInput = {
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectById?: Maybe<GameEventRecordGameEventRecordPkeyConnect>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByGameIdAndEventIndex?: Maybe<GameEventRecordGameEventRecordGameIdEventIndexKeyConnect>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameEventRecordNodeIdConnect>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteById?: Maybe<GameEventRecordGameEventRecordPkeyDelete>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByGameIdAndEventIndex?: Maybe<GameEventRecordGameEventRecordGameIdEventIndexKeyDelete>;
  /** The primary key(s) for `gameEventRecord` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameEventRecordNodeIdDelete>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateById?: Maybe<GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordPkeyUpdate>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByGameIdAndEventIndex?: Maybe<GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate>;
  /** The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship. */
  updateByNodeId?: Maybe<ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate>;
  /** A `GameEventRecordInput` object that will be created and connected to this object. */
  create?: Maybe<ScoredRunnerGameEventRecordIdFkeyGameEventRecordCreateInput>;
};

/** Input for the nested mutation of `scoredRunner` in the `GameEventRecordInput` mutation. */
export type ScoredRunnerGameEventRecordIdFkeyInverseInput = {
  /** Flag indicating whether all other `scoredRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ScoredRunnerNodeIdConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyDelete>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ScoredRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingScoredRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate>>;
  /** A `ScoredRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ScoredRunnerGameEventRecordIdFkeyScoredRunnerCreateInput>>;
};

/** The `scoredRunner` to be created by this mutation. */
export type ScoredRunnerGameEventRecordIdFkeyScoredRunnerCreateInput = {
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** The `game` to be created by this mutation. */
export type ScoredRunnerGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `ScoredRunnerInput` mutation. */
export type ScoredRunnerGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnScoredRunnerForScoredRunnerGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnScoredRunnerForScoredRunnerGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<ScoredRunnerOnScoredRunnerForScoredRunnerGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<ScoredRunnerGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `scoredRunner` in the `GameInput` mutation. */
export type ScoredRunnerGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `scoredRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ScoredRunnerNodeIdConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyDelete>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ScoredRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerOnScoredRunnerForScoredRunnerGameIdFkeyUsingScoredRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnScoredRunnerForScoredRunnerGameIdFkeyNodeIdUpdate>>;
  /** A `ScoredRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ScoredRunnerGameIdFkeyScoredRunnerCreateInput>>;
};

/** The `scoredRunner` to be created by this mutation. */
export type ScoredRunnerGameIdFkeyScoredRunnerCreateInput = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn: Scalars['Boolean'];
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** An input for mutations affecting `ScoredRunner` */
export type ScoredRunnerInput = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ScoredRunnerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `scoredRunner` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ScoredRunnerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `scoredRunner` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEventRecord` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** The fields on `scoredRunner` to look up the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingScoredRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: UpdateScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch;
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `scoredRunner` to look up the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerGameIdFkeyUsingScoredRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: UpdateScoredRunnerOnScoredRunnerForScoredRunnerGameIdFkeyPatch;
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `scoredRunner` to look up the row to update. */
export type ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingScoredRunnerPkeyUpdate = {
  /** An object where the defined keys will be set on the `scoredRunner` being updated. */
  patch: UpdateScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch;
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** Represents an update to a `ScoredRunner`. Fields that are set will be updated. */
export type ScoredRunnerPatch = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** Input for the nested mutation of `player` in the `ScoredRunnerInput` mutation. */
export type ScoredRunnerRunnerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<ScoredRunnerRunnerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `scoredRunner` in the `PlayerInput` mutation. */
export type ScoredRunnerRunnerIdFkeyInverseInput = {
  /** Flag indicating whether all other `scoredRunner` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ScoredRunnerNodeIdConnect>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerScoredRunnerPkeyDelete>>;
  /** The primary key(s) for `scoredRunner` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ScoredRunnerNodeIdDelete>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByGameEventRecordIdAndRunnerId?: Maybe<Array<ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingScoredRunnerPkeyUpdate>>;
  /** The primary key(s) and patch data for `scoredRunner` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate>>;
  /** A `ScoredRunnerInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ScoredRunnerRunnerIdFkeyScoredRunnerCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type ScoredRunnerRunnerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `scoredRunner` to be created by this mutation. */
export type ScoredRunnerRunnerIdFkeyScoredRunnerCreateInput = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  battedIn: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** The fields on `scoredRunner` to look up the row to connect. */
export type ScoredRunnerScoredRunnerPkeyConnect = {
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The fields on `scoredRunner` to look up the row to delete. */
export type ScoredRunnerScoredRunnerPkeyDelete = {
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** Methods to use when ordering `ScoredRunner`. */
export enum ScoredRunnersOrderBy {
  NATURAL = 'NATURAL',
  GAME_EVENT_RECORD_ID_ASC = 'GAME_EVENT_RECORD_ID_ASC',
  GAME_EVENT_RECORD_ID_DESC = 'GAME_EVENT_RECORD_ID_DESC',
  RUNNER_ID_ASC = 'RUNNER_ID_ASC',
  RUNNER_ID_DESC = 'RUNNER_ID_DESC',
  BATTED_IN_ASC = 'BATTED_IN_ASC',
  BATTED_IN_DESC = 'BATTED_IN_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type Season = Node & {
  __typename?: 'Season';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  groupId: Scalars['UUID'];
  year: Scalars['Int'];
  totalGames: Maybe<Scalars['BigInt']>;
};

/** A condition to be used against `Season` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type SeasonCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `year` field. */
  year?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `totalGames` field. */
  totalGames?: Maybe<Scalars['BigInt']>;
};

export type SeasonStat = {
  __typename?: 'SeasonStat';
  groupId: Maybe<Scalars['UUID']>;
  playerId: Maybe<Scalars['UUID']>;
  legacyPlayerId: Maybe<Scalars['Int']>;
  season: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['Int']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
  /** Reads a single `Player` that is related to this `SeasonStat`. */
  player: Maybe<Player>;
  /** Reads a single `LegacyPlayer` that is related to this `SeasonStat`. */
  legacyPlayer: Maybe<LegacyPlayer>;
  /** Reads a single `Group` that is related to this `SeasonStat`. */
  group: Maybe<Group>;
};

/**
 * A condition to be used against `SeasonStat` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type SeasonStatCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatOnSeasonStatForFakePublicSeasonStatsForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatOnSeasonStatForFakePublicSeasonStatsForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: LegacyPlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatOnSeasonStatForFakePublicSeasonStatsForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

export type SeasonStatsAllTimeQualifiedBatter = {
  __typename?: 'SeasonStatsAllTimeQualifiedBatter';
  groupId: Maybe<Scalars['UUID']>;
  playerId: Maybe<Scalars['UUID']>;
  legacyPlayerId: Maybe<Scalars['Int']>;
  season: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['Int']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
  /** Reads a single `Player` that is related to this `SeasonStatsAllTimeQualifiedBatter`. */
  player: Maybe<Player>;
  /** Reads a single `LegacyPlayer` that is related to this `SeasonStatsAllTimeQualifiedBatter`. */
  legacyPlayer: Maybe<LegacyPlayer>;
  /** Reads a single `Group` that is related to this `SeasonStatsAllTimeQualifiedBatter`. */
  group: Maybe<Group>;
};

/**
 * A condition to be used against `SeasonStatsAllTimeQualifiedBatter` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type SeasonStatsAllTimeQualifiedBatterCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatsAllTimeQualifiedBatterOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatsAllTimeQualifiedBatterOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: LegacyPlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatsAllTimeQualifiedBatterOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** Methods to use when ordering `SeasonStatsAllTimeQualifiedBatter`. */
export enum SeasonStatsAllTimeQualifiedBattersOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC'
}

/** Methods to use when ordering `SeasonStat`. */
export enum SeasonStatsOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC'
}

export type SeasonStatsQualifiedBatter = {
  __typename?: 'SeasonStatsQualifiedBatter';
  groupId: Maybe<Scalars['UUID']>;
  playerId: Maybe<Scalars['UUID']>;
  legacyPlayerId: Maybe<Scalars['Int']>;
  season: Maybe<Scalars['Int']>;
  games: Maybe<Scalars['Int']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
  /** Reads a single `Player` that is related to this `SeasonStatsQualifiedBatter`. */
  player: Maybe<Player>;
  /** Reads a single `LegacyPlayer` that is related to this `SeasonStatsQualifiedBatter`. */
  legacyPlayer: Maybe<LegacyPlayer>;
  /** Reads a single `Group` that is related to this `SeasonStatsQualifiedBatter`. */
  group: Maybe<Group>;
};

/**
 * A condition to be used against `SeasonStatsQualifiedBatter` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type SeasonStatsQualifiedBatterCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `playerId` field. */
  playerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyPlayerId` field. */
  legacyPlayerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `games` field. */
  games?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `plateAppearances` field. */
  plateAppearances?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `atBats` field. */
  atBats?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `hits` field. */
  hits?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `singles` field. */
  singles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `doubles` field. */
  doubles?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triples` field. */
  triples?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `homeruns` field. */
  homeruns?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `walks` field. */
  walks?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `strikeouts` field. */
  strikeouts?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sacFlies` field. */
  sacFlies?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gidp` field. */
  gidp?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `runs` field. */
  runs?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `rbi` field. */
  rbi?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `xbh` field. */
  xbh?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `battingAverage` field. */
  battingAverage?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `onBasePct` field. */
  onBasePct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `sluggingPct` field. */
  sluggingPct?: Maybe<Scalars['Float']>;
  /** Checks for equality with the object’s `ops` field. */
  ops?: Maybe<Scalars['Float']>;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatsQualifiedBatterOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatsQualifiedBatterOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyPlayer` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyPlayer` being updated. */
  patch: LegacyPlayerPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type SeasonStatsQualifiedBatterOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** Methods to use when ordering `SeasonStatsQualifiedBatter`. */
export enum SeasonStatsQualifiedBattersOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  PLAYER_ID_ASC = 'PLAYER_ID_ASC',
  PLAYER_ID_DESC = 'PLAYER_ID_DESC',
  LEGACY_PLAYER_ID_ASC = 'LEGACY_PLAYER_ID_ASC',
  LEGACY_PLAYER_ID_DESC = 'LEGACY_PLAYER_ID_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC',
  GAMES_ASC = 'GAMES_ASC',
  GAMES_DESC = 'GAMES_DESC',
  PLATE_APPEARANCES_ASC = 'PLATE_APPEARANCES_ASC',
  PLATE_APPEARANCES_DESC = 'PLATE_APPEARANCES_DESC',
  AT_BATS_ASC = 'AT_BATS_ASC',
  AT_BATS_DESC = 'AT_BATS_DESC',
  HITS_ASC = 'HITS_ASC',
  HITS_DESC = 'HITS_DESC',
  SINGLES_ASC = 'SINGLES_ASC',
  SINGLES_DESC = 'SINGLES_DESC',
  DOUBLES_ASC = 'DOUBLES_ASC',
  DOUBLES_DESC = 'DOUBLES_DESC',
  TRIPLES_ASC = 'TRIPLES_ASC',
  TRIPLES_DESC = 'TRIPLES_DESC',
  HOMERUNS_ASC = 'HOMERUNS_ASC',
  HOMERUNS_DESC = 'HOMERUNS_DESC',
  WALKS_ASC = 'WALKS_ASC',
  WALKS_DESC = 'WALKS_DESC',
  STRIKEOUTS_ASC = 'STRIKEOUTS_ASC',
  STRIKEOUTS_DESC = 'STRIKEOUTS_DESC',
  SAC_FLIES_ASC = 'SAC_FLIES_ASC',
  SAC_FLIES_DESC = 'SAC_FLIES_DESC',
  GIDP_ASC = 'GIDP_ASC',
  GIDP_DESC = 'GIDP_DESC',
  RUNS_ASC = 'RUNS_ASC',
  RUNS_DESC = 'RUNS_DESC',
  RBI_ASC = 'RBI_ASC',
  RBI_DESC = 'RBI_DESC',
  XBH_ASC = 'XBH_ASC',
  XBH_DESC = 'XBH_DESC',
  BATTING_AVERAGE_ASC = 'BATTING_AVERAGE_ASC',
  BATTING_AVERAGE_DESC = 'BATTING_AVERAGE_DESC',
  ON_BASE_PCT_ASC = 'ON_BASE_PCT_ASC',
  ON_BASE_PCT_DESC = 'ON_BASE_PCT_DESC',
  SLUGGING_PCT_ASC = 'SLUGGING_PCT_ASC',
  SLUGGING_PCT_DESC = 'SLUGGING_PCT_DESC',
  OPS_ASC = 'OPS_ASC',
  OPS_DESC = 'OPS_DESC'
}

/** Methods to use when ordering `Season`. */
export enum SeasonsOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  YEAR_ASC = 'YEAR_ASC',
  YEAR_DESC = 'YEAR_DESC',
  TOTAL_GAMES_ASC = 'TOTAL_GAMES_ASC',
  TOTAL_GAMES_DESC = 'TOTAL_GAMES_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type SoloModeOpponentInning = Node & {
  __typename?: 'SoloModeOpponentInning';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  runsScored: Scalars['Int'];
  gameId: Scalars['UUID'];
  /** Reads a single `Game` that is related to this `SoloModeOpponentInning`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `SoloModeOpponentInning` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type SoloModeOpponentInningCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runsScored` field. */
  runsScored?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** The `game` to be created by this mutation. */
export type SoloModeOpponentInningGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `SoloModeOpponentInningInput` mutation. */
export type SoloModeOpponentInningGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<SoloModeOpponentInningOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<SoloModeOpponentInningGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `soloModeOpponentInning` in the `GameInput` mutation. */
export type SoloModeOpponentInningGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `soloModeOpponentInning` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  connectById?: Maybe<Array<SoloModeOpponentInningSoloModeOpponentInningPkeyConnect>>;
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<SoloModeOpponentInningNodeIdConnect>>;
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  deleteById?: Maybe<Array<SoloModeOpponentInningSoloModeOpponentInningPkeyDelete>>;
  /** The primary key(s) for `soloModeOpponentInning` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<SoloModeOpponentInningNodeIdDelete>>;
  /** The primary key(s) and patch data for `soloModeOpponentInning` for the far side of the relationship. */
  updateById?: Maybe<Array<SoloModeOpponentInningOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyUsingSoloModeOpponentInningPkeyUpdate>>;
  /** The primary key(s) and patch data for `soloModeOpponentInning` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyNodeIdUpdate>>;
  /** A `SoloModeOpponentInningInput` object that will be created and connected to this object. */
  create?: Maybe<Array<SoloModeOpponentInningGameIdFkeySoloModeOpponentInningCreateInput>>;
};

/** The `soloModeOpponentInning` to be created by this mutation. */
export type SoloModeOpponentInningGameIdFkeySoloModeOpponentInningCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  runsScored: Scalars['Int'];
  game?: Maybe<SoloModeOpponentInningGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventSoloModeOpponentInningIdFkeyInverseInput>;
};

/** An input for mutations affecting `SoloModeOpponentInning` */
export type SoloModeOpponentInningInput = {
  id?: Maybe<Scalars['UUID']>;
  runsScored: Scalars['Int'];
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<SoloModeOpponentInningGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventSoloModeOpponentInningIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type SoloModeOpponentInningNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `soloModeOpponentInning` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type SoloModeOpponentInningNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `soloModeOpponentInning` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type SoloModeOpponentInningOnGameEventForGameEventSoloModeOpponentInningIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `soloModeOpponentInning` to look up the row to update. */
export type SoloModeOpponentInningOnGameEventForGameEventSoloModeOpponentInningIdFkeyUsingSoloModeOpponentInningPkeyUpdate = {
  /** An object where the defined keys will be set on the `soloModeOpponentInning` being updated. */
  patch: UpdateSoloModeOpponentInningOnGameEventForGameEventSoloModeOpponentInningIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type SoloModeOpponentInningOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `soloModeOpponentInning` to look up the row to update. */
export type SoloModeOpponentInningOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyUsingSoloModeOpponentInningPkeyUpdate = {
  /** An object where the defined keys will be set on the `soloModeOpponentInning` being updated. */
  patch: UpdateSoloModeOpponentInningOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `SoloModeOpponentInning`. Fields that are set will be updated. */
export type SoloModeOpponentInningPatch = {
  id?: Maybe<Scalars['UUID']>;
  runsScored?: Maybe<Scalars['Int']>;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<SoloModeOpponentInningGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventSoloModeOpponentInningIdFkeyInverseInput>;
};

/** The fields on `soloModeOpponentInning` to look up the row to connect. */
export type SoloModeOpponentInningSoloModeOpponentInningPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `soloModeOpponentInning` to look up the row to delete. */
export type SoloModeOpponentInningSoloModeOpponentInningPkeyDelete = {
  id: Scalars['UUID'];
};

/** Methods to use when ordering `SoloModeOpponentInning`. */
export enum SoloModeOpponentInningsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  RUNS_SCORED_ASC = 'RUNS_SCORED_ASC',
  RUNS_SCORED_DESC = 'RUNS_SCORED_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type StolenBaseAttempt = Node & {
  __typename?: 'StolenBaseAttempt';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  runnerId: Scalars['UUID'];
  success: Scalars['Boolean'];
  gameId: Scalars['UUID'];
  /** Reads a single `Player` that is related to this `StolenBaseAttempt`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `StolenBaseAttempt`. */
  game: Maybe<Game>;
};

/**
 * A condition to be used against `StolenBaseAttempt` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type StolenBaseAttemptCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `runnerId` field. */
  runnerId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `success` field. */
  success?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
};

/** The `game` to be created by this mutation. */
export type StolenBaseAttemptGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `StolenBaseAttemptInput` mutation. */
export type StolenBaseAttemptGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<StolenBaseAttemptGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `stolenBaseAttempt` in the `GameInput` mutation. */
export type StolenBaseAttemptGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `stolenBaseAttempt` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectById?: Maybe<Array<StolenBaseAttemptStolenBaseAttemptPkeyConnect>>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<StolenBaseAttemptNodeIdConnect>>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteById?: Maybe<Array<StolenBaseAttemptStolenBaseAttemptPkeyDelete>>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<StolenBaseAttemptNodeIdDelete>>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateById?: Maybe<Array<StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyUsingStolenBaseAttemptPkeyUpdate>>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyNodeIdUpdate>>;
  /** A `StolenBaseAttemptInput` object that will be created and connected to this object. */
  create?: Maybe<Array<StolenBaseAttemptGameIdFkeyStolenBaseAttemptCreateInput>>;
};

/** The `stolenBaseAttempt` to be created by this mutation. */
export type StolenBaseAttemptGameIdFkeyStolenBaseAttemptCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success: Scalars['Boolean'];
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** An input for mutations affecting `StolenBaseAttempt` */
export type StolenBaseAttemptInput = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type StolenBaseAttemptNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `stolenBaseAttempt` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type StolenBaseAttemptNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `stolenBaseAttempt` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `gameEvent` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `gameEvent` being updated. */
  patch: GameEventPatch;
};

/** The fields on `stolenBaseAttempt` to look up the row to update. */
export type StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingStolenBaseAttemptPkeyUpdate = {
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: UpdateStolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `stolenBaseAttempt` to look up the row to update. */
export type StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyUsingStolenBaseAttemptPkeyUpdate = {
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: UpdateStolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `stolenBaseAttempt` to look up the row to update. */
export type StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingStolenBaseAttemptPkeyUpdate = {
  /** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
  patch: UpdateStolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `StolenBaseAttempt`. Fields that are set will be updated. */
export type StolenBaseAttemptPatch = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** Input for the nested mutation of `player` in the `StolenBaseAttemptInput` mutation. */
export type StolenBaseAttemptRunnerIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<StolenBaseAttemptRunnerIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `stolenBaseAttempt` in the `PlayerInput` mutation. */
export type StolenBaseAttemptRunnerIdFkeyInverseInput = {
  /** Flag indicating whether all other `stolenBaseAttempt` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectById?: Maybe<Array<StolenBaseAttemptStolenBaseAttemptPkeyConnect>>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<StolenBaseAttemptNodeIdConnect>>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteById?: Maybe<Array<StolenBaseAttemptStolenBaseAttemptPkeyDelete>>;
  /** The primary key(s) for `stolenBaseAttempt` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<StolenBaseAttemptNodeIdDelete>>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateById?: Maybe<Array<StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingStolenBaseAttemptPkeyUpdate>>;
  /** The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate>>;
  /** A `StolenBaseAttemptInput` object that will be created and connected to this object. */
  create?: Maybe<Array<StolenBaseAttemptRunnerIdFkeyStolenBaseAttemptCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type StolenBaseAttemptRunnerIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `stolenBaseAttempt` to be created by this mutation. */
export type StolenBaseAttemptRunnerIdFkeyStolenBaseAttemptCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  success: Scalars['Boolean'];
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** The fields on `stolenBaseAttempt` to look up the row to connect. */
export type StolenBaseAttemptStolenBaseAttemptPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `stolenBaseAttempt` to look up the row to delete. */
export type StolenBaseAttemptStolenBaseAttemptPkeyDelete = {
  id: Scalars['UUID'];
};

/** Methods to use when ordering `StolenBaseAttempt`. */
export enum StolenBaseAttemptsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  RUNNER_ID_ASC = 'RUNNER_ID_ASC',
  RUNNER_ID_DESC = 'RUNNER_ID_DESC',
  SUCCESS_ASC = 'SUCCESS_ASC',
  SUCCESS_DESC = 'SUCCESS_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type Tag = Node & {
  __typename?: 'Tag';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  name: Scalars['String'];
  type: Maybe<TagType>;
  /** Reads and enables pagination through a set of `GameTag`. */
  gameTags: Array<GameTag>;
};


export type TagGameTagsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<GameTagsOrderBy>>;
  condition?: Maybe<GameTagCondition>;
};

/** A condition to be used against `Tag` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TagCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<TagType>;
};

/** An input for mutations affecting `Tag` */
export type TagInput = {
  id?: Maybe<Scalars['UUID']>;
  name: Scalars['String'];
  type?: Maybe<TagType>;
  gameTags?: Maybe<GameTagTagIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TagNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `tag` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TagNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `tag` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `tag` to look up the row to update. */
export type TagOnGameTagForGameTagTagIdFkeyUsingTagNameKeyUpdate = {
  /** An object where the defined keys will be set on the `tag` being updated. */
  patch: UpdateTagOnGameTagForGameTagTagIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `tag` to look up the row to update. */
export type TagOnGameTagForGameTagTagIdFkeyUsingTagPkeyUpdate = {
  /** An object where the defined keys will be set on the `tag` being updated. */
  patch: UpdateTagOnGameTagForGameTagTagIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Tag`. Fields that are set will be updated. */
export type TagPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<TagType>;
  gameTags?: Maybe<GameTagTagIdFkeyInverseInput>;
};

/** The fields on `tag` to look up the row to connect. */
export type TagTagNameKeyConnect = {
  name: Scalars['String'];
};

/** The fields on `tag` to look up the row to delete. */
export type TagTagNameKeyDelete = {
  name: Scalars['String'];
};

/** The fields on `tag` to look up the row to connect. */
export type TagTagPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `tag` to look up the row to delete. */
export type TagTagPkeyDelete = {
  id: Scalars['UUID'];
};

export enum TagType {
  SEASON = 'SEASON',
  TOURNAMENT = 'TOURNAMENT',
  FIELD = 'FIELD',
  TIME_OF_DAY = 'TIME_OF_DAY'
}

/** Methods to use when ordering `Tag`. */
export enum TagsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  TYPE_ASC = 'TYPE_ASC',
  TYPE_DESC = 'TYPE_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}

export type Team = Node & {
  __typename?: 'Team';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['UUID'];
  gameId: Scalars['UUID'];
  role: TeamRole;
  name: Maybe<Scalars['String']>;
  captainId: Maybe<Scalars['UUID']>;
  winner: Maybe<Scalars['Boolean']>;
  soloModeOpponent: Maybe<Scalars['Boolean']>;
  /** Reads a single `Game` that is related to this `Team`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `Team`. */
  captain: Maybe<Player>;
  /** Reads and enables pagination through a set of `Lineup`. */
  lineups: Array<Lineup>;
  finalLineup: Maybe<Lineup>;
};


export type TeamLineupsArgs = {
  first?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  orderBy?: Maybe<Array<LineupsOrderBy>>;
  condition?: Maybe<LineupCondition>;
};

/** Input for the nested mutation of `player` in the `TeamInput` mutation. */
export type TeamCaptainIdFkeyInput = {
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectById?: Maybe<PlayerPlayerPkeyConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  connectByNodeId?: Maybe<PlayerNodeIdConnect>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteById?: Maybe<PlayerPlayerPkeyDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByFirstNameAndLastName?: Maybe<PlayerPlayerNameUniqueDelete>;
  /** The primary key(s) for `player` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PlayerNodeIdDelete>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateById?: Maybe<PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerPkeyUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByFirstNameAndLastName?: Maybe<PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerNameUniqueUpdate>;
  /** The primary key(s) and patch data for `player` for the far side of the relationship. */
  updateByNodeId?: Maybe<TeamOnTeamForTeamCaptainIdFkeyNodeIdUpdate>;
  /** A `PlayerInput` object that will be created and connected to this object. */
  create?: Maybe<TeamCaptainIdFkeyPlayerCreateInput>;
};

/** Input for the nested mutation of `team` in the `PlayerInput` mutation. */
export type TeamCaptainIdFkeyInverseInput = {
  /** Flag indicating whether all other `team` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectById?: Maybe<Array<TeamTeamPkeyConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByGameIdAndRole?: Maybe<Array<TeamTeamGameIdRoleKeyConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TeamNodeIdConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteById?: Maybe<Array<TeamTeamPkeyDelete>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByGameIdAndRole?: Maybe<Array<TeamTeamGameIdRoleKeyDelete>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TeamNodeIdDelete>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateById?: Maybe<Array<TeamOnTeamForTeamCaptainIdFkeyUsingTeamPkeyUpdate>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByGameIdAndRole?: Maybe<Array<TeamOnTeamForTeamCaptainIdFkeyUsingTeamGameIdRoleKeyUpdate>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PlayerOnTeamForTeamCaptainIdFkeyNodeIdUpdate>>;
  /** A `TeamInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TeamCaptainIdFkeyTeamCreateInput>>;
};

/** The `player` to be created by this mutation. */
export type TeamCaptainIdFkeyPlayerCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName: Scalars['String'];
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** The `team` to be created by this mutation. */
export type TeamCaptainIdFkeyTeamCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role: TeamRole;
  name?: Maybe<Scalars['String']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

/** A condition to be used against `Team` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type TeamCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `role` field. */
  role?: Maybe<TeamRole>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `captainId` field. */
  captainId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `winner` field. */
  winner?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `soloModeOpponent` field. */
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
};

/** The `game` to be created by this mutation. */
export type TeamGameIdFkeyGameCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score: Array<Maybe<Scalars['Int']>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted: Scalars['Datetime'];
  timeEnded: Scalars['Datetime'];
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** Input for the nested mutation of `game` in the `TeamInput` mutation. */
export type TeamGameIdFkeyInput = {
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectById?: Maybe<GameGamePkeyConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  connectByNodeId?: Maybe<GameNodeIdConnect>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteById?: Maybe<GameGamePkeyDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByGroupIdAndName?: Maybe<GameGameNameUniqPerGroupDelete>;
  /** The primary key(s) for `game` for the far side of the relationship. */
  deleteByNodeId?: Maybe<GameNodeIdDelete>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateById?: Maybe<GameOnTeamForTeamGameIdFkeyUsingGamePkeyUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByGroupIdAndName?: Maybe<GameOnTeamForTeamGameIdFkeyUsingGameNameUniqPerGroupUpdate>;
  /** The primary key(s) and patch data for `game` for the far side of the relationship. */
  updateByNodeId?: Maybe<TeamOnTeamForTeamGameIdFkeyNodeIdUpdate>;
  /** A `GameInput` object that will be created and connected to this object. */
  create?: Maybe<TeamGameIdFkeyGameCreateInput>;
};

/** Input for the nested mutation of `team` in the `GameInput` mutation. */
export type TeamGameIdFkeyInverseInput = {
  /** Flag indicating whether all other `team` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectById?: Maybe<Array<TeamTeamPkeyConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByGameIdAndRole?: Maybe<Array<TeamTeamGameIdRoleKeyConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TeamNodeIdConnect>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteById?: Maybe<Array<TeamTeamPkeyDelete>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByGameIdAndRole?: Maybe<Array<TeamTeamGameIdRoleKeyDelete>>;
  /** The primary key(s) for `team` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TeamNodeIdDelete>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateById?: Maybe<Array<TeamOnTeamForTeamGameIdFkeyUsingTeamPkeyUpdate>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByGameIdAndRole?: Maybe<Array<TeamOnTeamForTeamGameIdFkeyUsingTeamGameIdRoleKeyUpdate>>;
  /** The primary key(s) and patch data for `team` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<GameOnTeamForTeamGameIdFkeyNodeIdUpdate>>;
  /** A `TeamInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TeamGameIdFkeyTeamCreateInput>>;
};

/** The `team` to be created by this mutation. */
export type TeamGameIdFkeyTeamCreateInput = {
  id?: Maybe<Scalars['UUID']>;
  role: TeamRole;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

/** An input for mutations affecting `Team` */
export type TeamInput = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role: TeamRole;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TeamNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `team` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TeamNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `team` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TeamOnLineupForLineupTeamIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `lineup` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `lineup` being updated. */
  patch: LineupPatch;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnLineupForLineupTeamIdFkeyUsingTeamGameIdRoleKeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnLineupForLineupTeamIdFkeyPatch;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnLineupForLineupTeamIdFkeyUsingTeamPkeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnLineupForLineupTeamIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TeamOnTeamForTeamCaptainIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `player` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `player` being updated. */
  patch: PlayerPatch;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnTeamForTeamCaptainIdFkeyUsingTeamGameIdRoleKeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnTeamForTeamCaptainIdFkeyPatch;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnTeamForTeamCaptainIdFkeyUsingTeamPkeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnTeamForTeamCaptainIdFkeyPatch;
  id: Scalars['UUID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TeamOnTeamForTeamGameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnTeamForTeamGameIdFkeyUsingTeamGameIdRoleKeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnTeamForTeamGameIdFkeyPatch;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to update. */
export type TeamOnTeamForTeamGameIdFkeyUsingTeamPkeyUpdate = {
  /** An object where the defined keys will be set on the `team` being updated. */
  patch: UpdateTeamOnTeamForTeamGameIdFkeyPatch;
  id: Scalars['UUID'];
};

/** Represents an update to a `Team`. Fields that are set will be updated. */
export type TeamPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role?: Maybe<TeamRole>;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

export enum TeamRole {
  AWAY = 'AWAY',
  HOME = 'HOME'
}

/** The fields on `team` to look up the row to connect. */
export type TeamTeamGameIdRoleKeyConnect = {
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to delete. */
export type TeamTeamGameIdRoleKeyDelete = {
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** The fields on `team` to look up the row to connect. */
export type TeamTeamPkeyConnect = {
  id: Scalars['UUID'];
};

/** The fields on `team` to look up the row to delete. */
export type TeamTeamPkeyDelete = {
  id: Scalars['UUID'];
};

/** Methods to use when ordering `Team`. */
export enum TeamsOrderBy {
  NATURAL = 'NATURAL',
  ID_ASC = 'ID_ASC',
  ID_DESC = 'ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  ROLE_ASC = 'ROLE_ASC',
  ROLE_DESC = 'ROLE_DESC',
  NAME_ASC = 'NAME_ASC',
  NAME_DESC = 'NAME_DESC',
  CAPTAIN_ID_ASC = 'CAPTAIN_ID_ASC',
  CAPTAIN_ID_DESC = 'CAPTAIN_ID_DESC',
  WINNER_ASC = 'WINNER_ASC',
  WINNER_DESC = 'WINNER_DESC',
  SOLO_MODE_OPPONENT_ASC = 'SOLO_MODE_OPPONENT_ASC',
  SOLO_MODE_OPPONENT_DESC = 'SOLO_MODE_OPPONENT_DESC',
  PRIMARY_KEY_ASC = 'PRIMARY_KEY_ASC',
  PRIMARY_KEY_DESC = 'PRIMARY_KEY_DESC'
}


export type TraditionalStatLine = {
  __typename?: 'TraditionalStatLine';
  playerId: Maybe<Scalars['UUID']>;
  games: Maybe<Scalars['Int']>;
  plateAppearances: Maybe<Scalars['Int']>;
  atBats: Maybe<Scalars['Int']>;
  hits: Maybe<Scalars['Int']>;
  singles: Maybe<Scalars['Int']>;
  doubles: Maybe<Scalars['Int']>;
  triples: Maybe<Scalars['Int']>;
  homeruns: Maybe<Scalars['Int']>;
  walks: Maybe<Scalars['Int']>;
  strikeouts: Maybe<Scalars['Int']>;
  sacFlies: Maybe<Scalars['Int']>;
  gidp: Maybe<Scalars['Int']>;
  runs: Maybe<Scalars['Int']>;
  rbi: Maybe<Scalars['Int']>;
  xbh: Maybe<Scalars['Int']>;
  battingAverage: Maybe<Scalars['Float']>;
  onBasePct: Maybe<Scalars['Float']>;
  sluggingPct: Maybe<Scalars['Float']>;
  ops: Maybe<Scalars['Float']>;
};


export type UnifiedGame = {
  __typename?: 'UnifiedGame';
  groupId: Maybe<Scalars['UUID']>;
  gameId: Maybe<Scalars['UUID']>;
  legacyGameId: Maybe<Scalars['Int']>;
  season: Maybe<Scalars['Int']>;
  /** Reads a single `Group` that is related to this `UnifiedGame`. */
  group: Maybe<Group>;
  /** Reads a single `Game` that is related to this `UnifiedGame`. */
  game: Maybe<Game>;
  /** Reads a single `LegacyGame` that is related to this `UnifiedGame`. */
  legacyGame: Maybe<LegacyGame>;
};

/**
 * A condition to be used against `UnifiedGame` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UnifiedGameCondition = {
  /** Checks for equality with the object’s `groupId` field. */
  groupId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `gameId` field. */
  gameId?: Maybe<Scalars['UUID']>;
  /** Checks for equality with the object’s `legacyGameId` field. */
  legacyGameId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `season` field. */
  season?: Maybe<Scalars['Int']>;
};

/** The globally unique `ID` look up for the row to update. */
export type UnifiedGameOnUnifiedGameForFakePublicUnifiedGamesForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `group` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `group` being updated. */
  patch: GroupPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UnifiedGameOnUnifiedGameForFakePublicUnifiedGamesForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `game` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `game` being updated. */
  patch: GamePatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UnifiedGameOnUnifiedGameForFakePublicUnifiedGamesForeignKey2NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `legacyGame` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `legacyGame` being updated. */
  patch: LegacyGamePatch;
};

/** Methods to use when ordering `UnifiedGame`. */
export enum UnifiedGamesOrderBy {
  NATURAL = 'NATURAL',
  GROUP_ID_ASC = 'GROUP_ID_ASC',
  GROUP_ID_DESC = 'GROUP_ID_DESC',
  GAME_ID_ASC = 'GAME_ID_ASC',
  GAME_ID_DESC = 'GAME_ID_DESC',
  LEGACY_GAME_ID_ASC = 'LEGACY_GAME_ID_ASC',
  LEGACY_GAME_ID_DESC = 'LEGACY_GAME_ID_DESC',
  SEASON_ASC = 'SEASON_ASC',
  SEASON_DESC = 'SEASON_DESC'
}

/** All input for the `updateAtBatSkipByNodeId` mutation. */
export type UpdateAtBatSkipByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `AtBatSkip` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `AtBatSkip` being updated. */
  patch: AtBatSkipPatch;
};

/** All input for the `updateAtBatSkip` mutation. */
export type UpdateAtBatSkipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `AtBatSkip` being updated. */
  patch: AtBatSkipPatch;
  id: Scalars['UUID'];
};

/** The output of our update `AtBatSkip` mutation. */
export type UpdateAtBatSkipPayload = {
  __typename?: 'UpdateAtBatSkipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `AtBatSkip` that was updated by this mutation. */
  atBatSkip: Maybe<AtBatSkip>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `AtBatSkip`. */
  batter: Maybe<Player>;
  /** Reads a single `Game` that is related to this `AtBatSkip`. */
  game: Maybe<Game>;
};

/** All input for the `updateBaseRunnerByNodeId` mutation. */
export type UpdateBaseRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `BaseRunner` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `BaseRunner` being updated. */
  patch: BaseRunnerPatch;
};

/** All input for the `updateBaseRunner` mutation. */
export type UpdateBaseRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `BaseRunner` being updated. */
  patch: BaseRunnerPatch;
  gameStateId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our update `BaseRunner` mutation. */
export type UpdateBaseRunnerPayload = {
  __typename?: 'UpdateBaseRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BaseRunner` that was updated by this mutation. */
  baseRunner: Maybe<BaseRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `BaseRunner`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Player` that is related to this `BaseRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BaseRunner`. */
  game: Maybe<Game>;
};

/** All input for the `updateBasepathMovementByNodeId` mutation. */
export type UpdateBasepathMovementByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `BasepathMovement` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `BasepathMovement` being updated. */
  patch: BasepathMovementPatch;
};

/** All input for the `updateBasepathMovement` mutation. */
export type UpdateBasepathMovementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `BasepathMovement` being updated. */
  patch: BasepathMovementPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our update `BasepathMovement` mutation. */
export type UpdateBasepathMovementPayload = {
  __typename?: 'UpdateBasepathMovementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `BasepathMovement` that was updated by this mutation. */
  basepathMovement: Maybe<BasepathMovement>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `BasepathMovement`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `BasepathMovement`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `BasepathMovement`. */
  game: Maybe<Game>;
};

/** All input for the `updateEarlyGameEndByNodeId` mutation. */
export type UpdateEarlyGameEndByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `EarlyGameEnd` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `EarlyGameEnd` being updated. */
  patch: EarlyGameEndPatch;
};

/** All input for the `updateEarlyGameEnd` mutation. */
export type UpdateEarlyGameEndInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `EarlyGameEnd` being updated. */
  patch: EarlyGameEndPatch;
  id: Scalars['UUID'];
};

/** The output of our update `EarlyGameEnd` mutation. */
export type UpdateEarlyGameEndPayload = {
  __typename?: 'UpdateEarlyGameEndPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `EarlyGameEnd` that was updated by this mutation. */
  earlyGameEnd: Maybe<EarlyGameEnd>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `EarlyGameEnd`. */
  game: Maybe<Game>;
};

/** All input for the `updateFieldByNodeId` mutation. */
export type UpdateFieldByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Field` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Field` being updated. */
  patch: FieldPatch;
};

/** All input for the `updateField` mutation. */
export type UpdateFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Field` being updated. */
  patch: FieldPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Field` mutation. */
export type UpdateFieldPayload = {
  __typename?: 'UpdateFieldPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Field` that was updated by this mutation. */
  field: Maybe<Field>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updateGameByGroupIdAndName` mutation. */
export type UpdateGameByGroupIdAndNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Game` being updated. */
  patch: GamePatch;
  groupId: Scalars['UUID'];
  name: Scalars['String'];
};

/** All input for the `updateGameByNodeId` mutation. */
export type UpdateGameByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Game` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Game` being updated. */
  patch: GamePatch;
};

/** All input for the `updateGameEventByNodeId` mutation. */
export type UpdateGameEventByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameEvent` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GameEvent` being updated. */
  patch: GameEventPatch;
};

/** All input for the `updateGameEvent` mutation. */
export type UpdateGameEventInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GameEvent` being updated. */
  patch: GameEventPatch;
  id: Scalars['UUID'];
};

/** The output of our update `GameEvent` mutation. */
export type UpdateGameEventPayload = {
  __typename?: 'UpdateGameEventPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEvent` that was updated by this mutation. */
  gameEvent: Maybe<GameEvent>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `GameEvent`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `StolenBaseAttempt` that is related to this `GameEvent`. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Reads a single `LineupChange` that is related to this `GameEvent`. */
  lineupChange: Maybe<LineupChange>;
  /** Reads a single `SoloModeOpponentInning` that is related to this `GameEvent`. */
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  /** Reads a single `AtBatSkip` that is related to this `GameEvent`. */
  atBatSkip: Maybe<AtBatSkip>;
  /** Reads a single `Game` that is related to this `GameEvent`. */
  game: Maybe<Game>;
  /** Reads a single `EarlyGameEnd` that is related to this `GameEvent`. */
  earlyGameEnd: Maybe<EarlyGameEnd>;
};

/** All input for the `updateGameEventRecordByGameIdAndEventIndex` mutation. */
export type UpdateGameEventRecordByGameIdAndEventIndexInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GameEventRecord` being updated. */
  patch: GameEventRecordPatch;
  gameId: Scalars['UUID'];
  eventIndex: Scalars['Int'];
};

/** All input for the `updateGameEventRecordByNodeId` mutation. */
export type UpdateGameEventRecordByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameEventRecord` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GameEventRecord` being updated. */
  patch: GameEventRecordPatch;
};

/** All input for the `updateGameEventRecord` mutation. */
export type UpdateGameEventRecordInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GameEventRecord` being updated. */
  patch: GameEventRecordPatch;
  id: Scalars['UUID'];
};

/** The output of our update `GameEventRecord` mutation. */
export type UpdateGameEventRecordPayload = {
  __typename?: 'UpdateGameEventRecordPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameEventRecord` that was updated by this mutation. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameEventRecord`. */
  game: Maybe<Game>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateBefore: Maybe<GameState>;
  /** Reads a single `GameState` that is related to this `GameEventRecord`. */
  gameStateAfter: Maybe<GameState>;
  /** Reads a single `GameEvent` that is related to this `GameEventRecord`. */
  gameEvent: Maybe<GameEvent>;
};

/** All input for the `updateGame` mutation. */
export type UpdateGameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Game` being updated. */
  patch: GamePatch;
  id: Scalars['UUID'];
};

/** The output of our update `Game` mutation. */
export type UpdateGamePayload = {
  __typename?: 'UpdateGamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Game` that was updated by this mutation. */
  game: Maybe<Game>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Group` that is related to this `Game`. */
  group: Maybe<Group>;
  /** Reads a single `Field` that is related to this `Game`. */
  field: Maybe<Field>;
};

/** All input for the `updateGameStateByNodeId` mutation. */
export type UpdateGameStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `GameState` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `GameState` being updated. */
  patch: GameStatePatch;
};

/** All input for the `updateGameState` mutation. */
export type UpdateGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `GameState` being updated. */
  patch: GameStatePatch;
  id: Scalars['UUID'];
};

/** The output of our update `GameState` mutation. */
export type UpdateGameStatePayload = {
  __typename?: 'UpdateGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `GameState` that was updated by this mutation. */
  gameState: Maybe<GameState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `GameState`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `GameState`. */
  playerByPlayerAtBat: Maybe<Player>;
};

/** All input for the `updateGroupByName` mutation. */
export type UpdateGroupByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
  name: Scalars['String'];
};

/** All input for the `updateGroupByNodeId` mutation. */
export type UpdateGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Group` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
};

/** All input for the `updateGroupByUrlSlug` mutation. */
export type UpdateGroupByUrlSlugInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
  urlSlug: Scalars['String'];
};

/** All input for the `updateGroup` mutation. */
export type UpdateGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Group` being updated. */
  patch: GroupPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Group` mutation. */
export type UpdateGroupPayload = {
  __typename?: 'UpdateGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Group` that was updated by this mutation. */
  group: Maybe<Group>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updateLegacyMeetupFieldRawByNameAndSubField` mutation. */
export type UpdateLegacyMeetupFieldRawByNameAndSubFieldInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LegacyMeetupFieldRaw` being updated. */
  patch: LegacyMeetupFieldRawPatch;
  name: Scalars['String'];
  subField: Scalars['String'];
};

/** All input for the `updateLegacyMeetupFieldRawByNodeId` mutation. */
export type UpdateLegacyMeetupFieldRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LegacyMeetupFieldRaw` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LegacyMeetupFieldRaw` being updated. */
  patch: LegacyMeetupFieldRawPatch;
};

/** All input for the `updateLegacyMeetupFieldRaw` mutation. */
export type UpdateLegacyMeetupFieldRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LegacyMeetupFieldRaw` being updated. */
  patch: LegacyMeetupFieldRawPatch;
  id: Scalars['Int'];
};

/** The output of our update `LegacyMeetupFieldRaw` mutation. */
export type UpdateLegacyMeetupFieldRawPayload = {
  __typename?: 'UpdateLegacyMeetupFieldRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LegacyMeetupFieldRaw` that was updated by this mutation. */
  legacyMeetupFieldRaw: Maybe<LegacyMeetupFieldRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updateLegacyMeetupGameRawByName` mutation. */
export type UpdateLegacyMeetupGameRawByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LegacyMeetupGameRaw` being updated. */
  patch: LegacyMeetupGameRawPatch;
  name: Scalars['String'];
};

/** All input for the `updateLegacyMeetupGameRawByNodeId` mutation. */
export type UpdateLegacyMeetupGameRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LegacyMeetupGameRaw` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LegacyMeetupGameRaw` being updated. */
  patch: LegacyMeetupGameRawPatch;
};

/** All input for the `updateLegacyMeetupGameRaw` mutation. */
export type UpdateLegacyMeetupGameRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LegacyMeetupGameRaw` being updated. */
  patch: LegacyMeetupGameRawPatch;
  id: Scalars['Int'];
};

/** The output of our update `LegacyMeetupGameRaw` mutation. */
export type UpdateLegacyMeetupGameRawPayload = {
  __typename?: 'UpdateLegacyMeetupGameRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LegacyMeetupGameRaw` that was updated by this mutation. */
  legacyMeetupGameRaw: Maybe<LegacyMeetupGameRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `LegacyMeetupTeamRaw` that is related to this `LegacyMeetupGameRaw`. */
  winningTeam: Maybe<LegacyMeetupTeamRaw>;
  /** Reads a single `LegacyMeetupTeamRaw` that is related to this `LegacyMeetupGameRaw`. */
  losingTeam: Maybe<LegacyMeetupTeamRaw>;
  /** Reads a single `LegacyMeetupFieldRaw` that is related to this `LegacyMeetupGameRaw`. */
  field: Maybe<LegacyMeetupFieldRaw>;
};

/** All input for the `updateLegacyMeetupPlayerRawByName` mutation. */
export type UpdateLegacyMeetupPlayerRawByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LegacyMeetupPlayerRaw` being updated. */
  patch: LegacyMeetupPlayerRawPatch;
  name: Scalars['String'];
};

/** All input for the `updateLegacyMeetupPlayerRawByNodeId` mutation. */
export type UpdateLegacyMeetupPlayerRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LegacyMeetupPlayerRaw` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LegacyMeetupPlayerRaw` being updated. */
  patch: LegacyMeetupPlayerRawPatch;
};

/** All input for the `updateLegacyMeetupPlayerRaw` mutation. */
export type UpdateLegacyMeetupPlayerRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LegacyMeetupPlayerRaw` being updated. */
  patch: LegacyMeetupPlayerRawPatch;
  id: Scalars['Int'];
};

/** The output of our update `LegacyMeetupPlayerRaw` mutation. */
export type UpdateLegacyMeetupPlayerRawPayload = {
  __typename?: 'UpdateLegacyMeetupPlayerRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LegacyMeetupPlayerRaw` that was updated by this mutation. */
  legacyMeetupPlayerRaw: Maybe<LegacyMeetupPlayerRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updateLegacyMeetupStatLineRawByNodeId` mutation. */
export type UpdateLegacyMeetupStatLineRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LegacyMeetupStatLineRaw` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LegacyMeetupStatLineRaw` being updated. */
  patch: LegacyMeetupStatLineRawPatch;
};

/** All input for the `updateLegacyMeetupStatLineRaw` mutation. */
export type UpdateLegacyMeetupStatLineRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LegacyMeetupStatLineRaw` being updated. */
  patch: LegacyMeetupStatLineRawPatch;
  id: Scalars['Int'];
};

/** The output of our update `LegacyMeetupStatLineRaw` mutation. */
export type UpdateLegacyMeetupStatLineRawPayload = {
  __typename?: 'UpdateLegacyMeetupStatLineRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LegacyMeetupStatLineRaw` that was updated by this mutation. */
  legacyMeetupStatLineRaw: Maybe<LegacyMeetupStatLineRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `LegacyMeetupPlayerRaw` that is related to this `LegacyMeetupStatLineRaw`. */
  player: Maybe<LegacyMeetupPlayerRaw>;
  /** Reads a single `LegacyMeetupGameRaw` that is related to this `LegacyMeetupStatLineRaw`. */
  game: Maybe<LegacyMeetupGameRaw>;
  /** Reads a single `LegacyMeetupTeamRaw` that is related to this `LegacyMeetupStatLineRaw`. */
  team: Maybe<LegacyMeetupTeamRaw>;
};

/** All input for the `updateLegacyMeetupTeamRawByName` mutation. */
export type UpdateLegacyMeetupTeamRawByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LegacyMeetupTeamRaw` being updated. */
  patch: LegacyMeetupTeamRawPatch;
  name: Scalars['String'];
};

/** All input for the `updateLegacyMeetupTeamRawByNodeId` mutation. */
export type UpdateLegacyMeetupTeamRawByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LegacyMeetupTeamRaw` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LegacyMeetupTeamRaw` being updated. */
  patch: LegacyMeetupTeamRawPatch;
};

/** All input for the `updateLegacyMeetupTeamRaw` mutation. */
export type UpdateLegacyMeetupTeamRawInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LegacyMeetupTeamRaw` being updated. */
  patch: LegacyMeetupTeamRawPatch;
  id: Scalars['Int'];
};

/** The output of our update `LegacyMeetupTeamRaw` mutation. */
export type UpdateLegacyMeetupTeamRawPayload = {
  __typename?: 'UpdateLegacyMeetupTeamRawPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LegacyMeetupTeamRaw` that was updated by this mutation. */
  legacyMeetupTeamRaw: Maybe<LegacyMeetupTeamRaw>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updateLineupByNodeId` mutation. */
export type UpdateLineupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Lineup` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Lineup` being updated. */
  patch: LineupPatch;
};

/** All input for the `updateLineupChangeByNodeId` mutation. */
export type UpdateLineupChangeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupChange` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LineupChange` being updated. */
  patch: LineupChangePatch;
};

/** All input for the `updateLineupChange` mutation. */
export type UpdateLineupChangeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LineupChange` being updated. */
  patch: LineupChangePatch;
  id: Scalars['UUID'];
};

/** The output of our update `LineupChange` mutation. */
export type UpdateLineupChangePayload = {
  __typename?: 'UpdateLineupChangePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupChange` that was updated by this mutation. */
  lineupChange: Maybe<LineupChange>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupBefore: Maybe<Lineup>;
  /** Reads a single `Lineup` that is related to this `LineupChange`. */
  lineupAfter: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupChange`. */
  game: Maybe<Game>;
};

/** All input for the `updateLineupForGameStateByNodeId` mutation. */
export type UpdateLineupForGameStateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupForGameState` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LineupForGameState` being updated. */
  patch: LineupForGameStatePatch;
};

/** All input for the `updateLineupForGameState` mutation. */
export type UpdateLineupForGameStateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LineupForGameState` being updated. */
  patch: LineupForGameStatePatch;
  gameStateId: Scalars['UUID'];
  lineupId: Scalars['UUID'];
};

/** The output of our update `LineupForGameState` mutation. */
export type UpdateLineupForGameStatePayload = {
  __typename?: 'UpdateLineupForGameStatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupForGameState` that was updated by this mutation. */
  lineupForGameState: Maybe<LineupForGameState>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameState` that is related to this `LineupForGameState`. */
  gameState: Maybe<GameState>;
  /** Reads a single `Lineup` that is related to this `LineupForGameState`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Game` that is related to this `LineupForGameState`. */
  game: Maybe<Game>;
};

/** All input for the `updateLineup` mutation. */
export type UpdateLineupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Lineup` being updated. */
  patch: LineupPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Lineup` mutation. */
export type UpdateLineupPayload = {
  __typename?: 'UpdateLineupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Lineup` that was updated by this mutation. */
  lineup: Maybe<Lineup>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Team` that is related to this `Lineup`. */
  team: Maybe<Team>;
  /** Reads a single `Game` that is related to this `Lineup`. */
  game: Maybe<Game>;
};

/** All input for the `updateLineupSpotByLineupIdAndBattingOrder` mutation. */
export type UpdateLineupSpotByLineupIdAndBattingOrderInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LineupSpot` being updated. */
  patch: LineupSpotPatch;
  lineupId: Scalars['UUID'];
  battingOrder: Scalars['Int'];
};

/** All input for the `updateLineupSpotByLineupIdAndPosition` mutation. */
export type UpdateLineupSpotByLineupIdAndPositionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LineupSpot` being updated. */
  patch: LineupSpotPatch;
  lineupId: Scalars['UUID'];
  position: FieldingPosition;
};

/** All input for the `updateLineupSpotByNodeId` mutation. */
export type UpdateLineupSpotByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `LineupSpot` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `LineupSpot` being updated. */
  patch: LineupSpotPatch;
};

/** All input for the `updateLineupSpot` mutation. */
export type UpdateLineupSpotInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `LineupSpot` being updated. */
  patch: LineupSpotPatch;
  lineupId: Scalars['UUID'];
  playerId: Scalars['UUID'];
};

/** The output of our update `LineupSpot` mutation. */
export type UpdateLineupSpotPayload = {
  __typename?: 'UpdateLineupSpotPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `LineupSpot` that was updated by this mutation. */
  lineupSpot: Maybe<LineupSpot>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Lineup` that is related to this `LineupSpot`. */
  lineup: Maybe<Lineup>;
  /** Reads a single `Player` that is related to this `LineupSpot`. */
  player: Maybe<Player>;
  /** Reads a single `Game` that is related to this `LineupSpot`. */
  game: Maybe<Game>;
};

/** All input for the `updateOutOnPlayRunnerByNodeId` mutation. */
export type UpdateOutOnPlayRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `OutOnPlayRunner` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `OutOnPlayRunner` being updated. */
  patch: OutOnPlayRunnerPatch;
};

/** All input for the `updateOutOnPlayRunner` mutation. */
export type UpdateOutOnPlayRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `OutOnPlayRunner` being updated. */
  patch: OutOnPlayRunnerPatch;
  plateAppearanceId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our update `OutOnPlayRunner` mutation. */
export type UpdateOutOnPlayRunnerPayload = {
  __typename?: 'UpdateOutOnPlayRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `OutOnPlayRunner` that was updated by this mutation. */
  outOnPlayRunner: Maybe<OutOnPlayRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Reads a single `Player` that is related to this `OutOnPlayRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `OutOnPlayRunner`. */
  game: Maybe<Game>;
};

/** All input for the `updatePlateAppearanceByNodeId` mutation. */
export type UpdatePlateAppearanceByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlateAppearance` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlateAppearance` being updated. */
  patch: PlateAppearancePatch;
};

/** All input for the `updatePlateAppearance` mutation. */
export type UpdatePlateAppearanceInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlateAppearance` being updated. */
  patch: PlateAppearancePatch;
  id: Scalars['UUID'];
};

/** The output of our update `PlateAppearance` mutation. */
export type UpdatePlateAppearancePayload = {
  __typename?: 'UpdatePlateAppearancePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlateAppearance` that was updated by this mutation. */
  plateAppearance: Maybe<PlateAppearance>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `PlateAppearance`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `PlateAppearance`. */
  batter: Maybe<Player>;
};

/** All input for the `updatePlayerByFirstNameAndLastName` mutation. */
export type UpdatePlayerByFirstNameAndLastNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Player` being updated. */
  patch: PlayerPatch;
  firstName: Scalars['String'];
  lastName: Scalars['String'];
};

/** All input for the `updatePlayerByNodeId` mutation. */
export type UpdatePlayerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Player` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Player` being updated. */
  patch: PlayerPatch;
};

/** All input for the `updatePlayerGroupMembershipByNodeId` mutation. */
export type UpdatePlayerGroupMembershipByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PlayerGroupMembership` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PlayerGroupMembership` being updated. */
  patch: PlayerGroupMembershipPatch;
};

/** All input for the `updatePlayerGroupMembership` mutation. */
export type UpdatePlayerGroupMembershipInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PlayerGroupMembership` being updated. */
  patch: PlayerGroupMembershipPatch;
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
};

/** The output of our update `PlayerGroupMembership` mutation. */
export type UpdatePlayerGroupMembershipPayload = {
  __typename?: 'UpdatePlayerGroupMembershipPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `PlayerGroupMembership` that was updated by this mutation. */
  playerGroupMembership: Maybe<PlayerGroupMembership>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `PlayerGroupMembership`. */
  player: Maybe<Player>;
  /** Reads a single `Group` that is related to this `PlayerGroupMembership`. */
  group: Maybe<Group>;
};

/** All input for the `updatePlayer` mutation. */
export type UpdatePlayerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Player` being updated. */
  patch: PlayerPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Player` mutation. */
export type UpdatePlayerPayload = {
  __typename?: 'UpdatePlayerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Player` that was updated by this mutation. */
  player: Maybe<Player>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `LegacyPlayer` that is related to this `Player`. */
  legacyPlayer: Maybe<LegacyPlayer>;
};

/** All input for the `updateReduxDumpByNodeId` mutation. */
export type UpdateReduxDumpByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ReduxDump` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ReduxDump` being updated. */
  patch: ReduxDumpPatch;
};

/** All input for the `updateReduxDump` mutation. */
export type UpdateReduxDumpInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ReduxDump` being updated. */
  patch: ReduxDumpPatch;
  id: Scalars['UUID'];
};

/** The output of our update `ReduxDump` mutation. */
export type UpdateReduxDumpPayload = {
  __typename?: 'UpdateReduxDumpPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ReduxDump` that was updated by this mutation. */
  reduxDump: Maybe<ReduxDump>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updateScoredRunnerByNodeId` mutation. */
export type UpdateScoredRunnerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ScoredRunner` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ScoredRunner` being updated. */
  patch: ScoredRunnerPatch;
};

/** All input for the `updateScoredRunner` mutation. */
export type UpdateScoredRunnerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ScoredRunner` being updated. */
  patch: ScoredRunnerPatch;
  gameEventRecordId: Scalars['UUID'];
  runnerId: Scalars['UUID'];
};

/** The output of our update `ScoredRunner` mutation. */
export type UpdateScoredRunnerPayload = {
  __typename?: 'UpdateScoredRunnerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `ScoredRunner` that was updated by this mutation. */
  scoredRunner: Maybe<ScoredRunner>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `GameEventRecord` that is related to this `ScoredRunner`. */
  gameEventRecord: Maybe<GameEventRecord>;
  /** Reads a single `Player` that is related to this `ScoredRunner`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `ScoredRunner`. */
  game: Maybe<Game>;
};

/** All input for the `updateSoloModeOpponentInningByNodeId` mutation. */
export type UpdateSoloModeOpponentInningByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `SoloModeOpponentInning` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `SoloModeOpponentInning` being updated. */
  patch: SoloModeOpponentInningPatch;
};

/** All input for the `updateSoloModeOpponentInning` mutation. */
export type UpdateSoloModeOpponentInningInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `SoloModeOpponentInning` being updated. */
  patch: SoloModeOpponentInningPatch;
  id: Scalars['UUID'];
};

/** The output of our update `SoloModeOpponentInning` mutation. */
export type UpdateSoloModeOpponentInningPayload = {
  __typename?: 'UpdateSoloModeOpponentInningPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `SoloModeOpponentInning` that was updated by this mutation. */
  soloModeOpponentInning: Maybe<SoloModeOpponentInning>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `SoloModeOpponentInning`. */
  game: Maybe<Game>;
};

/** All input for the `updateStolenBaseAttemptByNodeId` mutation. */
export type UpdateStolenBaseAttemptByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `StolenBaseAttempt` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `StolenBaseAttempt` being updated. */
  patch: StolenBaseAttemptPatch;
};

/** All input for the `updateStolenBaseAttempt` mutation. */
export type UpdateStolenBaseAttemptInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `StolenBaseAttempt` being updated. */
  patch: StolenBaseAttemptPatch;
  id: Scalars['UUID'];
};

/** The output of our update `StolenBaseAttempt` mutation. */
export type UpdateStolenBaseAttemptPayload = {
  __typename?: 'UpdateStolenBaseAttemptPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `StolenBaseAttempt` that was updated by this mutation. */
  stolenBaseAttempt: Maybe<StolenBaseAttempt>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Player` that is related to this `StolenBaseAttempt`. */
  runner: Maybe<Player>;
  /** Reads a single `Game` that is related to this `StolenBaseAttempt`. */
  game: Maybe<Game>;
};

/** All input for the `updateTagByName` mutation. */
export type UpdateTagByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Tag` being updated. */
  patch: TagPatch;
  name: Scalars['String'];
};

/** All input for the `updateTagByNodeId` mutation. */
export type UpdateTagByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Tag` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Tag` being updated. */
  patch: TagPatch;
};

/** All input for the `updateTag` mutation. */
export type UpdateTagInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Tag` being updated. */
  patch: TagPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Tag` mutation. */
export type UpdateTagPayload = {
  __typename?: 'UpdateTagPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Tag` that was updated by this mutation. */
  tag: Maybe<Tag>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** All input for the `updateTeamByGameIdAndRole` mutation. */
export type UpdateTeamByGameIdAndRoleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Team` being updated. */
  patch: TeamPatch;
  gameId: Scalars['UUID'];
  role: TeamRole;
};

/** All input for the `updateTeamByNodeId` mutation. */
export type UpdateTeamByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Team` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Team` being updated. */
  patch: TeamPatch;
};

/** All input for the `updateTeam` mutation. */
export type UpdateTeamInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Team` being updated. */
  patch: TeamPatch;
  id: Scalars['UUID'];
};

/** The output of our update `Team` mutation. */
export type UpdateTeamPayload = {
  __typename?: 'UpdateTeamPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  /** The `Team` that was updated by this mutation. */
  team: Maybe<Team>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
  /** Reads a single `Game` that is related to this `Team`. */
  game: Maybe<Game>;
  /** Reads a single `Player` that is related to this `Team`. */
  captain: Maybe<Player>;
};

export type UserGroupPermission = {
  __typename?: 'UserGroupPermission';
  groupId: Maybe<Scalars['UUID']>;
  permission: Maybe<GroupPermissionType>;
};

/** All input for the `verifyEmail` mutation. */
export type VerifyEmailInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  email: Scalars['String'];
  code: Scalars['String'];
};

/** The output of our `verifyEmail` mutation. */
export type VerifyEmailPayload = {
  __typename?: 'VerifyEmailPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId: Maybe<Scalars['String']>;
  boolean: Maybe<Scalars['Boolean']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query: Maybe<Query>;
};

/** An object where the defined keys will be set on the `atBatSkip` being updated. */
export type UpdateAtBatSkipOnAtBatSkipForAtBatSkipBatterIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `atBatSkip` being updated. */
export type UpdateAtBatSkipOnAtBatSkipForAtBatSkipGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `atBatSkip` being updated. */
export type UpdateAtBatSkipOnGameEventForGameEventAtBatSkipIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<AtBatSkipBatterIdFkeyInput>;
  game?: Maybe<AtBatSkipGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventAtBatSkipIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `baseRunner` being updated. */
export type UpdateBaseRunnerOnBaseRunnerForBaseRunnerGameIdFkeyPatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  base?: Maybe<BaseType>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `baseRunner` being updated. */
export type UpdateBaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch = {
  runnerId?: Maybe<Scalars['UUID']>;
  base?: Maybe<BaseType>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `baseRunner` being updated. */
export type UpdateBaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  base?: Maybe<BaseType>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<BaseRunnerGameStateIdFkeyInput>;
  player?: Maybe<BaseRunnerRunnerIdFkeyInput>;
  game?: Maybe<BaseRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `basepathMovement` being updated. */
export type UpdateBasepathMovementOnBasepathMovementForBasepathMovementGameIdFkeyPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe?: Maybe<Scalars['Boolean']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `basepathMovement` being updated. */
export type UpdateBasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch = {
  runnerId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `basepathMovement` being updated. */
export type UpdateBasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  endBase?: Maybe<BaseType>;
  wasSafe?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<BasepathMovementPlateAppearanceIdFkeyInput>;
  player?: Maybe<BasepathMovementRunnerIdFkeyInput>;
  game?: Maybe<BasepathMovementGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `earlyGameEnd` being updated. */
export type UpdateEarlyGameEndOnEarlyGameEndForEarlyGameEndGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  reason?: Maybe<EarlyGameEndReason>;
  game?: Maybe<EarlyGameEndGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventEarlyGameEndIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `earlyGameEnd` being updated. */
export type UpdateEarlyGameEndOnGameEventForGameEventEarlyGameEndIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  reason?: Maybe<EarlyGameEndReason>;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<EarlyGameEndGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventEarlyGameEndIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `field` being updated. */
export type UpdateFieldOnGameForGameFieldIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  games?: Maybe<GameFieldIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameBattingLine` being updated. */
export type UpdateGameBattingLineOnGameBattingLineForFakePublicGameBattingLinesForeignKey0Patch = {
  gameId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  teamId?: Maybe<Scalars['UUID']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicGameBattingLinesForeignKey0Input>;
  game?: Maybe<FakePublicGameBattingLinesForeignKey1Input>;
};

/** An object where the defined keys will be set on the `gameBattingLine` being updated. */
export type UpdateGameBattingLineOnGameBattingLineForFakePublicGameBattingLinesForeignKey1Patch = {
  playerId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  teamId?: Maybe<Scalars['UUID']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicGameBattingLinesForeignKey0Input>;
  game?: Maybe<FakePublicGameBattingLinesForeignKey1Input>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventAtBatSkipIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventEarlyGameEndIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventLineupChangeIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventPlateAppearanceIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventSoloModeOpponentInningIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEvent` being updated. */
export type UpdateGameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  stolenBaseAttemptId?: Maybe<Scalars['UUID']>;
  lineupChangeId?: Maybe<Scalars['UUID']>;
  soloModeOpponentInningId?: Maybe<Scalars['UUID']>;
  atBatSkipId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  earlyGameEndId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<GameEventPlateAppearanceIdFkeyInput>;
  stolenBaseAttempt?: Maybe<GameEventStolenBaseAttemptIdFkeyInput>;
  lineupChange?: Maybe<GameEventLineupChangeIdFkeyInput>;
  soloModeOpponentInning?: Maybe<GameEventSoloModeOpponentInningIdFkeyInput>;
  atBatSkip?: Maybe<GameEventAtBatSkipIdFkeyInput>;
  game?: Maybe<GameEventGameIdFkeyInput>;
  earlyGameEnd?: Maybe<GameEventEarlyGameEndIdFkeyInput>;
  gameEventRecords?: Maybe<GameEventRecordGameEventIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEventRecord` being updated. */
export type UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEventRecord` being updated. */
export type UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEventRecord` being updated. */
export type UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEventRecord` being updated. */
export type UpdateGameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `gameEventRecord` being updated. */
export type UpdateGameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  eventIndex?: Maybe<Scalars['Int']>;
  gameStateBeforeId?: Maybe<Scalars['UUID']>;
  gameStateAfterId?: Maybe<Scalars['UUID']>;
  gameEventId?: Maybe<Scalars['UUID']>;
  notes?: Maybe<Scalars['String']>;
  game?: Maybe<GameEventRecordGameIdFkeyInput>;
  gameStateBefore?: Maybe<GameEventRecordGameStateBeforeFkInput>;
  gameStateAfter?: Maybe<GameEventRecordGameStateAfterFkInput>;
  gameEvent?: Maybe<GameEventRecordGameEventIdFkeyInput>;
  scoredRunners?: Maybe<ScoredRunnerGameEventRecordIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnAtBatSkipForAtBatSkipGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnBaseRunnerForBaseRunnerGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnBasepathMovementForBasepathMovementGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnEarlyGameEndForEarlyGameEndGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameBattingLineForFakePublicGameBattingLinesForeignKey1Patch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameEventForGameEventGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameEventRecordForGameEventRecordGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameForGameFieldIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameForGameGroupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameStateForGameStateGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnGameTagForGameTagGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnLineupChangeForLineupChangeGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnLineupForGameStateForLineupForGameStateGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnLineupForLineupGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnLineupSpotForLineupSpotGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnPlateAppearanceForPlateAppearanceGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnScoredRunnerForScoredRunnerGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnTeamForTeamGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `game` being updated. */
export type UpdateGameOnUnifiedGameForFakePublicUnifiedGamesForeignKey1Patch = {
  id?: Maybe<Scalars['UUID']>;
  groupId?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  fieldId?: Maybe<Scalars['UUID']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  gameLength?: Maybe<Scalars['Int']>;
  timeStarted?: Maybe<Scalars['Datetime']>;
  timeEnded?: Maybe<Scalars['Datetime']>;
  timeSaved?: Maybe<Scalars['Datetime']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  group?: Maybe<GameGroupIdFkeyInput>;
  field?: Maybe<GameFieldIdFkeyInput>;
  teams?: Maybe<TeamGameIdFkeyInverseInput>;
  lineups?: Maybe<LineupGameIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotGameIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceGameIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementGameIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerGameIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptGameIdFkeyInverseInput>;
  lineupChanges?: Maybe<LineupChangeGameIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventGameIdFkeyInverseInput>;
  gameStates?: Maybe<GameStateGameIdFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerGameIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameIdFkeyInverseInput>;
  gameEventRecords?: Maybe<GameEventRecordGameIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerGameIdFkeyInverseInput>;
  soloModeOpponentInnings?: Maybe<SoloModeOpponentInningGameIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipGameIdFkeyInverseInput>;
  earlyGameEnds?: Maybe<EarlyGameEndGameIdFkeyInverseInput>;
  gameTags?: Maybe<GameTagGameIdFkeyInverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey1InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnGameEventRecordForGameEventRecordGameStateAfterFkPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnGameStateForGameStateGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnGameStateForGameStatePlayerAtBatFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `gameState` being updated. */
export type UpdateGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameStateIndex?: Maybe<Scalars['Int']>;
  playerAtBat?: Maybe<Scalars['UUID']>;
  inning?: Maybe<Scalars['Int']>;
  halfInning?: Maybe<HalfInning>;
  outs?: Maybe<Scalars['Int']>;
  score?: Maybe<Array<Maybe<Scalars['Int']>>>;
  game?: Maybe<GameStateGameIdFkeyInput>;
  player?: Maybe<GameStatePlayerAtBatFkeyInput>;
  baseRunners?: Maybe<BaseRunnerGameStateIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateGameStateIdFkeyInverseInput>;
  gameEventRecordsToGameStateBeforeIdUsingId?: Maybe<GameEventRecordGameStateBeforeFkInverseInput>;
  gameEventRecordsToGameStateAfterIdUsingId?: Maybe<GameEventRecordGameStateAfterFkInverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnCareerStatForFakePublicCareerStatsForeignKey2Patch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey2Patch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnGameForGameGroupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey2Patch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnSeasonStatForFakePublicSeasonStatsForeignKey2Patch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2Patch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey2Patch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `group` being updated. */
export type UpdateGroupOnUnifiedGameForFakePublicUnifiedGamesForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  soloMode?: Maybe<Scalars['Boolean']>;
  urlSlug?: Maybe<Scalars['String']>;
  allowSkippingAtBats?: Maybe<Scalars['Boolean']>;
  allowSteals?: Maybe<Scalars['Boolean']>;
  games?: Maybe<GameGroupIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipGroupIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey2InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey2InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey2InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey2InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey2InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `legacyGameBattingLine` being updated. */
export type UpdateLegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey0Patch = {
  legacyPlayerId?: Maybe<Scalars['Int']>;
  legacyGameId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeamId?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1Input>;
  legacyGame?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2Input>;
  legacyStatLine?: Maybe<FakePublicLegacyGameBattingLinesForeignKey3Input>;
};

/** An object where the defined keys will be set on the `legacyGameBattingLine` being updated. */
export type UpdateLegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey1Patch = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyGameId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeamId?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1Input>;
  legacyGame?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2Input>;
  legacyStatLine?: Maybe<FakePublicLegacyGameBattingLinesForeignKey3Input>;
};

/** An object where the defined keys will be set on the `legacyGameBattingLine` being updated. */
export type UpdateLegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey2Patch = {
  playerId?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeamId?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1Input>;
  legacyGame?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2Input>;
  legacyStatLine?: Maybe<FakePublicLegacyGameBattingLinesForeignKey3Input>;
};

/** An object where the defined keys will be set on the `legacyGameBattingLine` being updated. */
export type UpdateLegacyGameBattingLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey3Patch = {
  playerId?: Maybe<Scalars['UUID']>;
  season?: Maybe<Scalars['Int']>;
  plateAppearances?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  gidp?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  xbh?: Maybe<Scalars['Int']>;
  battingAverage?: Maybe<Scalars['Float']>;
  onBasePct?: Maybe<Scalars['Float']>;
  sluggingPct?: Maybe<Scalars['Float']>;
  ops?: Maybe<Scalars['Float']>;
  player?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0Input>;
  legacyPlayer?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1Input>;
  legacyGame?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2Input>;
  legacyStatLine?: Maybe<FakePublicLegacyGameBattingLinesForeignKey3Input>;
};

/** An object where the defined keys will be set on the `legacyGame` being updated. */
export type UpdateLegacyGameOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey2Patch = {
  gameId?: Maybe<Scalars['Int']>;
  gameTitle?: Maybe<Scalars['String']>;
  gameDate?: Maybe<Scalars['Date']>;
  gameStartTime?: Maybe<Scalars['Time']>;
  gameEndTime?: Maybe<Scalars['Time']>;
  gameTeamId1?: Maybe<Scalars['Int']>;
  gameTeamId2?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeam?: Maybe<FakePublicLegacyGameForeignKey1Input>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey2InverseInput>;
};

/** An object where the defined keys will be set on the `legacyGame` being updated. */
export type UpdateLegacyGameOnLegacyGameForFakePublicLegacyGameForeignKey0Patch = {
  gameId?: Maybe<Scalars['Int']>;
  gameTitle?: Maybe<Scalars['String']>;
  gameDate?: Maybe<Scalars['Date']>;
  gameStartTime?: Maybe<Scalars['Time']>;
  gameEndTime?: Maybe<Scalars['Time']>;
  gameTeamId2?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeam?: Maybe<FakePublicLegacyGameForeignKey1Input>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey2InverseInput>;
};

/** An object where the defined keys will be set on the `legacyGame` being updated. */
export type UpdateLegacyGameOnLegacyGameForFakePublicLegacyGameForeignKey1Patch = {
  gameId?: Maybe<Scalars['Int']>;
  gameTitle?: Maybe<Scalars['String']>;
  gameDate?: Maybe<Scalars['Date']>;
  gameStartTime?: Maybe<Scalars['Time']>;
  gameEndTime?: Maybe<Scalars['Time']>;
  gameTeamId1?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeam?: Maybe<FakePublicLegacyGameForeignKey1Input>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey2InverseInput>;
};

/** An object where the defined keys will be set on the `legacyGame` being updated. */
export type UpdateLegacyGameOnUnifiedGameForFakePublicUnifiedGamesForeignKey2Patch = {
  gameId?: Maybe<Scalars['Int']>;
  gameTitle?: Maybe<Scalars['String']>;
  gameDate?: Maybe<Scalars['Date']>;
  gameStartTime?: Maybe<Scalars['Time']>;
  gameEndTime?: Maybe<Scalars['Time']>;
  gameTeamId1?: Maybe<Scalars['Int']>;
  gameTeamId2?: Maybe<Scalars['Int']>;
  season?: Maybe<Scalars['Int']>;
  legacyTeam?: Maybe<FakePublicLegacyGameForeignKey1Input>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey2InverseInput>;
  unifiedGames?: Maybe<FakePublicUnifiedGamesForeignKey2InverseInput>;
};

/** An object where the defined keys will be set on the `legacyMeetupFieldRaw` being updated. */
export type UpdateLegacyMeetupFieldRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  subField?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  rating?: Maybe<Scalars['Int']>;
  legacyMeetupGameRaws?: Maybe<LegacyMeetupGameRawFieldIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
export type UpdateLegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawFieldIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  season?: Maybe<Scalars['Int']>;
  date?: Maybe<Scalars['Date']>;
  timeStarted?: Maybe<Scalars['Time']>;
  timeEnded?: Maybe<Scalars['Time']>;
  winningTeamId?: Maybe<Scalars['Int']>;
  losingTeamId?: Maybe<Scalars['Int']>;
  imageGalleryUrl?: Maybe<Scalars['String']>;
  meetupEventId?: Maybe<Scalars['String']>;
  dateInserted?: Maybe<Scalars['Date']>;
  dateUpdated?: Maybe<Scalars['Date']>;
  advanced?: Maybe<Scalars['Boolean']>;
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInput>;
  legacyMeetupFieldRaw?: Maybe<LegacyMeetupGameRawFieldIdFkeyInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
export type UpdateLegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  season?: Maybe<Scalars['Int']>;
  date?: Maybe<Scalars['Date']>;
  timeStarted?: Maybe<Scalars['Time']>;
  timeEnded?: Maybe<Scalars['Time']>;
  winningTeamId?: Maybe<Scalars['Int']>;
  fieldId?: Maybe<Scalars['Int']>;
  imageGalleryUrl?: Maybe<Scalars['String']>;
  meetupEventId?: Maybe<Scalars['String']>;
  dateInserted?: Maybe<Scalars['Date']>;
  dateUpdated?: Maybe<Scalars['Date']>;
  advanced?: Maybe<Scalars['Boolean']>;
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInput>;
  legacyMeetupFieldRaw?: Maybe<LegacyMeetupGameRawFieldIdFkeyInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
export type UpdateLegacyMeetupGameRawOnLegacyMeetupGameRawForLegacyMeetupGameRawWinningTeamIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  season?: Maybe<Scalars['Int']>;
  date?: Maybe<Scalars['Date']>;
  timeStarted?: Maybe<Scalars['Time']>;
  timeEnded?: Maybe<Scalars['Time']>;
  losingTeamId?: Maybe<Scalars['Int']>;
  fieldId?: Maybe<Scalars['Int']>;
  imageGalleryUrl?: Maybe<Scalars['String']>;
  meetupEventId?: Maybe<Scalars['String']>;
  dateInserted?: Maybe<Scalars['Date']>;
  dateUpdated?: Maybe<Scalars['Date']>;
  advanced?: Maybe<Scalars['Boolean']>;
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInput>;
  legacyMeetupFieldRaw?: Maybe<LegacyMeetupGameRawFieldIdFkeyInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `legacyMeetupGameRaw` being updated. */
export type UpdateLegacyMeetupGameRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawGameIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  season?: Maybe<Scalars['Int']>;
  date?: Maybe<Scalars['Date']>;
  timeStarted?: Maybe<Scalars['Time']>;
  timeEnded?: Maybe<Scalars['Time']>;
  winningTeamId?: Maybe<Scalars['Int']>;
  losingTeamId?: Maybe<Scalars['Int']>;
  fieldId?: Maybe<Scalars['Int']>;
  imageGalleryUrl?: Maybe<Scalars['String']>;
  meetupEventId?: Maybe<Scalars['String']>;
  dateInserted?: Maybe<Scalars['Date']>;
  dateUpdated?: Maybe<Scalars['Date']>;
  advanced?: Maybe<Scalars['Boolean']>;
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInput>;
  legacyMeetupFieldRaw?: Maybe<LegacyMeetupGameRawFieldIdFkeyInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `legacyMeetupPlayerRaw` being updated. */
export type UpdateLegacyMeetupPlayerRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawPlayerIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  gender?: Maybe<Gender>;
  nickname?: Maybe<Scalars['String']>;
  selfNickname?: Maybe<Scalars['String']>;
  bats?: Maybe<Handedness>;
  throws?: Maybe<Handedness>;
  imageUrl?: Maybe<Scalars['String']>;
  meetupMemberId?: Maybe<Scalars['String']>;
  skillLevel?: Maybe<Scalars['Int']>;
  preferredPositionFirst?: Maybe<FieldingPosition>;
  preferredPositionSecond?: Maybe<FieldingPosition>;
  preferredPositionThird?: Maybe<FieldingPosition>;
  favoriteTeam?: Maybe<Scalars['String']>;
  hometown?: Maybe<Scalars['String']>;
  school?: Maybe<Scalars['String']>;
  timeAdded?: Maybe<Scalars['Datetime']>;
  dateDebuted?: Maybe<Scalars['Date']>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawPlayerIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `legacyMeetupStatLineRaw` being updated. */
export type UpdateLegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawGameIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  playerId?: Maybe<Scalars['Int']>;
  teamId?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  pitched?: Maybe<Scalars['Boolean']>;
  pitcherWon?: Maybe<Scalars['Boolean']>;
  pitcherLost?: Maybe<Scalars['Boolean']>;
  pitcherSave?: Maybe<Scalars['Boolean']>;
  pitcherCompleteGame?: Maybe<Scalars['Boolean']>;
  pitcherQualityStart?: Maybe<Scalars['Boolean']>;
  inningsPitched?: Maybe<Scalars['Int']>;
  runsAllowed?: Maybe<Scalars['Int']>;
  earnedRunsAllowed?: Maybe<Scalars['Int']>;
  hitsAllowed?: Maybe<Scalars['Int']>;
  homerunsAllowed?: Maybe<Scalars['Int']>;
  pitcherStrikeouts?: Maybe<Scalars['Int']>;
  pitcherWalks?: Maybe<Scalars['Int']>;
  legacyMeetupPlayerRaw?: Maybe<LegacyMeetupStatLineRawPlayerIdFkeyInput>;
  legacyMeetupGameRaw?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInput>;
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupStatLineRawTeamIdFkeyInput>;
};

/** An object where the defined keys will be set on the `legacyMeetupStatLineRaw` being updated. */
export type UpdateLegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawPlayerIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  gameId?: Maybe<Scalars['Int']>;
  teamId?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  pitched?: Maybe<Scalars['Boolean']>;
  pitcherWon?: Maybe<Scalars['Boolean']>;
  pitcherLost?: Maybe<Scalars['Boolean']>;
  pitcherSave?: Maybe<Scalars['Boolean']>;
  pitcherCompleteGame?: Maybe<Scalars['Boolean']>;
  pitcherQualityStart?: Maybe<Scalars['Boolean']>;
  inningsPitched?: Maybe<Scalars['Int']>;
  runsAllowed?: Maybe<Scalars['Int']>;
  earnedRunsAllowed?: Maybe<Scalars['Int']>;
  hitsAllowed?: Maybe<Scalars['Int']>;
  homerunsAllowed?: Maybe<Scalars['Int']>;
  pitcherStrikeouts?: Maybe<Scalars['Int']>;
  pitcherWalks?: Maybe<Scalars['Int']>;
  legacyMeetupPlayerRaw?: Maybe<LegacyMeetupStatLineRawPlayerIdFkeyInput>;
  legacyMeetupGameRaw?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInput>;
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupStatLineRawTeamIdFkeyInput>;
};

/** An object where the defined keys will be set on the `legacyMeetupStatLineRaw` being updated. */
export type UpdateLegacyMeetupStatLineRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawTeamIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  playerId?: Maybe<Scalars['Int']>;
  gameId?: Maybe<Scalars['Int']>;
  atBats?: Maybe<Scalars['Int']>;
  runs?: Maybe<Scalars['Int']>;
  hits?: Maybe<Scalars['Int']>;
  singles?: Maybe<Scalars['Int']>;
  doubles?: Maybe<Scalars['Int']>;
  triples?: Maybe<Scalars['Int']>;
  homeruns?: Maybe<Scalars['Int']>;
  rbi?: Maybe<Scalars['Int']>;
  walks?: Maybe<Scalars['Int']>;
  strikeouts?: Maybe<Scalars['Int']>;
  sacFlies?: Maybe<Scalars['Int']>;
  stolenBases?: Maybe<Scalars['Int']>;
  pitched?: Maybe<Scalars['Boolean']>;
  pitcherWon?: Maybe<Scalars['Boolean']>;
  pitcherLost?: Maybe<Scalars['Boolean']>;
  pitcherSave?: Maybe<Scalars['Boolean']>;
  pitcherCompleteGame?: Maybe<Scalars['Boolean']>;
  pitcherQualityStart?: Maybe<Scalars['Boolean']>;
  inningsPitched?: Maybe<Scalars['Int']>;
  runsAllowed?: Maybe<Scalars['Int']>;
  earnedRunsAllowed?: Maybe<Scalars['Int']>;
  hitsAllowed?: Maybe<Scalars['Int']>;
  homerunsAllowed?: Maybe<Scalars['Int']>;
  pitcherStrikeouts?: Maybe<Scalars['Int']>;
  pitcherWalks?: Maybe<Scalars['Int']>;
  legacyMeetupPlayerRaw?: Maybe<LegacyMeetupStatLineRawPlayerIdFkeyInput>;
  legacyMeetupGameRaw?: Maybe<LegacyMeetupStatLineRawGameIdFkeyInput>;
  legacyMeetupTeamRaw?: Maybe<LegacyMeetupStatLineRawTeamIdFkeyInput>;
};

/** An object where the defined keys will be set on the `legacyMeetupTeamRaw` being updated. */
export type UpdateLegacyMeetupTeamRawOnLegacyMeetupGameRawForLegacyMeetupGameRawLosingTeamIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  legacyMeetupGameRawsToWinningTeamIdUsingId?: Maybe<LegacyMeetupGameRawWinningTeamIdFkeyInverseInput>;
  legacyMeetupGameRawsToLosingTeamIdUsingId?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInverseInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawTeamIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `legacyMeetupTeamRaw` being updated. */
export type UpdateLegacyMeetupTeamRawOnLegacyMeetupStatLineRawForLegacyMeetupStatLineRawTeamIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  legacyMeetupGameRawsToWinningTeamIdUsingId?: Maybe<LegacyMeetupGameRawWinningTeamIdFkeyInverseInput>;
  legacyMeetupGameRawsToLosingTeamIdUsingId?: Maybe<LegacyMeetupGameRawLosingTeamIdFkeyInverseInput>;
  legacyMeetupStatLineRaws?: Maybe<LegacyMeetupStatLineRawTeamIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `legacyPlayer` being updated. */
export type UpdateLegacyPlayerOnCareerStatForFakePublicCareerStatsForeignKey1Patch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `legacyPlayer` being updated. */
export type UpdateLegacyPlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey1Patch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `legacyPlayer` being updated. */
export type UpdateLegacyPlayerOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey1Patch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `legacyPlayer` being updated. */
export type UpdateLegacyPlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey1Patch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `legacyPlayer` being updated. */
export type UpdateLegacyPlayerOnPlayerForFakePublicPlayerForeignKey0Patch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `legacyPlayer` being updated. */
export type UpdateLegacyPlayerOnSeasonStatForFakePublicSeasonStatsForeignKey1Patch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `legacyPlayer` being updated. */
export type UpdateLegacyPlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1Patch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `legacyPlayer` being updated. */
export type UpdateLegacyPlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey1Patch = {
  playerId?: Maybe<Scalars['Int']>;
  playerName?: Maybe<Scalars['String']>;
  playerImage?: Maybe<Scalars['String']>;
  memberId?: Maybe<Scalars['String']>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey1InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey1InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey1InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey1InverseInput>;
  players?: Maybe<FakePublicPlayerForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey1InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey1InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `legacyStatLine` being updated. */
export type UpdateLegacyStatLineOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey3Patch = {
  sbStatsId?: Maybe<Scalars['Int']>;
  playerId?: Maybe<Scalars['Int']>;
  gameId?: Maybe<Scalars['Int']>;
  sbStatsTeam?: Maybe<Scalars['Int']>;
  sbStatsAb?: Maybe<Scalars['Int']>;
  sbStatsRuns?: Maybe<Scalars['Int']>;
  sbStatsHits?: Maybe<Scalars['Int']>;
  sbStats1B?: Maybe<Scalars['Int']>;
  sbStats2B?: Maybe<Scalars['Int']>;
  sbStats3B?: Maybe<Scalars['Int']>;
  sbStatsHr?: Maybe<Scalars['Int']>;
  sbStatsRbi?: Maybe<Scalars['Int']>;
  sbStatsBb?: Maybe<Scalars['Int']>;
  sbStatsSo?: Maybe<Scalars['Int']>;
  sbStatsSac?: Maybe<Scalars['Int']>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey3InverseInput>;
};

/** An object where the defined keys will be set on the `legacyTeam` being updated. */
export type UpdateLegacyTeamOnLegacyGameForFakePublicLegacyGameForeignKey1Patch = {
  teamId?: Maybe<Scalars['Int']>;
  teamName?: Maybe<Scalars['String']>;
  legacyGamesToGameTeamId1UsingTeamId?: Maybe<FakePublicLegacyGameForeignKey0InverseInput>;
  legacyGamesToGameTeamId2UsingTeamId?: Maybe<FakePublicLegacyGameForeignKey1InverseInput>;
};

/** An object where the defined keys will be set on the `lineupChange` being updated. */
export type UpdateLineupChangeOnGameEventForGameEventLineupChangeIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineupChange` being updated. */
export type UpdateLineupChangeOnLineupChangeForLineupChangeGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineupChange` being updated. */
export type UpdateLineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  lineupBeforeId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineupChange` being updated. */
export type UpdateLineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  lineupAfterId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupChangeLineupAfterIdFkeyInput>;
  game?: Maybe<LineupChangeGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventLineupChangeIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineupForGameState` being updated. */
export type UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateGameIdFkeyPatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  lineupId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `lineupForGameState` being updated. */
export type UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch = {
  lineupId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `lineupForGameState` being updated. */
export type UpdateLineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch = {
  gameStateId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameState?: Maybe<LineupForGameStateGameStateIdFkeyInput>;
  lineup?: Maybe<LineupForGameStateLineupIdFkeyInput>;
  game?: Maybe<LineupForGameStateGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `lineup` being updated. */
export type UpdateLineupOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineup` being updated. */
export type UpdateLineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineup` being updated. */
export type UpdateLineupOnLineupForLineupGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineup` being updated. */
export type UpdateLineupOnLineupForLineupTeamIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineup` being updated. */
export type UpdateLineupOnLineupSpotForLineupSpotLineupIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  teamId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  team?: Maybe<LineupTeamIdFkeyInput>;
  game?: Maybe<LineupGameIdFkeyInput>;
  lineupSpots?: Maybe<LineupSpotLineupIdFkeyInverseInput>;
  lineupChangesToLineupBeforeIdUsingId?: Maybe<LineupChangeLineupBeforeIdFkeyInverseInput>;
  lineupChangesToLineupAfterIdUsingId?: Maybe<LineupChangeLineupAfterIdFkeyInverseInput>;
  lineupForGameStates?: Maybe<LineupForGameStateLineupIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `lineupSpot` being updated. */
export type UpdateLineupSpotOnLineupSpotForLineupSpotGameIdFkeyPatch = {
  lineupId?: Maybe<Scalars['UUID']>;
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder?: Maybe<Scalars['Int']>;
  position?: Maybe<FieldingPosition>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `lineupSpot` being updated. */
export type UpdateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch = {
  playerId?: Maybe<Scalars['UUID']>;
  battingOrder?: Maybe<Scalars['Int']>;
  position?: Maybe<FieldingPosition>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `lineupSpot` being updated. */
export type UpdateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch = {
  lineupId?: Maybe<Scalars['UUID']>;
  battingOrder?: Maybe<Scalars['Int']>;
  position?: Maybe<FieldingPosition>;
  gameId?: Maybe<Scalars['UUID']>;
  lineup?: Maybe<LineupSpotLineupIdFkeyInput>;
  player?: Maybe<LineupSpotPlayerIdFkeyInput>;
  game?: Maybe<LineupSpotGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
export type UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerGameIdFkeyPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
export type UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch = {
  runnerId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `outOnPlayRunner` being updated. */
export type UpdateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch = {
  plateAppearanceId?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  plateAppearance?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInput>;
  player?: Maybe<OutOnPlayRunnerRunnerIdFkeyInput>;
  game?: Maybe<OutOnPlayRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `plateAppearance` being updated. */
export type UpdatePlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `plateAppearance` being updated. */
export type UpdatePlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `plateAppearance` being updated. */
export type UpdatePlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `plateAppearance` being updated. */
export type UpdatePlateAppearanceOnPlateAppearanceForPlateAppearanceBatterIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `plateAppearance` being updated. */
export type UpdatePlateAppearanceOnPlateAppearanceForPlateAppearanceGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  type?: Maybe<PlateAppearanceType>;
  contact?: Maybe<ContactQuality>;
  fieldedBy?: Maybe<FieldingPosition>;
  runsScoredOnSacFly?: Maybe<Scalars['Int']>;
  routinePlay?: Maybe<Scalars['Boolean']>;
  batterId?: Maybe<Scalars['UUID']>;
  game?: Maybe<PlateAppearanceGameIdFkeyInput>;
  player?: Maybe<PlateAppearanceBatterIdFkeyInput>;
  basepathMovements?: Maybe<BasepathMovementPlateAppearanceIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput>;
  gameEvents?: Maybe<GameEventPlateAppearanceIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `playerGroupMembership` being updated. */
export type UpdatePlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipGroupIdFkeyPatch = {
  playerId?: Maybe<Scalars['UUID']>;
  player?: Maybe<PlayerGroupMembershipPlayerIdFkeyInput>;
  group?: Maybe<PlayerGroupMembershipGroupIdFkeyInput>;
};

/** An object where the defined keys will be set on the `playerGroupMembership` being updated. */
export type UpdatePlayerGroupMembershipOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyPatch = {
  groupId?: Maybe<Scalars['UUID']>;
  player?: Maybe<PlayerGroupMembershipPlayerIdFkeyInput>;
  group?: Maybe<PlayerGroupMembershipGroupIdFkeyInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnAtBatSkipForAtBatSkipBatterIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnCareerStatForFakePublicCareerStatsForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnCareerStatsQualifiedBatterForFakePublicCareerStatsQualifiedBattersForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnGameBattingLineForFakePublicGameBattingLinesForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnGameStateForGameStatePlayerAtBatFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnLegacyGameBattingLineForFakePublicLegacyGameBattingLinesForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnLegacySeasonStatForFakePublicLegacySeasonStatsForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnLineupSpotForLineupSpotPlayerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnPlateAppearanceForPlateAppearanceBatterIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnPlayerForFakePublicPlayerForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnPlayerGroupMembershipForPlayerGroupMembershipPlayerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnSeasonStatForFakePublicSeasonStatsForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnSeasonStatsAllTimeQualifiedBatterForFakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnSeasonStatsQualifiedBatterForFakePublicSeasonStatsQualifiedBattersForeignKey0Patch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `player` being updated. */
export type UpdatePlayerOnTeamForTeamCaptainIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  legacyPlayerId?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  imageUrl?: Maybe<Scalars['String']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  claimed?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  timeClaimed?: Maybe<Scalars['Datetime']>;
  legacyPlayer?: Maybe<FakePublicPlayerForeignKey0Input>;
  teams?: Maybe<TeamCaptainIdFkeyInverseInput>;
  lineupSpots?: Maybe<LineupSpotPlayerIdFkeyInverseInput>;
  plateAppearances?: Maybe<PlateAppearanceBatterIdFkeyInverseInput>;
  basepathMovements?: Maybe<BasepathMovementRunnerIdFkeyInverseInput>;
  outOnPlayRunners?: Maybe<OutOnPlayRunnerRunnerIdFkeyInverseInput>;
  stolenBaseAttempts?: Maybe<StolenBaseAttemptRunnerIdFkeyInverseInput>;
  gameStates?: Maybe<GameStatePlayerAtBatFkeyInverseInput>;
  baseRunners?: Maybe<BaseRunnerRunnerIdFkeyInverseInput>;
  scoredRunners?: Maybe<ScoredRunnerRunnerIdFkeyInverseInput>;
  playerGroupMemberships?: Maybe<PlayerGroupMembershipPlayerIdFkeyInverseInput>;
  atBatSkips?: Maybe<AtBatSkipBatterIdFkeyInverseInput>;
  careerStats?: Maybe<FakePublicCareerStatsForeignKey0InverseInput>;
  careerStatsQualifiedBatters?: Maybe<FakePublicCareerStatsQualifiedBattersForeignKey0InverseInput>;
  gameBattingLines?: Maybe<FakePublicGameBattingLinesForeignKey0InverseInput>;
  legacyGameBattingLines?: Maybe<FakePublicLegacyGameBattingLinesForeignKey0InverseInput>;
  legacySeasonStats?: Maybe<FakePublicLegacySeasonStatsForeignKey0InverseInput>;
  seasonStats?: Maybe<FakePublicSeasonStatsForeignKey0InverseInput>;
  seasonStatsAllTimeQualifiedBatters?: Maybe<FakePublicSeasonStatsAllTimeQualifiedBattersForeignKey0InverseInput>;
  seasonStatsQualifiedBatters?: Maybe<FakePublicSeasonStatsQualifiedBattersForeignKey0InverseInput>;
};

/** An object where the defined keys will be set on the `scoredRunner` being updated. */
export type UpdateScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch = {
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `scoredRunner` being updated. */
export type UpdateScoredRunnerOnScoredRunnerForScoredRunnerGameIdFkeyPatch = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  battedIn?: Maybe<Scalars['Boolean']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `scoredRunner` being updated. */
export type UpdateScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch = {
  gameEventRecordId?: Maybe<Scalars['UUID']>;
  battedIn?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  gameEventRecord?: Maybe<ScoredRunnerGameEventRecordIdFkeyInput>;
  player?: Maybe<ScoredRunnerRunnerIdFkeyInput>;
  game?: Maybe<ScoredRunnerGameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `soloModeOpponentInning` being updated. */
export type UpdateSoloModeOpponentInningOnGameEventForGameEventSoloModeOpponentInningIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  runsScored?: Maybe<Scalars['Int']>;
  gameId?: Maybe<Scalars['UUID']>;
  game?: Maybe<SoloModeOpponentInningGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventSoloModeOpponentInningIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `soloModeOpponentInning` being updated. */
export type UpdateSoloModeOpponentInningOnSoloModeOpponentInningForSoloModeOpponentInningGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  runsScored?: Maybe<Scalars['Int']>;
  game?: Maybe<SoloModeOpponentInningGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventSoloModeOpponentInningIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
export type UpdateStolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
export type UpdateStolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  runnerId?: Maybe<Scalars['UUID']>;
  success?: Maybe<Scalars['Boolean']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `stolenBaseAttempt` being updated. */
export type UpdateStolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  success?: Maybe<Scalars['Boolean']>;
  gameId?: Maybe<Scalars['UUID']>;
  player?: Maybe<StolenBaseAttemptRunnerIdFkeyInput>;
  game?: Maybe<StolenBaseAttemptGameIdFkeyInput>;
  gameEvents?: Maybe<GameEventStolenBaseAttemptIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `tag` being updated. */
export type UpdateTagOnGameTagForGameTagTagIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<TagType>;
  gameTags?: Maybe<GameTagTagIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `team` being updated. */
export type UpdateTeamOnLineupForLineupTeamIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role?: Maybe<TeamRole>;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `team` being updated. */
export type UpdateTeamOnTeamForTeamCaptainIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  gameId?: Maybe<Scalars['UUID']>;
  role?: Maybe<TeamRole>;
  name?: Maybe<Scalars['String']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `team` being updated. */
export type UpdateTeamOnTeamForTeamGameIdFkeyPatch = {
  id?: Maybe<Scalars['UUID']>;
  role?: Maybe<TeamRole>;
  name?: Maybe<Scalars['String']>;
  captainId?: Maybe<Scalars['UUID']>;
  winner?: Maybe<Scalars['Boolean']>;
  soloModeOpponent?: Maybe<Scalars['Boolean']>;
  game?: Maybe<TeamGameIdFkeyInput>;
  player?: Maybe<TeamCaptainIdFkeyInput>;
  lineups?: Maybe<LineupTeamIdFkeyInverseInput>;
};

export type GameEventRecord_GameStateFragment = (
  { __typename?: 'GameState' }
  & Pick<GameState, 'inning' | 'halfInning' | 'outs' | 'playerAtBat' | 'score'>
  & { lineups: Maybe<Array<Maybe<(
    { __typename?: 'Lineup' }
    & Pick<Lineup, 'id'>
    & { team: Maybe<(
      { __typename?: 'Team' }
      & Pick<Team, 'role'>
    )> }
  )>>>, baseRunners: Array<(
    { __typename?: 'BaseRunner' }
    & Pick<BaseRunner, 'runnerId' | 'base'>
  )> }
);

export type UnpackedGame_GameFragment = (
  { __typename?: 'Game' }
  & Pick<Game, 'id' | 'gameLength' | 'name' | 'score' | 'timeStarted' | 'timeEnded'>
  & { gameStates: Array<(
    { __typename?: 'GameState' }
    & Pick<GameState, 'id' | 'inning' | 'halfInning' | 'outs' | 'playerAtBat' | 'score'>
    & { lineups: Maybe<Array<Maybe<(
      { __typename?: 'Lineup' }
      & Pick<Lineup, 'id'>
      & { team: Maybe<(
        { __typename?: 'Team' }
        & Pick<Team, 'role'>
      )> }
    )>>>, baseRunners: Array<(
      { __typename?: 'BaseRunner' }
      & Pick<BaseRunner, 'runnerId' | 'base'>
    )> }
  )>, gameEventRecords: Array<(
    { __typename?: 'GameEventRecord' }
    & Pick<GameEventRecord, 'eventIndex' | 'gameStateBeforeId' | 'gameStateAfterId'>
    & { gameEvent: Maybe<(
      { __typename?: 'GameEvent' }
      & { lineupChange: Maybe<(
        { __typename?: 'LineupChange' }
        & Pick<LineupChange, 'lineupBeforeId' | 'lineupAfterId'>
      )>, stolenBaseAttempt: Maybe<(
        { __typename?: 'StolenBaseAttempt' }
        & Pick<StolenBaseAttempt, 'runnerId' | 'success'>
      )>, plateAppearance: Maybe<(
        { __typename?: 'PlateAppearance' }
        & Pick<PlateAppearance, 'batterId' | 'type' | 'contact' | 'fieldedBy' | 'runsScoredOnSacFly'>
        & { outOnPlayRunners: Array<(
          { __typename?: 'OutOnPlayRunner' }
          & Pick<OutOnPlayRunner, 'runnerId'>
        )>, basepathMovements: Array<(
          { __typename?: 'BasepathMovement' }
          & Pick<BasepathMovement, 'runnerId' | 'endBase' | 'wasSafe'>
        )> }
      )>, soloModeOpponentInning: Maybe<(
        { __typename?: 'SoloModeOpponentInning' }
        & Pick<SoloModeOpponentInning, 'runsScored'>
      )>, atBatSkip: Maybe<(
        { __typename?: 'AtBatSkip' }
        & Pick<AtBatSkip, 'batterId'>
      )>, earlyGameEnd: Maybe<(
        { __typename?: 'EarlyGameEnd' }
        & Pick<EarlyGameEnd, 'reason'>
      )> }
    )>, scoredRunners: Array<(
      { __typename?: 'ScoredRunner' }
      & Pick<ScoredRunner, 'runnerId' | 'battedIn'>
    )> }
  )>, teams: Array<(
    { __typename?: 'Team' }
    & Pick<Team, 'name' | 'role' | 'winner' | 'soloModeOpponent'>
    & { lineups: Array<(
      { __typename?: 'Lineup' }
      & Pick<Lineup, 'id'>
      & { lineupSpots: Array<(
        { __typename?: 'LineupSpot' }
        & Pick<LineupSpot, 'playerId' | 'position'>
      )> }
    )> }
  )> }
);

export type AddPlayerToGroupMutationVariables = Exact<{
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
}>;


export type AddPlayerToGroupMutation = (
  { __typename?: 'Mutation' }
  & { updatePlayer: Maybe<(
    { __typename?: 'UpdatePlayerPayload' }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'firstName' | 'lastName'>
      & { groups: Array<(
        { __typename?: 'PlayerGroupMembership' }
        & Pick<PlayerGroupMembership, 'groupId'>
      )> }
    )> }
  )> }
);

export type CreateGameMutationVariables = Exact<{
  input: CreateGameInput;
}>;


export type CreateGameMutation = (
  { __typename?: 'Mutation' }
  & { createGame: Maybe<(
    { __typename?: 'CreateGamePayload' }
    & { game: Maybe<(
      { __typename?: 'Game' }
      & UnpackedGame_GameFragment
    )> }
  )> }
);

export type CreatePlayerMutationVariables = Exact<{
  input: CreatePlayerInput;
}>;


export type CreatePlayerMutation = (
  { __typename?: 'Mutation' }
  & { createPlayer: Maybe<(
    { __typename?: 'CreatePlayerPayload' }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'firstName' | 'lastName'>
      & { groups: Array<(
        { __typename?: 'PlayerGroupMembership' }
        & Pick<PlayerGroupMembership, 'groupId'>
      )> }
    )> }
  )> }
);

export type DumpReduxStoreMutationVariables = Exact<{
  storeJson: Scalars['JSON'];
}>;


export type DumpReduxStoreMutation = (
  { __typename?: 'Mutation' }
  & { createReduxDump: Maybe<(
    { __typename?: 'CreateReduxDumpPayload' }
    & { reduxDump: Maybe<(
      { __typename?: 'ReduxDump' }
      & Pick<ReduxDump, 'id'>
    )> }
  )> }
);

export type GetAllGamesQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetAllGamesQuery = (
  { __typename?: 'Query' }
  & { games: Maybe<Array<(
    { __typename?: 'Game' }
    & UnpackedGame_GameFragment
  )>> }
);

export type GetAllGroupsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllGroupsQuery = (
  { __typename?: 'Query' }
  & { groups: Maybe<Array<(
    { __typename?: 'Group' }
    & Pick<Group, 'id' | 'name' | 'soloMode' | 'urlSlug' | 'allowSkippingAtBats' | 'allowSteals'>
  )>> }
);

export type GetAllPlayersQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllPlayersQuery = (
  { __typename?: 'Query' }
  & { players: Maybe<Array<(
    { __typename?: 'Player' }
    & Pick<Player, 'id' | 'firstName' | 'lastName'>
    & { groups: Array<(
      { __typename?: 'PlayerGroupMembership' }
      & Pick<PlayerGroupMembership, 'groupId'>
    )> }
  )>> }
);

export type GetGameQueryVariables = Exact<{
  id: Scalars['UUID'];
}>;


export type GetGameQuery = (
  { __typename?: 'Query' }
  & { game: Maybe<(
    { __typename?: 'Game' }
    & UnpackedGame_GameFragment
  )> }
);

export type GetSoloModeOpponentBatterIdQueryVariables = Exact<{ [key: string]: never; }>;


export type GetSoloModeOpponentBatterIdQuery = (
  { __typename?: 'Query' }
  & { player: Maybe<(
    { __typename?: 'Player' }
    & Pick<Player, 'id'>
  )> }
);

export type ClaimPlayerAccountMutationVariables = Exact<{
  playerId: Scalars['UUID'];
  email: Scalars['String'];
}>;


export type ClaimPlayerAccountMutation = (
  { __typename?: 'Mutation' }
  & { initiatePlayerClaim: Maybe<(
    { __typename?: 'InitiatePlayerClaimPayload' }
    & { success: InitiatePlayerClaimPayload['boolean'] }
  )> }
);

export type ResetPasswordMutationVariables = Exact<{
  playerId: Scalars['UUID'];
  resetToken: Scalars['String'];
  newPassword: Scalars['String'];
}>;


export type ResetPasswordMutation = (
  { __typename?: 'Mutation' }
  & { resetPassword: Maybe<(
    { __typename?: 'ResetPasswordPayload' }
    & { success: ResetPasswordPayload['boolean'] }
  )> }
);

export type VerifyEmailMutationVariables = Exact<{
  email: Scalars['String'];
  code: Scalars['String'];
}>;


export type VerifyEmailMutation = (
  { __typename?: 'Mutation' }
  & { verifyEmail: Maybe<(
    { __typename?: 'VerifyEmailPayload' }
    & { success: VerifyEmailPayload['boolean'] }
  )> }
);

export type GetAllAvailableSeasonsQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetAllAvailableSeasonsQuery = (
  { __typename?: 'Query' }
  & { group: Maybe<(
    { __typename?: 'Group' }
    & Pick<Group, 'allSeasons'>
  )> }
);

export type GetBoxScoreQueryVariables = Exact<{
  gameId: Scalars['UUID'];
}>;


export type GetBoxScoreQuery = (
  { __typename?: 'Query' }
  & { game: Maybe<(
    { __typename?: 'Game' }
    & { boxScore: Maybe<Array<Maybe<(
      { __typename?: 'TraditionalStatLine' }
      & Pick<TraditionalStatLine, 'playerId' | 'plateAppearances' | 'atBats' | 'hits' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'runs' | 'rbi'>
    )>>> }
  )> }
);

export type GetCareerStatLeadersQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetCareerStatLeadersQuery = (
  { __typename?: 'Query' }
  & { hitsLeaders: Maybe<Array<(
    { __typename?: 'CareerStat' }
    & { value: CareerStat['hits'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, homerunsLeaders: Maybe<Array<(
    { __typename?: 'CareerStat' }
    & { value: CareerStat['homeruns'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, walksLeaders: Maybe<Array<(
    { __typename?: 'CareerStat' }
    & { value: CareerStat['walks'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, battingAverageLeaders: Maybe<Array<(
    { __typename?: 'CareerStatsQualifiedBatter' }
    & { value: CareerStatsQualifiedBatter['battingAverage'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, onBasePctLeaders: Maybe<Array<(
    { __typename?: 'CareerStatsQualifiedBatter' }
    & { value: CareerStatsQualifiedBatter['onBasePct'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, opsLeaders: Maybe<Array<(
    { __typename?: 'CareerStatsQualifiedBatter' }
    & { value: CareerStatsQualifiedBatter['ops'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>> }
);

export type GetCareerStatsQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetCareerStatsQuery = (
  { __typename?: 'Query' }
  & { careerStats: Maybe<Array<(
    { __typename?: 'CareerStat' }
    & Pick<CareerStat, 'seasons' | 'games' | 'plateAppearances' | 'atBats' | 'hits' | 'doubles' | 'triples' | 'homeruns' | 'xbh' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'runs' | 'rbi' | 'battingAverage' | 'onBasePct' | 'sluggingPct' | 'ops'>
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName' | 'playerImage'>
    )> }
  )>> }
);

export type GetGameDetailsQueryVariables = Exact<{
  gameId: Scalars['UUID'];
}>;


export type GetGameDetailsQuery = (
  { __typename?: 'Query' }
  & { game: Maybe<(
    { __typename?: 'Game' }
    & Pick<Game, 'id' | 'soloMode' | 'gameLength' | 'name' | 'score' | 'timeStarted' | 'timeEnded'>
    & { lineScore: Maybe<Array<Maybe<(
      { __typename?: 'LineScoreCell' }
      & Pick<LineScoreCell, 'inning' | 'halfInning' | 'runs' | 'hits'>
    )>>>, teams: Array<(
      { __typename?: 'Team' }
      & Pick<Team, 'name' | 'role' | 'winner' | 'soloModeOpponent'>
      & { finalLineup: Maybe<(
        { __typename?: 'Lineup' }
        & { lineupSpots: Array<(
          { __typename?: 'LineupSpot' }
          & Pick<LineupSpot, 'position'>
          & { player: Maybe<(
            { __typename?: 'Player' }
            & Pick<Player, 'id' | 'fullName'>
          )> }
        )> }
      )> }
    )>, boxScore: Maybe<Array<Maybe<(
      { __typename?: 'TraditionalStatLine' }
      & Pick<TraditionalStatLine, 'playerId' | 'plateAppearances' | 'atBats' | 'hits' | 'runs' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'rbi' | 'onBasePct' | 'ops'>
    )>>>, gameStates: Array<(
      { __typename?: 'GameState' }
      & Pick<GameState, 'id' | 'inning' | 'halfInning' | 'outs' | 'score'>
      & { playerByPlayerAtBat: Maybe<(
        { __typename?: 'Player' }
        & Pick<Player, 'id' | 'firstName' | 'lastName'>
      )>, lineups: Maybe<Array<Maybe<(
        { __typename?: 'Lineup' }
        & Pick<Lineup, 'id'>
        & { team: Maybe<(
          { __typename?: 'Team' }
          & Pick<Team, 'role'>
        )> }
      )>>>, baseRunners: Array<(
        { __typename?: 'BaseRunner' }
        & Pick<BaseRunner, 'base'>
        & { runner: Maybe<(
          { __typename?: 'Player' }
          & Pick<Player, 'id' | 'firstName' | 'lastName'>
        )> }
      )> }
    )>, gameEventRecords: Array<(
      { __typename?: 'GameEventRecord' }
      & Pick<GameEventRecord, 'eventIndex' | 'gameStateBeforeId' | 'gameStateAfterId'>
      & { gameEvent: Maybe<(
        { __typename?: 'GameEvent' }
        & { lineupChange: Maybe<(
          { __typename?: 'LineupChange' }
          & Pick<LineupChange, 'lineupBeforeId' | 'lineupAfterId'>
        )>, stolenBaseAttempt: Maybe<(
          { __typename?: 'StolenBaseAttempt' }
          & Pick<StolenBaseAttempt, 'success'>
          & { runner: Maybe<(
            { __typename?: 'Player' }
            & Pick<Player, 'id' | 'firstName' | 'lastName'>
          )> }
        )>, plateAppearance: Maybe<(
          { __typename?: 'PlateAppearance' }
          & Pick<PlateAppearance, 'type' | 'contact' | 'fieldedBy' | 'runsScoredOnSacFly'>
          & { outOnPlayRunners: Array<(
            { __typename?: 'OutOnPlayRunner' }
            & Pick<OutOnPlayRunner, 'runnerId'>
          )>, basepathMovements: Array<(
            { __typename?: 'BasepathMovement' }
            & Pick<BasepathMovement, 'runnerId' | 'endBase' | 'wasSafe'>
          )> }
        )> }
      )>, scoredRunners: Array<(
        { __typename?: 'ScoredRunner' }
        & Pick<ScoredRunner, 'battedIn'>
        & { runner: Maybe<(
          { __typename?: 'Player' }
          & Pick<Player, 'id' | 'firstName' | 'lastName'>
        )> }
      )>, gameStateBefore: Maybe<(
        { __typename?: 'GameState' }
        & Pick<GameState, 'inning' | 'halfInning'>
        & { playerByPlayerAtBat: Maybe<(
          { __typename?: 'Player' }
          & Pick<Player, 'id' | 'firstName' | 'lastName'>
        )> }
      )> }
    )> }
  )> }
);

export type GetGameSummariesQueryVariables = Exact<{
  groupId: Scalars['UUID'];
  season: Scalars['Int'];
}>;


export type GetGameSummariesQuery = (
  { __typename?: 'Query' }
  & { unifiedGames: Maybe<Array<(
    { __typename?: 'UnifiedGame' }
    & { game: Maybe<(
      { __typename?: 'Game' }
      & Pick<Game, 'id' | 'name' | 'timeStarted' | 'timeEnded' | 'score'>
    )>, legacyGame: Maybe<(
      { __typename?: 'LegacyGame' }
      & Pick<LegacyGame, 'gameId' | 'gameTitle' | 'gameDate' | 'gameStartTime' | 'gameEndTime' | 'score'>
    )> }
  )>> }
);

export type GetGameSummaryQueryVariables = Exact<{
  gameId: Scalars['UUID'];
}>;


export type GetGameSummaryQuery = (
  { __typename?: 'Query' }
  & { game: Maybe<(
    { __typename?: 'Game' }
    & Pick<Game, 'id'>
    & { lineScore: Maybe<Array<Maybe<(
      { __typename?: 'LineScoreCell' }
      & Pick<LineScoreCell, 'inning' | 'halfInning' | 'hits' | 'runs'>
    )>>>, teams: Array<(
      { __typename?: 'Team' }
      & Pick<Team, 'name' | 'role' | 'winner' | 'soloModeOpponent'>
    )> }
  )> }
);

export type GetGameTitleQueryVariables = Exact<{
  gameId: Scalars['UUID'];
}>;


export type GetGameTitleQuery = (
  { __typename?: 'Query' }
  & { game: Maybe<(
    { __typename?: 'Game' }
    & Pick<Game, 'id' | 'name' | 'timeStarted'>
  )> }
);

export type GetLatestGameSummaryQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetLatestGameSummaryQuery = (
  { __typename?: 'Query' }
  & { games: Maybe<Array<(
    { __typename?: 'Game' }
    & Pick<Game, 'id' | 'name' | 'timeStarted' | 'timeEnded' | 'score' | 'gameLength'>
    & { teams: Array<(
      { __typename?: 'Team' }
      & Pick<Team, 'role' | 'name' | 'winner'>
    )> }
  )>> }
);

export type GetLegacyGameDetailsQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetLegacyGameDetailsQuery = (
  { __typename?: 'Query' }
  & { legacyGame: Maybe<(
    { __typename?: 'LegacyGame' }
    & Pick<LegacyGame, 'gameId' | 'gameTitle' | 'gameDate' | 'gameStartTime' | 'gameEndTime'>
    & { team1: Maybe<(
      { __typename?: 'LegacyTeam' }
      & Pick<LegacyTeam, 'teamId' | 'teamName'>
    )>, team2: Maybe<(
      { __typename?: 'LegacyTeam' }
      & Pick<LegacyTeam, 'teamId' | 'teamName'>
    )>, battingLines: Array<(
      { __typename?: 'LegacyGameBattingLine' }
      & Pick<LegacyGameBattingLine, 'statLineId' | 'legacyTeamId' | 'plateAppearances' | 'atBats' | 'hits' | 'runs' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'rbi' | 'onBasePct' | 'ops'>
      & { player: Maybe<(
        { __typename?: 'Player' }
        & Pick<Player, 'id' | 'fullName'>
      )>, legacyPlayer: Maybe<(
        { __typename?: 'LegacyPlayer' }
        & Pick<LegacyPlayer, 'playerId' | 'playerName'>
      )> }
    )> }
  )> }
);

export type GetLegacyGameTitleQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type GetLegacyGameTitleQuery = (
  { __typename?: 'Query' }
  & { legacyGame: Maybe<(
    { __typename?: 'LegacyGame' }
    & Pick<LegacyGame, 'gameId' | 'gameTitle' | 'gameDate'>
  )> }
);

export type GetPlayerProfileQueryVariables = Exact<{
  playerId: Scalars['UUID'];
  groupId: Scalars['UUID'];
}>;


export type GetPlayerProfileQuery = (
  { __typename?: 'Query' }
  & { player: Maybe<(
    { __typename?: 'Player' }
    & Pick<Player, 'id' | 'fullName' | 'debut' | 'claimed'>
    & { groups: Array<(
      { __typename?: 'PlayerGroupMembership' }
      & Pick<PlayerGroupMembership, 'groupId'>
    )>, careerStats: Array<(
      { __typename?: 'CareerStat' }
      & Pick<CareerStat, 'games' | 'plateAppearances' | 'atBats' | 'hits' | 'runs' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'rbi' | 'battingAverage' | 'onBasePct' | 'sluggingPct' | 'ops'>
    )>, seasonStats: Array<(
      { __typename?: 'SeasonStat' }
      & Pick<SeasonStat, 'season' | 'games' | 'plateAppearances' | 'atBats' | 'hits' | 'runs' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'rbi' | 'battingAverage' | 'onBasePct' | 'sluggingPct' | 'ops'>
    )>, gameBattingLines: Array<(
      { __typename?: 'GameBattingLine' }
      & Pick<GameBattingLine, 'season' | 'plateAppearances' | 'atBats' | 'hits' | 'runs' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'rbi' | 'onBasePct'>
      & { game: Maybe<(
        { __typename?: 'Game' }
        & Pick<Game, 'groupId' | 'id' | 'name' | 'timeStarted' | 'timeEnded'>
      )> }
    )>, legacyGameBattingLines: Array<(
      { __typename?: 'LegacyGameBattingLine' }
      & Pick<LegacyGameBattingLine, 'season' | 'plateAppearances' | 'atBats' | 'hits' | 'runs' | 'doubles' | 'triples' | 'homeruns' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'rbi' | 'onBasePct'>
      & { legacyGame: Maybe<(
        { __typename?: 'LegacyGame' }
        & Pick<LegacyGame, 'gameId' | 'gameTitle' | 'gameDate' | 'gameStartTime' | 'gameEndTime'>
      )> }
    )> }
  )> }
);

export type GetPreviewLeadersQueryVariables = Exact<{
  groupId: Scalars['UUID'];
  currentSeason: Scalars['Int'];
}>;


export type GetPreviewLeadersQuery = (
  { __typename?: 'Query' }
  & { hits: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & { value: SeasonStat['hits'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, homeruns: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & { value: SeasonStat['homeruns'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, walks: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & { value: SeasonStat['walks'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, battingAverage: Maybe<Array<(
    { __typename?: 'SeasonStatsQualifiedBatter' }
    & { value: SeasonStatsQualifiedBatter['battingAverage'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, onBasePct: Maybe<Array<(
    { __typename?: 'SeasonStatsQualifiedBatter' }
    & { value: SeasonStatsQualifiedBatter['onBasePct'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>>, ops: Maybe<Array<(
    { __typename?: 'SeasonStatsQualifiedBatter' }
    & { value: SeasonStatsQualifiedBatter['ops'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>> }
);

export type GetPreviewStatsQueryVariables = Exact<{
  groupId: Scalars['UUID'];
  currentSeason: Scalars['Int'];
}>;


export type GetPreviewStatsQuery = (
  { __typename?: 'Query' }
  & { seasonStats: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & Pick<SeasonStat, 'games' | 'plateAppearances' | 'atBats' | 'hits' | 'doubles' | 'triples' | 'homeruns' | 'xbh' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'runs' | 'rbi' | 'battingAverage' | 'onBasePct' | 'sluggingPct' | 'ops'>
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )> }
  )>> }
);

export type GetSingleSeasonStatLeadersQueryVariables = Exact<{
  groupId: Scalars['UUID'];
}>;


export type GetSingleSeasonStatLeadersQuery = (
  { __typename?: 'Query' }
  & { hitsLeaders: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & Pick<SeasonStat, 'season'>
    & { value: SeasonStat['hits'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, homerunsLeaders: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & Pick<SeasonStat, 'season'>
    & { value: SeasonStat['homeruns'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, walksLeaders: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & Pick<SeasonStat, 'season'>
    & { value: SeasonStat['walks'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, battingAverageLeaders: Maybe<Array<(
    { __typename?: 'SeasonStatsAllTimeQualifiedBatter' }
    & Pick<SeasonStatsAllTimeQualifiedBatter, 'season'>
    & { value: SeasonStatsAllTimeQualifiedBatter['battingAverage'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, onBasePctLeaders: Maybe<Array<(
    { __typename?: 'SeasonStatsAllTimeQualifiedBatter' }
    & Pick<SeasonStatsAllTimeQualifiedBatter, 'season'>
    & { value: SeasonStatsAllTimeQualifiedBatter['onBasePct'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, opsLeaders: Maybe<Array<(
    { __typename?: 'SeasonStatsAllTimeQualifiedBatter' }
    & Pick<SeasonStatsAllTimeQualifiedBatter, 'season'>
    & { value: SeasonStatsAllTimeQualifiedBatter['ops'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>> }
);

export type GetStatLeadersForSeasonQueryVariables = Exact<{
  groupId: Scalars['UUID'];
  season: Scalars['Int'];
}>;


export type GetStatLeadersForSeasonQuery = (
  { __typename?: 'Query' }
  & { hitsLeaders: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & { value: SeasonStat['hits'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, homerunsLeaders: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & { value: SeasonStat['homeruns'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, walksLeaders: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & { value: SeasonStat['walks'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, battingAverageLeaders: Maybe<Array<(
    { __typename?: 'SeasonStatsQualifiedBatter' }
    & { value: SeasonStatsQualifiedBatter['battingAverage'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, onBasePctLeaders: Maybe<Array<(
    { __typename?: 'SeasonStatsQualifiedBatter' }
    & { value: SeasonStatsQualifiedBatter['onBasePct'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>>, opsLeaders: Maybe<Array<(
    { __typename?: 'SeasonStatsQualifiedBatter' }
    & { value: SeasonStatsQualifiedBatter['ops'] }
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName'>
    )> }
  )>> }
);

export type GetStatsForSeasonQueryVariables = Exact<{
  groupId: Scalars['UUID'];
  season: Scalars['Int'];
}>;


export type GetStatsForSeasonQuery = (
  { __typename?: 'Query' }
  & { season: Maybe<(
    { __typename?: 'Season' }
    & Pick<Season, 'totalGames'>
  )>, seasonStats: Maybe<Array<(
    { __typename?: 'SeasonStat' }
    & Pick<SeasonStat, 'games' | 'plateAppearances' | 'atBats' | 'hits' | 'doubles' | 'triples' | 'homeruns' | 'xbh' | 'walks' | 'strikeouts' | 'sacFlies' | 'gidp' | 'runs' | 'rbi' | 'battingAverage' | 'onBasePct' | 'sluggingPct' | 'ops'>
    & { player: Maybe<(
      { __typename?: 'Player' }
      & Pick<Player, 'id' | 'fullName'>
    )>, legacyPlayer: Maybe<(
      { __typename?: 'LegacyPlayer' }
      & Pick<LegacyPlayer, 'playerId' | 'playerName' | 'playerImage'>
    )> }
  )>> }
);

export type LoginMutationVariables = Exact<{
  email: Scalars['String'];
  password: Scalars['String'];
}>;


export type LoginMutation = (
  { __typename?: 'Mutation' }
  & { login: Maybe<(
    { __typename?: 'LoginPayload' }
    & Pick<LoginPayload, 'jwt'>
  )> }
);

export type GetCurrentUserQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCurrentUserQuery = (
  { __typename?: 'Query' }
  & { user: Maybe<(
    { __typename?: 'Player' }
    & Pick<Player, 'id' | 'fullName'>
  )> }
);

export type GetPermissionsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPermissionsQuery = (
  { __typename?: 'Query' }
  & Pick<Query, 'currentUserPermissions'>
  & { currentUserGroupPermissions: Maybe<Array<Maybe<(
    { __typename?: 'UserGroupPermission' }
    & Pick<UserGroupPermission, 'groupId' | 'permission'>
  )>>> }
);

export const GameEventRecord_GameStateFragmentDoc = gql`
    fragment GameEventRecord_GameState on GameState {
  inning
  halfInning
  outs
  playerAtBat
  score
  lineups {
    id
    team {
      role
    }
  }
  baseRunners {
    runnerId
    base
  }
}
    `;
export const UnpackedGame_GameFragmentDoc = gql`
    fragment UnpackedGame_Game on Game {
  id
  gameLength
  name
  score
  timeStarted
  timeEnded
  gameStates(orderBy: GAME_STATE_INDEX_ASC) {
    id
    inning
    halfInning
    outs
    playerAtBat
    score
    lineups {
      id
      team {
        role
      }
    }
    baseRunners {
      runnerId
      base
    }
  }
  gameEventRecords(orderBy: EVENT_INDEX_ASC) {
    eventIndex
    gameEvent {
      lineupChange {
        lineupBeforeId
        lineupAfterId
      }
      stolenBaseAttempt {
        runnerId
        success
      }
      plateAppearance {
        batterId
        type
        contact
        fieldedBy
        outOnPlayRunners {
          runnerId
        }
        basepathMovements {
          runnerId
          endBase
          wasSafe
        }
        runsScoredOnSacFly
      }
      soloModeOpponentInning {
        runsScored
      }
      atBatSkip {
        batterId
      }
      earlyGameEnd {
        reason
      }
    }
    scoredRunners {
      runnerId
      battedIn
    }
    gameStateBeforeId
    gameStateAfterId
  }
  teams {
    name
    role
    lineups {
      id
      lineupSpots(orderBy: BATTING_ORDER_ASC) {
        playerId
        position
      }
    }
    winner
    soloModeOpponent
  }
}
    `;
export const AddPlayerToGroupDocument = gql`
    mutation AddPlayerToGroup($playerId: UUID!, $groupId: UUID!) {
  updatePlayer(
    input: {id: $playerId, patch: {playerGroupMemberships: {create: [{groupId: $groupId}]}}}
  ) {
    player {
      id
      firstName
      lastName
      groups: playerGroupMemberships {
        groupId
      }
    }
  }
}
    `;
export type AddPlayerToGroupMutationFn = Apollo.MutationFunction<AddPlayerToGroupMutation, AddPlayerToGroupMutationVariables>;

/**
 * __useAddPlayerToGroupMutation__
 *
 * To run a mutation, you first call `useAddPlayerToGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddPlayerToGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addPlayerToGroupMutation, { data, loading, error }] = useAddPlayerToGroupMutation({
 *   variables: {
 *      playerId: // value for 'playerId'
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useAddPlayerToGroupMutation(baseOptions?: Apollo.MutationHookOptions<AddPlayerToGroupMutation, AddPlayerToGroupMutationVariables>) {
        return Apollo.useMutation<AddPlayerToGroupMutation, AddPlayerToGroupMutationVariables>(AddPlayerToGroupDocument, baseOptions);
      }
export type AddPlayerToGroupMutationHookResult = ReturnType<typeof useAddPlayerToGroupMutation>;
export type AddPlayerToGroupMutationResult = Apollo.MutationResult<AddPlayerToGroupMutation>;
export type AddPlayerToGroupMutationOptions = Apollo.BaseMutationOptions<AddPlayerToGroupMutation, AddPlayerToGroupMutationVariables>;
export const CreateGameDocument = gql`
    mutation CreateGame($input: CreateGameInput!) {
  createGame(input: $input) {
    game {
      ...UnpackedGame_Game
    }
  }
}
    ${UnpackedGame_GameFragmentDoc}`;
export type CreateGameMutationFn = Apollo.MutationFunction<CreateGameMutation, CreateGameMutationVariables>;

/**
 * __useCreateGameMutation__
 *
 * To run a mutation, you first call `useCreateGameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateGameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createGameMutation, { data, loading, error }] = useCreateGameMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateGameMutation(baseOptions?: Apollo.MutationHookOptions<CreateGameMutation, CreateGameMutationVariables>) {
        return Apollo.useMutation<CreateGameMutation, CreateGameMutationVariables>(CreateGameDocument, baseOptions);
      }
export type CreateGameMutationHookResult = ReturnType<typeof useCreateGameMutation>;
export type CreateGameMutationResult = Apollo.MutationResult<CreateGameMutation>;
export type CreateGameMutationOptions = Apollo.BaseMutationOptions<CreateGameMutation, CreateGameMutationVariables>;
export const CreatePlayerDocument = gql`
    mutation CreatePlayer($input: CreatePlayerInput!) {
  createPlayer(input: $input) {
    player {
      id
      firstName
      lastName
      groups: playerGroupMemberships {
        groupId
      }
    }
  }
}
    `;
export type CreatePlayerMutationFn = Apollo.MutationFunction<CreatePlayerMutation, CreatePlayerMutationVariables>;

/**
 * __useCreatePlayerMutation__
 *
 * To run a mutation, you first call `useCreatePlayerMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePlayerMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPlayerMutation, { data, loading, error }] = useCreatePlayerMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePlayerMutation(baseOptions?: Apollo.MutationHookOptions<CreatePlayerMutation, CreatePlayerMutationVariables>) {
        return Apollo.useMutation<CreatePlayerMutation, CreatePlayerMutationVariables>(CreatePlayerDocument, baseOptions);
      }
export type CreatePlayerMutationHookResult = ReturnType<typeof useCreatePlayerMutation>;
export type CreatePlayerMutationResult = Apollo.MutationResult<CreatePlayerMutation>;
export type CreatePlayerMutationOptions = Apollo.BaseMutationOptions<CreatePlayerMutation, CreatePlayerMutationVariables>;
export const DumpReduxStoreDocument = gql`
    mutation DumpReduxStore($storeJson: JSON!) {
  createReduxDump(input: {reduxDump: {storeData: $storeJson}}) {
    reduxDump {
      id
    }
  }
}
    `;
export type DumpReduxStoreMutationFn = Apollo.MutationFunction<DumpReduxStoreMutation, DumpReduxStoreMutationVariables>;

/**
 * __useDumpReduxStoreMutation__
 *
 * To run a mutation, you first call `useDumpReduxStoreMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDumpReduxStoreMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [dumpReduxStoreMutation, { data, loading, error }] = useDumpReduxStoreMutation({
 *   variables: {
 *      storeJson: // value for 'storeJson'
 *   },
 * });
 */
export function useDumpReduxStoreMutation(baseOptions?: Apollo.MutationHookOptions<DumpReduxStoreMutation, DumpReduxStoreMutationVariables>) {
        return Apollo.useMutation<DumpReduxStoreMutation, DumpReduxStoreMutationVariables>(DumpReduxStoreDocument, baseOptions);
      }
export type DumpReduxStoreMutationHookResult = ReturnType<typeof useDumpReduxStoreMutation>;
export type DumpReduxStoreMutationResult = Apollo.MutationResult<DumpReduxStoreMutation>;
export type DumpReduxStoreMutationOptions = Apollo.BaseMutationOptions<DumpReduxStoreMutation, DumpReduxStoreMutationVariables>;
export const GetAllGamesDocument = gql`
    query GetAllGames($groupId: UUID!) {
  games(condition: {groupId: $groupId}) {
    ...UnpackedGame_Game
  }
}
    ${UnpackedGame_GameFragmentDoc}`;

/**
 * __useGetAllGamesQuery__
 *
 * To run a query within a React component, call `useGetAllGamesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllGamesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllGamesQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetAllGamesQuery(baseOptions: Apollo.QueryHookOptions<GetAllGamesQuery, GetAllGamesQueryVariables>) {
        return Apollo.useQuery<GetAllGamesQuery, GetAllGamesQueryVariables>(GetAllGamesDocument, baseOptions);
      }
export function useGetAllGamesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllGamesQuery, GetAllGamesQueryVariables>) {
          return Apollo.useLazyQuery<GetAllGamesQuery, GetAllGamesQueryVariables>(GetAllGamesDocument, baseOptions);
        }
export type GetAllGamesQueryHookResult = ReturnType<typeof useGetAllGamesQuery>;
export type GetAllGamesLazyQueryHookResult = ReturnType<typeof useGetAllGamesLazyQuery>;
export type GetAllGamesQueryResult = Apollo.QueryResult<GetAllGamesQuery, GetAllGamesQueryVariables>;
export const GetAllGroupsDocument = gql`
    query GetAllGroups {
  groups {
    id
    name
    soloMode
    urlSlug
    allowSkippingAtBats
    allowSteals
  }
}
    `;

/**
 * __useGetAllGroupsQuery__
 *
 * To run a query within a React component, call `useGetAllGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllGroupsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllGroupsQuery(baseOptions?: Apollo.QueryHookOptions<GetAllGroupsQuery, GetAllGroupsQueryVariables>) {
        return Apollo.useQuery<GetAllGroupsQuery, GetAllGroupsQueryVariables>(GetAllGroupsDocument, baseOptions);
      }
export function useGetAllGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllGroupsQuery, GetAllGroupsQueryVariables>) {
          return Apollo.useLazyQuery<GetAllGroupsQuery, GetAllGroupsQueryVariables>(GetAllGroupsDocument, baseOptions);
        }
export type GetAllGroupsQueryHookResult = ReturnType<typeof useGetAllGroupsQuery>;
export type GetAllGroupsLazyQueryHookResult = ReturnType<typeof useGetAllGroupsLazyQuery>;
export type GetAllGroupsQueryResult = Apollo.QueryResult<GetAllGroupsQuery, GetAllGroupsQueryVariables>;
export const GetAllPlayersDocument = gql`
    query GetAllPlayers {
  players {
    id
    firstName
    lastName
    groups: playerGroupMemberships {
      groupId
    }
  }
}
    `;

/**
 * __useGetAllPlayersQuery__
 *
 * To run a query within a React component, call `useGetAllPlayersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllPlayersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllPlayersQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAllPlayersQuery(baseOptions?: Apollo.QueryHookOptions<GetAllPlayersQuery, GetAllPlayersQueryVariables>) {
        return Apollo.useQuery<GetAllPlayersQuery, GetAllPlayersQueryVariables>(GetAllPlayersDocument, baseOptions);
      }
export function useGetAllPlayersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllPlayersQuery, GetAllPlayersQueryVariables>) {
          return Apollo.useLazyQuery<GetAllPlayersQuery, GetAllPlayersQueryVariables>(GetAllPlayersDocument, baseOptions);
        }
export type GetAllPlayersQueryHookResult = ReturnType<typeof useGetAllPlayersQuery>;
export type GetAllPlayersLazyQueryHookResult = ReturnType<typeof useGetAllPlayersLazyQuery>;
export type GetAllPlayersQueryResult = Apollo.QueryResult<GetAllPlayersQuery, GetAllPlayersQueryVariables>;
export const GetGameDocument = gql`
    query GetGame($id: UUID!) {
  game(id: $id) {
    ...UnpackedGame_Game
  }
}
    ${UnpackedGame_GameFragmentDoc}`;

/**
 * __useGetGameQuery__
 *
 * To run a query within a React component, call `useGetGameQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetGameQuery(baseOptions: Apollo.QueryHookOptions<GetGameQuery, GetGameQueryVariables>) {
        return Apollo.useQuery<GetGameQuery, GetGameQueryVariables>(GetGameDocument, baseOptions);
      }
export function useGetGameLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGameQuery, GetGameQueryVariables>) {
          return Apollo.useLazyQuery<GetGameQuery, GetGameQueryVariables>(GetGameDocument, baseOptions);
        }
export type GetGameQueryHookResult = ReturnType<typeof useGetGameQuery>;
export type GetGameLazyQueryHookResult = ReturnType<typeof useGetGameLazyQuery>;
export type GetGameQueryResult = Apollo.QueryResult<GetGameQuery, GetGameQueryVariables>;
export const GetSoloModeOpponentBatterIdDocument = gql`
    query GetSoloModeOpponentBatterId {
  player: playerByFirstNameAndLastName(firstName: "Opponent", lastName: "Batter") {
    id
  }
}
    `;

/**
 * __useGetSoloModeOpponentBatterIdQuery__
 *
 * To run a query within a React component, call `useGetSoloModeOpponentBatterIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSoloModeOpponentBatterIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSoloModeOpponentBatterIdQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetSoloModeOpponentBatterIdQuery(baseOptions?: Apollo.QueryHookOptions<GetSoloModeOpponentBatterIdQuery, GetSoloModeOpponentBatterIdQueryVariables>) {
        return Apollo.useQuery<GetSoloModeOpponentBatterIdQuery, GetSoloModeOpponentBatterIdQueryVariables>(GetSoloModeOpponentBatterIdDocument, baseOptions);
      }
export function useGetSoloModeOpponentBatterIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSoloModeOpponentBatterIdQuery, GetSoloModeOpponentBatterIdQueryVariables>) {
          return Apollo.useLazyQuery<GetSoloModeOpponentBatterIdQuery, GetSoloModeOpponentBatterIdQueryVariables>(GetSoloModeOpponentBatterIdDocument, baseOptions);
        }
export type GetSoloModeOpponentBatterIdQueryHookResult = ReturnType<typeof useGetSoloModeOpponentBatterIdQuery>;
export type GetSoloModeOpponentBatterIdLazyQueryHookResult = ReturnType<typeof useGetSoloModeOpponentBatterIdLazyQuery>;
export type GetSoloModeOpponentBatterIdQueryResult = Apollo.QueryResult<GetSoloModeOpponentBatterIdQuery, GetSoloModeOpponentBatterIdQueryVariables>;
export const ClaimPlayerAccountDocument = gql`
    mutation ClaimPlayerAccount($playerId: UUID!, $email: String!) {
  initiatePlayerClaim(input: {playerId: $playerId, email: $email}) {
    success: boolean
  }
}
    `;
export type ClaimPlayerAccountMutationFn = Apollo.MutationFunction<ClaimPlayerAccountMutation, ClaimPlayerAccountMutationVariables>;

/**
 * __useClaimPlayerAccountMutation__
 *
 * To run a mutation, you first call `useClaimPlayerAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useClaimPlayerAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [claimPlayerAccountMutation, { data, loading, error }] = useClaimPlayerAccountMutation({
 *   variables: {
 *      playerId: // value for 'playerId'
 *      email: // value for 'email'
 *   },
 * });
 */
export function useClaimPlayerAccountMutation(baseOptions?: Apollo.MutationHookOptions<ClaimPlayerAccountMutation, ClaimPlayerAccountMutationVariables>) {
        return Apollo.useMutation<ClaimPlayerAccountMutation, ClaimPlayerAccountMutationVariables>(ClaimPlayerAccountDocument, baseOptions);
      }
export type ClaimPlayerAccountMutationHookResult = ReturnType<typeof useClaimPlayerAccountMutation>;
export type ClaimPlayerAccountMutationResult = Apollo.MutationResult<ClaimPlayerAccountMutation>;
export type ClaimPlayerAccountMutationOptions = Apollo.BaseMutationOptions<ClaimPlayerAccountMutation, ClaimPlayerAccountMutationVariables>;
export const ResetPasswordDocument = gql`
    mutation ResetPassword($playerId: UUID!, $resetToken: String!, $newPassword: String!) {
  resetPassword(
    input: {playerId: $playerId, resetToken: $resetToken, newPassword: $newPassword}
  ) {
    success: boolean
  }
}
    `;
export type ResetPasswordMutationFn = Apollo.MutationFunction<ResetPasswordMutation, ResetPasswordMutationVariables>;

/**
 * __useResetPasswordMutation__
 *
 * To run a mutation, you first call `useResetPasswordMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useResetPasswordMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [resetPasswordMutation, { data, loading, error }] = useResetPasswordMutation({
 *   variables: {
 *      playerId: // value for 'playerId'
 *      resetToken: // value for 'resetToken'
 *      newPassword: // value for 'newPassword'
 *   },
 * });
 */
export function useResetPasswordMutation(baseOptions?: Apollo.MutationHookOptions<ResetPasswordMutation, ResetPasswordMutationVariables>) {
        return Apollo.useMutation<ResetPasswordMutation, ResetPasswordMutationVariables>(ResetPasswordDocument, baseOptions);
      }
export type ResetPasswordMutationHookResult = ReturnType<typeof useResetPasswordMutation>;
export type ResetPasswordMutationResult = Apollo.MutationResult<ResetPasswordMutation>;
export type ResetPasswordMutationOptions = Apollo.BaseMutationOptions<ResetPasswordMutation, ResetPasswordMutationVariables>;
export const VerifyEmailDocument = gql`
    mutation VerifyEmail($email: String!, $code: String!) {
  verifyEmail(input: {email: $email, code: $code}) {
    success: boolean
  }
}
    `;
export type VerifyEmailMutationFn = Apollo.MutationFunction<VerifyEmailMutation, VerifyEmailMutationVariables>;

/**
 * __useVerifyEmailMutation__
 *
 * To run a mutation, you first call `useVerifyEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useVerifyEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [verifyEmailMutation, { data, loading, error }] = useVerifyEmailMutation({
 *   variables: {
 *      email: // value for 'email'
 *      code: // value for 'code'
 *   },
 * });
 */
export function useVerifyEmailMutation(baseOptions?: Apollo.MutationHookOptions<VerifyEmailMutation, VerifyEmailMutationVariables>) {
        return Apollo.useMutation<VerifyEmailMutation, VerifyEmailMutationVariables>(VerifyEmailDocument, baseOptions);
      }
export type VerifyEmailMutationHookResult = ReturnType<typeof useVerifyEmailMutation>;
export type VerifyEmailMutationResult = Apollo.MutationResult<VerifyEmailMutation>;
export type VerifyEmailMutationOptions = Apollo.BaseMutationOptions<VerifyEmailMutation, VerifyEmailMutationVariables>;
export const GetAllAvailableSeasonsDocument = gql`
    query GetAllAvailableSeasons($groupId: UUID!) {
  group(id: $groupId) {
    allSeasons
  }
}
    `;

/**
 * __useGetAllAvailableSeasonsQuery__
 *
 * To run a query within a React component, call `useGetAllAvailableSeasonsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllAvailableSeasonsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllAvailableSeasonsQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetAllAvailableSeasonsQuery(baseOptions: Apollo.QueryHookOptions<GetAllAvailableSeasonsQuery, GetAllAvailableSeasonsQueryVariables>) {
        return Apollo.useQuery<GetAllAvailableSeasonsQuery, GetAllAvailableSeasonsQueryVariables>(GetAllAvailableSeasonsDocument, baseOptions);
      }
export function useGetAllAvailableSeasonsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllAvailableSeasonsQuery, GetAllAvailableSeasonsQueryVariables>) {
          return Apollo.useLazyQuery<GetAllAvailableSeasonsQuery, GetAllAvailableSeasonsQueryVariables>(GetAllAvailableSeasonsDocument, baseOptions);
        }
export type GetAllAvailableSeasonsQueryHookResult = ReturnType<typeof useGetAllAvailableSeasonsQuery>;
export type GetAllAvailableSeasonsLazyQueryHookResult = ReturnType<typeof useGetAllAvailableSeasonsLazyQuery>;
export type GetAllAvailableSeasonsQueryResult = Apollo.QueryResult<GetAllAvailableSeasonsQuery, GetAllAvailableSeasonsQueryVariables>;
export const GetBoxScoreDocument = gql`
    query GetBoxScore($gameId: UUID!) {
  game(id: $gameId) {
    boxScore {
      playerId
      plateAppearances
      atBats
      hits
      doubles
      triples
      homeruns
      walks
      strikeouts
      sacFlies
      gidp
      runs
      rbi
    }
  }
}
    `;

/**
 * __useGetBoxScoreQuery__
 *
 * To run a query within a React component, call `useGetBoxScoreQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBoxScoreQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBoxScoreQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useGetBoxScoreQuery(baseOptions: Apollo.QueryHookOptions<GetBoxScoreQuery, GetBoxScoreQueryVariables>) {
        return Apollo.useQuery<GetBoxScoreQuery, GetBoxScoreQueryVariables>(GetBoxScoreDocument, baseOptions);
      }
export function useGetBoxScoreLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBoxScoreQuery, GetBoxScoreQueryVariables>) {
          return Apollo.useLazyQuery<GetBoxScoreQuery, GetBoxScoreQueryVariables>(GetBoxScoreDocument, baseOptions);
        }
export type GetBoxScoreQueryHookResult = ReturnType<typeof useGetBoxScoreQuery>;
export type GetBoxScoreLazyQueryHookResult = ReturnType<typeof useGetBoxScoreLazyQuery>;
export type GetBoxScoreQueryResult = Apollo.QueryResult<GetBoxScoreQuery, GetBoxScoreQueryVariables>;
export const GetCareerStatLeadersDocument = gql`
    query GetCareerStatLeaders($groupId: UUID!) {
  hitsLeaders: careerStats(
    condition: {groupId: $groupId}
    orderBy: HITS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: hits
  }
  homerunsLeaders: careerStats(
    condition: {groupId: $groupId}
    orderBy: HOMERUNS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: homeruns
  }
  walksLeaders: careerStats(
    condition: {groupId: $groupId}
    orderBy: WALKS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: walks
  }
  battingAverageLeaders: careerStatsQualifiedBatters(
    condition: {groupId: $groupId}
    orderBy: BATTING_AVERAGE_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: battingAverage
  }
  onBasePctLeaders: careerStatsQualifiedBatters(
    condition: {groupId: $groupId}
    orderBy: ON_BASE_PCT_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: onBasePct
  }
  opsLeaders: careerStatsQualifiedBatters(
    condition: {groupId: $groupId}
    orderBy: OPS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: ops
  }
}
    `;

/**
 * __useGetCareerStatLeadersQuery__
 *
 * To run a query within a React component, call `useGetCareerStatLeadersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCareerStatLeadersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCareerStatLeadersQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetCareerStatLeadersQuery(baseOptions: Apollo.QueryHookOptions<GetCareerStatLeadersQuery, GetCareerStatLeadersQueryVariables>) {
        return Apollo.useQuery<GetCareerStatLeadersQuery, GetCareerStatLeadersQueryVariables>(GetCareerStatLeadersDocument, baseOptions);
      }
export function useGetCareerStatLeadersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCareerStatLeadersQuery, GetCareerStatLeadersQueryVariables>) {
          return Apollo.useLazyQuery<GetCareerStatLeadersQuery, GetCareerStatLeadersQueryVariables>(GetCareerStatLeadersDocument, baseOptions);
        }
export type GetCareerStatLeadersQueryHookResult = ReturnType<typeof useGetCareerStatLeadersQuery>;
export type GetCareerStatLeadersLazyQueryHookResult = ReturnType<typeof useGetCareerStatLeadersLazyQuery>;
export type GetCareerStatLeadersQueryResult = Apollo.QueryResult<GetCareerStatLeadersQuery, GetCareerStatLeadersQueryVariables>;
export const GetCareerStatsDocument = gql`
    query GetCareerStats($groupId: UUID!) {
  careerStats(condition: {groupId: $groupId}, orderBy: GAMES_DESC) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
      playerImage
    }
    seasons
    games
    plateAppearances
    atBats
    hits
    doubles
    triples
    homeruns
    xbh
    walks
    strikeouts
    sacFlies
    gidp
    runs
    rbi
    battingAverage
    onBasePct
    sluggingPct
    ops
  }
}
    `;

/**
 * __useGetCareerStatsQuery__
 *
 * To run a query within a React component, call `useGetCareerStatsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCareerStatsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCareerStatsQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetCareerStatsQuery(baseOptions: Apollo.QueryHookOptions<GetCareerStatsQuery, GetCareerStatsQueryVariables>) {
        return Apollo.useQuery<GetCareerStatsQuery, GetCareerStatsQueryVariables>(GetCareerStatsDocument, baseOptions);
      }
export function useGetCareerStatsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCareerStatsQuery, GetCareerStatsQueryVariables>) {
          return Apollo.useLazyQuery<GetCareerStatsQuery, GetCareerStatsQueryVariables>(GetCareerStatsDocument, baseOptions);
        }
export type GetCareerStatsQueryHookResult = ReturnType<typeof useGetCareerStatsQuery>;
export type GetCareerStatsLazyQueryHookResult = ReturnType<typeof useGetCareerStatsLazyQuery>;
export type GetCareerStatsQueryResult = Apollo.QueryResult<GetCareerStatsQuery, GetCareerStatsQueryVariables>;
export const GetGameDetailsDocument = gql`
    query GetGameDetails($gameId: UUID!) {
  game(id: $gameId) {
    id
    soloMode
    gameLength
    name
    score
    timeStarted
    timeEnded
    lineScore {
      inning
      halfInning
      runs
      hits
    }
    teams {
      name
      role
      winner
      soloModeOpponent
      finalLineup {
        lineupSpots(orderBy: BATTING_ORDER_ASC) {
          player {
            id
            fullName
          }
          position
        }
      }
    }
    boxScore {
      playerId
      plateAppearances
      atBats
      hits
      runs
      doubles
      triples
      homeruns
      walks
      strikeouts
      sacFlies
      gidp
      rbi
      onBasePct
      ops
    }
    gameStates(orderBy: GAME_STATE_INDEX_ASC) {
      id
      inning
      halfInning
      outs
      playerByPlayerAtBat {
        id
        firstName
        lastName
      }
      score
      lineups {
        id
        team {
          role
        }
      }
      baseRunners {
        runner {
          id
          firstName
          lastName
        }
        base
      }
    }
    gameEventRecords(orderBy: EVENT_INDEX_ASC) {
      eventIndex
      gameEvent {
        lineupChange {
          lineupBeforeId
          lineupAfterId
        }
        stolenBaseAttempt {
          runner {
            id
            firstName
            lastName
          }
          success
        }
        plateAppearance {
          type
          contact
          fieldedBy
          outOnPlayRunners {
            runnerId
          }
          basepathMovements {
            runnerId
            endBase
            wasSafe
          }
          runsScoredOnSacFly
        }
      }
      scoredRunners {
        runner {
          id
          firstName
          lastName
        }
        battedIn
      }
      gameStateBeforeId
      gameStateBefore {
        inning
        halfInning
        playerByPlayerAtBat {
          id
          firstName
          lastName
        }
      }
      gameStateAfterId
    }
  }
}
    `;

/**
 * __useGetGameDetailsQuery__
 *
 * To run a query within a React component, call `useGetGameDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameDetailsQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useGetGameDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetGameDetailsQuery, GetGameDetailsQueryVariables>) {
        return Apollo.useQuery<GetGameDetailsQuery, GetGameDetailsQueryVariables>(GetGameDetailsDocument, baseOptions);
      }
export function useGetGameDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGameDetailsQuery, GetGameDetailsQueryVariables>) {
          return Apollo.useLazyQuery<GetGameDetailsQuery, GetGameDetailsQueryVariables>(GetGameDetailsDocument, baseOptions);
        }
export type GetGameDetailsQueryHookResult = ReturnType<typeof useGetGameDetailsQuery>;
export type GetGameDetailsLazyQueryHookResult = ReturnType<typeof useGetGameDetailsLazyQuery>;
export type GetGameDetailsQueryResult = Apollo.QueryResult<GetGameDetailsQuery, GetGameDetailsQueryVariables>;
export const GetGameSummariesDocument = gql`
    query GetGameSummaries($groupId: UUID!, $season: Int!) {
  unifiedGames(condition: {groupId: $groupId, season: $season}) {
    game {
      id
      name
      timeStarted
      timeEnded
      score
    }
    legacyGame {
      gameId
      gameTitle
      gameDate
      gameStartTime
      gameEndTime
      score
    }
  }
}
    `;

/**
 * __useGetGameSummariesQuery__
 *
 * To run a query within a React component, call `useGetGameSummariesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameSummariesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameSummariesQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      season: // value for 'season'
 *   },
 * });
 */
export function useGetGameSummariesQuery(baseOptions: Apollo.QueryHookOptions<GetGameSummariesQuery, GetGameSummariesQueryVariables>) {
        return Apollo.useQuery<GetGameSummariesQuery, GetGameSummariesQueryVariables>(GetGameSummariesDocument, baseOptions);
      }
export function useGetGameSummariesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGameSummariesQuery, GetGameSummariesQueryVariables>) {
          return Apollo.useLazyQuery<GetGameSummariesQuery, GetGameSummariesQueryVariables>(GetGameSummariesDocument, baseOptions);
        }
export type GetGameSummariesQueryHookResult = ReturnType<typeof useGetGameSummariesQuery>;
export type GetGameSummariesLazyQueryHookResult = ReturnType<typeof useGetGameSummariesLazyQuery>;
export type GetGameSummariesQueryResult = Apollo.QueryResult<GetGameSummariesQuery, GetGameSummariesQueryVariables>;
export const GetGameSummaryDocument = gql`
    query GetGameSummary($gameId: UUID!) {
  game(id: $gameId) {
    id
    lineScore {
      inning
      halfInning
      hits
      runs
    }
    teams {
      name
      role
      winner
      soloModeOpponent
    }
  }
}
    `;

/**
 * __useGetGameSummaryQuery__
 *
 * To run a query within a React component, call `useGetGameSummaryQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameSummaryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameSummaryQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useGetGameSummaryQuery(baseOptions: Apollo.QueryHookOptions<GetGameSummaryQuery, GetGameSummaryQueryVariables>) {
        return Apollo.useQuery<GetGameSummaryQuery, GetGameSummaryQueryVariables>(GetGameSummaryDocument, baseOptions);
      }
export function useGetGameSummaryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGameSummaryQuery, GetGameSummaryQueryVariables>) {
          return Apollo.useLazyQuery<GetGameSummaryQuery, GetGameSummaryQueryVariables>(GetGameSummaryDocument, baseOptions);
        }
export type GetGameSummaryQueryHookResult = ReturnType<typeof useGetGameSummaryQuery>;
export type GetGameSummaryLazyQueryHookResult = ReturnType<typeof useGetGameSummaryLazyQuery>;
export type GetGameSummaryQueryResult = Apollo.QueryResult<GetGameSummaryQuery, GetGameSummaryQueryVariables>;
export const GetGameTitleDocument = gql`
    query GetGameTitle($gameId: UUID!) {
  game(id: $gameId) {
    id
    name
    timeStarted
  }
}
    `;

/**
 * __useGetGameTitleQuery__
 *
 * To run a query within a React component, call `useGetGameTitleQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetGameTitleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetGameTitleQuery({
 *   variables: {
 *      gameId: // value for 'gameId'
 *   },
 * });
 */
export function useGetGameTitleQuery(baseOptions: Apollo.QueryHookOptions<GetGameTitleQuery, GetGameTitleQueryVariables>) {
        return Apollo.useQuery<GetGameTitleQuery, GetGameTitleQueryVariables>(GetGameTitleDocument, baseOptions);
      }
export function useGetGameTitleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetGameTitleQuery, GetGameTitleQueryVariables>) {
          return Apollo.useLazyQuery<GetGameTitleQuery, GetGameTitleQueryVariables>(GetGameTitleDocument, baseOptions);
        }
export type GetGameTitleQueryHookResult = ReturnType<typeof useGetGameTitleQuery>;
export type GetGameTitleLazyQueryHookResult = ReturnType<typeof useGetGameTitleLazyQuery>;
export type GetGameTitleQueryResult = Apollo.QueryResult<GetGameTitleQuery, GetGameTitleQueryVariables>;
export const GetLatestGameSummaryDocument = gql`
    query GetLatestGameSummary($groupId: UUID!) {
  games(orderBy: TIME_STARTED_DESC, first: 1, condition: {groupId: $groupId}) {
    id
    name
    timeStarted
    timeEnded
    score
    gameLength
    teams {
      role
      name
      winner
    }
  }
}
    `;

/**
 * __useGetLatestGameSummaryQuery__
 *
 * To run a query within a React component, call `useGetLatestGameSummaryQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLatestGameSummaryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLatestGameSummaryQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetLatestGameSummaryQuery(baseOptions: Apollo.QueryHookOptions<GetLatestGameSummaryQuery, GetLatestGameSummaryQueryVariables>) {
        return Apollo.useQuery<GetLatestGameSummaryQuery, GetLatestGameSummaryQueryVariables>(GetLatestGameSummaryDocument, baseOptions);
      }
export function useGetLatestGameSummaryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLatestGameSummaryQuery, GetLatestGameSummaryQueryVariables>) {
          return Apollo.useLazyQuery<GetLatestGameSummaryQuery, GetLatestGameSummaryQueryVariables>(GetLatestGameSummaryDocument, baseOptions);
        }
export type GetLatestGameSummaryQueryHookResult = ReturnType<typeof useGetLatestGameSummaryQuery>;
export type GetLatestGameSummaryLazyQueryHookResult = ReturnType<typeof useGetLatestGameSummaryLazyQuery>;
export type GetLatestGameSummaryQueryResult = Apollo.QueryResult<GetLatestGameSummaryQuery, GetLatestGameSummaryQueryVariables>;
export const GetLegacyGameDetailsDocument = gql`
    query GetLegacyGameDetails($id: Int!) {
  legacyGame(gameId: $id) {
    gameId
    gameTitle
    gameDate
    gameStartTime
    gameEndTime
    team1: legacyTeamByGameTeamId1 {
      teamId
      teamName
    }
    team2: legacyTeamByGameTeamId2 {
      teamId
      teamName
    }
    battingLines: legacyGameBattingLines {
      player {
        id
        fullName
      }
      legacyPlayer {
        playerId
        playerName
      }
      statLineId
      legacyTeamId
      plateAppearances
      atBats
      hits
      runs
      doubles
      triples
      homeruns
      walks
      strikeouts
      sacFlies
      rbi
      onBasePct
      ops
    }
  }
}
    `;

/**
 * __useGetLegacyGameDetailsQuery__
 *
 * To run a query within a React component, call `useGetLegacyGameDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLegacyGameDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLegacyGameDetailsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetLegacyGameDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetLegacyGameDetailsQuery, GetLegacyGameDetailsQueryVariables>) {
        return Apollo.useQuery<GetLegacyGameDetailsQuery, GetLegacyGameDetailsQueryVariables>(GetLegacyGameDetailsDocument, baseOptions);
      }
export function useGetLegacyGameDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLegacyGameDetailsQuery, GetLegacyGameDetailsQueryVariables>) {
          return Apollo.useLazyQuery<GetLegacyGameDetailsQuery, GetLegacyGameDetailsQueryVariables>(GetLegacyGameDetailsDocument, baseOptions);
        }
export type GetLegacyGameDetailsQueryHookResult = ReturnType<typeof useGetLegacyGameDetailsQuery>;
export type GetLegacyGameDetailsLazyQueryHookResult = ReturnType<typeof useGetLegacyGameDetailsLazyQuery>;
export type GetLegacyGameDetailsQueryResult = Apollo.QueryResult<GetLegacyGameDetailsQuery, GetLegacyGameDetailsQueryVariables>;
export const GetLegacyGameTitleDocument = gql`
    query GetLegacyGameTitle($id: Int!) {
  legacyGame(gameId: $id) {
    gameId
    gameTitle
    gameDate
  }
}
    `;

/**
 * __useGetLegacyGameTitleQuery__
 *
 * To run a query within a React component, call `useGetLegacyGameTitleQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetLegacyGameTitleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetLegacyGameTitleQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetLegacyGameTitleQuery(baseOptions: Apollo.QueryHookOptions<GetLegacyGameTitleQuery, GetLegacyGameTitleQueryVariables>) {
        return Apollo.useQuery<GetLegacyGameTitleQuery, GetLegacyGameTitleQueryVariables>(GetLegacyGameTitleDocument, baseOptions);
      }
export function useGetLegacyGameTitleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetLegacyGameTitleQuery, GetLegacyGameTitleQueryVariables>) {
          return Apollo.useLazyQuery<GetLegacyGameTitleQuery, GetLegacyGameTitleQueryVariables>(GetLegacyGameTitleDocument, baseOptions);
        }
export type GetLegacyGameTitleQueryHookResult = ReturnType<typeof useGetLegacyGameTitleQuery>;
export type GetLegacyGameTitleLazyQueryHookResult = ReturnType<typeof useGetLegacyGameTitleLazyQuery>;
export type GetLegacyGameTitleQueryResult = Apollo.QueryResult<GetLegacyGameTitleQuery, GetLegacyGameTitleQueryVariables>;
export const GetPlayerProfileDocument = gql`
    query GetPlayerProfile($playerId: UUID!, $groupId: UUID!) {
  player(id: $playerId) {
    id
    fullName
    debut
    claimed
    groups: playerGroupMemberships {
      groupId
    }
    careerStats(condition: {groupId: $groupId}) {
      games
      plateAppearances
      atBats
      hits
      runs
      doubles
      triples
      homeruns
      walks
      strikeouts
      sacFlies
      gidp
      rbi
      battingAverage
      onBasePct
      sluggingPct
      ops
    }
    seasonStats(orderBy: SEASON_DESC, condition: {groupId: $groupId}) {
      season
      games
      plateAppearances
      atBats
      hits
      runs
      doubles
      triples
      homeruns
      walks
      strikeouts
      sacFlies
      gidp
      rbi
      battingAverage
      onBasePct
      sluggingPct
      ops
    }
    gameBattingLines {
      game {
        groupId
        id
        name
        timeStarted
        timeEnded
      }
      season
      plateAppearances
      atBats
      hits
      runs
      doubles
      triples
      homeruns
      walks
      strikeouts
      sacFlies
      gidp
      rbi
      onBasePct
    }
    legacyGameBattingLines {
      legacyGame {
        gameId
        gameTitle
        gameDate
        gameStartTime
        gameEndTime
      }
      season
      plateAppearances
      atBats
      hits
      runs
      doubles
      triples
      homeruns
      walks
      strikeouts
      sacFlies
      gidp
      rbi
      onBasePct
    }
  }
}
    `;

/**
 * __useGetPlayerProfileQuery__
 *
 * To run a query within a React component, call `useGetPlayerProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPlayerProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPlayerProfileQuery({
 *   variables: {
 *      playerId: // value for 'playerId'
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetPlayerProfileQuery(baseOptions: Apollo.QueryHookOptions<GetPlayerProfileQuery, GetPlayerProfileQueryVariables>) {
        return Apollo.useQuery<GetPlayerProfileQuery, GetPlayerProfileQueryVariables>(GetPlayerProfileDocument, baseOptions);
      }
export function useGetPlayerProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPlayerProfileQuery, GetPlayerProfileQueryVariables>) {
          return Apollo.useLazyQuery<GetPlayerProfileQuery, GetPlayerProfileQueryVariables>(GetPlayerProfileDocument, baseOptions);
        }
export type GetPlayerProfileQueryHookResult = ReturnType<typeof useGetPlayerProfileQuery>;
export type GetPlayerProfileLazyQueryHookResult = ReturnType<typeof useGetPlayerProfileLazyQuery>;
export type GetPlayerProfileQueryResult = Apollo.QueryResult<GetPlayerProfileQuery, GetPlayerProfileQueryVariables>;
export const GetPreviewLeadersDocument = gql`
    query GetPreviewLeaders($groupId: UUID!, $currentSeason: Int!) {
  hits: seasonStats(
    condition: {groupId: $groupId, season: $currentSeason}
    orderBy: HITS_DESC
    first: 1
  ) {
    player {
      id
      fullName
    }
    value: hits
  }
  homeruns: seasonStats(
    condition: {groupId: $groupId, season: $currentSeason}
    orderBy: HOMERUNS_DESC
    first: 1
  ) {
    player {
      id
      fullName
    }
    value: homeruns
  }
  walks: seasonStats(
    condition: {groupId: $groupId, season: $currentSeason}
    orderBy: WALKS_DESC
    first: 1
  ) {
    player {
      id
      fullName
    }
    value: walks
  }
  battingAverage: seasonStatsQualifiedBatters(
    condition: {groupId: $groupId, season: $currentSeason}
    orderBy: BATTING_AVERAGE_DESC
    first: 1
  ) {
    player {
      id
      fullName
    }
    value: battingAverage
  }
  onBasePct: seasonStatsQualifiedBatters(
    condition: {groupId: $groupId, season: $currentSeason}
    orderBy: ON_BASE_PCT_DESC
    first: 1
  ) {
    player {
      id
      fullName
    }
    value: onBasePct
  }
  ops: seasonStatsQualifiedBatters(
    condition: {groupId: $groupId, season: $currentSeason}
    orderBy: OPS_DESC
    first: 1
  ) {
    player {
      id
      fullName
    }
    value: ops
  }
}
    `;

/**
 * __useGetPreviewLeadersQuery__
 *
 * To run a query within a React component, call `useGetPreviewLeadersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPreviewLeadersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPreviewLeadersQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      currentSeason: // value for 'currentSeason'
 *   },
 * });
 */
export function useGetPreviewLeadersQuery(baseOptions: Apollo.QueryHookOptions<GetPreviewLeadersQuery, GetPreviewLeadersQueryVariables>) {
        return Apollo.useQuery<GetPreviewLeadersQuery, GetPreviewLeadersQueryVariables>(GetPreviewLeadersDocument, baseOptions);
      }
export function useGetPreviewLeadersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPreviewLeadersQuery, GetPreviewLeadersQueryVariables>) {
          return Apollo.useLazyQuery<GetPreviewLeadersQuery, GetPreviewLeadersQueryVariables>(GetPreviewLeadersDocument, baseOptions);
        }
export type GetPreviewLeadersQueryHookResult = ReturnType<typeof useGetPreviewLeadersQuery>;
export type GetPreviewLeadersLazyQueryHookResult = ReturnType<typeof useGetPreviewLeadersLazyQuery>;
export type GetPreviewLeadersQueryResult = Apollo.QueryResult<GetPreviewLeadersQuery, GetPreviewLeadersQueryVariables>;
export const GetPreviewStatsDocument = gql`
    query GetPreviewStats($groupId: UUID!, $currentSeason: Int!) {
  seasonStats(
    condition: {groupId: $groupId, season: $currentSeason}
    orderBy: GAMES_DESC
    first: 25
  ) {
    player {
      id
      fullName
    }
    games
    plateAppearances
    atBats
    hits
    doubles
    triples
    homeruns
    xbh
    walks
    strikeouts
    sacFlies
    gidp
    runs
    rbi
    battingAverage
    onBasePct
    sluggingPct
    ops
  }
}
    `;

/**
 * __useGetPreviewStatsQuery__
 *
 * To run a query within a React component, call `useGetPreviewStatsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPreviewStatsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPreviewStatsQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      currentSeason: // value for 'currentSeason'
 *   },
 * });
 */
export function useGetPreviewStatsQuery(baseOptions: Apollo.QueryHookOptions<GetPreviewStatsQuery, GetPreviewStatsQueryVariables>) {
        return Apollo.useQuery<GetPreviewStatsQuery, GetPreviewStatsQueryVariables>(GetPreviewStatsDocument, baseOptions);
      }
export function useGetPreviewStatsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPreviewStatsQuery, GetPreviewStatsQueryVariables>) {
          return Apollo.useLazyQuery<GetPreviewStatsQuery, GetPreviewStatsQueryVariables>(GetPreviewStatsDocument, baseOptions);
        }
export type GetPreviewStatsQueryHookResult = ReturnType<typeof useGetPreviewStatsQuery>;
export type GetPreviewStatsLazyQueryHookResult = ReturnType<typeof useGetPreviewStatsLazyQuery>;
export type GetPreviewStatsQueryResult = Apollo.QueryResult<GetPreviewStatsQuery, GetPreviewStatsQueryVariables>;
export const GetSingleSeasonStatLeadersDocument = gql`
    query GetSingleSeasonStatLeaders($groupId: UUID!) {
  hitsLeaders: seasonStats(
    condition: {groupId: $groupId}
    orderBy: HITS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    season
    value: hits
  }
  homerunsLeaders: seasonStats(
    condition: {groupId: $groupId}
    orderBy: HOMERUNS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    season
    value: homeruns
  }
  walksLeaders: seasonStats(
    condition: {groupId: $groupId}
    orderBy: WALKS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    season
    value: walks
  }
  battingAverageLeaders: seasonStatsAllTimeQualifiedBatters(
    condition: {groupId: $groupId}
    orderBy: BATTING_AVERAGE_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    season
    value: battingAverage
  }
  onBasePctLeaders: seasonStatsAllTimeQualifiedBatters(
    condition: {groupId: $groupId}
    orderBy: ON_BASE_PCT_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    season
    value: onBasePct
  }
  opsLeaders: seasonStatsAllTimeQualifiedBatters(
    condition: {groupId: $groupId}
    orderBy: OPS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    season
    value: ops
  }
}
    `;

/**
 * __useGetSingleSeasonStatLeadersQuery__
 *
 * To run a query within a React component, call `useGetSingleSeasonStatLeadersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSingleSeasonStatLeadersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSingleSeasonStatLeadersQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useGetSingleSeasonStatLeadersQuery(baseOptions: Apollo.QueryHookOptions<GetSingleSeasonStatLeadersQuery, GetSingleSeasonStatLeadersQueryVariables>) {
        return Apollo.useQuery<GetSingleSeasonStatLeadersQuery, GetSingleSeasonStatLeadersQueryVariables>(GetSingleSeasonStatLeadersDocument, baseOptions);
      }
export function useGetSingleSeasonStatLeadersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSingleSeasonStatLeadersQuery, GetSingleSeasonStatLeadersQueryVariables>) {
          return Apollo.useLazyQuery<GetSingleSeasonStatLeadersQuery, GetSingleSeasonStatLeadersQueryVariables>(GetSingleSeasonStatLeadersDocument, baseOptions);
        }
export type GetSingleSeasonStatLeadersQueryHookResult = ReturnType<typeof useGetSingleSeasonStatLeadersQuery>;
export type GetSingleSeasonStatLeadersLazyQueryHookResult = ReturnType<typeof useGetSingleSeasonStatLeadersLazyQuery>;
export type GetSingleSeasonStatLeadersQueryResult = Apollo.QueryResult<GetSingleSeasonStatLeadersQuery, GetSingleSeasonStatLeadersQueryVariables>;
export const GetStatLeadersForSeasonDocument = gql`
    query GetStatLeadersForSeason($groupId: UUID!, $season: Int!) {
  hitsLeaders: seasonStats(
    condition: {groupId: $groupId, season: $season}
    orderBy: HITS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: hits
  }
  homerunsLeaders: seasonStats(
    condition: {groupId: $groupId, season: $season}
    orderBy: HOMERUNS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: homeruns
  }
  walksLeaders: seasonStats(
    condition: {groupId: $groupId, season: $season}
    orderBy: WALKS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: walks
  }
  battingAverageLeaders: seasonStatsQualifiedBatters(
    condition: {groupId: $groupId, season: $season}
    orderBy: BATTING_AVERAGE_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: battingAverage
  }
  onBasePctLeaders: seasonStatsQualifiedBatters(
    condition: {groupId: $groupId, season: $season}
    orderBy: ON_BASE_PCT_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: onBasePct
  }
  opsLeaders: seasonStatsQualifiedBatters(
    condition: {groupId: $groupId, season: $season}
    orderBy: OPS_DESC
    first: 5
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
    }
    value: ops
  }
}
    `;

/**
 * __useGetStatLeadersForSeasonQuery__
 *
 * To run a query within a React component, call `useGetStatLeadersForSeasonQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStatLeadersForSeasonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStatLeadersForSeasonQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      season: // value for 'season'
 *   },
 * });
 */
export function useGetStatLeadersForSeasonQuery(baseOptions: Apollo.QueryHookOptions<GetStatLeadersForSeasonQuery, GetStatLeadersForSeasonQueryVariables>) {
        return Apollo.useQuery<GetStatLeadersForSeasonQuery, GetStatLeadersForSeasonQueryVariables>(GetStatLeadersForSeasonDocument, baseOptions);
      }
export function useGetStatLeadersForSeasonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStatLeadersForSeasonQuery, GetStatLeadersForSeasonQueryVariables>) {
          return Apollo.useLazyQuery<GetStatLeadersForSeasonQuery, GetStatLeadersForSeasonQueryVariables>(GetStatLeadersForSeasonDocument, baseOptions);
        }
export type GetStatLeadersForSeasonQueryHookResult = ReturnType<typeof useGetStatLeadersForSeasonQuery>;
export type GetStatLeadersForSeasonLazyQueryHookResult = ReturnType<typeof useGetStatLeadersForSeasonLazyQuery>;
export type GetStatLeadersForSeasonQueryResult = Apollo.QueryResult<GetStatLeadersForSeasonQuery, GetStatLeadersForSeasonQueryVariables>;
export const GetStatsForSeasonDocument = gql`
    query GetStatsForSeason($groupId: UUID!, $season: Int!) {
  season(groupId: $groupId, year: $season) {
    totalGames
  }
  seasonStats(
    condition: {groupId: $groupId, season: $season}
    orderBy: GAMES_DESC
  ) {
    player {
      id
      fullName
    }
    legacyPlayer {
      playerId
      playerName
      playerImage
    }
    games
    plateAppearances
    atBats
    hits
    doubles
    triples
    homeruns
    xbh
    walks
    strikeouts
    sacFlies
    gidp
    runs
    rbi
    battingAverage
    onBasePct
    sluggingPct
    ops
  }
}
    `;

/**
 * __useGetStatsForSeasonQuery__
 *
 * To run a query within a React component, call `useGetStatsForSeasonQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetStatsForSeasonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetStatsForSeasonQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      season: // value for 'season'
 *   },
 * });
 */
export function useGetStatsForSeasonQuery(baseOptions: Apollo.QueryHookOptions<GetStatsForSeasonQuery, GetStatsForSeasonQueryVariables>) {
        return Apollo.useQuery<GetStatsForSeasonQuery, GetStatsForSeasonQueryVariables>(GetStatsForSeasonDocument, baseOptions);
      }
export function useGetStatsForSeasonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetStatsForSeasonQuery, GetStatsForSeasonQueryVariables>) {
          return Apollo.useLazyQuery<GetStatsForSeasonQuery, GetStatsForSeasonQueryVariables>(GetStatsForSeasonDocument, baseOptions);
        }
export type GetStatsForSeasonQueryHookResult = ReturnType<typeof useGetStatsForSeasonQuery>;
export type GetStatsForSeasonLazyQueryHookResult = ReturnType<typeof useGetStatsForSeasonLazyQuery>;
export type GetStatsForSeasonQueryResult = Apollo.QueryResult<GetStatsForSeasonQuery, GetStatsForSeasonQueryVariables>;
export const LoginDocument = gql`
    mutation Login($email: String!, $password: String!) {
  login(input: {email: $email, password: $password}) {
    jwt
  }
}
    `;
export type LoginMutationFn = Apollo.MutationFunction<LoginMutation, LoginMutationVariables>;

/**
 * __useLoginMutation__
 *
 * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginMutation, { data, loading, error }] = useLoginMutation({
 *   variables: {
 *      email: // value for 'email'
 *      password: // value for 'password'
 *   },
 * });
 */
export function useLoginMutation(baseOptions?: Apollo.MutationHookOptions<LoginMutation, LoginMutationVariables>) {
        return Apollo.useMutation<LoginMutation, LoginMutationVariables>(LoginDocument, baseOptions);
      }
export type LoginMutationHookResult = ReturnType<typeof useLoginMutation>;
export type LoginMutationResult = Apollo.MutationResult<LoginMutation>;
export type LoginMutationOptions = Apollo.BaseMutationOptions<LoginMutation, LoginMutationVariables>;
export const GetCurrentUserDocument = gql`
    query GetCurrentUser {
  user: getCurrentUser {
    id
    fullName
  }
}
    `;

/**
 * __useGetCurrentUserQuery__
 *
 * To run a query within a React component, call `useGetCurrentUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCurrentUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCurrentUserQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetCurrentUserQuery(baseOptions?: Apollo.QueryHookOptions<GetCurrentUserQuery, GetCurrentUserQueryVariables>) {
        return Apollo.useQuery<GetCurrentUserQuery, GetCurrentUserQueryVariables>(GetCurrentUserDocument, baseOptions);
      }
export function useGetCurrentUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCurrentUserQuery, GetCurrentUserQueryVariables>) {
          return Apollo.useLazyQuery<GetCurrentUserQuery, GetCurrentUserQueryVariables>(GetCurrentUserDocument, baseOptions);
        }
export type GetCurrentUserQueryHookResult = ReturnType<typeof useGetCurrentUserQuery>;
export type GetCurrentUserLazyQueryHookResult = ReturnType<typeof useGetCurrentUserLazyQuery>;
export type GetCurrentUserQueryResult = Apollo.QueryResult<GetCurrentUserQuery, GetCurrentUserQueryVariables>;
export const GetPermissionsDocument = gql`
    query GetPermissions {
  currentUserPermissions
  currentUserGroupPermissions {
    groupId
    permission
  }
}
    `;

/**
 * __useGetPermissionsQuery__
 *
 * To run a query within a React component, call `useGetPermissionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPermissionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPermissionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPermissionsQuery(baseOptions?: Apollo.QueryHookOptions<GetPermissionsQuery, GetPermissionsQueryVariables>) {
        return Apollo.useQuery<GetPermissionsQuery, GetPermissionsQueryVariables>(GetPermissionsDocument, baseOptions);
      }
export function useGetPermissionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPermissionsQuery, GetPermissionsQueryVariables>) {
          return Apollo.useLazyQuery<GetPermissionsQuery, GetPermissionsQueryVariables>(GetPermissionsDocument, baseOptions);
        }
export type GetPermissionsQueryHookResult = ReturnType<typeof useGetPermissionsQuery>;
export type GetPermissionsLazyQueryHookResult = ReturnType<typeof useGetPermissionsLazyQuery>;
export type GetPermissionsQueryResult = Apollo.QueryResult<GetPermissionsQuery, GetPermissionsQueryVariables>;
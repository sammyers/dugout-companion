"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads a set of `BaseRunner`."""
  baseRunners(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `BaseRunner`."""
    orderBy: [BaseRunnersOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BaseRunnerCondition
  ): [BaseRunner!]

  """Reads a set of `BasepathMovement`."""
  basepathMovements(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `BasepathMovement`."""
    orderBy: [BasepathMovementsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BasepathMovementCondition
  ): [BasepathMovement!]

  """Reads a set of `Field`."""
  fields(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Field`."""
    orderBy: [FieldsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FieldCondition
  ): [Field!]

  """Reads a set of `Game`."""
  games(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Game`."""
    orderBy: [GamesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GameCondition
  ): [Game!]

  """Reads a set of `GameEvent`."""
  gameEvents(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `GameEvent`."""
    orderBy: [GameEventsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GameEventCondition
  ): [GameEvent!]

  """Reads a set of `GameEventRecord`."""
  gameEventRecords(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `GameEventRecord`."""
    orderBy: [GameEventRecordsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GameEventRecordCondition
  ): [GameEventRecord!]

  """Reads a set of `GameState`."""
  gameStates(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `GameState`."""
    orderBy: [GameStatesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GameStateCondition
  ): [GameState!]

  """Reads a set of `Group`."""
  groups(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Group`."""
    orderBy: [GroupsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GroupCondition
  ): [Group!]

  """Reads a set of `LegacyField`."""
  legacyFields(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LegacyField`."""
    orderBy: [LegacyFieldsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LegacyFieldCondition
  ): [LegacyField!]

  """Reads a set of `LegacyGame`."""
  legacyGames(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LegacyGame`."""
    orderBy: [LegacyGamesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LegacyGameCondition
  ): [LegacyGame!]

  """Reads a set of `LegacyPlayer`."""
  legacyPlayers(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LegacyPlayer`."""
    orderBy: [LegacyPlayersOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LegacyPlayerCondition
  ): [LegacyPlayer!]

  """Reads a set of `LegacyStatLine`."""
  legacyStatLines(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LegacyStatLine`."""
    orderBy: [LegacyStatLinesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LegacyStatLineCondition
  ): [LegacyStatLine!]

  """Reads a set of `LegacyTeam`."""
  legacyTeams(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LegacyTeam`."""
    orderBy: [LegacyTeamsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LegacyTeamCondition
  ): [LegacyTeam!]

  """Reads a set of `Lineup`."""
  lineups(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Lineup`."""
    orderBy: [LineupsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LineupCondition
  ): [Lineup!]

  """Reads a set of `LineupChange`."""
  lineupChanges(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LineupChange`."""
    orderBy: [LineupChangesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LineupChangeCondition
  ): [LineupChange!]

  """Reads a set of `LineupForGameState`."""
  lineupForGameStates(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LineupForGameState`."""
    orderBy: [LineupForGameStatesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LineupForGameStateCondition
  ): [LineupForGameState!]

  """Reads a set of `LineupSpot`."""
  lineupSpots(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LineupSpot`."""
    orderBy: [LineupSpotsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LineupSpotCondition
  ): [LineupSpot!]

  """Reads a set of `OutOnPlayRunner`."""
  outOnPlayRunners(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `OutOnPlayRunner`."""
    orderBy: [OutOnPlayRunnersOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OutOnPlayRunnerCondition
  ): [OutOnPlayRunner!]

  """Reads a set of `PlateAppearance`."""
  plateAppearances(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PlateAppearance`."""
    orderBy: [PlateAppearancesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlateAppearanceCondition
  ): [PlateAppearance!]

  """Reads a set of `Player`."""
  players(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Player`."""
    orderBy: [PlayersOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlayerCondition
  ): [Player!]

  """Reads a set of `ScoredRunner`."""
  scoredRunners(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `ScoredRunner`."""
    orderBy: [ScoredRunnersOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ScoredRunnerCondition
  ): [ScoredRunner!]

  """Reads a set of `StolenBaseAttempt`."""
  stolenBaseAttempts(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `StolenBaseAttempt`."""
    orderBy: [StolenBaseAttemptsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StolenBaseAttemptCondition
  ): [StolenBaseAttempt!]

  """Reads a set of `Team`."""
  teams(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Team`."""
    orderBy: [TeamsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamCondition
  ): [Team!]
  baseRunner(gameStateId: UUID!, runnerId: UUID!): BaseRunner
  basepathMovement(plateAppearanceId: UUID!, runnerId: UUID!): BasepathMovement
  field(id: UUID!): Field
  game(id: UUID!): Game
  gameByName(name: String!): Game
  gameEvent(id: UUID!): GameEvent
  gameEventRecord(id: UUID!): GameEventRecord
  gameEventRecordByGameIdAndEventIndex(gameId: UUID!, eventIndex: Int!): GameEventRecord
  gameState(id: UUID!): GameState
  group(id: UUID!): Group
  groupByName(name: String!): Group
  legacyField(fieldId: Int!): LegacyField
  legacyGame(gameId: Int!): LegacyGame
  legacyPlayer(playerId: Int!): LegacyPlayer
  legacyTeam(teamId: Int!): LegacyTeam
  lineup(id: UUID!): Lineup
  lineupChange(id: UUID!): LineupChange
  lineupForGameState(gameStateId: UUID!, lineupId: UUID!): LineupForGameState
  lineupSpot(lineupId: UUID!, playerId: UUID!): LineupSpot
  lineupSpotByLineupIdAndBattingOrder(lineupId: UUID!, battingOrder: Int!): LineupSpot
  lineupSpotByLineupIdAndPosition(lineupId: UUID!, position: FieldingPosition!): LineupSpot
  outOnPlayRunner(plateAppearanceId: UUID!, runnerId: UUID!): OutOnPlayRunner
  plateAppearance(id: UUID!): PlateAppearance
  player(id: UUID!): Player
  playerByFirstNameAndLastName(firstName: String!, lastName: String!): Player
  scoredRunner(gameEventRecordId: UUID!, runnerId: UUID!): ScoredRunner
  stolenBaseAttempt(id: UUID!): StolenBaseAttempt
  team(id: UUID!): Team
  teamByGameIdAndRole(gameId: UUID!, role: TeamRole!): Team
  getAvg(hits: Int, atBats: Int): Float
  getObp(hits: Int, walks: Int, plateAppearances: Int): Float
  getOps(hits: Int, totalBases: Int, walks: Int, atBats: Int, plateAppearances: Int): Float
  getPlateAppearances(
    playerId: UUID
    gameId: UUID
    beforeDate: Datetime
    afterDate: Datetime

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int
  ): [GetPlateAppearancesRecord]
  getRunsScored(
    gameId: UUID
    batterId: UUID
    runnerId: UUID
    beforeDate: Datetime
    afterDate: Datetime

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int
  ): [GetRunsScoredRecord]
  getSlg(totalBases: Int, atBats: Int): Float
  getTb(singles: Int, doubles: Int, triples: Int, homeruns: Int): Int

  """Reads a single `BaseRunner` using its globally unique `ID`."""
  baseRunnerByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `BaseRunner`.
    """
    nodeId: ID!
  ): BaseRunner

  """Reads a single `BasepathMovement` using its globally unique `ID`."""
  basepathMovementByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `BasepathMovement`.
    """
    nodeId: ID!
  ): BasepathMovement

  """Reads a single `Field` using its globally unique `ID`."""
  fieldByNodeId(
    """The globally unique `ID` to be used in selecting a single `Field`."""
    nodeId: ID!
  ): Field

  """Reads a single `Game` using its globally unique `ID`."""
  gameByNodeId(
    """The globally unique `ID` to be used in selecting a single `Game`."""
    nodeId: ID!
  ): Game

  """Reads a single `GameEvent` using its globally unique `ID`."""
  gameEventByNodeId(
    """The globally unique `ID` to be used in selecting a single `GameEvent`."""
    nodeId: ID!
  ): GameEvent

  """Reads a single `GameEventRecord` using its globally unique `ID`."""
  gameEventRecordByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `GameEventRecord`.
    """
    nodeId: ID!
  ): GameEventRecord

  """Reads a single `GameState` using its globally unique `ID`."""
  gameStateByNodeId(
    """The globally unique `ID` to be used in selecting a single `GameState`."""
    nodeId: ID!
  ): GameState

  """Reads a single `Group` using its globally unique `ID`."""
  groupByNodeId(
    """The globally unique `ID` to be used in selecting a single `Group`."""
    nodeId: ID!
  ): Group

  """Reads a single `LegacyField` using its globally unique `ID`."""
  legacyFieldByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `LegacyField`.
    """
    nodeId: ID!
  ): LegacyField

  """Reads a single `LegacyGame` using its globally unique `ID`."""
  legacyGameByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `LegacyGame`.
    """
    nodeId: ID!
  ): LegacyGame

  """Reads a single `LegacyPlayer` using its globally unique `ID`."""
  legacyPlayerByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `LegacyPlayer`.
    """
    nodeId: ID!
  ): LegacyPlayer

  """Reads a single `LegacyTeam` using its globally unique `ID`."""
  legacyTeamByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `LegacyTeam`.
    """
    nodeId: ID!
  ): LegacyTeam

  """Reads a single `Lineup` using its globally unique `ID`."""
  lineupByNodeId(
    """The globally unique `ID` to be used in selecting a single `Lineup`."""
    nodeId: ID!
  ): Lineup

  """Reads a single `LineupChange` using its globally unique `ID`."""
  lineupChangeByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `LineupChange`.
    """
    nodeId: ID!
  ): LineupChange

  """Reads a single `LineupForGameState` using its globally unique `ID`."""
  lineupForGameStateByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `LineupForGameState`.
    """
    nodeId: ID!
  ): LineupForGameState

  """Reads a single `LineupSpot` using its globally unique `ID`."""
  lineupSpotByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `LineupSpot`.
    """
    nodeId: ID!
  ): LineupSpot

  """Reads a single `OutOnPlayRunner` using its globally unique `ID`."""
  outOnPlayRunnerByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `OutOnPlayRunner`.
    """
    nodeId: ID!
  ): OutOnPlayRunner

  """Reads a single `PlateAppearance` using its globally unique `ID`."""
  plateAppearanceByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `PlateAppearance`.
    """
    nodeId: ID!
  ): PlateAppearance

  """Reads a single `Player` using its globally unique `ID`."""
  playerByNodeId(
    """The globally unique `ID` to be used in selecting a single `Player`."""
    nodeId: ID!
  ): Player

  """Reads a single `ScoredRunner` using its globally unique `ID`."""
  scoredRunnerByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `ScoredRunner`.
    """
    nodeId: ID!
  ): ScoredRunner

  """Reads a single `StolenBaseAttempt` using its globally unique `ID`."""
  stolenBaseAttemptByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `StolenBaseAttempt`.
    """
    nodeId: ID!
  ): StolenBaseAttempt

  """Reads a single `Team` using its globally unique `ID`."""
  teamByNodeId(
    """The globally unique `ID` to be used in selecting a single `Team`."""
    nodeId: ID!
  ): Team
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

type BaseRunner implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  gameStateId: UUID!
  runnerId: UUID!
  base: BaseType!

  """Reads a single `GameState` that is related to this `BaseRunner`."""
  gameState: GameState

  """Reads a single `Player` that is related to this `BaseRunner`."""
  runner: Player
}

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID

enum BaseType {
  FIRST
  SECOND
  THIRD
}

type GameState implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  gameId: UUID!
  gameStateIndex: Int!
  playerAtBat: UUID!
  inning: Int!
  halfInning: HalfInning!
  outs: Int!
  score: [Int]!

  """Reads a single `Game` that is related to this `GameState`."""
  game: Game

  """Reads a single `Player` that is related to this `GameState`."""
  playerByPlayerAtBat: Player

  """Reads and enables pagination through a set of `BaseRunner`."""
  baseRunners(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `BaseRunner`."""
    orderBy: [BaseRunnersOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BaseRunnerCondition
  ): [BaseRunner!]!

  """Reads and enables pagination through a set of `LineupForGameState`."""
  lineupForGameStates(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LineupForGameState`."""
    orderBy: [LineupForGameStatesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LineupForGameStateCondition
  ): [LineupForGameState!]!

  """Reads and enables pagination through a set of `GameEventRecord`."""
  gameEventRecordsByGameStateBeforeId(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `GameEventRecord`."""
    orderBy: [GameEventRecordsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GameEventRecordCondition
  ): [GameEventRecord!]!

  """Reads and enables pagination through a set of `GameEventRecord`."""
  gameEventRecordsByGameStateAfterId(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `GameEventRecord`."""
    orderBy: [GameEventRecordsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GameEventRecordCondition
  ): [GameEventRecord!]!

  """Reads and enables pagination through a set of `Lineup`."""
  lineups(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int
  ): [Lineup]
}

enum HalfInning {
  TOP
  BOTTOM
}

type Game implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  groupId: UUID!
  name: String
  fieldId: UUID
  score: [Int]!
  gameLength: Int!
  timeStarted: Datetime!
  timeEnded: Datetime!
  timeSaved: Datetime!

  """Reads a single `Group` that is related to this `Game`."""
  group: Group

  """Reads a single `Field` that is related to this `Game`."""
  field: Field

  """Reads and enables pagination through a set of `Team`."""
  teams(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Team`."""
    orderBy: [TeamsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamCondition
  ): [Team!]!

  """Reads and enables pagination through a set of `GameState`."""
  gameStates(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `GameState`."""
    orderBy: [GameStatesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GameStateCondition
  ): [GameState!]!

  """Reads and enables pagination through a set of `GameEventRecord`."""
  gameEventRecords(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `GameEventRecord`."""
    orderBy: [GameEventRecordsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GameEventRecordCondition
  ): [GameEventRecord!]!

  """Reads and enables pagination through a set of `TraditionalStatLine`."""
  boxScore(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int
  ): [TraditionalStatLine]

  """Reads and enables pagination through a set of `LineScoreCell`."""
  lineScore(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int
  ): [LineScoreCell]
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

type Group implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  name: String!
  notes: String

  """Reads and enables pagination through a set of `Player`."""
  players(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Player`."""
    orderBy: [PlayersOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlayerCondition
  ): [Player!]!

  """Reads and enables pagination through a set of `Game`."""
  games(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Game`."""
    orderBy: [GamesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GameCondition
  ): [Game!]!
}

type Player implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  groupId: UUID!
  legacyPlayerId: Int
  firstName: String!
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime

  """Reads a single `Group` that is related to this `Player`."""
  group: Group

  """Reads a single `LegacyPlayer` that is related to this `Player`."""
  legacyPlayer: LegacyPlayer

  """Reads and enables pagination through a set of `Team`."""
  teamsByCaptainId(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Team`."""
    orderBy: [TeamsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TeamCondition
  ): [Team!]!

  """Reads and enables pagination through a set of `LineupSpot`."""
  lineupSpots(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LineupSpot`."""
    orderBy: [LineupSpotsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LineupSpotCondition
  ): [LineupSpot!]!

  """Reads and enables pagination through a set of `BasepathMovement`."""
  basepathMovementsByRunnerId(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `BasepathMovement`."""
    orderBy: [BasepathMovementsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BasepathMovementCondition
  ): [BasepathMovement!]!

  """Reads and enables pagination through a set of `OutOnPlayRunner`."""
  outOnPlayRunnersByRunnerId(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `OutOnPlayRunner`."""
    orderBy: [OutOnPlayRunnersOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OutOnPlayRunnerCondition
  ): [OutOnPlayRunner!]!

  """Reads and enables pagination through a set of `StolenBaseAttempt`."""
  stolenBaseAttemptsByRunnerId(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `StolenBaseAttempt`."""
    orderBy: [StolenBaseAttemptsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StolenBaseAttemptCondition
  ): [StolenBaseAttempt!]!

  """Reads and enables pagination through a set of `GameState`."""
  gameStatesByPlayerAtBat(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `GameState`."""
    orderBy: [GameStatesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GameStateCondition
  ): [GameState!]!

  """Reads and enables pagination through a set of `BaseRunner`."""
  baseRunnersByRunnerId(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `BaseRunner`."""
    orderBy: [BaseRunnersOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BaseRunnerCondition
  ): [BaseRunner!]!

  """Reads and enables pagination through a set of `ScoredRunner`."""
  scoredRunnersByRunnerId(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `ScoredRunner`."""
    orderBy: [ScoredRunnersOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ScoredRunnerCondition
  ): [ScoredRunner!]!
  fullName: String
  gamesPlayed(beforeDate: Datetime, afterDate: Datetime): Int

  """sortable"""
  gamesPlayedThisYear: Int
  traditionalStats(beforeDate: Datetime, afterDate: Datetime): TraditionalStatLine
}

type LegacyPlayer implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  playerId: Int!
  playerName: String!
  playerImage: String
  memberId: String

  """Reads and enables pagination through a set of `LegacyStatLine`."""
  legacyStatLinesByPlayerId(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LegacyStatLine`."""
    orderBy: [LegacyStatLinesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LegacyStatLineCondition
  ): [LegacyStatLine!]!

  """Reads and enables pagination through a set of `Player`."""
  players(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Player`."""
    orderBy: [PlayersOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlayerCondition
  ): [Player!]!
}

type LegacyStatLine {
  sbStatsId: Int!
  playerId: Int!
  gameId: Int!
  sbStatsTeam: Int!
  atBats: Int!
  runs: Int!
  hits: Int!
  singles: Int!
  doubles: Int!
  triples: Int!
  homeruns: Int!
  rbi: Int!
  walks: Int!
  strikeouts: Int!
  sacFlies: Int!

  """
  Reads a single `LegacyPlayer` that is related to this `LegacyStatLine`.
  """
  player: LegacyPlayer

  """Reads a single `LegacyGame` that is related to this `LegacyStatLine`."""
  game: LegacyGame

  """Reads a single `LegacyTeam` that is related to this `LegacyStatLine`."""
  legacyTeamBySbStatsTeam: LegacyTeam
}

type LegacyGame implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  gameId: Int!
  gameTitle: String!
  gameDate: Date!
  gameStartTime: Time!
  gameEndTime: Time!
  gameTeamId1: Int!
  gameTeamId2: Int!
  season: Int!

  """Reads and enables pagination through a set of `LegacyStatLine`."""
  legacyStatLinesByGameId(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LegacyStatLine`."""
    orderBy: [LegacyStatLinesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LegacyStatLineCondition
  ): [LegacyStatLine!]!
}

"""The day, does not include a time."""
scalar Date

"""
The exact time of day, does not include the date. May or may not have a timezone offset.
"""
scalar Time

"""Methods to use when ordering `LegacyStatLine`."""
enum LegacyStatLinesOrderBy {
  NATURAL
  SB_STATS_ID_ASC
  SB_STATS_ID_DESC
  PLAYER_ID_ASC
  PLAYER_ID_DESC
  GAME_ID_ASC
  GAME_ID_DESC
  SB_STATS_TEAM_ASC
  SB_STATS_TEAM_DESC
  AT_BATS_ASC
  AT_BATS_DESC
  RUNS_ASC
  RUNS_DESC
  HITS_ASC
  HITS_DESC
  SINGLES_ASC
  SINGLES_DESC
  DOUBLES_ASC
  DOUBLES_DESC
  TRIPLES_ASC
  TRIPLES_DESC
  HOMERUNS_ASC
  HOMERUNS_DESC
  RBI_ASC
  RBI_DESC
  WALKS_ASC
  WALKS_DESC
  STRIKEOUTS_ASC
  STRIKEOUTS_DESC
  SAC_FLIES_ASC
  SAC_FLIES_DESC
}

"""
A condition to be used against `LegacyStatLine` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input LegacyStatLineCondition {
  """Checks for equality with the object’s `sbStatsId` field."""
  sbStatsId: Int

  """Checks for equality with the object’s `playerId` field."""
  playerId: Int

  """Checks for equality with the object’s `gameId` field."""
  gameId: Int

  """Checks for equality with the object’s `sbStatsTeam` field."""
  sbStatsTeam: Int

  """Checks for equality with the object’s `atBats` field."""
  atBats: Int

  """Checks for equality with the object’s `runs` field."""
  runs: Int

  """Checks for equality with the object’s `hits` field."""
  hits: Int

  """Checks for equality with the object’s `singles` field."""
  singles: Int

  """Checks for equality with the object’s `doubles` field."""
  doubles: Int

  """Checks for equality with the object’s `triples` field."""
  triples: Int

  """Checks for equality with the object’s `homeruns` field."""
  homeruns: Int

  """Checks for equality with the object’s `rbi` field."""
  rbi: Int

  """Checks for equality with the object’s `walks` field."""
  walks: Int

  """Checks for equality with the object’s `strikeouts` field."""
  strikeouts: Int

  """Checks for equality with the object’s `sacFlies` field."""
  sacFlies: Int
}

type LegacyTeam implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  teamId: Int!
  teamName: String!

  """Reads and enables pagination through a set of `LegacyStatLine`."""
  legacyStatLinesBySbStatsTeam(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LegacyStatLine`."""
    orderBy: [LegacyStatLinesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LegacyStatLineCondition
  ): [LegacyStatLine!]!
}

"""Methods to use when ordering `Player`."""
enum PlayersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  GROUP_ID_ASC
  GROUP_ID_DESC
  LEGACY_PLAYER_ID_ASC
  LEGACY_PLAYER_ID_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  NICKNAME_ASC
  NICKNAME_DESC
  IMAGE_URL_ASC
  IMAGE_URL_DESC
  TIME_CREATED_ASC
  TIME_CREATED_DESC
  FULL_NAME_ASC
  FULL_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Player` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PlayerCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `groupId` field."""
  groupId: UUID

  """Checks for equality with the object’s `legacyPlayerId` field."""
  legacyPlayerId: Int

  """Checks for equality with the object’s `firstName` field."""
  firstName: String

  """Checks for equality with the object’s `lastName` field."""
  lastName: String

  """Checks for equality with the object’s `nickname` field."""
  nickname: String

  """Checks for equality with the object’s `imageUrl` field."""
  imageUrl: String

  """Checks for equality with the object’s `timeCreated` field."""
  timeCreated: Datetime
}

type Team implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  gameId: UUID!
  role: TeamRole!
  name: String
  captainId: UUID
  winner: Boolean

  """Reads a single `Game` that is related to this `Team`."""
  game: Game

  """Reads a single `Player` that is related to this `Team`."""
  captain: Player

  """Reads and enables pagination through a set of `Lineup`."""
  lineups(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Lineup`."""
    orderBy: [LineupsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LineupCondition
  ): [Lineup!]!
  finalLineup: Lineup
}

enum TeamRole {
  AWAY
  HOME
}

type Lineup implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  teamId: UUID!

  """Reads a single `Team` that is related to this `Lineup`."""
  team: Team

  """Reads and enables pagination through a set of `LineupSpot`."""
  lineupSpots(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LineupSpot`."""
    orderBy: [LineupSpotsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LineupSpotCondition
  ): [LineupSpot!]!

  """Reads and enables pagination through a set of `LineupChange`."""
  lineupChangesByLineupBeforeId(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LineupChange`."""
    orderBy: [LineupChangesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LineupChangeCondition
  ): [LineupChange!]!

  """Reads and enables pagination through a set of `LineupChange`."""
  lineupChangesByLineupAfterId(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LineupChange`."""
    orderBy: [LineupChangesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LineupChangeCondition
  ): [LineupChange!]!

  """Reads and enables pagination through a set of `LineupForGameState`."""
  lineupForGameStates(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LineupForGameState`."""
    orderBy: [LineupForGameStatesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LineupForGameStateCondition
  ): [LineupForGameState!]!
}

type LineupSpot implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  lineupId: UUID!
  playerId: UUID!
  battingOrder: Int!
  position: FieldingPosition

  """Reads a single `Lineup` that is related to this `LineupSpot`."""
  lineup: Lineup

  """Reads a single `Player` that is related to this `LineupSpot`."""
  player: Player
}

enum FieldingPosition {
  PITCHER
  CATCHER
  FIRST_BASE
  SECOND_BASE
  THIRD_BASE
  SHORTSTOP
  LEFT_FIELD
  CENTER_FIELD
  LEFT_CENTER
  RIGHT_CENTER
  RIGHT_FIELD
}

"""Methods to use when ordering `LineupSpot`."""
enum LineupSpotsOrderBy {
  NATURAL
  LINEUP_ID_ASC
  LINEUP_ID_DESC
  PLAYER_ID_ASC
  PLAYER_ID_DESC
  BATTING_ORDER_ASC
  BATTING_ORDER_DESC
  POSITION_ASC
  POSITION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `LineupSpot` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input LineupSpotCondition {
  """Checks for equality with the object’s `lineupId` field."""
  lineupId: UUID

  """Checks for equality with the object’s `playerId` field."""
  playerId: UUID

  """Checks for equality with the object’s `battingOrder` field."""
  battingOrder: Int

  """Checks for equality with the object’s `position` field."""
  position: FieldingPosition
}

type LineupChange implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  lineupBeforeId: UUID!
  lineupAfterId: UUID!

  """Reads a single `Lineup` that is related to this `LineupChange`."""
  lineupBefore: Lineup

  """Reads a single `Lineup` that is related to this `LineupChange`."""
  lineupAfter: Lineup
}

"""Methods to use when ordering `LineupChange`."""
enum LineupChangesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  LINEUP_BEFORE_ID_ASC
  LINEUP_BEFORE_ID_DESC
  LINEUP_AFTER_ID_ASC
  LINEUP_AFTER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `LineupChange` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input LineupChangeCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `lineupBeforeId` field."""
  lineupBeforeId: UUID

  """Checks for equality with the object’s `lineupAfterId` field."""
  lineupAfterId: UUID
}

type LineupForGameState implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  gameStateId: UUID!
  lineupId: UUID!

  """
  Reads a single `GameState` that is related to this `LineupForGameState`.
  """
  gameState: GameState

  """Reads a single `Lineup` that is related to this `LineupForGameState`."""
  lineup: Lineup
}

"""Methods to use when ordering `LineupForGameState`."""
enum LineupForGameStatesOrderBy {
  NATURAL
  GAME_STATE_ID_ASC
  GAME_STATE_ID_DESC
  LINEUP_ID_ASC
  LINEUP_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `LineupForGameState` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input LineupForGameStateCondition {
  """Checks for equality with the object’s `gameStateId` field."""
  gameStateId: UUID

  """Checks for equality with the object’s `lineupId` field."""
  lineupId: UUID
}

"""Methods to use when ordering `Lineup`."""
enum LineupsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TEAM_ID_ASC
  TEAM_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Lineup` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input LineupCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `teamId` field."""
  teamId: UUID
}

"""Methods to use when ordering `Team`."""
enum TeamsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  GAME_ID_ASC
  GAME_ID_DESC
  ROLE_ASC
  ROLE_DESC
  NAME_ASC
  NAME_DESC
  CAPTAIN_ID_ASC
  CAPTAIN_ID_DESC
  WINNER_ASC
  WINNER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Team` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TeamCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `gameId` field."""
  gameId: UUID

  """Checks for equality with the object’s `role` field."""
  role: TeamRole

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `captainId` field."""
  captainId: UUID

  """Checks for equality with the object’s `winner` field."""
  winner: Boolean
}

type BasepathMovement implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  plateAppearanceId: UUID!
  runnerId: UUID!
  endBase: BaseType
  wasSafe: Boolean!

  """
  Reads a single `PlateAppearance` that is related to this `BasepathMovement`.
  """
  plateAppearance: PlateAppearance

  """Reads a single `Player` that is related to this `BasepathMovement`."""
  runner: Player
}

type PlateAppearance implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  type: PlateAppearanceType!
  contact: ContactQuality
  fieldedBy: FieldingPosition
  runsScoredOnSacFly: Int
  routinePlay: Boolean!

  """Reads and enables pagination through a set of `BasepathMovement`."""
  basepathMovements(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `BasepathMovement`."""
    orderBy: [BasepathMovementsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: BasepathMovementCondition
  ): [BasepathMovement!]!

  """Reads and enables pagination through a set of `OutOnPlayRunner`."""
  outOnPlayRunners(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `OutOnPlayRunner`."""
    orderBy: [OutOnPlayRunnersOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OutOnPlayRunnerCondition
  ): [OutOnPlayRunner!]!
}

enum PlateAppearanceType {
  OUT
  WALK
  SINGLE
  DOUBLE
  TRIPLE
  HOMERUN
  SACRIFICE_FLY
  FIELDERS_CHOICE
  DOUBLE_PLAY
}

enum ContactQuality {
  NONE
  GROUNDER
  LINE_DRIVE
  POPUP
  LAZY_FLY
  LONG_FLY
}

"""Methods to use when ordering `BasepathMovement`."""
enum BasepathMovementsOrderBy {
  NATURAL
  PLATE_APPEARANCE_ID_ASC
  PLATE_APPEARANCE_ID_DESC
  RUNNER_ID_ASC
  RUNNER_ID_DESC
  END_BASE_ASC
  END_BASE_DESC
  WAS_SAFE_ASC
  WAS_SAFE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `BasepathMovement` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input BasepathMovementCondition {
  """Checks for equality with the object’s `plateAppearanceId` field."""
  plateAppearanceId: UUID

  """Checks for equality with the object’s `runnerId` field."""
  runnerId: UUID

  """Checks for equality with the object’s `endBase` field."""
  endBase: BaseType

  """Checks for equality with the object’s `wasSafe` field."""
  wasSafe: Boolean
}

type OutOnPlayRunner implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  plateAppearanceId: UUID!
  runnerId: UUID!

  """
  Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`.
  """
  plateAppearance: PlateAppearance

  """Reads a single `Player` that is related to this `OutOnPlayRunner`."""
  runner: Player
}

"""Methods to use when ordering `OutOnPlayRunner`."""
enum OutOnPlayRunnersOrderBy {
  NATURAL
  PLATE_APPEARANCE_ID_ASC
  PLATE_APPEARANCE_ID_DESC
  RUNNER_ID_ASC
  RUNNER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `OutOnPlayRunner` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input OutOnPlayRunnerCondition {
  """Checks for equality with the object’s `plateAppearanceId` field."""
  plateAppearanceId: UUID

  """Checks for equality with the object’s `runnerId` field."""
  runnerId: UUID
}

type StolenBaseAttempt implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  runnerId: UUID!
  success: Boolean!

  """Reads a single `Player` that is related to this `StolenBaseAttempt`."""
  runner: Player
}

"""Methods to use when ordering `StolenBaseAttempt`."""
enum StolenBaseAttemptsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  RUNNER_ID_ASC
  RUNNER_ID_DESC
  SUCCESS_ASC
  SUCCESS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `StolenBaseAttempt` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input StolenBaseAttemptCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `runnerId` field."""
  runnerId: UUID

  """Checks for equality with the object’s `success` field."""
  success: Boolean
}

"""Methods to use when ordering `GameState`."""
enum GameStatesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  GAME_ID_ASC
  GAME_ID_DESC
  GAME_STATE_INDEX_ASC
  GAME_STATE_INDEX_DESC
  PLAYER_AT_BAT_ASC
  PLAYER_AT_BAT_DESC
  INNING_ASC
  INNING_DESC
  HALF_INNING_ASC
  HALF_INNING_DESC
  OUTS_ASC
  OUTS_DESC
  SCORE_ASC
  SCORE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `GameState` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input GameStateCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `gameId` field."""
  gameId: UUID

  """Checks for equality with the object’s `gameStateIndex` field."""
  gameStateIndex: Int

  """Checks for equality with the object’s `playerAtBat` field."""
  playerAtBat: UUID

  """Checks for equality with the object’s `inning` field."""
  inning: Int

  """Checks for equality with the object’s `halfInning` field."""
  halfInning: HalfInning

  """Checks for equality with the object’s `outs` field."""
  outs: Int

  """Checks for equality with the object’s `score` field."""
  score: [Int]
}

"""Methods to use when ordering `BaseRunner`."""
enum BaseRunnersOrderBy {
  NATURAL
  GAME_STATE_ID_ASC
  GAME_STATE_ID_DESC
  RUNNER_ID_ASC
  RUNNER_ID_DESC
  BASE_ASC
  BASE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `BaseRunner` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input BaseRunnerCondition {
  """Checks for equality with the object’s `gameStateId` field."""
  gameStateId: UUID

  """Checks for equality with the object’s `runnerId` field."""
  runnerId: UUID

  """Checks for equality with the object’s `base` field."""
  base: BaseType
}

type ScoredRunner implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  gameEventRecordId: UUID!
  runnerId: UUID!
  battedIn: Boolean!

  """
  Reads a single `GameEventRecord` that is related to this `ScoredRunner`.
  """
  gameEventRecord: GameEventRecord

  """Reads a single `Player` that is related to this `ScoredRunner`."""
  runner: Player
}

type GameEventRecord implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  gameId: UUID!
  eventIndex: Int!
  gameStateBeforeId: UUID!
  gameStateAfterId: UUID!
  gameEventId: UUID!
  notes: String

  """Reads a single `Game` that is related to this `GameEventRecord`."""
  game: Game

  """Reads a single `GameState` that is related to this `GameEventRecord`."""
  gameStateBefore: GameState

  """Reads a single `GameState` that is related to this `GameEventRecord`."""
  gameStateAfter: GameState

  """Reads a single `GameEvent` that is related to this `GameEventRecord`."""
  gameEvent: GameEvent

  """Reads and enables pagination through a set of `ScoredRunner`."""
  scoredRunners(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `ScoredRunner`."""
    orderBy: [ScoredRunnersOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ScoredRunnerCondition
  ): [ScoredRunner!]!
}

type GameEvent implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  plateAppearanceId: UUID
  stolenBaseAttemptId: UUID
  lineupChangeId: UUID

  """Reads a single `PlateAppearance` that is related to this `GameEvent`."""
  plateAppearance: PlateAppearance

  """
  Reads a single `StolenBaseAttempt` that is related to this `GameEvent`.
  """
  stolenBaseAttempt: StolenBaseAttempt

  """Reads a single `LineupChange` that is related to this `GameEvent`."""
  lineupChange: LineupChange

  """Reads and enables pagination through a set of `GameEventRecord`."""
  gameEventRecords(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `GameEventRecord`."""
    orderBy: [GameEventRecordsOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GameEventRecordCondition
  ): [GameEventRecord!]!
}

"""Methods to use when ordering `GameEventRecord`."""
enum GameEventRecordsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  GAME_ID_ASC
  GAME_ID_DESC
  EVENT_INDEX_ASC
  EVENT_INDEX_DESC
  GAME_STATE_BEFORE_ID_ASC
  GAME_STATE_BEFORE_ID_DESC
  GAME_STATE_AFTER_ID_ASC
  GAME_STATE_AFTER_ID_DESC
  GAME_EVENT_ID_ASC
  GAME_EVENT_ID_DESC
  NOTES_ASC
  NOTES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `GameEventRecord` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input GameEventRecordCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `gameId` field."""
  gameId: UUID

  """Checks for equality with the object’s `eventIndex` field."""
  eventIndex: Int

  """Checks for equality with the object’s `gameStateBeforeId` field."""
  gameStateBeforeId: UUID

  """Checks for equality with the object’s `gameStateAfterId` field."""
  gameStateAfterId: UUID

  """Checks for equality with the object’s `gameEventId` field."""
  gameEventId: UUID

  """Checks for equality with the object’s `notes` field."""
  notes: String
}

"""Methods to use when ordering `ScoredRunner`."""
enum ScoredRunnersOrderBy {
  NATURAL
  GAME_EVENT_RECORD_ID_ASC
  GAME_EVENT_RECORD_ID_DESC
  RUNNER_ID_ASC
  RUNNER_ID_DESC
  BATTED_IN_ASC
  BATTED_IN_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ScoredRunner` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ScoredRunnerCondition {
  """Checks for equality with the object’s `gameEventRecordId` field."""
  gameEventRecordId: UUID

  """Checks for equality with the object’s `runnerId` field."""
  runnerId: UUID

  """Checks for equality with the object’s `battedIn` field."""
  battedIn: Boolean
}

type TraditionalStatLine {
  playerId: UUID
  games: Int
  plateAppearances: Int
  atBats: Int
  hits: Int
  singles: Int
  doubles: Int
  triples: Int
  homeruns: Int
  walks: Int
  strikeouts: Int
  sacFlies: Int
  gidp: Int
  runs: Int
  rbi: Int
  battingAverage: Float
  onBasePct: Float
  sluggingPct: Float
  ops: Float
}

"""Methods to use when ordering `Game`."""
enum GamesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  GROUP_ID_ASC
  GROUP_ID_DESC
  NAME_ASC
  NAME_DESC
  FIELD_ID_ASC
  FIELD_ID_DESC
  SCORE_ASC
  SCORE_DESC
  GAME_LENGTH_ASC
  GAME_LENGTH_DESC
  TIME_STARTED_ASC
  TIME_STARTED_DESC
  TIME_ENDED_ASC
  TIME_ENDED_DESC
  TIME_SAVED_ASC
  TIME_SAVED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Game` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input GameCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `groupId` field."""
  groupId: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `fieldId` field."""
  fieldId: UUID

  """Checks for equality with the object’s `score` field."""
  score: [Int]

  """Checks for equality with the object’s `gameLength` field."""
  gameLength: Int

  """Checks for equality with the object’s `timeStarted` field."""
  timeStarted: Datetime

  """Checks for equality with the object’s `timeEnded` field."""
  timeEnded: Datetime

  """Checks for equality with the object’s `timeSaved` field."""
  timeSaved: Datetime
}

type Field implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  name: String!
  notes: String

  """Reads and enables pagination through a set of `Game`."""
  games(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Game`."""
    orderBy: [GamesOrderBy!]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GameCondition
  ): [Game!]!
}

type LineScoreCell {
  inning: Int
  halfInning: HalfInning
  runs: Int
  hits: Int
}

"""Methods to use when ordering `Field`."""
enum FieldsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  NOTES_ASC
  NOTES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Field` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input FieldCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `notes` field."""
  notes: String
}

"""Methods to use when ordering `GameEvent`."""
enum GameEventsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  PLATE_APPEARANCE_ID_ASC
  PLATE_APPEARANCE_ID_DESC
  STOLEN_BASE_ATTEMPT_ID_ASC
  STOLEN_BASE_ATTEMPT_ID_DESC
  LINEUP_CHANGE_ID_ASC
  LINEUP_CHANGE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `GameEvent` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input GameEventCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `plateAppearanceId` field."""
  plateAppearanceId: UUID

  """Checks for equality with the object’s `stolenBaseAttemptId` field."""
  stolenBaseAttemptId: UUID

  """Checks for equality with the object’s `lineupChangeId` field."""
  lineupChangeId: UUID
}

"""Methods to use when ordering `Group`."""
enum GroupsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  NOTES_ASC
  NOTES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Group` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input GroupCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `notes` field."""
  notes: String
}

type LegacyField implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  fieldId: Int!
  fieldName: String!
  fieldAddress: String!
  fieldNumber: String
}

"""Methods to use when ordering `LegacyField`."""
enum LegacyFieldsOrderBy {
  NATURAL
  FIELD_ID_ASC
  FIELD_ID_DESC
  FIELD_NAME_ASC
  FIELD_NAME_DESC
  FIELD_ADDRESS_ASC
  FIELD_ADDRESS_DESC
  FIELD_NUMBER_ASC
  FIELD_NUMBER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `LegacyField` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input LegacyFieldCondition {
  """Checks for equality with the object’s `fieldId` field."""
  fieldId: Int

  """Checks for equality with the object’s `fieldName` field."""
  fieldName: String

  """Checks for equality with the object’s `fieldAddress` field."""
  fieldAddress: String

  """Checks for equality with the object’s `fieldNumber` field."""
  fieldNumber: String
}

"""Methods to use when ordering `LegacyGame`."""
enum LegacyGamesOrderBy {
  NATURAL
  GAME_ID_ASC
  GAME_ID_DESC
  GAME_TITLE_ASC
  GAME_TITLE_DESC
  GAME_DATE_ASC
  GAME_DATE_DESC
  GAME_START_TIME_ASC
  GAME_START_TIME_DESC
  GAME_END_TIME_ASC
  GAME_END_TIME_DESC
  GAME_TEAM_ID_1_ASC
  GAME_TEAM_ID_1_DESC
  GAME_TEAM_ID_2_ASC
  GAME_TEAM_ID_2_DESC
  SEASON_ASC
  SEASON_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `LegacyGame` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input LegacyGameCondition {
  """Checks for equality with the object’s `gameId` field."""
  gameId: Int

  """Checks for equality with the object’s `gameTitle` field."""
  gameTitle: String

  """Checks for equality with the object’s `gameDate` field."""
  gameDate: Date

  """Checks for equality with the object’s `gameStartTime` field."""
  gameStartTime: Time

  """Checks for equality with the object’s `gameEndTime` field."""
  gameEndTime: Time

  """Checks for equality with the object’s `gameTeamId1` field."""
  gameTeamId1: Int

  """Checks for equality with the object’s `gameTeamId2` field."""
  gameTeamId2: Int

  """Checks for equality with the object’s `season` field."""
  season: Int
}

"""Methods to use when ordering `LegacyPlayer`."""
enum LegacyPlayersOrderBy {
  NATURAL
  PLAYER_ID_ASC
  PLAYER_ID_DESC
  PLAYER_NAME_ASC
  PLAYER_NAME_DESC
  PLAYER_IMAGE_ASC
  PLAYER_IMAGE_DESC
  MEMBER_ID_ASC
  MEMBER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `LegacyPlayer` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input LegacyPlayerCondition {
  """Checks for equality with the object’s `playerId` field."""
  playerId: Int

  """Checks for equality with the object’s `playerName` field."""
  playerName: String

  """Checks for equality with the object’s `playerImage` field."""
  playerImage: String

  """Checks for equality with the object’s `memberId` field."""
  memberId: String
}

"""Methods to use when ordering `LegacyTeam`."""
enum LegacyTeamsOrderBy {
  NATURAL
  TEAM_ID_ASC
  TEAM_ID_DESC
  TEAM_NAME_ASC
  TEAM_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `LegacyTeam` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input LegacyTeamCondition {
  """Checks for equality with the object’s `teamId` field."""
  teamId: Int

  """Checks for equality with the object’s `teamName` field."""
  teamName: String
}

"""Methods to use when ordering `PlateAppearance`."""
enum PlateAppearancesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TYPE_ASC
  TYPE_DESC
  CONTACT_ASC
  CONTACT_DESC
  FIELDED_BY_ASC
  FIELDED_BY_DESC
  RUNS_SCORED_ON_SAC_FLY_ASC
  RUNS_SCORED_ON_SAC_FLY_DESC
  ROUTINE_PLAY_ASC
  ROUTINE_PLAY_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `PlateAppearance` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input PlateAppearanceCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `type` field."""
  type: PlateAppearanceType

  """Checks for equality with the object’s `contact` field."""
  contact: ContactQuality

  """Checks for equality with the object’s `fieldedBy` field."""
  fieldedBy: FieldingPosition

  """Checks for equality with the object’s `runsScoredOnSacFly` field."""
  runsScoredOnSacFly: Int

  """Checks for equality with the object’s `routinePlay` field."""
  routinePlay: Boolean
}

"""The return type of our `getPlateAppearancesConnection` query."""
type GetPlateAppearancesRecord {
  gameId: UUID
  gameStartTime: Datetime
  playerId: UUID
  type: PlateAppearanceType
  contact: ContactQuality
  hitTo: FieldingPosition
  runsScored: Int
  inning: Int
  halfInning: HalfInning
  gameStateBeforeId: UUID
  gameEventRecordId: UUID
}

"""The return type of our `getRunsScoredConnection` query."""
type GetRunsScoredRecord {
  batterId: UUID
  runnerId: UUID
  battedIn: Boolean
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `BaseRunner`."""
  createBaseRunner(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateBaseRunnerInput!
  ): CreateBaseRunnerPayload

  """Creates a single `BasepathMovement`."""
  createBasepathMovement(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateBasepathMovementInput!
  ): CreateBasepathMovementPayload

  """Creates a single `Field`."""
  createField(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateFieldInput!
  ): CreateFieldPayload

  """Creates a single `Game`."""
  createGame(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateGameInput!
  ): CreateGamePayload

  """Creates a single `GameEvent`."""
  createGameEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateGameEventInput!
  ): CreateGameEventPayload

  """Creates a single `GameEventRecord`."""
  createGameEventRecord(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateGameEventRecordInput!
  ): CreateGameEventRecordPayload

  """Creates a single `GameState`."""
  createGameState(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateGameStateInput!
  ): CreateGameStatePayload

  """Creates a single `Group`."""
  createGroup(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateGroupInput!
  ): CreateGroupPayload

  """Creates a single `LegacyField`."""
  createLegacyField(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLegacyFieldInput!
  ): CreateLegacyFieldPayload

  """Creates a single `LegacyGame`."""
  createLegacyGame(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLegacyGameInput!
  ): CreateLegacyGamePayload

  """Creates a single `LegacyPlayer`."""
  createLegacyPlayer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLegacyPlayerInput!
  ): CreateLegacyPlayerPayload

  """Creates a single `LegacyStatLine`."""
  createLegacyStatLine(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLegacyStatLineInput!
  ): CreateLegacyStatLinePayload

  """Creates a single `LegacyTeam`."""
  createLegacyTeam(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLegacyTeamInput!
  ): CreateLegacyTeamPayload

  """Creates a single `Lineup`."""
  createLineup(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLineupInput!
  ): CreateLineupPayload

  """Creates a single `LineupChange`."""
  createLineupChange(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLineupChangeInput!
  ): CreateLineupChangePayload

  """Creates a single `LineupForGameState`."""
  createLineupForGameState(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLineupForGameStateInput!
  ): CreateLineupForGameStatePayload

  """Creates a single `LineupSpot`."""
  createLineupSpot(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLineupSpotInput!
  ): CreateLineupSpotPayload

  """Creates a single `OutOnPlayRunner`."""
  createOutOnPlayRunner(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateOutOnPlayRunnerInput!
  ): CreateOutOnPlayRunnerPayload

  """Creates a single `PlateAppearance`."""
  createPlateAppearance(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePlateAppearanceInput!
  ): CreatePlateAppearancePayload

  """Creates a single `Player`."""
  createPlayer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePlayerInput!
  ): CreatePlayerPayload

  """Creates a single `ScoredRunner`."""
  createScoredRunner(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateScoredRunnerInput!
  ): CreateScoredRunnerPayload

  """Creates a single `StolenBaseAttempt`."""
  createStolenBaseAttempt(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStolenBaseAttemptInput!
  ): CreateStolenBaseAttemptPayload

  """Creates a single `Team`."""
  createTeam(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTeamInput!
  ): CreateTeamPayload

  """
  Updates a single `BaseRunner` using its globally unique id and a patch.
  """
  updateBaseRunnerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateBaseRunnerByNodeIdInput!
  ): UpdateBaseRunnerPayload

  """Updates a single `BaseRunner` using a unique key and a patch."""
  updateBaseRunner(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateBaseRunnerInput!
  ): UpdateBaseRunnerPayload

  """
  Updates a single `BasepathMovement` using its globally unique id and a patch.
  """
  updateBasepathMovementByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateBasepathMovementByNodeIdInput!
  ): UpdateBasepathMovementPayload

  """Updates a single `BasepathMovement` using a unique key and a patch."""
  updateBasepathMovement(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateBasepathMovementInput!
  ): UpdateBasepathMovementPayload

  """Updates a single `Field` using its globally unique id and a patch."""
  updateFieldByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateFieldByNodeIdInput!
  ): UpdateFieldPayload

  """Updates a single `Field` using a unique key and a patch."""
  updateField(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateFieldInput!
  ): UpdateFieldPayload

  """Updates a single `Game` using its globally unique id and a patch."""
  updateGameByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGameByNodeIdInput!
  ): UpdateGamePayload

  """Updates a single `Game` using a unique key and a patch."""
  updateGame(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGameInput!
  ): UpdateGamePayload

  """Updates a single `Game` using a unique key and a patch."""
  updateGameByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGameByNameInput!
  ): UpdateGamePayload

  """Updates a single `GameEvent` using its globally unique id and a patch."""
  updateGameEventByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGameEventByNodeIdInput!
  ): UpdateGameEventPayload

  """Updates a single `GameEvent` using a unique key and a patch."""
  updateGameEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGameEventInput!
  ): UpdateGameEventPayload

  """
  Updates a single `GameEventRecord` using its globally unique id and a patch.
  """
  updateGameEventRecordByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGameEventRecordByNodeIdInput!
  ): UpdateGameEventRecordPayload

  """Updates a single `GameEventRecord` using a unique key and a patch."""
  updateGameEventRecord(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGameEventRecordInput!
  ): UpdateGameEventRecordPayload

  """Updates a single `GameEventRecord` using a unique key and a patch."""
  updateGameEventRecordByGameIdAndEventIndex(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGameEventRecordByGameIdAndEventIndexInput!
  ): UpdateGameEventRecordPayload

  """Updates a single `GameState` using its globally unique id and a patch."""
  updateGameStateByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGameStateByNodeIdInput!
  ): UpdateGameStatePayload

  """Updates a single `GameState` using a unique key and a patch."""
  updateGameState(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGameStateInput!
  ): UpdateGameStatePayload

  """Updates a single `Group` using its globally unique id and a patch."""
  updateGroupByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGroupByNodeIdInput!
  ): UpdateGroupPayload

  """Updates a single `Group` using a unique key and a patch."""
  updateGroup(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGroupInput!
  ): UpdateGroupPayload

  """Updates a single `Group` using a unique key and a patch."""
  updateGroupByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGroupByNameInput!
  ): UpdateGroupPayload

  """
  Updates a single `LegacyField` using its globally unique id and a patch.
  """
  updateLegacyFieldByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLegacyFieldByNodeIdInput!
  ): UpdateLegacyFieldPayload

  """Updates a single `LegacyField` using a unique key and a patch."""
  updateLegacyField(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLegacyFieldInput!
  ): UpdateLegacyFieldPayload

  """
  Updates a single `LegacyGame` using its globally unique id and a patch.
  """
  updateLegacyGameByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLegacyGameByNodeIdInput!
  ): UpdateLegacyGamePayload

  """Updates a single `LegacyGame` using a unique key and a patch."""
  updateLegacyGame(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLegacyGameInput!
  ): UpdateLegacyGamePayload

  """
  Updates a single `LegacyPlayer` using its globally unique id and a patch.
  """
  updateLegacyPlayerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLegacyPlayerByNodeIdInput!
  ): UpdateLegacyPlayerPayload

  """Updates a single `LegacyPlayer` using a unique key and a patch."""
  updateLegacyPlayer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLegacyPlayerInput!
  ): UpdateLegacyPlayerPayload

  """
  Updates a single `LegacyTeam` using its globally unique id and a patch.
  """
  updateLegacyTeamByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLegacyTeamByNodeIdInput!
  ): UpdateLegacyTeamPayload

  """Updates a single `LegacyTeam` using a unique key and a patch."""
  updateLegacyTeam(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLegacyTeamInput!
  ): UpdateLegacyTeamPayload

  """Updates a single `Lineup` using its globally unique id and a patch."""
  updateLineupByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLineupByNodeIdInput!
  ): UpdateLineupPayload

  """Updates a single `Lineup` using a unique key and a patch."""
  updateLineup(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLineupInput!
  ): UpdateLineupPayload

  """
  Updates a single `LineupChange` using its globally unique id and a patch.
  """
  updateLineupChangeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLineupChangeByNodeIdInput!
  ): UpdateLineupChangePayload

  """Updates a single `LineupChange` using a unique key and a patch."""
  updateLineupChange(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLineupChangeInput!
  ): UpdateLineupChangePayload

  """
  Updates a single `LineupForGameState` using its globally unique id and a patch.
  """
  updateLineupForGameStateByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLineupForGameStateByNodeIdInput!
  ): UpdateLineupForGameStatePayload

  """Updates a single `LineupForGameState` using a unique key and a patch."""
  updateLineupForGameState(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLineupForGameStateInput!
  ): UpdateLineupForGameStatePayload

  """
  Updates a single `LineupSpot` using its globally unique id and a patch.
  """
  updateLineupSpotByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLineupSpotByNodeIdInput!
  ): UpdateLineupSpotPayload

  """Updates a single `LineupSpot` using a unique key and a patch."""
  updateLineupSpot(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLineupSpotInput!
  ): UpdateLineupSpotPayload

  """Updates a single `LineupSpot` using a unique key and a patch."""
  updateLineupSpotByLineupIdAndBattingOrder(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLineupSpotByLineupIdAndBattingOrderInput!
  ): UpdateLineupSpotPayload

  """Updates a single `LineupSpot` using a unique key and a patch."""
  updateLineupSpotByLineupIdAndPosition(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLineupSpotByLineupIdAndPositionInput!
  ): UpdateLineupSpotPayload

  """
  Updates a single `OutOnPlayRunner` using its globally unique id and a patch.
  """
  updateOutOnPlayRunnerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOutOnPlayRunnerByNodeIdInput!
  ): UpdateOutOnPlayRunnerPayload

  """Updates a single `OutOnPlayRunner` using a unique key and a patch."""
  updateOutOnPlayRunner(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOutOnPlayRunnerInput!
  ): UpdateOutOnPlayRunnerPayload

  """
  Updates a single `PlateAppearance` using its globally unique id and a patch.
  """
  updatePlateAppearanceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlateAppearanceByNodeIdInput!
  ): UpdatePlateAppearancePayload

  """Updates a single `PlateAppearance` using a unique key and a patch."""
  updatePlateAppearance(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlateAppearanceInput!
  ): UpdatePlateAppearancePayload

  """Updates a single `Player` using its globally unique id and a patch."""
  updatePlayerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlayerByNodeIdInput!
  ): UpdatePlayerPayload

  """Updates a single `Player` using a unique key and a patch."""
  updatePlayer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlayerInput!
  ): UpdatePlayerPayload

  """Updates a single `Player` using a unique key and a patch."""
  updatePlayerByFirstNameAndLastName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlayerByFirstNameAndLastNameInput!
  ): UpdatePlayerPayload

  """
  Updates a single `ScoredRunner` using its globally unique id and a patch.
  """
  updateScoredRunnerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateScoredRunnerByNodeIdInput!
  ): UpdateScoredRunnerPayload

  """Updates a single `ScoredRunner` using a unique key and a patch."""
  updateScoredRunner(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateScoredRunnerInput!
  ): UpdateScoredRunnerPayload

  """
  Updates a single `StolenBaseAttempt` using its globally unique id and a patch.
  """
  updateStolenBaseAttemptByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStolenBaseAttemptByNodeIdInput!
  ): UpdateStolenBaseAttemptPayload

  """Updates a single `StolenBaseAttempt` using a unique key and a patch."""
  updateStolenBaseAttempt(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStolenBaseAttemptInput!
  ): UpdateStolenBaseAttemptPayload

  """Updates a single `Team` using its globally unique id and a patch."""
  updateTeamByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamByNodeIdInput!
  ): UpdateTeamPayload

  """Updates a single `Team` using a unique key and a patch."""
  updateTeam(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamInput!
  ): UpdateTeamPayload

  """Updates a single `Team` using a unique key and a patch."""
  updateTeamByGameIdAndRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTeamByGameIdAndRoleInput!
  ): UpdateTeamPayload

  """Deletes a single `BaseRunner` using its globally unique id."""
  deleteBaseRunnerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteBaseRunnerByNodeIdInput!
  ): DeleteBaseRunnerPayload

  """Deletes a single `BaseRunner` using a unique key."""
  deleteBaseRunner(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteBaseRunnerInput!
  ): DeleteBaseRunnerPayload

  """Deletes a single `BasepathMovement` using its globally unique id."""
  deleteBasepathMovementByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteBasepathMovementByNodeIdInput!
  ): DeleteBasepathMovementPayload

  """Deletes a single `BasepathMovement` using a unique key."""
  deleteBasepathMovement(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteBasepathMovementInput!
  ): DeleteBasepathMovementPayload

  """Deletes a single `Field` using its globally unique id."""
  deleteFieldByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteFieldByNodeIdInput!
  ): DeleteFieldPayload

  """Deletes a single `Field` using a unique key."""
  deleteField(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteFieldInput!
  ): DeleteFieldPayload

  """Deletes a single `Game` using its globally unique id."""
  deleteGameByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGameByNodeIdInput!
  ): DeleteGamePayload

  """Deletes a single `Game` using a unique key."""
  deleteGame(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGameInput!
  ): DeleteGamePayload

  """Deletes a single `Game` using a unique key."""
  deleteGameByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGameByNameInput!
  ): DeleteGamePayload

  """Deletes a single `GameEvent` using its globally unique id."""
  deleteGameEventByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGameEventByNodeIdInput!
  ): DeleteGameEventPayload

  """Deletes a single `GameEvent` using a unique key."""
  deleteGameEvent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGameEventInput!
  ): DeleteGameEventPayload

  """Deletes a single `GameEventRecord` using its globally unique id."""
  deleteGameEventRecordByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGameEventRecordByNodeIdInput!
  ): DeleteGameEventRecordPayload

  """Deletes a single `GameEventRecord` using a unique key."""
  deleteGameEventRecord(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGameEventRecordInput!
  ): DeleteGameEventRecordPayload

  """Deletes a single `GameEventRecord` using a unique key."""
  deleteGameEventRecordByGameIdAndEventIndex(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGameEventRecordByGameIdAndEventIndexInput!
  ): DeleteGameEventRecordPayload

  """Deletes a single `GameState` using its globally unique id."""
  deleteGameStateByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGameStateByNodeIdInput!
  ): DeleteGameStatePayload

  """Deletes a single `GameState` using a unique key."""
  deleteGameState(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGameStateInput!
  ): DeleteGameStatePayload

  """Deletes a single `Group` using its globally unique id."""
  deleteGroupByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGroupByNodeIdInput!
  ): DeleteGroupPayload

  """Deletes a single `Group` using a unique key."""
  deleteGroup(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGroupInput!
  ): DeleteGroupPayload

  """Deletes a single `Group` using a unique key."""
  deleteGroupByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGroupByNameInput!
  ): DeleteGroupPayload

  """Deletes a single `LegacyField` using its globally unique id."""
  deleteLegacyFieldByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLegacyFieldByNodeIdInput!
  ): DeleteLegacyFieldPayload

  """Deletes a single `LegacyField` using a unique key."""
  deleteLegacyField(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLegacyFieldInput!
  ): DeleteLegacyFieldPayload

  """Deletes a single `LegacyGame` using its globally unique id."""
  deleteLegacyGameByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLegacyGameByNodeIdInput!
  ): DeleteLegacyGamePayload

  """Deletes a single `LegacyGame` using a unique key."""
  deleteLegacyGame(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLegacyGameInput!
  ): DeleteLegacyGamePayload

  """Deletes a single `LegacyPlayer` using its globally unique id."""
  deleteLegacyPlayerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLegacyPlayerByNodeIdInput!
  ): DeleteLegacyPlayerPayload

  """Deletes a single `LegacyPlayer` using a unique key."""
  deleteLegacyPlayer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLegacyPlayerInput!
  ): DeleteLegacyPlayerPayload

  """Deletes a single `LegacyTeam` using its globally unique id."""
  deleteLegacyTeamByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLegacyTeamByNodeIdInput!
  ): DeleteLegacyTeamPayload

  """Deletes a single `LegacyTeam` using a unique key."""
  deleteLegacyTeam(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLegacyTeamInput!
  ): DeleteLegacyTeamPayload

  """Deletes a single `Lineup` using its globally unique id."""
  deleteLineupByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLineupByNodeIdInput!
  ): DeleteLineupPayload

  """Deletes a single `Lineup` using a unique key."""
  deleteLineup(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLineupInput!
  ): DeleteLineupPayload

  """Deletes a single `LineupChange` using its globally unique id."""
  deleteLineupChangeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLineupChangeByNodeIdInput!
  ): DeleteLineupChangePayload

  """Deletes a single `LineupChange` using a unique key."""
  deleteLineupChange(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLineupChangeInput!
  ): DeleteLineupChangePayload

  """Deletes a single `LineupForGameState` using its globally unique id."""
  deleteLineupForGameStateByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLineupForGameStateByNodeIdInput!
  ): DeleteLineupForGameStatePayload

  """Deletes a single `LineupForGameState` using a unique key."""
  deleteLineupForGameState(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLineupForGameStateInput!
  ): DeleteLineupForGameStatePayload

  """Deletes a single `LineupSpot` using its globally unique id."""
  deleteLineupSpotByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLineupSpotByNodeIdInput!
  ): DeleteLineupSpotPayload

  """Deletes a single `LineupSpot` using a unique key."""
  deleteLineupSpot(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLineupSpotInput!
  ): DeleteLineupSpotPayload

  """Deletes a single `LineupSpot` using a unique key."""
  deleteLineupSpotByLineupIdAndBattingOrder(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLineupSpotByLineupIdAndBattingOrderInput!
  ): DeleteLineupSpotPayload

  """Deletes a single `LineupSpot` using a unique key."""
  deleteLineupSpotByLineupIdAndPosition(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLineupSpotByLineupIdAndPositionInput!
  ): DeleteLineupSpotPayload

  """Deletes a single `OutOnPlayRunner` using its globally unique id."""
  deleteOutOnPlayRunnerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOutOnPlayRunnerByNodeIdInput!
  ): DeleteOutOnPlayRunnerPayload

  """Deletes a single `OutOnPlayRunner` using a unique key."""
  deleteOutOnPlayRunner(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOutOnPlayRunnerInput!
  ): DeleteOutOnPlayRunnerPayload

  """Deletes a single `PlateAppearance` using its globally unique id."""
  deletePlateAppearanceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlateAppearanceByNodeIdInput!
  ): DeletePlateAppearancePayload

  """Deletes a single `PlateAppearance` using a unique key."""
  deletePlateAppearance(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlateAppearanceInput!
  ): DeletePlateAppearancePayload

  """Deletes a single `Player` using its globally unique id."""
  deletePlayerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlayerByNodeIdInput!
  ): DeletePlayerPayload

  """Deletes a single `Player` using a unique key."""
  deletePlayer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlayerInput!
  ): DeletePlayerPayload

  """Deletes a single `Player` using a unique key."""
  deletePlayerByFirstNameAndLastName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlayerByFirstNameAndLastNameInput!
  ): DeletePlayerPayload

  """Deletes a single `ScoredRunner` using its globally unique id."""
  deleteScoredRunnerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteScoredRunnerByNodeIdInput!
  ): DeleteScoredRunnerPayload

  """Deletes a single `ScoredRunner` using a unique key."""
  deleteScoredRunner(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteScoredRunnerInput!
  ): DeleteScoredRunnerPayload

  """Deletes a single `StolenBaseAttempt` using its globally unique id."""
  deleteStolenBaseAttemptByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStolenBaseAttemptByNodeIdInput!
  ): DeleteStolenBaseAttemptPayload

  """Deletes a single `StolenBaseAttempt` using a unique key."""
  deleteStolenBaseAttempt(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStolenBaseAttemptInput!
  ): DeleteStolenBaseAttemptPayload

  """Deletes a single `Team` using its globally unique id."""
  deleteTeamByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamByNodeIdInput!
  ): DeleteTeamPayload

  """Deletes a single `Team` using a unique key."""
  deleteTeam(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamInput!
  ): DeleteTeamPayload

  """Deletes a single `Team` using a unique key."""
  deleteTeamByGameIdAndRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTeamByGameIdAndRoleInput!
  ): DeleteTeamPayload
}

"""The output of our create `BaseRunner` mutation."""
type CreateBaseRunnerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BaseRunner` that was created by this mutation."""
  baseRunner: BaseRunner

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `GameState` that is related to this `BaseRunner`."""
  gameState: GameState

  """Reads a single `Player` that is related to this `BaseRunner`."""
  runner: Player
}

"""All input for the create `BaseRunner` mutation."""
input CreateBaseRunnerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `BaseRunner` to be created by this mutation."""
  baseRunner: BaseRunnerInput!
}

"""An input for mutations affecting `BaseRunner`"""
input BaseRunnerInput {
  gameStateId: UUID
  runnerId: UUID
  base: BaseType!
  gameState: BaseRunnerGameStateIdFkeyInput
  player: BaseRunnerRunnerIdFkeyInput
}

"""
Input for the nested mutation of `gameState` in the `BaseRunnerInput` mutation.
"""
input BaseRunnerGameStateIdFkeyInput {
  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  connectById: GameStateGameStatePkeyConnect

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  connectByNodeId: GameStateNodeIdConnect

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  deleteById: GameStateGameStatePkeyDelete

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  deleteByNodeId: GameStateNodeIdDelete

  """
  The primary key(s) and patch data for `gameState` for the far side of the relationship.
  """
  updateById: GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingGameStatePkeyUpdate

  """
  The primary key(s) and patch data for `gameState` for the far side of the relationship.
  """
  updateByNodeId: BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate

  """
  A `GameStateInput` object that will be created and connected to this object.
  """
  create: BaseRunnerGameStateIdFkeyGameStateCreateInput
}

"""The fields on `gameState` to look up the row to connect."""
input GameStateGameStatePkeyConnect {
  id: UUID!
}

"""The globally unique `ID` look up for the row to connect."""
input GameStateNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `gameState` to be connected.
  """
  nodeId: ID!
}

"""The fields on `gameState` to look up the row to delete."""
input GameStateGameStatePkeyDelete {
  id: UUID!
}

"""The globally unique `ID` look up for the row to delete."""
input GameStateNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `gameState` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `gameState` to look up the row to update."""
input GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingGameStatePkeyUpdate {
  """
  An object where the defined keys will be set on the `gameState` being updated.
  """
  patch: updateGameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `gameState` being updated.
"""
input updateGameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch {
  id: UUID
  gameId: UUID
  gameStateIndex: Int
  playerAtBat: UUID
  inning: Int
  halfInning: HalfInning
  outs: Int
  score: [Int]
  game: GameStateGameIdFkeyInput
  player: GameStatePlayerAtBatFkeyInput
  baseRunners: BaseRunnerGameStateIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateGameStateIdFkeyInverseInput
  gameEventRecordsToGameStateBeforeIdUsingId: GameEventRecordGameStateBeforeFkInverseInput
  gameEventRecordsToGameStateAfterIdUsingId: GameEventRecordGameStateAfterFkInverseInput
}

"""
Input for the nested mutation of `game` in the `GameStateInput` mutation.
"""
input GameStateGameIdFkeyInput {
  """The primary key(s) for `game` for the far side of the relationship."""
  connectById: GameGamePkeyConnect

  """The primary key(s) for `game` for the far side of the relationship."""
  connectByName: GameGameNameKeyConnect

  """The primary key(s) for `game` for the far side of the relationship."""
  connectByNodeId: GameNodeIdConnect

  """The primary key(s) for `game` for the far side of the relationship."""
  deleteById: GameGamePkeyDelete

  """The primary key(s) for `game` for the far side of the relationship."""
  deleteByName: GameGameNameKeyDelete

  """The primary key(s) for `game` for the far side of the relationship."""
  deleteByNodeId: GameNodeIdDelete

  """
  The primary key(s) and patch data for `game` for the far side of the relationship.
  """
  updateById: GameOnGameStateForGameStateGameIdFkeyUsingGamePkeyUpdate

  """
  The primary key(s) and patch data for `game` for the far side of the relationship.
  """
  updateByName: GameOnGameStateForGameStateGameIdFkeyUsingGameNameKeyUpdate

  """
  The primary key(s) and patch data for `game` for the far side of the relationship.
  """
  updateByNodeId: GameStateOnGameStateForGameStateGameIdFkeyNodeIdUpdate

  """
  A `GameInput` object that will be created and connected to this object.
  """
  create: GameStateGameIdFkeyGameCreateInput
}

"""The fields on `game` to look up the row to connect."""
input GameGamePkeyConnect {
  id: UUID!
}

"""The fields on `game` to look up the row to connect."""
input GameGameNameKeyConnect {
  name: String!
}

"""The globally unique `ID` look up for the row to connect."""
input GameNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `game` to be connected.
  """
  nodeId: ID!
}

"""The fields on `game` to look up the row to delete."""
input GameGamePkeyDelete {
  id: UUID!
}

"""The fields on `game` to look up the row to delete."""
input GameGameNameKeyDelete {
  name: String!
}

"""The globally unique `ID` look up for the row to delete."""
input GameNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `game` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `game` to look up the row to update."""
input GameOnGameStateForGameStateGameIdFkeyUsingGamePkeyUpdate {
  """
  An object where the defined keys will be set on the `game` being updated.
  """
  patch: updateGameOnGameStateForGameStateGameIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `game` being updated.
"""
input updateGameOnGameStateForGameStateGameIdFkeyPatch {
  id: UUID
  groupId: UUID
  name: String
  fieldId: UUID
  score: [Int]
  gameLength: Int
  timeStarted: Datetime
  timeEnded: Datetime
  timeSaved: Datetime
  group: GameGroupIdFkeyInput
  field: GameFieldIdFkeyInput
  teams: TeamGameIdFkeyInverseInput
  gameStates: GameStateGameIdFkeyInverseInput
  gameEventRecords: GameEventRecordGameIdFkeyInverseInput
}

"""Input for the nested mutation of `group` in the `GameInput` mutation."""
input GameGroupIdFkeyInput {
  """The primary key(s) for `group` for the far side of the relationship."""
  connectById: GroupGroupPkeyConnect

  """The primary key(s) for `group` for the far side of the relationship."""
  connectByName: GroupGroupNameKeyConnect

  """The primary key(s) for `group` for the far side of the relationship."""
  connectByNodeId: GroupNodeIdConnect

  """The primary key(s) for `group` for the far side of the relationship."""
  deleteById: GroupGroupPkeyDelete

  """The primary key(s) for `group` for the far side of the relationship."""
  deleteByName: GroupGroupNameKeyDelete

  """The primary key(s) for `group` for the far side of the relationship."""
  deleteByNodeId: GroupNodeIdDelete

  """
  The primary key(s) and patch data for `group` for the far side of the relationship.
  """
  updateById: GroupOnGameForGameGroupIdFkeyUsingGroupPkeyUpdate

  """
  The primary key(s) and patch data for `group` for the far side of the relationship.
  """
  updateByName: GroupOnGameForGameGroupIdFkeyUsingGroupNameKeyUpdate

  """
  The primary key(s) and patch data for `group` for the far side of the relationship.
  """
  updateByNodeId: GameOnGameForGameGroupIdFkeyNodeIdUpdate

  """
  A `GroupInput` object that will be created and connected to this object.
  """
  create: GameGroupIdFkeyGroupCreateInput
}

"""The fields on `group` to look up the row to connect."""
input GroupGroupPkeyConnect {
  id: UUID!
}

"""The fields on `group` to look up the row to connect."""
input GroupGroupNameKeyConnect {
  name: String!
}

"""The globally unique `ID` look up for the row to connect."""
input GroupNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `group` to be connected.
  """
  nodeId: ID!
}

"""The fields on `group` to look up the row to delete."""
input GroupGroupPkeyDelete {
  id: UUID!
}

"""The fields on `group` to look up the row to delete."""
input GroupGroupNameKeyDelete {
  name: String!
}

"""The globally unique `ID` look up for the row to delete."""
input GroupNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `group` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `group` to look up the row to update."""
input GroupOnGameForGameGroupIdFkeyUsingGroupPkeyUpdate {
  """
  An object where the defined keys will be set on the `group` being updated.
  """
  patch: updateGroupOnGameForGameGroupIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `group` being updated.
"""
input updateGroupOnGameForGameGroupIdFkeyPatch {
  id: UUID
  name: String
  notes: String
  players: PlayerGroupIdFkeyInverseInput
  games: GameGroupIdFkeyInverseInput
}

"""
Input for the nested mutation of `player` in the `GroupInput` mutation.
"""
input PlayerGroupIdFkeyInverseInput {
  """
  Flag indicating whether all other `player` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """The primary key(s) for `player` for the far side of the relationship."""
  connectById: [PlayerPlayerPkeyConnect!]

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByFirstNameAndLastName: [PlayerPlayerFirstNameLastNameKeyConnect!]

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByNodeId: [PlayerNodeIdConnect!]

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteById: [PlayerPlayerPkeyDelete!]

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByFirstNameAndLastName: [PlayerPlayerFirstNameLastNameKeyDelete!]

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByNodeId: [PlayerNodeIdDelete!]

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateById: [PlayerOnPlayerForPlayerGroupIdFkeyUsingPlayerPkeyUpdate!]

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByFirstNameAndLastName: [PlayerOnPlayerForPlayerGroupIdFkeyUsingPlayerFirstNameLastNameKeyUpdate!]

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByNodeId: [GroupOnPlayerForPlayerGroupIdFkeyNodeIdUpdate!]

  """
  A `PlayerInput` object that will be created and connected to this object.
  """
  create: [PlayerGroupIdFkeyPlayerCreateInput!]
}

"""The fields on `player` to look up the row to connect."""
input PlayerPlayerPkeyConnect {
  id: UUID!
}

"""The fields on `player` to look up the row to connect."""
input PlayerPlayerFirstNameLastNameKeyConnect {
  firstName: String!
  lastName: String!
}

"""The globally unique `ID` look up for the row to connect."""
input PlayerNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `player` to be connected.
  """
  nodeId: ID!
}

"""The fields on `player` to look up the row to delete."""
input PlayerPlayerPkeyDelete {
  id: UUID!
}

"""The fields on `player` to look up the row to delete."""
input PlayerPlayerFirstNameLastNameKeyDelete {
  firstName: String!
  lastName: String!
}

"""The globally unique `ID` look up for the row to delete."""
input PlayerNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `player` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `player` to look up the row to update."""
input PlayerOnPlayerForPlayerGroupIdFkeyUsingPlayerPkeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnPlayerForPlayerGroupIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `player` being updated.
"""
input updatePlayerOnPlayerForPlayerGroupIdFkeyPatch {
  id: UUID
  legacyPlayerId: Int
  firstName: String
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""
Input for the nested mutation of `group` in the `PlayerInput` mutation.
"""
input PlayerGroupIdFkeyInput {
  """The primary key(s) for `group` for the far side of the relationship."""
  connectById: GroupGroupPkeyConnect

  """The primary key(s) for `group` for the far side of the relationship."""
  connectByName: GroupGroupNameKeyConnect

  """The primary key(s) for `group` for the far side of the relationship."""
  connectByNodeId: GroupNodeIdConnect

  """The primary key(s) for `group` for the far side of the relationship."""
  deleteById: GroupGroupPkeyDelete

  """The primary key(s) for `group` for the far side of the relationship."""
  deleteByName: GroupGroupNameKeyDelete

  """The primary key(s) for `group` for the far side of the relationship."""
  deleteByNodeId: GroupNodeIdDelete

  """
  The primary key(s) and patch data for `group` for the far side of the relationship.
  """
  updateById: GroupOnPlayerForPlayerGroupIdFkeyUsingGroupPkeyUpdate

  """
  The primary key(s) and patch data for `group` for the far side of the relationship.
  """
  updateByName: GroupOnPlayerForPlayerGroupIdFkeyUsingGroupNameKeyUpdate

  """
  The primary key(s) and patch data for `group` for the far side of the relationship.
  """
  updateByNodeId: PlayerOnPlayerForPlayerGroupIdFkeyNodeIdUpdate

  """
  A `GroupInput` object that will be created and connected to this object.
  """
  create: PlayerGroupIdFkeyGroupCreateInput
}

"""The fields on `group` to look up the row to update."""
input GroupOnPlayerForPlayerGroupIdFkeyUsingGroupPkeyUpdate {
  """
  An object where the defined keys will be set on the `group` being updated.
  """
  patch: updateGroupOnPlayerForPlayerGroupIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `group` being updated.
"""
input updateGroupOnPlayerForPlayerGroupIdFkeyPatch {
  id: UUID
  name: String
  notes: String
  players: PlayerGroupIdFkeyInverseInput
  games: GameGroupIdFkeyInverseInput
}

"""Input for the nested mutation of `game` in the `GroupInput` mutation."""
input GameGroupIdFkeyInverseInput {
  """
  Flag indicating whether all other `game` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """The primary key(s) for `game` for the far side of the relationship."""
  connectById: [GameGamePkeyConnect!]

  """The primary key(s) for `game` for the far side of the relationship."""
  connectByName: [GameGameNameKeyConnect!]

  """The primary key(s) for `game` for the far side of the relationship."""
  connectByNodeId: [GameNodeIdConnect!]

  """The primary key(s) for `game` for the far side of the relationship."""
  deleteById: [GameGamePkeyDelete!]

  """The primary key(s) for `game` for the far side of the relationship."""
  deleteByName: [GameGameNameKeyDelete!]

  """The primary key(s) for `game` for the far side of the relationship."""
  deleteByNodeId: [GameNodeIdDelete!]

  """
  The primary key(s) and patch data for `game` for the far side of the relationship.
  """
  updateById: [GameOnGameForGameGroupIdFkeyUsingGamePkeyUpdate!]

  """
  The primary key(s) and patch data for `game` for the far side of the relationship.
  """
  updateByName: [GameOnGameForGameGroupIdFkeyUsingGameNameKeyUpdate!]

  """
  The primary key(s) and patch data for `game` for the far side of the relationship.
  """
  updateByNodeId: [GroupOnGameForGameGroupIdFkeyNodeIdUpdate!]

  """
  A `GameInput` object that will be created and connected to this object.
  """
  create: [GameGroupIdFkeyGameCreateInput!]
}

"""The fields on `game` to look up the row to update."""
input GameOnGameForGameGroupIdFkeyUsingGamePkeyUpdate {
  """
  An object where the defined keys will be set on the `game` being updated.
  """
  patch: updateGameOnGameForGameGroupIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `game` being updated.
"""
input updateGameOnGameForGameGroupIdFkeyPatch {
  id: UUID
  name: String
  fieldId: UUID
  score: [Int]
  gameLength: Int
  timeStarted: Datetime
  timeEnded: Datetime
  timeSaved: Datetime
  group: GameGroupIdFkeyInput
  field: GameFieldIdFkeyInput
  teams: TeamGameIdFkeyInverseInput
  gameStates: GameStateGameIdFkeyInverseInput
  gameEventRecords: GameEventRecordGameIdFkeyInverseInput
}

"""Input for the nested mutation of `field` in the `GameInput` mutation."""
input GameFieldIdFkeyInput {
  """The primary key(s) for `field` for the far side of the relationship."""
  connectById: FieldFieldPkeyConnect

  """The primary key(s) for `field` for the far side of the relationship."""
  connectByNodeId: FieldNodeIdConnect

  """The primary key(s) for `field` for the far side of the relationship."""
  deleteById: FieldFieldPkeyDelete

  """The primary key(s) for `field` for the far side of the relationship."""
  deleteByNodeId: FieldNodeIdDelete

  """
  The primary key(s) and patch data for `field` for the far side of the relationship.
  """
  updateById: FieldOnGameForGameFieldIdFkeyUsingFieldPkeyUpdate

  """
  The primary key(s) and patch data for `field` for the far side of the relationship.
  """
  updateByNodeId: GameOnGameForGameFieldIdFkeyNodeIdUpdate

  """
  A `FieldInput` object that will be created and connected to this object.
  """
  create: GameFieldIdFkeyFieldCreateInput
}

"""The fields on `field` to look up the row to connect."""
input FieldFieldPkeyConnect {
  id: UUID!
}

"""The globally unique `ID` look up for the row to connect."""
input FieldNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `field` to be connected.
  """
  nodeId: ID!
}

"""The fields on `field` to look up the row to delete."""
input FieldFieldPkeyDelete {
  id: UUID!
}

"""The globally unique `ID` look up for the row to delete."""
input FieldNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `field` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `field` to look up the row to update."""
input FieldOnGameForGameFieldIdFkeyUsingFieldPkeyUpdate {
  """
  An object where the defined keys will be set on the `field` being updated.
  """
  patch: updateFieldOnGameForGameFieldIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `field` being updated.
"""
input updateFieldOnGameForGameFieldIdFkeyPatch {
  id: UUID
  name: String
  notes: String
  games: GameFieldIdFkeyInverseInput
}

"""Input for the nested mutation of `game` in the `FieldInput` mutation."""
input GameFieldIdFkeyInverseInput {
  """
  Flag indicating whether all other `game` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """The primary key(s) for `game` for the far side of the relationship."""
  connectById: [GameGamePkeyConnect!]

  """The primary key(s) for `game` for the far side of the relationship."""
  connectByName: [GameGameNameKeyConnect!]

  """The primary key(s) for `game` for the far side of the relationship."""
  connectByNodeId: [GameNodeIdConnect!]

  """The primary key(s) for `game` for the far side of the relationship."""
  deleteById: [GameGamePkeyDelete!]

  """The primary key(s) for `game` for the far side of the relationship."""
  deleteByName: [GameGameNameKeyDelete!]

  """The primary key(s) for `game` for the far side of the relationship."""
  deleteByNodeId: [GameNodeIdDelete!]

  """
  The primary key(s) and patch data for `game` for the far side of the relationship.
  """
  updateById: [GameOnGameForGameFieldIdFkeyUsingGamePkeyUpdate!]

  """
  The primary key(s) and patch data for `game` for the far side of the relationship.
  """
  updateByName: [GameOnGameForGameFieldIdFkeyUsingGameNameKeyUpdate!]

  """
  The primary key(s) and patch data for `game` for the far side of the relationship.
  """
  updateByNodeId: [FieldOnGameForGameFieldIdFkeyNodeIdUpdate!]

  """
  A `GameInput` object that will be created and connected to this object.
  """
  create: [GameFieldIdFkeyGameCreateInput!]
}

"""The fields on `game` to look up the row to update."""
input GameOnGameForGameFieldIdFkeyUsingGamePkeyUpdate {
  """
  An object where the defined keys will be set on the `game` being updated.
  """
  patch: updateGameOnGameForGameFieldIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `game` being updated.
"""
input updateGameOnGameForGameFieldIdFkeyPatch {
  id: UUID
  groupId: UUID
  name: String
  score: [Int]
  gameLength: Int
  timeStarted: Datetime
  timeEnded: Datetime
  timeSaved: Datetime
  group: GameGroupIdFkeyInput
  field: GameFieldIdFkeyInput
  teams: TeamGameIdFkeyInverseInput
  gameStates: GameStateGameIdFkeyInverseInput
  gameEventRecords: GameEventRecordGameIdFkeyInverseInput
}

"""Input for the nested mutation of `team` in the `GameInput` mutation."""
input TeamGameIdFkeyInverseInput {
  """
  Flag indicating whether all other `team` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """The primary key(s) for `team` for the far side of the relationship."""
  connectById: [TeamTeamPkeyConnect!]

  """The primary key(s) for `team` for the far side of the relationship."""
  connectByGameIdAndRole: [TeamTeamGameIdRoleKeyConnect!]

  """The primary key(s) for `team` for the far side of the relationship."""
  connectByNodeId: [TeamNodeIdConnect!]

  """The primary key(s) for `team` for the far side of the relationship."""
  deleteById: [TeamTeamPkeyDelete!]

  """The primary key(s) for `team` for the far side of the relationship."""
  deleteByGameIdAndRole: [TeamTeamGameIdRoleKeyDelete!]

  """The primary key(s) for `team` for the far side of the relationship."""
  deleteByNodeId: [TeamNodeIdDelete!]

  """
  The primary key(s) and patch data for `team` for the far side of the relationship.
  """
  updateById: [TeamOnTeamForTeamGameIdFkeyUsingTeamPkeyUpdate!]

  """
  The primary key(s) and patch data for `team` for the far side of the relationship.
  """
  updateByGameIdAndRole: [TeamOnTeamForTeamGameIdFkeyUsingTeamGameIdRoleKeyUpdate!]

  """
  The primary key(s) and patch data for `team` for the far side of the relationship.
  """
  updateByNodeId: [GameOnTeamForTeamGameIdFkeyNodeIdUpdate!]

  """
  A `TeamInput` object that will be created and connected to this object.
  """
  create: [TeamGameIdFkeyTeamCreateInput!]
}

"""The fields on `team` to look up the row to connect."""
input TeamTeamPkeyConnect {
  id: UUID!
}

"""The fields on `team` to look up the row to connect."""
input TeamTeamGameIdRoleKeyConnect {
  gameId: UUID!
  role: TeamRole!
}

"""The globally unique `ID` look up for the row to connect."""
input TeamNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `team` to be connected.
  """
  nodeId: ID!
}

"""The fields on `team` to look up the row to delete."""
input TeamTeamPkeyDelete {
  id: UUID!
}

"""The fields on `team` to look up the row to delete."""
input TeamTeamGameIdRoleKeyDelete {
  gameId: UUID!
  role: TeamRole!
}

"""The globally unique `ID` look up for the row to delete."""
input TeamNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `team` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `team` to look up the row to update."""
input TeamOnTeamForTeamGameIdFkeyUsingTeamPkeyUpdate {
  """
  An object where the defined keys will be set on the `team` being updated.
  """
  patch: updateTeamOnTeamForTeamGameIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `team` being updated.
"""
input updateTeamOnTeamForTeamGameIdFkeyPatch {
  id: UUID
  role: TeamRole
  name: String
  captainId: UUID
  winner: Boolean
  game: TeamGameIdFkeyInput
  player: TeamCaptainIdFkeyInput
  lineups: LineupTeamIdFkeyInverseInput
}

"""Input for the nested mutation of `game` in the `TeamInput` mutation."""
input TeamGameIdFkeyInput {
  """The primary key(s) for `game` for the far side of the relationship."""
  connectById: GameGamePkeyConnect

  """The primary key(s) for `game` for the far side of the relationship."""
  connectByName: GameGameNameKeyConnect

  """The primary key(s) for `game` for the far side of the relationship."""
  connectByNodeId: GameNodeIdConnect

  """The primary key(s) for `game` for the far side of the relationship."""
  deleteById: GameGamePkeyDelete

  """The primary key(s) for `game` for the far side of the relationship."""
  deleteByName: GameGameNameKeyDelete

  """The primary key(s) for `game` for the far side of the relationship."""
  deleteByNodeId: GameNodeIdDelete

  """
  The primary key(s) and patch data for `game` for the far side of the relationship.
  """
  updateById: GameOnTeamForTeamGameIdFkeyUsingGamePkeyUpdate

  """
  The primary key(s) and patch data for `game` for the far side of the relationship.
  """
  updateByName: GameOnTeamForTeamGameIdFkeyUsingGameNameKeyUpdate

  """
  The primary key(s) and patch data for `game` for the far side of the relationship.
  """
  updateByNodeId: TeamOnTeamForTeamGameIdFkeyNodeIdUpdate

  """
  A `GameInput` object that will be created and connected to this object.
  """
  create: TeamGameIdFkeyGameCreateInput
}

"""The fields on `game` to look up the row to update."""
input GameOnTeamForTeamGameIdFkeyUsingGamePkeyUpdate {
  """
  An object where the defined keys will be set on the `game` being updated.
  """
  patch: updateGameOnTeamForTeamGameIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `game` being updated.
"""
input updateGameOnTeamForTeamGameIdFkeyPatch {
  id: UUID
  groupId: UUID
  name: String
  fieldId: UUID
  score: [Int]
  gameLength: Int
  timeStarted: Datetime
  timeEnded: Datetime
  timeSaved: Datetime
  group: GameGroupIdFkeyInput
  field: GameFieldIdFkeyInput
  teams: TeamGameIdFkeyInverseInput
  gameStates: GameStateGameIdFkeyInverseInput
  gameEventRecords: GameEventRecordGameIdFkeyInverseInput
}

"""
Input for the nested mutation of `gameState` in the `GameInput` mutation.
"""
input GameStateGameIdFkeyInverseInput {
  """
  Flag indicating whether all other `gameState` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  connectById: [GameStateGameStatePkeyConnect!]

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  connectByNodeId: [GameStateNodeIdConnect!]

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  deleteById: [GameStateGameStatePkeyDelete!]

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  deleteByNodeId: [GameStateNodeIdDelete!]

  """
  The primary key(s) and patch data for `gameState` for the far side of the relationship.
  """
  updateById: [GameStateOnGameStateForGameStateGameIdFkeyUsingGameStatePkeyUpdate!]

  """
  The primary key(s) and patch data for `gameState` for the far side of the relationship.
  """
  updateByNodeId: [GameOnGameStateForGameStateGameIdFkeyNodeIdUpdate!]

  """
  A `GameStateInput` object that will be created and connected to this object.
  """
  create: [GameStateGameIdFkeyGameStateCreateInput!]
}

"""The fields on `gameState` to look up the row to update."""
input GameStateOnGameStateForGameStateGameIdFkeyUsingGameStatePkeyUpdate {
  """
  An object where the defined keys will be set on the `gameState` being updated.
  """
  patch: updateGameStateOnGameStateForGameStateGameIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `gameState` being updated.
"""
input updateGameStateOnGameStateForGameStateGameIdFkeyPatch {
  id: UUID
  gameStateIndex: Int
  playerAtBat: UUID
  inning: Int
  halfInning: HalfInning
  outs: Int
  score: [Int]
  game: GameStateGameIdFkeyInput
  player: GameStatePlayerAtBatFkeyInput
  baseRunners: BaseRunnerGameStateIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateGameStateIdFkeyInverseInput
  gameEventRecordsToGameStateBeforeIdUsingId: GameEventRecordGameStateBeforeFkInverseInput
  gameEventRecordsToGameStateAfterIdUsingId: GameEventRecordGameStateAfterFkInverseInput
}

"""
Input for the nested mutation of `player` in the `GameStateInput` mutation.
"""
input GameStatePlayerAtBatFkeyInput {
  """The primary key(s) for `player` for the far side of the relationship."""
  connectById: PlayerPlayerPkeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByNodeId: PlayerNodeIdConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteById: PlayerPlayerPkeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByNodeId: PlayerNodeIdDelete

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateById: PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerPkeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByFirstNameAndLastName: PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerFirstNameLastNameKeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByNodeId: GameStateOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate

  """
  A `PlayerInput` object that will be created and connected to this object.
  """
  create: GameStatePlayerAtBatFkeyPlayerCreateInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerPkeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnGameStateForGameStatePlayerAtBatFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `player` being updated.
"""
input updatePlayerOnGameStateForGameStatePlayerAtBatFkeyPatch {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""
Input for the nested mutation of `legacyPlayer` in the `PlayerInput` mutation.
"""
input FakePublicPlayerForeignKey0Input {
  """
  The primary key(s) for `legacyPlayer` for the far side of the relationship.
  """
  connectByPlayerId: LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect

  """
  The primary key(s) for `legacyPlayer` for the far side of the relationship.
  """
  connectByNodeId: LegacyPlayerNodeIdConnect

  """
  The primary key(s) for `legacyPlayer` for the far side of the relationship.
  """
  deleteByPlayerId: LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete

  """
  The primary key(s) for `legacyPlayer` for the far side of the relationship.
  """
  deleteByNodeId: LegacyPlayerNodeIdDelete

  """
  The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship.
  """
  updateByPlayerId: LegacyPlayerOnPlayerForFakePublicPlayerForeignKey0UsingFakePublicLegacyPlayerPrimaryKeyUpdate

  """
  The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship.
  """
  updateByNodeId: PlayerOnPlayerForFakePublicPlayerForeignKey0NodeIdUpdate

  """
  A `LegacyPlayerInput` object that will be created and connected to this object.
  """
  create: FakePublicPlayerForeignKey0LegacyPlayerCreateInput
}

"""The fields on `legacyPlayer` to look up the row to connect."""
input LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect {
  playerId: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input LegacyPlayerNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `legacyPlayer` to be connected.
  """
  nodeId: ID!
}

"""The fields on `legacyPlayer` to look up the row to delete."""
input LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete {
  playerId: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input LegacyPlayerNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `legacyPlayer` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `legacyPlayer` to look up the row to update."""
input LegacyPlayerOnPlayerForFakePublicPlayerForeignKey0UsingFakePublicLegacyPlayerPrimaryKeyUpdate {
  """
  An object where the defined keys will be set on the `legacyPlayer` being updated.
  """
  patch: updateLegacyPlayerOnPlayerForFakePublicPlayerForeignKey0Patch!
  playerId: Int!
}

"""
An object where the defined keys will be set on the `legacyPlayer` being updated.
"""
input updateLegacyPlayerOnPlayerForFakePublicPlayerForeignKey0Patch {
  playerId: Int
  playerName: String
  playerImage: String
  memberId: String
  legacyStatLines: FakePublicLegacyStatLineForeignKey0InverseInput
  players: FakePublicPlayerForeignKey0InverseInput
}

"""
Input for the nested mutation of `legacyStatLine` in the `LegacyPlayerInput` mutation.
"""
input FakePublicLegacyStatLineForeignKey0InverseInput {
  """
  A `LegacyStatLineInput` object that will be created and connected to this object.
  """
  create: [FakePublicLegacyStatLineForeignKey0LegacyStatLineCreateInput!]
}

"""The `legacyStatLine` to be created by this mutation."""
input FakePublicLegacyStatLineForeignKey0LegacyStatLineCreateInput {
  sbStatsId: Int!
  gameId: Int
  sbStatsTeam: Int
  atBats: Int!
  runs: Int!
  hits: Int!
  singles: Int!
  doubles: Int!
  triples: Int!
  homeruns: Int!
  rbi: Int!
  walks: Int!
  strikeouts: Int!
  sacFlies: Int!
  legacyPlayer: FakePublicLegacyStatLineForeignKey0Input
  legacyGame: FakePublicLegacyStatLineForeignKey1Input
  legacyTeam: FakePublicLegacyStatLineForeignKey2Input
}

"""
Input for the nested mutation of `legacyPlayer` in the `LegacyStatLineInput` mutation.
"""
input FakePublicLegacyStatLineForeignKey0Input {
  """
  The primary key(s) for `legacyPlayer` for the far side of the relationship.
  """
  connectByPlayerId: LegacyPlayerFakePublicLegacyPlayerPrimaryKeyConnect

  """
  The primary key(s) for `legacyPlayer` for the far side of the relationship.
  """
  connectByNodeId: LegacyPlayerNodeIdConnect

  """
  The primary key(s) for `legacyPlayer` for the far side of the relationship.
  """
  deleteByPlayerId: LegacyPlayerFakePublicLegacyPlayerPrimaryKeyDelete

  """
  The primary key(s) for `legacyPlayer` for the far side of the relationship.
  """
  deleteByNodeId: LegacyPlayerNodeIdDelete

  """
  The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship.
  """
  updateByPlayerId: LegacyPlayerOnLegacyStatLineForFakePublicLegacyStatLineForeignKey0UsingFakePublicLegacyPlayerPrimaryKeyUpdate

  """
  The primary key(s) and patch data for `legacyPlayer` for the far side of the relationship.
  """
  updateByNodeId: LegacyStatLineOnLegacyStatLineForFakePublicLegacyStatLineForeignKey0NodeIdUpdate

  """
  A `LegacyPlayerInput` object that will be created and connected to this object.
  """
  create: FakePublicLegacyStatLineForeignKey0LegacyPlayerCreateInput
}

"""The fields on `legacyPlayer` to look up the row to update."""
input LegacyPlayerOnLegacyStatLineForFakePublicLegacyStatLineForeignKey0UsingFakePublicLegacyPlayerPrimaryKeyUpdate {
  """
  An object where the defined keys will be set on the `legacyPlayer` being updated.
  """
  patch: updateLegacyPlayerOnLegacyStatLineForFakePublicLegacyStatLineForeignKey0Patch!
  playerId: Int!
}

"""
An object where the defined keys will be set on the `legacyPlayer` being updated.
"""
input updateLegacyPlayerOnLegacyStatLineForFakePublicLegacyStatLineForeignKey0Patch {
  playerName: String
  playerImage: String
  memberId: String
  legacyStatLines: FakePublicLegacyStatLineForeignKey0InverseInput
  players: FakePublicPlayerForeignKey0InverseInput
}

"""
Input for the nested mutation of `player` in the `LegacyPlayerInput` mutation.
"""
input FakePublicPlayerForeignKey0InverseInput {
  """
  Flag indicating whether all other `player` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """The primary key(s) for `player` for the far side of the relationship."""
  connectById: [PlayerPlayerPkeyConnect!]

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByFirstNameAndLastName: [PlayerPlayerFirstNameLastNameKeyConnect!]

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByNodeId: [PlayerNodeIdConnect!]

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteById: [PlayerPlayerPkeyDelete!]

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByFirstNameAndLastName: [PlayerPlayerFirstNameLastNameKeyDelete!]

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByNodeId: [PlayerNodeIdDelete!]

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateById: [PlayerOnPlayerForFakePublicPlayerForeignKey0UsingPlayerPkeyUpdate!]

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByFirstNameAndLastName: [PlayerOnPlayerForFakePublicPlayerForeignKey0UsingPlayerFirstNameLastNameKeyUpdate!]

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByNodeId: [LegacyPlayerOnPlayerForFakePublicPlayerForeignKey0NodeIdUpdate!]

  """
  A `PlayerInput` object that will be created and connected to this object.
  """
  create: [FakePublicPlayerForeignKey0PlayerCreateInput!]
}

"""The fields on `player` to look up the row to update."""
input PlayerOnPlayerForFakePublicPlayerForeignKey0UsingPlayerPkeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnPlayerForFakePublicPlayerForeignKey0Patch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `player` being updated.
"""
input updatePlayerOnPlayerForFakePublicPlayerForeignKey0Patch {
  id: UUID
  groupId: UUID
  firstName: String
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""Input for the nested mutation of `team` in the `PlayerInput` mutation."""
input TeamCaptainIdFkeyInverseInput {
  """
  Flag indicating whether all other `team` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """The primary key(s) for `team` for the far side of the relationship."""
  connectById: [TeamTeamPkeyConnect!]

  """The primary key(s) for `team` for the far side of the relationship."""
  connectByGameIdAndRole: [TeamTeamGameIdRoleKeyConnect!]

  """The primary key(s) for `team` for the far side of the relationship."""
  connectByNodeId: [TeamNodeIdConnect!]

  """The primary key(s) for `team` for the far side of the relationship."""
  deleteById: [TeamTeamPkeyDelete!]

  """The primary key(s) for `team` for the far side of the relationship."""
  deleteByGameIdAndRole: [TeamTeamGameIdRoleKeyDelete!]

  """The primary key(s) for `team` for the far side of the relationship."""
  deleteByNodeId: [TeamNodeIdDelete!]

  """
  The primary key(s) and patch data for `team` for the far side of the relationship.
  """
  updateById: [TeamOnTeamForTeamCaptainIdFkeyUsingTeamPkeyUpdate!]

  """
  The primary key(s) and patch data for `team` for the far side of the relationship.
  """
  updateByGameIdAndRole: [TeamOnTeamForTeamCaptainIdFkeyUsingTeamGameIdRoleKeyUpdate!]

  """
  The primary key(s) and patch data for `team` for the far side of the relationship.
  """
  updateByNodeId: [PlayerOnTeamForTeamCaptainIdFkeyNodeIdUpdate!]

  """
  A `TeamInput` object that will be created and connected to this object.
  """
  create: [TeamCaptainIdFkeyTeamCreateInput!]
}

"""The fields on `team` to look up the row to update."""
input TeamOnTeamForTeamCaptainIdFkeyUsingTeamPkeyUpdate {
  """
  An object where the defined keys will be set on the `team` being updated.
  """
  patch: updateTeamOnTeamForTeamCaptainIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `team` being updated.
"""
input updateTeamOnTeamForTeamCaptainIdFkeyPatch {
  id: UUID
  gameId: UUID
  role: TeamRole
  name: String
  winner: Boolean
  game: TeamGameIdFkeyInput
  player: TeamCaptainIdFkeyInput
  lineups: LineupTeamIdFkeyInverseInput
}

"""Input for the nested mutation of `player` in the `TeamInput` mutation."""
input TeamCaptainIdFkeyInput {
  """The primary key(s) for `player` for the far side of the relationship."""
  connectById: PlayerPlayerPkeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByNodeId: PlayerNodeIdConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteById: PlayerPlayerPkeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByNodeId: PlayerNodeIdDelete

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateById: PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerPkeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByFirstNameAndLastName: PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerFirstNameLastNameKeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByNodeId: TeamOnTeamForTeamCaptainIdFkeyNodeIdUpdate

  """
  A `PlayerInput` object that will be created and connected to this object.
  """
  create: TeamCaptainIdFkeyPlayerCreateInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerPkeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnTeamForTeamCaptainIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `player` being updated.
"""
input updatePlayerOnTeamForTeamCaptainIdFkeyPatch {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""
Input for the nested mutation of `lineupSpot` in the `PlayerInput` mutation.
"""
input LineupSpotPlayerIdFkeyInverseInput {
  """
  Flag indicating whether all other `lineupSpot` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  connectByLineupIdAndPlayerId: [LineupSpotLineupSpotPkeyConnect!]

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  connectByLineupIdAndBattingOrder: [LineupSpotLineupSpotLineupIdBattingOrderKeyConnect!]

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  connectByLineupIdAndPosition: [LineupSpotLineupSpotLineupIdPositionKeyConnect!]

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  connectByNodeId: [LineupSpotNodeIdConnect!]

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  deleteByLineupIdAndPlayerId: [LineupSpotLineupSpotPkeyDelete!]

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  deleteByLineupIdAndBattingOrder: [LineupSpotLineupSpotLineupIdBattingOrderKeyDelete!]

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  deleteByLineupIdAndPosition: [LineupSpotLineupSpotLineupIdPositionKeyDelete!]

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  deleteByNodeId: [LineupSpotNodeIdDelete!]

  """
  The primary key(s) and patch data for `lineupSpot` for the far side of the relationship.
  """
  updateByLineupIdAndPlayerId: [LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotPkeyUpdate!]

  """
  The primary key(s) and patch data for `lineupSpot` for the far side of the relationship.
  """
  updateByLineupIdAndBattingOrder: [LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate!]

  """
  The primary key(s) and patch data for `lineupSpot` for the far side of the relationship.
  """
  updateByLineupIdAndPosition: [LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate!]

  """
  The primary key(s) and patch data for `lineupSpot` for the far side of the relationship.
  """
  updateByNodeId: [PlayerOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate!]

  """
  A `LineupSpotInput` object that will be created and connected to this object.
  """
  create: [LineupSpotPlayerIdFkeyLineupSpotCreateInput!]
}

"""The fields on `lineupSpot` to look up the row to connect."""
input LineupSpotLineupSpotPkeyConnect {
  lineupId: UUID!
  playerId: UUID!
}

"""The fields on `lineupSpot` to look up the row to connect."""
input LineupSpotLineupSpotLineupIdBattingOrderKeyConnect {
  lineupId: UUID!
  battingOrder: Int!
}

"""The fields on `lineupSpot` to look up the row to connect."""
input LineupSpotLineupSpotLineupIdPositionKeyConnect {
  lineupId: UUID!
  position: FieldingPosition!
}

"""The globally unique `ID` look up for the row to connect."""
input LineupSpotNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `lineupSpot` to be connected.
  """
  nodeId: ID!
}

"""The fields on `lineupSpot` to look up the row to delete."""
input LineupSpotLineupSpotPkeyDelete {
  lineupId: UUID!
  playerId: UUID!
}

"""The fields on `lineupSpot` to look up the row to delete."""
input LineupSpotLineupSpotLineupIdBattingOrderKeyDelete {
  lineupId: UUID!
  battingOrder: Int!
}

"""The fields on `lineupSpot` to look up the row to delete."""
input LineupSpotLineupSpotLineupIdPositionKeyDelete {
  lineupId: UUID!
  position: FieldingPosition!
}

"""The globally unique `ID` look up for the row to delete."""
input LineupSpotNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `lineupSpot` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `lineupSpot` to look up the row to update."""
input LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotPkeyUpdate {
  """
  An object where the defined keys will be set on the `lineupSpot` being updated.
  """
  patch: updateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch!
  lineupId: UUID!
  playerId: UUID!
}

"""
An object where the defined keys will be set on the `lineupSpot` being updated.
"""
input updateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch {
  lineupId: UUID
  battingOrder: Int
  position: FieldingPosition
  lineup: LineupSpotLineupIdFkeyInput
  player: LineupSpotPlayerIdFkeyInput
}

"""
Input for the nested mutation of `lineup` in the `LineupSpotInput` mutation.
"""
input LineupSpotLineupIdFkeyInput {
  """The primary key(s) for `lineup` for the far side of the relationship."""
  connectById: LineupLineupPkeyConnect

  """The primary key(s) for `lineup` for the far side of the relationship."""
  connectByNodeId: LineupNodeIdConnect

  """The primary key(s) for `lineup` for the far side of the relationship."""
  deleteById: LineupLineupPkeyDelete

  """The primary key(s) for `lineup` for the far side of the relationship."""
  deleteByNodeId: LineupNodeIdDelete

  """
  The primary key(s) and patch data for `lineup` for the far side of the relationship.
  """
  updateById: LineupOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupPkeyUpdate

  """
  The primary key(s) and patch data for `lineup` for the far side of the relationship.
  """
  updateByNodeId: LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate

  """
  A `LineupInput` object that will be created and connected to this object.
  """
  create: LineupSpotLineupIdFkeyLineupCreateInput
}

"""The fields on `lineup` to look up the row to connect."""
input LineupLineupPkeyConnect {
  id: UUID!
}

"""The globally unique `ID` look up for the row to connect."""
input LineupNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `lineup` to be connected.
  """
  nodeId: ID!
}

"""The fields on `lineup` to look up the row to delete."""
input LineupLineupPkeyDelete {
  id: UUID!
}

"""The globally unique `ID` look up for the row to delete."""
input LineupNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `lineup` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `lineup` to look up the row to update."""
input LineupOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupPkeyUpdate {
  """
  An object where the defined keys will be set on the `lineup` being updated.
  """
  patch: updateLineupOnLineupSpotForLineupSpotLineupIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `lineup` being updated.
"""
input updateLineupOnLineupSpotForLineupSpotLineupIdFkeyPatch {
  id: UUID
  teamId: UUID
  team: LineupTeamIdFkeyInput
  lineupSpots: LineupSpotLineupIdFkeyInverseInput
  lineupChangesToLineupBeforeIdUsingId: LineupChangeLineupBeforeIdFkeyInverseInput
  lineupChangesToLineupAfterIdUsingId: LineupChangeLineupAfterIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateLineupIdFkeyInverseInput
}

"""Input for the nested mutation of `team` in the `LineupInput` mutation."""
input LineupTeamIdFkeyInput {
  """The primary key(s) for `team` for the far side of the relationship."""
  connectById: TeamTeamPkeyConnect

  """The primary key(s) for `team` for the far side of the relationship."""
  connectByGameIdAndRole: TeamTeamGameIdRoleKeyConnect

  """The primary key(s) for `team` for the far side of the relationship."""
  connectByNodeId: TeamNodeIdConnect

  """The primary key(s) for `team` for the far side of the relationship."""
  deleteById: TeamTeamPkeyDelete

  """The primary key(s) for `team` for the far side of the relationship."""
  deleteByGameIdAndRole: TeamTeamGameIdRoleKeyDelete

  """The primary key(s) for `team` for the far side of the relationship."""
  deleteByNodeId: TeamNodeIdDelete

  """
  The primary key(s) and patch data for `team` for the far side of the relationship.
  """
  updateById: TeamOnLineupForLineupTeamIdFkeyUsingTeamPkeyUpdate

  """
  The primary key(s) and patch data for `team` for the far side of the relationship.
  """
  updateByGameIdAndRole: TeamOnLineupForLineupTeamIdFkeyUsingTeamGameIdRoleKeyUpdate

  """
  The primary key(s) and patch data for `team` for the far side of the relationship.
  """
  updateByNodeId: LineupOnLineupForLineupTeamIdFkeyNodeIdUpdate

  """
  A `TeamInput` object that will be created and connected to this object.
  """
  create: LineupTeamIdFkeyTeamCreateInput
}

"""The fields on `team` to look up the row to update."""
input TeamOnLineupForLineupTeamIdFkeyUsingTeamPkeyUpdate {
  """
  An object where the defined keys will be set on the `team` being updated.
  """
  patch: updateTeamOnLineupForLineupTeamIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `team` being updated.
"""
input updateTeamOnLineupForLineupTeamIdFkeyPatch {
  id: UUID
  gameId: UUID
  role: TeamRole
  name: String
  captainId: UUID
  winner: Boolean
  game: TeamGameIdFkeyInput
  player: TeamCaptainIdFkeyInput
  lineups: LineupTeamIdFkeyInverseInput
}

"""Input for the nested mutation of `lineup` in the `TeamInput` mutation."""
input LineupTeamIdFkeyInverseInput {
  """
  Flag indicating whether all other `lineup` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """The primary key(s) for `lineup` for the far side of the relationship."""
  connectById: [LineupLineupPkeyConnect!]

  """The primary key(s) for `lineup` for the far side of the relationship."""
  connectByNodeId: [LineupNodeIdConnect!]

  """The primary key(s) for `lineup` for the far side of the relationship."""
  deleteById: [LineupLineupPkeyDelete!]

  """The primary key(s) for `lineup` for the far side of the relationship."""
  deleteByNodeId: [LineupNodeIdDelete!]

  """
  The primary key(s) and patch data for `lineup` for the far side of the relationship.
  """
  updateById: [LineupOnLineupForLineupTeamIdFkeyUsingLineupPkeyUpdate!]

  """
  The primary key(s) and patch data for `lineup` for the far side of the relationship.
  """
  updateByNodeId: [TeamOnLineupForLineupTeamIdFkeyNodeIdUpdate!]

  """
  A `LineupInput` object that will be created and connected to this object.
  """
  create: [LineupTeamIdFkeyLineupCreateInput!]
}

"""The fields on `lineup` to look up the row to update."""
input LineupOnLineupForLineupTeamIdFkeyUsingLineupPkeyUpdate {
  """
  An object where the defined keys will be set on the `lineup` being updated.
  """
  patch: updateLineupOnLineupForLineupTeamIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `lineup` being updated.
"""
input updateLineupOnLineupForLineupTeamIdFkeyPatch {
  id: UUID
  team: LineupTeamIdFkeyInput
  lineupSpots: LineupSpotLineupIdFkeyInverseInput
  lineupChangesToLineupBeforeIdUsingId: LineupChangeLineupBeforeIdFkeyInverseInput
  lineupChangesToLineupAfterIdUsingId: LineupChangeLineupAfterIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateLineupIdFkeyInverseInput
}

"""
Input for the nested mutation of `lineupSpot` in the `LineupInput` mutation.
"""
input LineupSpotLineupIdFkeyInverseInput {
  """
  Flag indicating whether all other `lineupSpot` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  connectByLineupIdAndPlayerId: [LineupSpotLineupSpotPkeyConnect!]

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  connectByLineupIdAndBattingOrder: [LineupSpotLineupSpotLineupIdBattingOrderKeyConnect!]

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  connectByLineupIdAndPosition: [LineupSpotLineupSpotLineupIdPositionKeyConnect!]

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  connectByNodeId: [LineupSpotNodeIdConnect!]

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  deleteByLineupIdAndPlayerId: [LineupSpotLineupSpotPkeyDelete!]

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  deleteByLineupIdAndBattingOrder: [LineupSpotLineupSpotLineupIdBattingOrderKeyDelete!]

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  deleteByLineupIdAndPosition: [LineupSpotLineupSpotLineupIdPositionKeyDelete!]

  """
  The primary key(s) for `lineupSpot` for the far side of the relationship.
  """
  deleteByNodeId: [LineupSpotNodeIdDelete!]

  """
  The primary key(s) and patch data for `lineupSpot` for the far side of the relationship.
  """
  updateByLineupIdAndPlayerId: [LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotPkeyUpdate!]

  """
  The primary key(s) and patch data for `lineupSpot` for the far side of the relationship.
  """
  updateByLineupIdAndBattingOrder: [LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate!]

  """
  The primary key(s) and patch data for `lineupSpot` for the far side of the relationship.
  """
  updateByLineupIdAndPosition: [LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate!]

  """
  The primary key(s) and patch data for `lineupSpot` for the far side of the relationship.
  """
  updateByNodeId: [LineupOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate!]

  """
  A `LineupSpotInput` object that will be created and connected to this object.
  """
  create: [LineupSpotLineupIdFkeyLineupSpotCreateInput!]
}

"""The fields on `lineupSpot` to look up the row to update."""
input LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotPkeyUpdate {
  """
  An object where the defined keys will be set on the `lineupSpot` being updated.
  """
  patch: updateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch!
  lineupId: UUID!
  playerId: UUID!
}

"""
An object where the defined keys will be set on the `lineupSpot` being updated.
"""
input updateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch {
  playerId: UUID
  battingOrder: Int
  position: FieldingPosition
  lineup: LineupSpotLineupIdFkeyInput
  player: LineupSpotPlayerIdFkeyInput
}

"""
Input for the nested mutation of `player` in the `LineupSpotInput` mutation.
"""
input LineupSpotPlayerIdFkeyInput {
  """The primary key(s) for `player` for the far side of the relationship."""
  connectById: PlayerPlayerPkeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByNodeId: PlayerNodeIdConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteById: PlayerPlayerPkeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByNodeId: PlayerNodeIdDelete

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateById: PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerPkeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByFirstNameAndLastName: PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByNodeId: LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate

  """
  A `PlayerInput` object that will be created and connected to this object.
  """
  create: LineupSpotPlayerIdFkeyPlayerCreateInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerPkeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnLineupSpotForLineupSpotPlayerIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `player` being updated.
"""
input updatePlayerOnLineupSpotForLineupSpotPlayerIdFkeyPatch {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""
Input for the nested mutation of `basepathMovement` in the `PlayerInput` mutation.
"""
input BasepathMovementRunnerIdFkeyInverseInput {
  """
  Flag indicating whether all other `basepathMovement` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `basepathMovement` for the far side of the relationship.
  """
  connectByPlateAppearanceIdAndRunnerId: [BasepathMovementBasepathMovementPkeyConnect!]

  """
  The primary key(s) for `basepathMovement` for the far side of the relationship.
  """
  connectByNodeId: [BasepathMovementNodeIdConnect!]

  """
  The primary key(s) for `basepathMovement` for the far side of the relationship.
  """
  deleteByPlateAppearanceIdAndRunnerId: [BasepathMovementBasepathMovementPkeyDelete!]

  """
  The primary key(s) for `basepathMovement` for the far side of the relationship.
  """
  deleteByNodeId: [BasepathMovementNodeIdDelete!]

  """
  The primary key(s) and patch data for `basepathMovement` for the far side of the relationship.
  """
  updateByPlateAppearanceIdAndRunnerId: [BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingBasepathMovementPkeyUpdate!]

  """
  The primary key(s) and patch data for `basepathMovement` for the far side of the relationship.
  """
  updateByNodeId: [PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate!]

  """
  A `BasepathMovementInput` object that will be created and connected to this object.
  """
  create: [BasepathMovementRunnerIdFkeyBasepathMovementCreateInput!]
}

"""The fields on `basepathMovement` to look up the row to connect."""
input BasepathMovementBasepathMovementPkeyConnect {
  plateAppearanceId: UUID!
  runnerId: UUID!
}

"""The globally unique `ID` look up for the row to connect."""
input BasepathMovementNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `basepathMovement` to be connected.
  """
  nodeId: ID!
}

"""The fields on `basepathMovement` to look up the row to delete."""
input BasepathMovementBasepathMovementPkeyDelete {
  plateAppearanceId: UUID!
  runnerId: UUID!
}

"""The globally unique `ID` look up for the row to delete."""
input BasepathMovementNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `basepathMovement` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `basepathMovement` to look up the row to update."""
input BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingBasepathMovementPkeyUpdate {
  """
  An object where the defined keys will be set on the `basepathMovement` being updated.
  """
  patch: updateBasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch!
  plateAppearanceId: UUID!
  runnerId: UUID!
}

"""
An object where the defined keys will be set on the `basepathMovement` being updated.
"""
input updateBasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch {
  plateAppearanceId: UUID
  endBase: BaseType
  wasSafe: Boolean
  plateAppearance: BasepathMovementPlateAppearanceIdFkeyInput
  player: BasepathMovementRunnerIdFkeyInput
}

"""
Input for the nested mutation of `plateAppearance` in the `BasepathMovementInput` mutation.
"""
input BasepathMovementPlateAppearanceIdFkeyInput {
  """
  The primary key(s) for `plateAppearance` for the far side of the relationship.
  """
  connectById: PlateAppearancePlateAppearancePkeyConnect

  """
  The primary key(s) for `plateAppearance` for the far side of the relationship.
  """
  connectByNodeId: PlateAppearanceNodeIdConnect

  """
  The primary key(s) for `plateAppearance` for the far side of the relationship.
  """
  deleteById: PlateAppearancePlateAppearancePkeyDelete

  """
  The primary key(s) for `plateAppearance` for the far side of the relationship.
  """
  deleteByNodeId: PlateAppearanceNodeIdDelete

  """
  The primary key(s) and patch data for `plateAppearance` for the far side of the relationship.
  """
  updateById: PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate

  """
  The primary key(s) and patch data for `plateAppearance` for the far side of the relationship.
  """
  updateByNodeId: BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate

  """
  A `PlateAppearanceInput` object that will be created and connected to this object.
  """
  create: BasepathMovementPlateAppearanceIdFkeyPlateAppearanceCreateInput
}

"""The fields on `plateAppearance` to look up the row to connect."""
input PlateAppearancePlateAppearancePkeyConnect {
  id: UUID!
}

"""The globally unique `ID` look up for the row to connect."""
input PlateAppearanceNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `plateAppearance` to be connected.
  """
  nodeId: ID!
}

"""The fields on `plateAppearance` to look up the row to delete."""
input PlateAppearancePlateAppearancePkeyDelete {
  id: UUID!
}

"""The globally unique `ID` look up for the row to delete."""
input PlateAppearanceNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `plateAppearance` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `plateAppearance` to look up the row to update."""
input PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate {
  """
  An object where the defined keys will be set on the `plateAppearance` being updated.
  """
  patch: updatePlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `plateAppearance` being updated.
"""
input updatePlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch {
  id: UUID
  type: PlateAppearanceType
  contact: ContactQuality
  fieldedBy: FieldingPosition
  runsScoredOnSacFly: Int
  routinePlay: Boolean
  basepathMovements: BasepathMovementPlateAppearanceIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput
  gameEvents: GameEventPlateAppearanceIdFkeyInverseInput
}

"""
Input for the nested mutation of `basepathMovement` in the `PlateAppearanceInput` mutation.
"""
input BasepathMovementPlateAppearanceIdFkeyInverseInput {
  """
  Flag indicating whether all other `basepathMovement` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `basepathMovement` for the far side of the relationship.
  """
  connectByPlateAppearanceIdAndRunnerId: [BasepathMovementBasepathMovementPkeyConnect!]

  """
  The primary key(s) for `basepathMovement` for the far side of the relationship.
  """
  connectByNodeId: [BasepathMovementNodeIdConnect!]

  """
  The primary key(s) for `basepathMovement` for the far side of the relationship.
  """
  deleteByPlateAppearanceIdAndRunnerId: [BasepathMovementBasepathMovementPkeyDelete!]

  """
  The primary key(s) for `basepathMovement` for the far side of the relationship.
  """
  deleteByNodeId: [BasepathMovementNodeIdDelete!]

  """
  The primary key(s) and patch data for `basepathMovement` for the far side of the relationship.
  """
  updateByPlateAppearanceIdAndRunnerId: [BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingBasepathMovementPkeyUpdate!]

  """
  The primary key(s) and patch data for `basepathMovement` for the far side of the relationship.
  """
  updateByNodeId: [PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate!]

  """
  A `BasepathMovementInput` object that will be created and connected to this object.
  """
  create: [BasepathMovementPlateAppearanceIdFkeyBasepathMovementCreateInput!]
}

"""The fields on `basepathMovement` to look up the row to update."""
input BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyUsingBasepathMovementPkeyUpdate {
  """
  An object where the defined keys will be set on the `basepathMovement` being updated.
  """
  patch: updateBasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch!
  plateAppearanceId: UUID!
  runnerId: UUID!
}

"""
An object where the defined keys will be set on the `basepathMovement` being updated.
"""
input updateBasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyPatch {
  runnerId: UUID
  endBase: BaseType
  wasSafe: Boolean
  plateAppearance: BasepathMovementPlateAppearanceIdFkeyInput
  player: BasepathMovementRunnerIdFkeyInput
}

"""
Input for the nested mutation of `player` in the `BasepathMovementInput` mutation.
"""
input BasepathMovementRunnerIdFkeyInput {
  """The primary key(s) for `player` for the far side of the relationship."""
  connectById: PlayerPlayerPkeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByNodeId: PlayerNodeIdConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteById: PlayerPlayerPkeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByNodeId: PlayerNodeIdDelete

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateById: PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerPkeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByFirstNameAndLastName: PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByNodeId: BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate

  """
  A `PlayerInput` object that will be created and connected to this object.
  """
  create: BasepathMovementRunnerIdFkeyPlayerCreateInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerPkeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `player` being updated.
"""
input updatePlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""
Input for the nested mutation of `outOnPlayRunner` in the `PlayerInput` mutation.
"""
input OutOnPlayRunnerRunnerIdFkeyInverseInput {
  """
  Flag indicating whether all other `outOnPlayRunner` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `outOnPlayRunner` for the far side of the relationship.
  """
  connectByPlateAppearanceIdAndRunnerId: [OutOnPlayRunnerOutOnPlayRunnerPkeyConnect!]

  """
  The primary key(s) for `outOnPlayRunner` for the far side of the relationship.
  """
  connectByNodeId: [OutOnPlayRunnerNodeIdConnect!]

  """
  The primary key(s) for `outOnPlayRunner` for the far side of the relationship.
  """
  deleteByPlateAppearanceIdAndRunnerId: [OutOnPlayRunnerOutOnPlayRunnerPkeyDelete!]

  """
  The primary key(s) for `outOnPlayRunner` for the far side of the relationship.
  """
  deleteByNodeId: [OutOnPlayRunnerNodeIdDelete!]

  """
  The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship.
  """
  updateByPlateAppearanceIdAndRunnerId: [OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingOutOnPlayRunnerPkeyUpdate!]

  """
  The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship.
  """
  updateByNodeId: [PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate!]

  """
  A `OutOnPlayRunnerInput` object that will be created and connected to this object.
  """
  create: [OutOnPlayRunnerRunnerIdFkeyOutOnPlayRunnerCreateInput!]
}

"""The fields on `outOnPlayRunner` to look up the row to connect."""
input OutOnPlayRunnerOutOnPlayRunnerPkeyConnect {
  plateAppearanceId: UUID!
  runnerId: UUID!
}

"""The globally unique `ID` look up for the row to connect."""
input OutOnPlayRunnerNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `outOnPlayRunner` to be connected.
  """
  nodeId: ID!
}

"""The fields on `outOnPlayRunner` to look up the row to delete."""
input OutOnPlayRunnerOutOnPlayRunnerPkeyDelete {
  plateAppearanceId: UUID!
  runnerId: UUID!
}

"""The globally unique `ID` look up for the row to delete."""
input OutOnPlayRunnerNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `outOnPlayRunner` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `outOnPlayRunner` to look up the row to update."""
input OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingOutOnPlayRunnerPkeyUpdate {
  """
  An object where the defined keys will be set on the `outOnPlayRunner` being updated.
  """
  patch: updateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch!
  plateAppearanceId: UUID!
  runnerId: UUID!
}

"""
An object where the defined keys will be set on the `outOnPlayRunner` being updated.
"""
input updateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch {
  plateAppearanceId: UUID
  plateAppearance: OutOnPlayRunnerPlateAppearanceIdFkeyInput
  player: OutOnPlayRunnerRunnerIdFkeyInput
}

"""
Input for the nested mutation of `plateAppearance` in the `OutOnPlayRunnerInput` mutation.
"""
input OutOnPlayRunnerPlateAppearanceIdFkeyInput {
  """
  The primary key(s) for `plateAppearance` for the far side of the relationship.
  """
  connectById: PlateAppearancePlateAppearancePkeyConnect

  """
  The primary key(s) for `plateAppearance` for the far side of the relationship.
  """
  connectByNodeId: PlateAppearanceNodeIdConnect

  """
  The primary key(s) for `plateAppearance` for the far side of the relationship.
  """
  deleteById: PlateAppearancePlateAppearancePkeyDelete

  """
  The primary key(s) for `plateAppearance` for the far side of the relationship.
  """
  deleteByNodeId: PlateAppearanceNodeIdDelete

  """
  The primary key(s) and patch data for `plateAppearance` for the far side of the relationship.
  """
  updateById: PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate

  """
  The primary key(s) and patch data for `plateAppearance` for the far side of the relationship.
  """
  updateByNodeId: OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate

  """
  A `PlateAppearanceInput` object that will be created and connected to this object.
  """
  create: OutOnPlayRunnerPlateAppearanceIdFkeyPlateAppearanceCreateInput
}

"""The fields on `plateAppearance` to look up the row to update."""
input PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate {
  """
  An object where the defined keys will be set on the `plateAppearance` being updated.
  """
  patch: updatePlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `plateAppearance` being updated.
"""
input updatePlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch {
  id: UUID
  type: PlateAppearanceType
  contact: ContactQuality
  fieldedBy: FieldingPosition
  runsScoredOnSacFly: Int
  routinePlay: Boolean
  basepathMovements: BasepathMovementPlateAppearanceIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput
  gameEvents: GameEventPlateAppearanceIdFkeyInverseInput
}

"""
Input for the nested mutation of `outOnPlayRunner` in the `PlateAppearanceInput` mutation.
"""
input OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput {
  """
  Flag indicating whether all other `outOnPlayRunner` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `outOnPlayRunner` for the far side of the relationship.
  """
  connectByPlateAppearanceIdAndRunnerId: [OutOnPlayRunnerOutOnPlayRunnerPkeyConnect!]

  """
  The primary key(s) for `outOnPlayRunner` for the far side of the relationship.
  """
  connectByNodeId: [OutOnPlayRunnerNodeIdConnect!]

  """
  The primary key(s) for `outOnPlayRunner` for the far side of the relationship.
  """
  deleteByPlateAppearanceIdAndRunnerId: [OutOnPlayRunnerOutOnPlayRunnerPkeyDelete!]

  """
  The primary key(s) for `outOnPlayRunner` for the far side of the relationship.
  """
  deleteByNodeId: [OutOnPlayRunnerNodeIdDelete!]

  """
  The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship.
  """
  updateByPlateAppearanceIdAndRunnerId: [OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingOutOnPlayRunnerPkeyUpdate!]

  """
  The primary key(s) and patch data for `outOnPlayRunner` for the far side of the relationship.
  """
  updateByNodeId: [PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate!]

  """
  A `OutOnPlayRunnerInput` object that will be created and connected to this object.
  """
  create: [OutOnPlayRunnerPlateAppearanceIdFkeyOutOnPlayRunnerCreateInput!]
}

"""The fields on `outOnPlayRunner` to look up the row to update."""
input OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyUsingOutOnPlayRunnerPkeyUpdate {
  """
  An object where the defined keys will be set on the `outOnPlayRunner` being updated.
  """
  patch: updateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch!
  plateAppearanceId: UUID!
  runnerId: UUID!
}

"""
An object where the defined keys will be set on the `outOnPlayRunner` being updated.
"""
input updateOutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyPatch {
  runnerId: UUID
  plateAppearance: OutOnPlayRunnerPlateAppearanceIdFkeyInput
  player: OutOnPlayRunnerRunnerIdFkeyInput
}

"""
Input for the nested mutation of `player` in the `OutOnPlayRunnerInput` mutation.
"""
input OutOnPlayRunnerRunnerIdFkeyInput {
  """The primary key(s) for `player` for the far side of the relationship."""
  connectById: PlayerPlayerPkeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByNodeId: PlayerNodeIdConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteById: PlayerPlayerPkeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByNodeId: PlayerNodeIdDelete

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateById: PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerPkeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByFirstNameAndLastName: PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByNodeId: OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate

  """
  A `PlayerInput` object that will be created and connected to this object.
  """
  create: OutOnPlayRunnerRunnerIdFkeyPlayerCreateInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerPkeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `player` being updated.
"""
input updatePlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""
Input for the nested mutation of `stolenBaseAttempt` in the `PlayerInput` mutation.
"""
input StolenBaseAttemptRunnerIdFkeyInverseInput {
  """
  Flag indicating whether all other `stolenBaseAttempt` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `stolenBaseAttempt` for the far side of the relationship.
  """
  connectById: [StolenBaseAttemptStolenBaseAttemptPkeyConnect!]

  """
  The primary key(s) for `stolenBaseAttempt` for the far side of the relationship.
  """
  connectByNodeId: [StolenBaseAttemptNodeIdConnect!]

  """
  The primary key(s) for `stolenBaseAttempt` for the far side of the relationship.
  """
  deleteById: [StolenBaseAttemptStolenBaseAttemptPkeyDelete!]

  """
  The primary key(s) for `stolenBaseAttempt` for the far side of the relationship.
  """
  deleteByNodeId: [StolenBaseAttemptNodeIdDelete!]

  """
  The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship.
  """
  updateById: [StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingStolenBaseAttemptPkeyUpdate!]

  """
  The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship.
  """
  updateByNodeId: [PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate!]

  """
  A `StolenBaseAttemptInput` object that will be created and connected to this object.
  """
  create: [StolenBaseAttemptRunnerIdFkeyStolenBaseAttemptCreateInput!]
}

"""The fields on `stolenBaseAttempt` to look up the row to connect."""
input StolenBaseAttemptStolenBaseAttemptPkeyConnect {
  id: UUID!
}

"""The globally unique `ID` look up for the row to connect."""
input StolenBaseAttemptNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `stolenBaseAttempt` to be connected.
  """
  nodeId: ID!
}

"""The fields on `stolenBaseAttempt` to look up the row to delete."""
input StolenBaseAttemptStolenBaseAttemptPkeyDelete {
  id: UUID!
}

"""The globally unique `ID` look up for the row to delete."""
input StolenBaseAttemptNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `stolenBaseAttempt` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `stolenBaseAttempt` to look up the row to update."""
input StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingStolenBaseAttemptPkeyUpdate {
  """
  An object where the defined keys will be set on the `stolenBaseAttempt` being updated.
  """
  patch: updateStolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `stolenBaseAttempt` being updated.
"""
input updateStolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch {
  id: UUID
  success: Boolean
  player: StolenBaseAttemptRunnerIdFkeyInput
  gameEvents: GameEventStolenBaseAttemptIdFkeyInverseInput
}

"""
Input for the nested mutation of `player` in the `StolenBaseAttemptInput` mutation.
"""
input StolenBaseAttemptRunnerIdFkeyInput {
  """The primary key(s) for `player` for the far side of the relationship."""
  connectById: PlayerPlayerPkeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByNodeId: PlayerNodeIdConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteById: PlayerPlayerPkeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByNodeId: PlayerNodeIdDelete

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateById: PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerPkeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByFirstNameAndLastName: PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByNodeId: StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate

  """
  A `PlayerInput` object that will be created and connected to this object.
  """
  create: StolenBaseAttemptRunnerIdFkeyPlayerCreateInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerPkeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `player` being updated.
"""
input updatePlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""
Input for the nested mutation of `gameState` in the `PlayerInput` mutation.
"""
input GameStatePlayerAtBatFkeyInverseInput {
  """
  Flag indicating whether all other `gameState` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  connectById: [GameStateGameStatePkeyConnect!]

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  connectByNodeId: [GameStateNodeIdConnect!]

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  deleteById: [GameStateGameStatePkeyDelete!]

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  deleteByNodeId: [GameStateNodeIdDelete!]

  """
  The primary key(s) and patch data for `gameState` for the far side of the relationship.
  """
  updateById: [GameStateOnGameStateForGameStatePlayerAtBatFkeyUsingGameStatePkeyUpdate!]

  """
  The primary key(s) and patch data for `gameState` for the far side of the relationship.
  """
  updateByNodeId: [PlayerOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate!]

  """
  A `GameStateInput` object that will be created and connected to this object.
  """
  create: [GameStatePlayerAtBatFkeyGameStateCreateInput!]
}

"""The fields on `gameState` to look up the row to update."""
input GameStateOnGameStateForGameStatePlayerAtBatFkeyUsingGameStatePkeyUpdate {
  """
  An object where the defined keys will be set on the `gameState` being updated.
  """
  patch: updateGameStateOnGameStateForGameStatePlayerAtBatFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `gameState` being updated.
"""
input updateGameStateOnGameStateForGameStatePlayerAtBatFkeyPatch {
  id: UUID
  gameId: UUID
  gameStateIndex: Int
  inning: Int
  halfInning: HalfInning
  outs: Int
  score: [Int]
  game: GameStateGameIdFkeyInput
  player: GameStatePlayerAtBatFkeyInput
  baseRunners: BaseRunnerGameStateIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateGameStateIdFkeyInverseInput
  gameEventRecordsToGameStateBeforeIdUsingId: GameEventRecordGameStateBeforeFkInverseInput
  gameEventRecordsToGameStateAfterIdUsingId: GameEventRecordGameStateAfterFkInverseInput
}

"""
Input for the nested mutation of `baseRunner` in the `GameStateInput` mutation.
"""
input BaseRunnerGameStateIdFkeyInverseInput {
  """
  Flag indicating whether all other `baseRunner` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `baseRunner` for the far side of the relationship.
  """
  connectByGameStateIdAndRunnerId: [BaseRunnerBaseRunnerPkeyConnect!]

  """
  The primary key(s) for `baseRunner` for the far side of the relationship.
  """
  connectByNodeId: [BaseRunnerNodeIdConnect!]

  """
  The primary key(s) for `baseRunner` for the far side of the relationship.
  """
  deleteByGameStateIdAndRunnerId: [BaseRunnerBaseRunnerPkeyDelete!]

  """
  The primary key(s) for `baseRunner` for the far side of the relationship.
  """
  deleteByNodeId: [BaseRunnerNodeIdDelete!]

  """
  The primary key(s) and patch data for `baseRunner` for the far side of the relationship.
  """
  updateByGameStateIdAndRunnerId: [BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingBaseRunnerPkeyUpdate!]

  """
  The primary key(s) and patch data for `baseRunner` for the far side of the relationship.
  """
  updateByNodeId: [GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate!]

  """
  A `BaseRunnerInput` object that will be created and connected to this object.
  """
  create: [BaseRunnerGameStateIdFkeyBaseRunnerCreateInput!]
}

"""The fields on `baseRunner` to look up the row to connect."""
input BaseRunnerBaseRunnerPkeyConnect {
  gameStateId: UUID!
  runnerId: UUID!
}

"""The globally unique `ID` look up for the row to connect."""
input BaseRunnerNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `baseRunner` to be connected.
  """
  nodeId: ID!
}

"""The fields on `baseRunner` to look up the row to delete."""
input BaseRunnerBaseRunnerPkeyDelete {
  gameStateId: UUID!
  runnerId: UUID!
}

"""The globally unique `ID` look up for the row to delete."""
input BaseRunnerNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `baseRunner` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `baseRunner` to look up the row to update."""
input BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyUsingBaseRunnerPkeyUpdate {
  """
  An object where the defined keys will be set on the `baseRunner` being updated.
  """
  patch: updateBaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch!
  gameStateId: UUID!
  runnerId: UUID!
}

"""
An object where the defined keys will be set on the `baseRunner` being updated.
"""
input updateBaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyPatch {
  runnerId: UUID
  base: BaseType
  gameState: BaseRunnerGameStateIdFkeyInput
  player: BaseRunnerRunnerIdFkeyInput
}

"""
Input for the nested mutation of `player` in the `BaseRunnerInput` mutation.
"""
input BaseRunnerRunnerIdFkeyInput {
  """The primary key(s) for `player` for the far side of the relationship."""
  connectById: PlayerPlayerPkeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByNodeId: PlayerNodeIdConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteById: PlayerPlayerPkeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByNodeId: PlayerNodeIdDelete

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateById: PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerPkeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByFirstNameAndLastName: PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByNodeId: BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate

  """
  A `PlayerInput` object that will be created and connected to this object.
  """
  create: BaseRunnerRunnerIdFkeyPlayerCreateInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerPkeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `player` being updated.
"""
input updatePlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""
Input for the nested mutation of `baseRunner` in the `PlayerInput` mutation.
"""
input BaseRunnerRunnerIdFkeyInverseInput {
  """
  Flag indicating whether all other `baseRunner` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `baseRunner` for the far side of the relationship.
  """
  connectByGameStateIdAndRunnerId: [BaseRunnerBaseRunnerPkeyConnect!]

  """
  The primary key(s) for `baseRunner` for the far side of the relationship.
  """
  connectByNodeId: [BaseRunnerNodeIdConnect!]

  """
  The primary key(s) for `baseRunner` for the far side of the relationship.
  """
  deleteByGameStateIdAndRunnerId: [BaseRunnerBaseRunnerPkeyDelete!]

  """
  The primary key(s) for `baseRunner` for the far side of the relationship.
  """
  deleteByNodeId: [BaseRunnerNodeIdDelete!]

  """
  The primary key(s) and patch data for `baseRunner` for the far side of the relationship.
  """
  updateByGameStateIdAndRunnerId: [BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingBaseRunnerPkeyUpdate!]

  """
  The primary key(s) and patch data for `baseRunner` for the far side of the relationship.
  """
  updateByNodeId: [PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate!]

  """
  A `BaseRunnerInput` object that will be created and connected to this object.
  """
  create: [BaseRunnerRunnerIdFkeyBaseRunnerCreateInput!]
}

"""The fields on `baseRunner` to look up the row to update."""
input BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingBaseRunnerPkeyUpdate {
  """
  An object where the defined keys will be set on the `baseRunner` being updated.
  """
  patch: updateBaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch!
  gameStateId: UUID!
  runnerId: UUID!
}

"""
An object where the defined keys will be set on the `baseRunner` being updated.
"""
input updateBaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch {
  gameStateId: UUID
  base: BaseType
  gameState: BaseRunnerGameStateIdFkeyInput
  player: BaseRunnerRunnerIdFkeyInput
}

"""The globally unique `ID` look up for the row to update."""
input PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `baseRunner` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `baseRunner` being updated.
  """
  patch: BaseRunnerPatch!
}

"""
Represents an update to a `BaseRunner`. Fields that are set will be updated.
"""
input BaseRunnerPatch {
  gameStateId: UUID
  runnerId: UUID
  base: BaseType
  gameState: BaseRunnerGameStateIdFkeyInput
  player: BaseRunnerRunnerIdFkeyInput
}

"""The `baseRunner` to be created by this mutation."""
input BaseRunnerRunnerIdFkeyBaseRunnerCreateInput {
  gameStateId: UUID
  base: BaseType!
  gameState: BaseRunnerGameStateIdFkeyInput
  player: BaseRunnerRunnerIdFkeyInput
}

"""
Input for the nested mutation of `scoredRunner` in the `PlayerInput` mutation.
"""
input ScoredRunnerRunnerIdFkeyInverseInput {
  """
  Flag indicating whether all other `scoredRunner` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `scoredRunner` for the far side of the relationship.
  """
  connectByGameEventRecordIdAndRunnerId: [ScoredRunnerScoredRunnerPkeyConnect!]

  """
  The primary key(s) for `scoredRunner` for the far side of the relationship.
  """
  connectByNodeId: [ScoredRunnerNodeIdConnect!]

  """
  The primary key(s) for `scoredRunner` for the far side of the relationship.
  """
  deleteByGameEventRecordIdAndRunnerId: [ScoredRunnerScoredRunnerPkeyDelete!]

  """
  The primary key(s) for `scoredRunner` for the far side of the relationship.
  """
  deleteByNodeId: [ScoredRunnerNodeIdDelete!]

  """
  The primary key(s) and patch data for `scoredRunner` for the far side of the relationship.
  """
  updateByGameEventRecordIdAndRunnerId: [ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingScoredRunnerPkeyUpdate!]

  """
  The primary key(s) and patch data for `scoredRunner` for the far side of the relationship.
  """
  updateByNodeId: [PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate!]

  """
  A `ScoredRunnerInput` object that will be created and connected to this object.
  """
  create: [ScoredRunnerRunnerIdFkeyScoredRunnerCreateInput!]
}

"""The fields on `scoredRunner` to look up the row to connect."""
input ScoredRunnerScoredRunnerPkeyConnect {
  gameEventRecordId: UUID!
  runnerId: UUID!
}

"""The globally unique `ID` look up for the row to connect."""
input ScoredRunnerNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `scoredRunner` to be connected.
  """
  nodeId: ID!
}

"""The fields on `scoredRunner` to look up the row to delete."""
input ScoredRunnerScoredRunnerPkeyDelete {
  gameEventRecordId: UUID!
  runnerId: UUID!
}

"""The globally unique `ID` look up for the row to delete."""
input ScoredRunnerNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `scoredRunner` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `scoredRunner` to look up the row to update."""
input ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingScoredRunnerPkeyUpdate {
  """
  An object where the defined keys will be set on the `scoredRunner` being updated.
  """
  patch: updateScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch!
  gameEventRecordId: UUID!
  runnerId: UUID!
}

"""
An object where the defined keys will be set on the `scoredRunner` being updated.
"""
input updateScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch {
  gameEventRecordId: UUID
  battedIn: Boolean
  gameEventRecord: ScoredRunnerGameEventRecordIdFkeyInput
  player: ScoredRunnerRunnerIdFkeyInput
}

"""
Input for the nested mutation of `gameEventRecord` in the `ScoredRunnerInput` mutation.
"""
input ScoredRunnerGameEventRecordIdFkeyInput {
  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  connectById: GameEventRecordGameEventRecordPkeyConnect

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  connectByGameIdAndEventIndex: GameEventRecordGameEventRecordGameIdEventIndexKeyConnect

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  connectByNodeId: GameEventRecordNodeIdConnect

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  deleteById: GameEventRecordGameEventRecordPkeyDelete

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  deleteByGameIdAndEventIndex: GameEventRecordGameEventRecordGameIdEventIndexKeyDelete

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  deleteByNodeId: GameEventRecordNodeIdDelete

  """
  The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship.
  """
  updateById: GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordPkeyUpdate

  """
  The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship.
  """
  updateByGameIdAndEventIndex: GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate

  """
  The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship.
  """
  updateByNodeId: ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate

  """
  A `GameEventRecordInput` object that will be created and connected to this object.
  """
  create: ScoredRunnerGameEventRecordIdFkeyGameEventRecordCreateInput
}

"""The fields on `gameEventRecord` to look up the row to connect."""
input GameEventRecordGameEventRecordPkeyConnect {
  id: UUID!
}

"""The fields on `gameEventRecord` to look up the row to connect."""
input GameEventRecordGameEventRecordGameIdEventIndexKeyConnect {
  gameId: UUID!
  eventIndex: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input GameEventRecordNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `gameEventRecord` to be connected.
  """
  nodeId: ID!
}

"""The fields on `gameEventRecord` to look up the row to delete."""
input GameEventRecordGameEventRecordPkeyDelete {
  id: UUID!
}

"""The fields on `gameEventRecord` to look up the row to delete."""
input GameEventRecordGameEventRecordGameIdEventIndexKeyDelete {
  gameId: UUID!
  eventIndex: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input GameEventRecordNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `gameEventRecord` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `gameEventRecord` to look up the row to update."""
input GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordPkeyUpdate {
  """
  An object where the defined keys will be set on the `gameEventRecord` being updated.
  """
  patch: updateGameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `gameEventRecord` being updated.
"""
input updateGameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch {
  id: UUID
  gameId: UUID
  eventIndex: Int
  gameStateBeforeId: UUID
  gameStateAfterId: UUID
  gameEventId: UUID
  notes: String
  game: GameEventRecordGameIdFkeyInput
  gameStateBefore: GameEventRecordGameStateBeforeFkInput
  gameStateAfter: GameEventRecordGameStateAfterFkInput
  gameEvent: GameEventRecordGameEventIdFkeyInput
  scoredRunners: ScoredRunnerGameEventRecordIdFkeyInverseInput
}

"""
Input for the nested mutation of `game` in the `GameEventRecordInput` mutation.
"""
input GameEventRecordGameIdFkeyInput {
  """The primary key(s) for `game` for the far side of the relationship."""
  connectById: GameGamePkeyConnect

  """The primary key(s) for `game` for the far side of the relationship."""
  connectByName: GameGameNameKeyConnect

  """The primary key(s) for `game` for the far side of the relationship."""
  connectByNodeId: GameNodeIdConnect

  """The primary key(s) for `game` for the far side of the relationship."""
  deleteById: GameGamePkeyDelete

  """The primary key(s) for `game` for the far side of the relationship."""
  deleteByName: GameGameNameKeyDelete

  """The primary key(s) for `game` for the far side of the relationship."""
  deleteByNodeId: GameNodeIdDelete

  """
  The primary key(s) and patch data for `game` for the far side of the relationship.
  """
  updateById: GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGamePkeyUpdate

  """
  The primary key(s) and patch data for `game` for the far side of the relationship.
  """
  updateByName: GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameNameKeyUpdate

  """
  The primary key(s) and patch data for `game` for the far side of the relationship.
  """
  updateByNodeId: GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate

  """
  A `GameInput` object that will be created and connected to this object.
  """
  create: GameEventRecordGameIdFkeyGameCreateInput
}

"""The fields on `game` to look up the row to update."""
input GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGamePkeyUpdate {
  """
  An object where the defined keys will be set on the `game` being updated.
  """
  patch: updateGameOnGameEventRecordForGameEventRecordGameIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `game` being updated.
"""
input updateGameOnGameEventRecordForGameEventRecordGameIdFkeyPatch {
  id: UUID
  groupId: UUID
  name: String
  fieldId: UUID
  score: [Int]
  gameLength: Int
  timeStarted: Datetime
  timeEnded: Datetime
  timeSaved: Datetime
  group: GameGroupIdFkeyInput
  field: GameFieldIdFkeyInput
  teams: TeamGameIdFkeyInverseInput
  gameStates: GameStateGameIdFkeyInverseInput
  gameEventRecords: GameEventRecordGameIdFkeyInverseInput
}

"""
Input for the nested mutation of `gameEventRecord` in the `GameInput` mutation.
"""
input GameEventRecordGameIdFkeyInverseInput {
  """
  Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  connectById: [GameEventRecordGameEventRecordPkeyConnect!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  connectByGameIdAndEventIndex: [GameEventRecordGameEventRecordGameIdEventIndexKeyConnect!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  connectByNodeId: [GameEventRecordNodeIdConnect!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  deleteById: [GameEventRecordGameEventRecordPkeyDelete!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  deleteByGameIdAndEventIndex: [GameEventRecordGameEventRecordGameIdEventIndexKeyDelete!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  deleteByNodeId: [GameEventRecordNodeIdDelete!]

  """
  The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship.
  """
  updateById: [GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordPkeyUpdate!]

  """
  The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship.
  """
  updateByGameIdAndEventIndex: [GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate!]

  """
  The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship.
  """
  updateByNodeId: [GameOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate!]

  """
  A `GameEventRecordInput` object that will be created and connected to this object.
  """
  create: [GameEventRecordGameIdFkeyGameEventRecordCreateInput!]
}

"""The fields on `gameEventRecord` to look up the row to update."""
input GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordPkeyUpdate {
  """
  An object where the defined keys will be set on the `gameEventRecord` being updated.
  """
  patch: updateGameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `gameEventRecord` being updated.
"""
input updateGameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyPatch {
  id: UUID
  eventIndex: Int
  gameStateBeforeId: UUID
  gameStateAfterId: UUID
  gameEventId: UUID
  notes: String
  game: GameEventRecordGameIdFkeyInput
  gameStateBefore: GameEventRecordGameStateBeforeFkInput
  gameStateAfter: GameEventRecordGameStateAfterFkInput
  gameEvent: GameEventRecordGameEventIdFkeyInput
  scoredRunners: ScoredRunnerGameEventRecordIdFkeyInverseInput
}

"""
Input for the nested mutation of `gameState` in the `GameEventRecordInput` mutation.
"""
input GameEventRecordGameStateBeforeFkInput {
  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  connectById: GameStateGameStatePkeyConnect

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  connectByNodeId: GameStateNodeIdConnect

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  deleteById: GameStateGameStatePkeyDelete

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  deleteByNodeId: GameStateNodeIdDelete

  """
  The primary key(s) and patch data for `gameState` for the far side of the relationship.
  """
  updateById: GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameStatePkeyUpdate

  """
  The primary key(s) and patch data for `gameState` for the far side of the relationship.
  """
  updateByNodeId: GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate

  """
  A `GameStateInput` object that will be created and connected to this object.
  """
  create: GameEventRecordGameStateBeforeFkGameStateCreateInput
}

"""The fields on `gameState` to look up the row to update."""
input GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameStatePkeyUpdate {
  """
  An object where the defined keys will be set on the `gameState` being updated.
  """
  patch: updateGameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `gameState` being updated.
"""
input updateGameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch {
  id: UUID
  gameId: UUID
  gameStateIndex: Int
  playerAtBat: UUID
  inning: Int
  halfInning: HalfInning
  outs: Int
  score: [Int]
  game: GameStateGameIdFkeyInput
  player: GameStatePlayerAtBatFkeyInput
  baseRunners: BaseRunnerGameStateIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateGameStateIdFkeyInverseInput
  gameEventRecordsToGameStateBeforeIdUsingId: GameEventRecordGameStateBeforeFkInverseInput
  gameEventRecordsToGameStateAfterIdUsingId: GameEventRecordGameStateAfterFkInverseInput
}

"""
Input for the nested mutation of `lineupForGameState` in the `GameStateInput` mutation.
"""
input LineupForGameStateGameStateIdFkeyInverseInput {
  """
  Flag indicating whether all other `lineupForGameState` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `lineupForGameState` for the far side of the relationship.
  """
  connectByGameStateIdAndLineupId: [LineupForGameStateLineupForGameStatePkeyConnect!]

  """
  The primary key(s) for `lineupForGameState` for the far side of the relationship.
  """
  connectByNodeId: [LineupForGameStateNodeIdConnect!]

  """
  The primary key(s) for `lineupForGameState` for the far side of the relationship.
  """
  deleteByGameStateIdAndLineupId: [LineupForGameStateLineupForGameStatePkeyDelete!]

  """
  The primary key(s) for `lineupForGameState` for the far side of the relationship.
  """
  deleteByNodeId: [LineupForGameStateNodeIdDelete!]

  """
  The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship.
  """
  updateByGameStateIdAndLineupId: [LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingLineupForGameStatePkeyUpdate!]

  """
  The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship.
  """
  updateByNodeId: [GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate!]

  """
  A `LineupForGameStateInput` object that will be created and connected to this object.
  """
  create: [LineupForGameStateGameStateIdFkeyLineupForGameStateCreateInput!]
}

"""The fields on `lineupForGameState` to look up the row to connect."""
input LineupForGameStateLineupForGameStatePkeyConnect {
  gameStateId: UUID!
  lineupId: UUID!
}

"""The globally unique `ID` look up for the row to connect."""
input LineupForGameStateNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `lineupForGameState` to be connected.
  """
  nodeId: ID!
}

"""The fields on `lineupForGameState` to look up the row to delete."""
input LineupForGameStateLineupForGameStatePkeyDelete {
  gameStateId: UUID!
  lineupId: UUID!
}

"""The globally unique `ID` look up for the row to delete."""
input LineupForGameStateNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `lineupForGameState` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `lineupForGameState` to look up the row to update."""
input LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingLineupForGameStatePkeyUpdate {
  """
  An object where the defined keys will be set on the `lineupForGameState` being updated.
  """
  patch: updateLineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch!
  gameStateId: UUID!
  lineupId: UUID!
}

"""
An object where the defined keys will be set on the `lineupForGameState` being updated.
"""
input updateLineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch {
  lineupId: UUID
  gameState: LineupForGameStateGameStateIdFkeyInput
  lineup: LineupForGameStateLineupIdFkeyInput
}

"""
Input for the nested mutation of `gameState` in the `LineupForGameStateInput` mutation.
"""
input LineupForGameStateGameStateIdFkeyInput {
  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  connectById: GameStateGameStatePkeyConnect

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  connectByNodeId: GameStateNodeIdConnect

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  deleteById: GameStateGameStatePkeyDelete

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  deleteByNodeId: GameStateNodeIdDelete

  """
  The primary key(s) and patch data for `gameState` for the far side of the relationship.
  """
  updateById: GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingGameStatePkeyUpdate

  """
  The primary key(s) and patch data for `gameState` for the far side of the relationship.
  """
  updateByNodeId: LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate

  """
  A `GameStateInput` object that will be created and connected to this object.
  """
  create: LineupForGameStateGameStateIdFkeyGameStateCreateInput
}

"""The fields on `gameState` to look up the row to update."""
input GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyUsingGameStatePkeyUpdate {
  """
  An object where the defined keys will be set on the `gameState` being updated.
  """
  patch: updateGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `gameState` being updated.
"""
input updateGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyPatch {
  id: UUID
  gameId: UUID
  gameStateIndex: Int
  playerAtBat: UUID
  inning: Int
  halfInning: HalfInning
  outs: Int
  score: [Int]
  game: GameStateGameIdFkeyInput
  player: GameStatePlayerAtBatFkeyInput
  baseRunners: BaseRunnerGameStateIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateGameStateIdFkeyInverseInput
  gameEventRecordsToGameStateBeforeIdUsingId: GameEventRecordGameStateBeforeFkInverseInput
  gameEventRecordsToGameStateAfterIdUsingId: GameEventRecordGameStateAfterFkInverseInput
}

"""
Input for the nested mutation of `gameEventRecord` in the `GameStateInput` mutation.
"""
input GameEventRecordGameStateBeforeFkInverseInput {
  """
  Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  connectById: [GameEventRecordGameEventRecordPkeyConnect!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  connectByGameIdAndEventIndex: [GameEventRecordGameEventRecordGameIdEventIndexKeyConnect!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  connectByNodeId: [GameEventRecordNodeIdConnect!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  deleteById: [GameEventRecordGameEventRecordPkeyDelete!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  deleteByGameIdAndEventIndex: [GameEventRecordGameEventRecordGameIdEventIndexKeyDelete!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  deleteByNodeId: [GameEventRecordNodeIdDelete!]

  """
  The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship.
  """
  updateById: [GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordPkeyUpdate!]

  """
  The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship.
  """
  updateByGameIdAndEventIndex: [GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordGameIdEventIndexKeyUpdate!]

  """
  The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship.
  """
  updateByNodeId: [GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate!]

  """
  A `GameEventRecordInput` object that will be created and connected to this object.
  """
  create: [GameEventRecordGameStateBeforeFkGameEventRecordCreateInput!]
}

"""The fields on `gameEventRecord` to look up the row to update."""
input GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordPkeyUpdate {
  """
  An object where the defined keys will be set on the `gameEventRecord` being updated.
  """
  patch: updateGameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `gameEventRecord` being updated.
"""
input updateGameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch {
  id: UUID
  gameId: UUID
  eventIndex: Int
  gameStateAfterId: UUID
  gameEventId: UUID
  notes: String
  game: GameEventRecordGameIdFkeyInput
  gameStateBefore: GameEventRecordGameStateBeforeFkInput
  gameStateAfter: GameEventRecordGameStateAfterFkInput
  gameEvent: GameEventRecordGameEventIdFkeyInput
  scoredRunners: ScoredRunnerGameEventRecordIdFkeyInverseInput
}

"""
Input for the nested mutation of `gameState` in the `GameEventRecordInput` mutation.
"""
input GameEventRecordGameStateAfterFkInput {
  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  connectById: GameStateGameStatePkeyConnect

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  connectByNodeId: GameStateNodeIdConnect

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  deleteById: GameStateGameStatePkeyDelete

  """
  The primary key(s) for `gameState` for the far side of the relationship.
  """
  deleteByNodeId: GameStateNodeIdDelete

  """
  The primary key(s) and patch data for `gameState` for the far side of the relationship.
  """
  updateById: GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameStatePkeyUpdate

  """
  The primary key(s) and patch data for `gameState` for the far side of the relationship.
  """
  updateByNodeId: GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate

  """
  A `GameStateInput` object that will be created and connected to this object.
  """
  create: GameEventRecordGameStateAfterFkGameStateCreateInput
}

"""The fields on `gameState` to look up the row to update."""
input GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameStatePkeyUpdate {
  """
  An object where the defined keys will be set on the `gameState` being updated.
  """
  patch: updateGameStateOnGameEventRecordForGameEventRecordGameStateAfterFkPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `gameState` being updated.
"""
input updateGameStateOnGameEventRecordForGameEventRecordGameStateAfterFkPatch {
  id: UUID
  gameId: UUID
  gameStateIndex: Int
  playerAtBat: UUID
  inning: Int
  halfInning: HalfInning
  outs: Int
  score: [Int]
  game: GameStateGameIdFkeyInput
  player: GameStatePlayerAtBatFkeyInput
  baseRunners: BaseRunnerGameStateIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateGameStateIdFkeyInverseInput
  gameEventRecordsToGameStateBeforeIdUsingId: GameEventRecordGameStateBeforeFkInverseInput
  gameEventRecordsToGameStateAfterIdUsingId: GameEventRecordGameStateAfterFkInverseInput
}

"""
Input for the nested mutation of `gameEventRecord` in the `GameStateInput` mutation.
"""
input GameEventRecordGameStateAfterFkInverseInput {
  """
  Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  connectById: [GameEventRecordGameEventRecordPkeyConnect!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  connectByGameIdAndEventIndex: [GameEventRecordGameEventRecordGameIdEventIndexKeyConnect!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  connectByNodeId: [GameEventRecordNodeIdConnect!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  deleteById: [GameEventRecordGameEventRecordPkeyDelete!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  deleteByGameIdAndEventIndex: [GameEventRecordGameEventRecordGameIdEventIndexKeyDelete!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  deleteByNodeId: [GameEventRecordNodeIdDelete!]

  """
  The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship.
  """
  updateById: [GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordPkeyUpdate!]

  """
  The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship.
  """
  updateByGameIdAndEventIndex: [GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordGameIdEventIndexKeyUpdate!]

  """
  The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship.
  """
  updateByNodeId: [GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate!]

  """
  A `GameEventRecordInput` object that will be created and connected to this object.
  """
  create: [GameEventRecordGameStateAfterFkGameEventRecordCreateInput!]
}

"""The fields on `gameEventRecord` to look up the row to update."""
input GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordPkeyUpdate {
  """
  An object where the defined keys will be set on the `gameEventRecord` being updated.
  """
  patch: updateGameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `gameEventRecord` being updated.
"""
input updateGameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkPatch {
  id: UUID
  gameId: UUID
  eventIndex: Int
  gameStateBeforeId: UUID
  gameEventId: UUID
  notes: String
  game: GameEventRecordGameIdFkeyInput
  gameStateBefore: GameEventRecordGameStateBeforeFkInput
  gameStateAfter: GameEventRecordGameStateAfterFkInput
  gameEvent: GameEventRecordGameEventIdFkeyInput
  scoredRunners: ScoredRunnerGameEventRecordIdFkeyInverseInput
}

"""
Input for the nested mutation of `gameEvent` in the `GameEventRecordInput` mutation.
"""
input GameEventRecordGameEventIdFkeyInput {
  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  connectById: GameEventGameEventPkeyConnect

  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  connectByNodeId: GameEventNodeIdConnect

  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  deleteById: GameEventGameEventPkeyDelete

  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  deleteByNodeId: GameEventNodeIdDelete

  """
  The primary key(s) and patch data for `gameEvent` for the far side of the relationship.
  """
  updateById: GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventPkeyUpdate

  """
  The primary key(s) and patch data for `gameEvent` for the far side of the relationship.
  """
  updateByNodeId: GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate

  """
  A `GameEventInput` object that will be created and connected to this object.
  """
  create: GameEventRecordGameEventIdFkeyGameEventCreateInput
}

"""The fields on `gameEvent` to look up the row to connect."""
input GameEventGameEventPkeyConnect {
  id: UUID!
}

"""The globally unique `ID` look up for the row to connect."""
input GameEventNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `gameEvent` to be connected.
  """
  nodeId: ID!
}

"""The fields on `gameEvent` to look up the row to delete."""
input GameEventGameEventPkeyDelete {
  id: UUID!
}

"""The globally unique `ID` look up for the row to delete."""
input GameEventNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `gameEvent` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `gameEvent` to look up the row to update."""
input GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventPkeyUpdate {
  """
  An object where the defined keys will be set on the `gameEvent` being updated.
  """
  patch: updateGameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `gameEvent` being updated.
"""
input updateGameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch {
  id: UUID
  plateAppearanceId: UUID
  stolenBaseAttemptId: UUID
  lineupChangeId: UUID
  plateAppearance: GameEventPlateAppearanceIdFkeyInput
  stolenBaseAttempt: GameEventStolenBaseAttemptIdFkeyInput
  lineupChange: GameEventLineupChangeIdFkeyInput
  gameEventRecords: GameEventRecordGameEventIdFkeyInverseInput
}

"""
Input for the nested mutation of `plateAppearance` in the `GameEventInput` mutation.
"""
input GameEventPlateAppearanceIdFkeyInput {
  """
  The primary key(s) for `plateAppearance` for the far side of the relationship.
  """
  connectById: PlateAppearancePlateAppearancePkeyConnect

  """
  The primary key(s) for `plateAppearance` for the far side of the relationship.
  """
  connectByNodeId: PlateAppearanceNodeIdConnect

  """
  The primary key(s) for `plateAppearance` for the far side of the relationship.
  """
  deleteById: PlateAppearancePlateAppearancePkeyDelete

  """
  The primary key(s) for `plateAppearance` for the far side of the relationship.
  """
  deleteByNodeId: PlateAppearanceNodeIdDelete

  """
  The primary key(s) and patch data for `plateAppearance` for the far side of the relationship.
  """
  updateById: PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate

  """
  The primary key(s) and patch data for `plateAppearance` for the far side of the relationship.
  """
  updateByNodeId: GameEventOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate

  """
  A `PlateAppearanceInput` object that will be created and connected to this object.
  """
  create: GameEventPlateAppearanceIdFkeyPlateAppearanceCreateInput
}

"""The fields on `plateAppearance` to look up the row to update."""
input PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyUsingPlateAppearancePkeyUpdate {
  """
  An object where the defined keys will be set on the `plateAppearance` being updated.
  """
  patch: updatePlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `plateAppearance` being updated.
"""
input updatePlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyPatch {
  id: UUID
  type: PlateAppearanceType
  contact: ContactQuality
  fieldedBy: FieldingPosition
  runsScoredOnSacFly: Int
  routinePlay: Boolean
  basepathMovements: BasepathMovementPlateAppearanceIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput
  gameEvents: GameEventPlateAppearanceIdFkeyInverseInput
}

"""
Input for the nested mutation of `gameEvent` in the `PlateAppearanceInput` mutation.
"""
input GameEventPlateAppearanceIdFkeyInverseInput {
  """
  Flag indicating whether all other `gameEvent` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  connectById: [GameEventGameEventPkeyConnect!]

  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  connectByNodeId: [GameEventNodeIdConnect!]

  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  deleteById: [GameEventGameEventPkeyDelete!]

  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  deleteByNodeId: [GameEventNodeIdDelete!]

  """
  The primary key(s) and patch data for `gameEvent` for the far side of the relationship.
  """
  updateById: [GameEventOnGameEventForGameEventPlateAppearanceIdFkeyUsingGameEventPkeyUpdate!]

  """
  The primary key(s) and patch data for `gameEvent` for the far side of the relationship.
  """
  updateByNodeId: [PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate!]

  """
  A `GameEventInput` object that will be created and connected to this object.
  """
  create: [GameEventPlateAppearanceIdFkeyGameEventCreateInput!]
}

"""The fields on `gameEvent` to look up the row to update."""
input GameEventOnGameEventForGameEventPlateAppearanceIdFkeyUsingGameEventPkeyUpdate {
  """
  An object where the defined keys will be set on the `gameEvent` being updated.
  """
  patch: updateGameEventOnGameEventForGameEventPlateAppearanceIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `gameEvent` being updated.
"""
input updateGameEventOnGameEventForGameEventPlateAppearanceIdFkeyPatch {
  id: UUID
  stolenBaseAttemptId: UUID
  lineupChangeId: UUID
  plateAppearance: GameEventPlateAppearanceIdFkeyInput
  stolenBaseAttempt: GameEventStolenBaseAttemptIdFkeyInput
  lineupChange: GameEventLineupChangeIdFkeyInput
  gameEventRecords: GameEventRecordGameEventIdFkeyInverseInput
}

"""
Input for the nested mutation of `stolenBaseAttempt` in the `GameEventInput` mutation.
"""
input GameEventStolenBaseAttemptIdFkeyInput {
  """
  The primary key(s) for `stolenBaseAttempt` for the far side of the relationship.
  """
  connectById: StolenBaseAttemptStolenBaseAttemptPkeyConnect

  """
  The primary key(s) for `stolenBaseAttempt` for the far side of the relationship.
  """
  connectByNodeId: StolenBaseAttemptNodeIdConnect

  """
  The primary key(s) for `stolenBaseAttempt` for the far side of the relationship.
  """
  deleteById: StolenBaseAttemptStolenBaseAttemptPkeyDelete

  """
  The primary key(s) for `stolenBaseAttempt` for the far side of the relationship.
  """
  deleteByNodeId: StolenBaseAttemptNodeIdDelete

  """
  The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship.
  """
  updateById: StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingStolenBaseAttemptPkeyUpdate

  """
  The primary key(s) and patch data for `stolenBaseAttempt` for the far side of the relationship.
  """
  updateByNodeId: GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate

  """
  A `StolenBaseAttemptInput` object that will be created and connected to this object.
  """
  create: GameEventStolenBaseAttemptIdFkeyStolenBaseAttemptCreateInput
}

"""The fields on `stolenBaseAttempt` to look up the row to update."""
input StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingStolenBaseAttemptPkeyUpdate {
  """
  An object where the defined keys will be set on the `stolenBaseAttempt` being updated.
  """
  patch: updateStolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `stolenBaseAttempt` being updated.
"""
input updateStolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch {
  id: UUID
  runnerId: UUID
  success: Boolean
  player: StolenBaseAttemptRunnerIdFkeyInput
  gameEvents: GameEventStolenBaseAttemptIdFkeyInverseInput
}

"""
Input for the nested mutation of `gameEvent` in the `StolenBaseAttemptInput` mutation.
"""
input GameEventStolenBaseAttemptIdFkeyInverseInput {
  """
  Flag indicating whether all other `gameEvent` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  connectById: [GameEventGameEventPkeyConnect!]

  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  connectByNodeId: [GameEventNodeIdConnect!]

  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  deleteById: [GameEventGameEventPkeyDelete!]

  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  deleteByNodeId: [GameEventNodeIdDelete!]

  """
  The primary key(s) and patch data for `gameEvent` for the far side of the relationship.
  """
  updateById: [GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingGameEventPkeyUpdate!]

  """
  The primary key(s) and patch data for `gameEvent` for the far side of the relationship.
  """
  updateByNodeId: [StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate!]

  """
  A `GameEventInput` object that will be created and connected to this object.
  """
  create: [GameEventStolenBaseAttemptIdFkeyGameEventCreateInput!]
}

"""The fields on `gameEvent` to look up the row to update."""
input GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyUsingGameEventPkeyUpdate {
  """
  An object where the defined keys will be set on the `gameEvent` being updated.
  """
  patch: updateGameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `gameEvent` being updated.
"""
input updateGameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyPatch {
  id: UUID
  plateAppearanceId: UUID
  lineupChangeId: UUID
  plateAppearance: GameEventPlateAppearanceIdFkeyInput
  stolenBaseAttempt: GameEventStolenBaseAttemptIdFkeyInput
  lineupChange: GameEventLineupChangeIdFkeyInput
  gameEventRecords: GameEventRecordGameEventIdFkeyInverseInput
}

"""
Input for the nested mutation of `lineupChange` in the `GameEventInput` mutation.
"""
input GameEventLineupChangeIdFkeyInput {
  """
  The primary key(s) for `lineupChange` for the far side of the relationship.
  """
  connectById: LineupChangeLineupChangePkeyConnect

  """
  The primary key(s) for `lineupChange` for the far side of the relationship.
  """
  connectByNodeId: LineupChangeNodeIdConnect

  """
  The primary key(s) for `lineupChange` for the far side of the relationship.
  """
  deleteById: LineupChangeLineupChangePkeyDelete

  """
  The primary key(s) for `lineupChange` for the far side of the relationship.
  """
  deleteByNodeId: LineupChangeNodeIdDelete

  """
  The primary key(s) and patch data for `lineupChange` for the far side of the relationship.
  """
  updateById: LineupChangeOnGameEventForGameEventLineupChangeIdFkeyUsingLineupChangePkeyUpdate

  """
  The primary key(s) and patch data for `lineupChange` for the far side of the relationship.
  """
  updateByNodeId: GameEventOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate

  """
  A `LineupChangeInput` object that will be created and connected to this object.
  """
  create: GameEventLineupChangeIdFkeyLineupChangeCreateInput
}

"""The fields on `lineupChange` to look up the row to connect."""
input LineupChangeLineupChangePkeyConnect {
  id: UUID!
}

"""The globally unique `ID` look up for the row to connect."""
input LineupChangeNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `lineupChange` to be connected.
  """
  nodeId: ID!
}

"""The fields on `lineupChange` to look up the row to delete."""
input LineupChangeLineupChangePkeyDelete {
  id: UUID!
}

"""The globally unique `ID` look up for the row to delete."""
input LineupChangeNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `lineupChange` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `lineupChange` to look up the row to update."""
input LineupChangeOnGameEventForGameEventLineupChangeIdFkeyUsingLineupChangePkeyUpdate {
  """
  An object where the defined keys will be set on the `lineupChange` being updated.
  """
  patch: updateLineupChangeOnGameEventForGameEventLineupChangeIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `lineupChange` being updated.
"""
input updateLineupChangeOnGameEventForGameEventLineupChangeIdFkeyPatch {
  id: UUID
  lineupBeforeId: UUID
  lineupAfterId: UUID
  lineup: LineupChangeLineupAfterIdFkeyInput
  gameEvents: GameEventLineupChangeIdFkeyInverseInput
}

"""
Input for the nested mutation of `lineup` in the `LineupChangeInput` mutation.
"""
input LineupChangeLineupAfterIdFkeyInput {
  """The primary key(s) for `lineup` for the far side of the relationship."""
  connectById: LineupLineupPkeyConnect

  """The primary key(s) for `lineup` for the far side of the relationship."""
  connectByNodeId: LineupNodeIdConnect

  """The primary key(s) for `lineup` for the far side of the relationship."""
  deleteById: LineupLineupPkeyDelete

  """The primary key(s) for `lineup` for the far side of the relationship."""
  deleteByNodeId: LineupNodeIdDelete

  """
  The primary key(s) and patch data for `lineup` for the far side of the relationship.
  """
  updateById: LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupPkeyUpdate

  """
  The primary key(s) and patch data for `lineup` for the far side of the relationship.
  """
  updateByNodeId: LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate

  """
  A `LineupInput` object that will be created and connected to this object.
  """
  create: LineupChangeLineupAfterIdFkeyLineupCreateInput
}

"""The fields on `lineup` to look up the row to update."""
input LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupPkeyUpdate {
  """
  An object where the defined keys will be set on the `lineup` being updated.
  """
  patch: updateLineupOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `lineup` being updated.
"""
input updateLineupOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch {
  id: UUID
  teamId: UUID
  team: LineupTeamIdFkeyInput
  lineupSpots: LineupSpotLineupIdFkeyInverseInput
  lineupChangesToLineupBeforeIdUsingId: LineupChangeLineupBeforeIdFkeyInverseInput
  lineupChangesToLineupAfterIdUsingId: LineupChangeLineupAfterIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateLineupIdFkeyInverseInput
}

"""
Input for the nested mutation of `lineupChange` in the `LineupInput` mutation.
"""
input LineupChangeLineupBeforeIdFkeyInverseInput {
  """
  Flag indicating whether all other `lineupChange` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `lineupChange` for the far side of the relationship.
  """
  connectById: [LineupChangeLineupChangePkeyConnect!]

  """
  The primary key(s) for `lineupChange` for the far side of the relationship.
  """
  connectByNodeId: [LineupChangeNodeIdConnect!]

  """
  The primary key(s) for `lineupChange` for the far side of the relationship.
  """
  deleteById: [LineupChangeLineupChangePkeyDelete!]

  """
  The primary key(s) for `lineupChange` for the far side of the relationship.
  """
  deleteByNodeId: [LineupChangeNodeIdDelete!]

  """
  The primary key(s) and patch data for `lineupChange` for the far side of the relationship.
  """
  updateById: [LineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyUsingLineupChangePkeyUpdate!]

  """
  The primary key(s) and patch data for `lineupChange` for the far side of the relationship.
  """
  updateByNodeId: [LineupOnLineupChangeForLineupChangeLineupBeforeIdFkeyNodeIdUpdate!]

  """
  A `LineupChangeInput` object that will be created and connected to this object.
  """
  create: [LineupChangeLineupBeforeIdFkeyLineupChangeCreateInput!]
}

"""The fields on `lineupChange` to look up the row to update."""
input LineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyUsingLineupChangePkeyUpdate {
  """
  An object where the defined keys will be set on the `lineupChange` being updated.
  """
  patch: updateLineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `lineupChange` being updated.
"""
input updateLineupChangeOnLineupChangeForLineupChangeLineupBeforeIdFkeyPatch {
  id: UUID
  lineupAfterId: UUID
  lineup: LineupChangeLineupAfterIdFkeyInput
  gameEvents: GameEventLineupChangeIdFkeyInverseInput
}

"""
Input for the nested mutation of `gameEvent` in the `LineupChangeInput` mutation.
"""
input GameEventLineupChangeIdFkeyInverseInput {
  """
  Flag indicating whether all other `gameEvent` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  connectById: [GameEventGameEventPkeyConnect!]

  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  connectByNodeId: [GameEventNodeIdConnect!]

  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  deleteById: [GameEventGameEventPkeyDelete!]

  """
  The primary key(s) for `gameEvent` for the far side of the relationship.
  """
  deleteByNodeId: [GameEventNodeIdDelete!]

  """
  The primary key(s) and patch data for `gameEvent` for the far side of the relationship.
  """
  updateById: [GameEventOnGameEventForGameEventLineupChangeIdFkeyUsingGameEventPkeyUpdate!]

  """
  The primary key(s) and patch data for `gameEvent` for the far side of the relationship.
  """
  updateByNodeId: [LineupChangeOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate!]

  """
  A `GameEventInput` object that will be created and connected to this object.
  """
  create: [GameEventLineupChangeIdFkeyGameEventCreateInput!]
}

"""The fields on `gameEvent` to look up the row to update."""
input GameEventOnGameEventForGameEventLineupChangeIdFkeyUsingGameEventPkeyUpdate {
  """
  An object where the defined keys will be set on the `gameEvent` being updated.
  """
  patch: updateGameEventOnGameEventForGameEventLineupChangeIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `gameEvent` being updated.
"""
input updateGameEventOnGameEventForGameEventLineupChangeIdFkeyPatch {
  id: UUID
  plateAppearanceId: UUID
  stolenBaseAttemptId: UUID
  plateAppearance: GameEventPlateAppearanceIdFkeyInput
  stolenBaseAttempt: GameEventStolenBaseAttemptIdFkeyInput
  lineupChange: GameEventLineupChangeIdFkeyInput
  gameEventRecords: GameEventRecordGameEventIdFkeyInverseInput
}

"""
Input for the nested mutation of `gameEventRecord` in the `GameEventInput` mutation.
"""
input GameEventRecordGameEventIdFkeyInverseInput {
  """
  Flag indicating whether all other `gameEventRecord` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  connectById: [GameEventRecordGameEventRecordPkeyConnect!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  connectByGameIdAndEventIndex: [GameEventRecordGameEventRecordGameIdEventIndexKeyConnect!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  connectByNodeId: [GameEventRecordNodeIdConnect!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  deleteById: [GameEventRecordGameEventRecordPkeyDelete!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  deleteByGameIdAndEventIndex: [GameEventRecordGameEventRecordGameIdEventIndexKeyDelete!]

  """
  The primary key(s) for `gameEventRecord` for the far side of the relationship.
  """
  deleteByNodeId: [GameEventRecordNodeIdDelete!]

  """
  The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship.
  """
  updateById: [GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordPkeyUpdate!]

  """
  The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship.
  """
  updateByGameIdAndEventIndex: [GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate!]

  """
  The primary key(s) and patch data for `gameEventRecord` for the far side of the relationship.
  """
  updateByNodeId: [GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate!]

  """
  A `GameEventRecordInput` object that will be created and connected to this object.
  """
  create: [GameEventRecordGameEventIdFkeyGameEventRecordCreateInput!]
}

"""The fields on `gameEventRecord` to look up the row to update."""
input GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordPkeyUpdate {
  """
  An object where the defined keys will be set on the `gameEventRecord` being updated.
  """
  patch: updateGameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `gameEventRecord` being updated.
"""
input updateGameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch {
  id: UUID
  gameId: UUID
  eventIndex: Int
  gameStateBeforeId: UUID
  gameStateAfterId: UUID
  notes: String
  game: GameEventRecordGameIdFkeyInput
  gameStateBefore: GameEventRecordGameStateBeforeFkInput
  gameStateAfter: GameEventRecordGameStateAfterFkInput
  gameEvent: GameEventRecordGameEventIdFkeyInput
  scoredRunners: ScoredRunnerGameEventRecordIdFkeyInverseInput
}

"""
Input for the nested mutation of `scoredRunner` in the `GameEventRecordInput` mutation.
"""
input ScoredRunnerGameEventRecordIdFkeyInverseInput {
  """
  Flag indicating whether all other `scoredRunner` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `scoredRunner` for the far side of the relationship.
  """
  connectByGameEventRecordIdAndRunnerId: [ScoredRunnerScoredRunnerPkeyConnect!]

  """
  The primary key(s) for `scoredRunner` for the far side of the relationship.
  """
  connectByNodeId: [ScoredRunnerNodeIdConnect!]

  """
  The primary key(s) for `scoredRunner` for the far side of the relationship.
  """
  deleteByGameEventRecordIdAndRunnerId: [ScoredRunnerScoredRunnerPkeyDelete!]

  """
  The primary key(s) for `scoredRunner` for the far side of the relationship.
  """
  deleteByNodeId: [ScoredRunnerNodeIdDelete!]

  """
  The primary key(s) and patch data for `scoredRunner` for the far side of the relationship.
  """
  updateByGameEventRecordIdAndRunnerId: [ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingScoredRunnerPkeyUpdate!]

  """
  The primary key(s) and patch data for `scoredRunner` for the far side of the relationship.
  """
  updateByNodeId: [GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate!]

  """
  A `ScoredRunnerInput` object that will be created and connected to this object.
  """
  create: [ScoredRunnerGameEventRecordIdFkeyScoredRunnerCreateInput!]
}

"""The fields on `scoredRunner` to look up the row to update."""
input ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingScoredRunnerPkeyUpdate {
  """
  An object where the defined keys will be set on the `scoredRunner` being updated.
  """
  patch: updateScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch!
  gameEventRecordId: UUID!
  runnerId: UUID!
}

"""
An object where the defined keys will be set on the `scoredRunner` being updated.
"""
input updateScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch {
  runnerId: UUID
  battedIn: Boolean
  gameEventRecord: ScoredRunnerGameEventRecordIdFkeyInput
  player: ScoredRunnerRunnerIdFkeyInput
}

"""
Input for the nested mutation of `player` in the `ScoredRunnerInput` mutation.
"""
input ScoredRunnerRunnerIdFkeyInput {
  """The primary key(s) for `player` for the far side of the relationship."""
  connectById: PlayerPlayerPkeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  connectByNodeId: PlayerNodeIdConnect

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteById: PlayerPlayerPkeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByFirstNameAndLastName: PlayerPlayerFirstNameLastNameKeyDelete

  """The primary key(s) for `player` for the far side of the relationship."""
  deleteByNodeId: PlayerNodeIdDelete

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateById: PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerPkeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByFirstNameAndLastName: PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate

  """
  The primary key(s) and patch data for `player` for the far side of the relationship.
  """
  updateByNodeId: ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate

  """
  A `PlayerInput` object that will be created and connected to this object.
  """
  create: ScoredRunnerRunnerIdFkeyPlayerCreateInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerPkeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `player` being updated.
"""
input updatePlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyPatch!
  firstName: String!
  lastName: String!
}

"""The globally unique `ID` look up for the row to update."""
input ScoredRunnerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `player` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: PlayerPatch!
}

"""
Represents an update to a `Player`. Fields that are set will be updated.
"""
input PlayerPatch {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""The `player` to be created by this mutation."""
input ScoredRunnerRunnerIdFkeyPlayerCreateInput {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String!
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `scoredRunner` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `scoredRunner` being updated.
  """
  patch: ScoredRunnerPatch!
}

"""
Represents an update to a `ScoredRunner`. Fields that are set will be updated.
"""
input ScoredRunnerPatch {
  gameEventRecordId: UUID
  runnerId: UUID
  battedIn: Boolean
  gameEventRecord: ScoredRunnerGameEventRecordIdFkeyInput
  player: ScoredRunnerRunnerIdFkeyInput
}

"""The `scoredRunner` to be created by this mutation."""
input ScoredRunnerGameEventRecordIdFkeyScoredRunnerCreateInput {
  runnerId: UUID
  battedIn: Boolean!
  gameEventRecord: ScoredRunnerGameEventRecordIdFkeyInput
  player: ScoredRunnerRunnerIdFkeyInput
}

"""The fields on `gameEventRecord` to look up the row to update."""
input GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate {
  """
  An object where the defined keys will be set on the `gameEventRecord` being updated.
  """
  patch: updateGameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyPatch!
  gameId: UUID!
  eventIndex: Int!
}

"""The globally unique `ID` look up for the row to update."""
input GameEventOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gameEventRecord` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gameEventRecord` being updated.
  """
  patch: GameEventRecordPatch!
}

"""
Represents an update to a `GameEventRecord`. Fields that are set will be updated.
"""
input GameEventRecordPatch {
  id: UUID
  gameId: UUID
  eventIndex: Int
  gameStateBeforeId: UUID
  gameStateAfterId: UUID
  gameEventId: UUID
  notes: String
  game: GameEventRecordGameIdFkeyInput
  gameStateBefore: GameEventRecordGameStateBeforeFkInput
  gameStateAfter: GameEventRecordGameStateAfterFkInput
  gameEvent: GameEventRecordGameEventIdFkeyInput
  scoredRunners: ScoredRunnerGameEventRecordIdFkeyInverseInput
}

"""The `gameEventRecord` to be created by this mutation."""
input GameEventRecordGameEventIdFkeyGameEventRecordCreateInput {
  id: UUID
  gameId: UUID
  eventIndex: Int!
  gameStateBeforeId: UUID
  gameStateAfterId: UUID
  notes: String
  game: GameEventRecordGameIdFkeyInput
  gameStateBefore: GameEventRecordGameStateBeforeFkInput
  gameStateAfter: GameEventRecordGameStateAfterFkInput
  gameEvent: GameEventRecordGameEventIdFkeyInput
  scoredRunners: ScoredRunnerGameEventRecordIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input LineupChangeOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gameEvent` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gameEvent` being updated.
  """
  patch: GameEventPatch!
}

"""
Represents an update to a `GameEvent`. Fields that are set will be updated.
"""
input GameEventPatch {
  id: UUID
  plateAppearanceId: UUID
  stolenBaseAttemptId: UUID
  lineupChangeId: UUID
  plateAppearance: GameEventPlateAppearanceIdFkeyInput
  stolenBaseAttempt: GameEventStolenBaseAttemptIdFkeyInput
  lineupChange: GameEventLineupChangeIdFkeyInput
  gameEventRecords: GameEventRecordGameEventIdFkeyInverseInput
}

"""The `gameEvent` to be created by this mutation."""
input GameEventLineupChangeIdFkeyGameEventCreateInput {
  id: UUID
  plateAppearanceId: UUID
  stolenBaseAttemptId: UUID
  plateAppearance: GameEventPlateAppearanceIdFkeyInput
  stolenBaseAttempt: GameEventStolenBaseAttemptIdFkeyInput
  lineupChange: GameEventLineupChangeIdFkeyInput
  gameEventRecords: GameEventRecordGameEventIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input LineupOnLineupChangeForLineupChangeLineupBeforeIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `lineupChange` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `lineupChange` being updated.
  """
  patch: LineupChangePatch!
}

"""
Represents an update to a `LineupChange`. Fields that are set will be updated.
"""
input LineupChangePatch {
  id: UUID
  lineupBeforeId: UUID
  lineupAfterId: UUID
  lineup: LineupChangeLineupAfterIdFkeyInput
  gameEvents: GameEventLineupChangeIdFkeyInverseInput
}

"""The `lineupChange` to be created by this mutation."""
input LineupChangeLineupBeforeIdFkeyLineupChangeCreateInput {
  id: UUID
  lineupAfterId: UUID
  lineup: LineupChangeLineupAfterIdFkeyInput
  gameEvents: GameEventLineupChangeIdFkeyInverseInput
}

"""
Input for the nested mutation of `lineupChange` in the `LineupInput` mutation.
"""
input LineupChangeLineupAfterIdFkeyInverseInput {
  """
  Flag indicating whether all other `lineupChange` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `lineupChange` for the far side of the relationship.
  """
  connectById: [LineupChangeLineupChangePkeyConnect!]

  """
  The primary key(s) for `lineupChange` for the far side of the relationship.
  """
  connectByNodeId: [LineupChangeNodeIdConnect!]

  """
  The primary key(s) for `lineupChange` for the far side of the relationship.
  """
  deleteById: [LineupChangeLineupChangePkeyDelete!]

  """
  The primary key(s) for `lineupChange` for the far side of the relationship.
  """
  deleteByNodeId: [LineupChangeNodeIdDelete!]

  """
  The primary key(s) and patch data for `lineupChange` for the far side of the relationship.
  """
  updateById: [LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupChangePkeyUpdate!]

  """
  The primary key(s) and patch data for `lineupChange` for the far side of the relationship.
  """
  updateByNodeId: [LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate!]

  """
  A `LineupChangeInput` object that will be created and connected to this object.
  """
  create: [LineupChangeLineupAfterIdFkeyLineupChangeCreateInput!]
}

"""The fields on `lineupChange` to look up the row to update."""
input LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyUsingLineupChangePkeyUpdate {
  """
  An object where the defined keys will be set on the `lineupChange` being updated.
  """
  patch: updateLineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `lineupChange` being updated.
"""
input updateLineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyPatch {
  id: UUID
  lineupBeforeId: UUID
  lineup: LineupChangeLineupAfterIdFkeyInput
  gameEvents: GameEventLineupChangeIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input LineupOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `lineupChange` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `lineupChange` being updated.
  """
  patch: LineupChangePatch!
}

"""The `lineupChange` to be created by this mutation."""
input LineupChangeLineupAfterIdFkeyLineupChangeCreateInput {
  id: UUID
  lineupBeforeId: UUID
  lineup: LineupChangeLineupAfterIdFkeyInput
  gameEvents: GameEventLineupChangeIdFkeyInverseInput
}

"""
Input for the nested mutation of `lineupForGameState` in the `LineupInput` mutation.
"""
input LineupForGameStateLineupIdFkeyInverseInput {
  """
  Flag indicating whether all other `lineupForGameState` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) for `lineupForGameState` for the far side of the relationship.
  """
  connectByGameStateIdAndLineupId: [LineupForGameStateLineupForGameStatePkeyConnect!]

  """
  The primary key(s) for `lineupForGameState` for the far side of the relationship.
  """
  connectByNodeId: [LineupForGameStateNodeIdConnect!]

  """
  The primary key(s) for `lineupForGameState` for the far side of the relationship.
  """
  deleteByGameStateIdAndLineupId: [LineupForGameStateLineupForGameStatePkeyDelete!]

  """
  The primary key(s) for `lineupForGameState` for the far side of the relationship.
  """
  deleteByNodeId: [LineupForGameStateNodeIdDelete!]

  """
  The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship.
  """
  updateByGameStateIdAndLineupId: [LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupForGameStatePkeyUpdate!]

  """
  The primary key(s) and patch data for `lineupForGameState` for the far side of the relationship.
  """
  updateByNodeId: [LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate!]

  """
  A `LineupForGameStateInput` object that will be created and connected to this object.
  """
  create: [LineupForGameStateLineupIdFkeyLineupForGameStateCreateInput!]
}

"""The fields on `lineupForGameState` to look up the row to update."""
input LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupForGameStatePkeyUpdate {
  """
  An object where the defined keys will be set on the `lineupForGameState` being updated.
  """
  patch: updateLineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch!
  gameStateId: UUID!
  lineupId: UUID!
}

"""
An object where the defined keys will be set on the `lineupForGameState` being updated.
"""
input updateLineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch {
  gameStateId: UUID
  gameState: LineupForGameStateGameStateIdFkeyInput
  lineup: LineupForGameStateLineupIdFkeyInput
}

"""
Input for the nested mutation of `lineup` in the `LineupForGameStateInput` mutation.
"""
input LineupForGameStateLineupIdFkeyInput {
  """The primary key(s) for `lineup` for the far side of the relationship."""
  connectById: LineupLineupPkeyConnect

  """The primary key(s) for `lineup` for the far side of the relationship."""
  connectByNodeId: LineupNodeIdConnect

  """The primary key(s) for `lineup` for the far side of the relationship."""
  deleteById: LineupLineupPkeyDelete

  """The primary key(s) for `lineup` for the far side of the relationship."""
  deleteByNodeId: LineupNodeIdDelete

  """
  The primary key(s) and patch data for `lineup` for the far side of the relationship.
  """
  updateById: LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupPkeyUpdate

  """
  The primary key(s) and patch data for `lineup` for the far side of the relationship.
  """
  updateByNodeId: LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate

  """
  A `LineupInput` object that will be created and connected to this object.
  """
  create: LineupForGameStateLineupIdFkeyLineupCreateInput
}

"""The fields on `lineup` to look up the row to update."""
input LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyUsingLineupPkeyUpdate {
  """
  An object where the defined keys will be set on the `lineup` being updated.
  """
  patch: updateLineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch!
  id: UUID!
}

"""
An object where the defined keys will be set on the `lineup` being updated.
"""
input updateLineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyPatch {
  id: UUID
  teamId: UUID
  team: LineupTeamIdFkeyInput
  lineupSpots: LineupSpotLineupIdFkeyInverseInput
  lineupChangesToLineupBeforeIdUsingId: LineupChangeLineupBeforeIdFkeyInverseInput
  lineupChangesToLineupAfterIdUsingId: LineupChangeLineupAfterIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateLineupIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input LineupForGameStateOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `lineup` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `lineup` being updated.
  """
  patch: LineupPatch!
}

"""
Represents an update to a `Lineup`. Fields that are set will be updated.
"""
input LineupPatch {
  id: UUID
  teamId: UUID
  team: LineupTeamIdFkeyInput
  lineupSpots: LineupSpotLineupIdFkeyInverseInput
  lineupChangesToLineupBeforeIdUsingId: LineupChangeLineupBeforeIdFkeyInverseInput
  lineupChangesToLineupAfterIdUsingId: LineupChangeLineupAfterIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateLineupIdFkeyInverseInput
}

"""The `lineup` to be created by this mutation."""
input LineupForGameStateLineupIdFkeyLineupCreateInput {
  id: UUID
  teamId: UUID
  team: LineupTeamIdFkeyInput
  lineupSpots: LineupSpotLineupIdFkeyInverseInput
  lineupChangesToLineupBeforeIdUsingId: LineupChangeLineupBeforeIdFkeyInverseInput
  lineupChangesToLineupAfterIdUsingId: LineupChangeLineupAfterIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateLineupIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input LineupOnLineupForGameStateForLineupForGameStateLineupIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `lineupForGameState` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `lineupForGameState` being updated.
  """
  patch: LineupForGameStatePatch!
}

"""
Represents an update to a `LineupForGameState`. Fields that are set will be updated.
"""
input LineupForGameStatePatch {
  gameStateId: UUID
  lineupId: UUID
  gameState: LineupForGameStateGameStateIdFkeyInput
  lineup: LineupForGameStateLineupIdFkeyInput
}

"""The `lineupForGameState` to be created by this mutation."""
input LineupForGameStateLineupIdFkeyLineupForGameStateCreateInput {
  gameStateId: UUID
  gameState: LineupForGameStateGameStateIdFkeyInput
  lineup: LineupForGameStateLineupIdFkeyInput
}

"""The globally unique `ID` look up for the row to update."""
input LineupChangeOnLineupChangeForLineupChangeLineupAfterIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `lineup` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `lineup` being updated.
  """
  patch: LineupPatch!
}

"""The `lineup` to be created by this mutation."""
input LineupChangeLineupAfterIdFkeyLineupCreateInput {
  id: UUID
  teamId: UUID
  team: LineupTeamIdFkeyInput
  lineupSpots: LineupSpotLineupIdFkeyInverseInput
  lineupChangesToLineupBeforeIdUsingId: LineupChangeLineupBeforeIdFkeyInverseInput
  lineupChangesToLineupAfterIdUsingId: LineupChangeLineupAfterIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateLineupIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input GameEventOnGameEventForGameEventLineupChangeIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `lineupChange` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `lineupChange` being updated.
  """
  patch: LineupChangePatch!
}

"""The `lineupChange` to be created by this mutation."""
input GameEventLineupChangeIdFkeyLineupChangeCreateInput {
  id: UUID
  lineupBeforeId: UUID
  lineupAfterId: UUID
  lineup: LineupChangeLineupAfterIdFkeyInput
  gameEvents: GameEventLineupChangeIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input StolenBaseAttemptOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gameEvent` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gameEvent` being updated.
  """
  patch: GameEventPatch!
}

"""The `gameEvent` to be created by this mutation."""
input GameEventStolenBaseAttemptIdFkeyGameEventCreateInput {
  id: UUID
  plateAppearanceId: UUID
  lineupChangeId: UUID
  plateAppearance: GameEventPlateAppearanceIdFkeyInput
  stolenBaseAttempt: GameEventStolenBaseAttemptIdFkeyInput
  lineupChange: GameEventLineupChangeIdFkeyInput
  gameEventRecords: GameEventRecordGameEventIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input GameEventOnGameEventForGameEventStolenBaseAttemptIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `stolenBaseAttempt` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `stolenBaseAttempt` being updated.
  """
  patch: StolenBaseAttemptPatch!
}

"""
Represents an update to a `StolenBaseAttempt`. Fields that are set will be updated.
"""
input StolenBaseAttemptPatch {
  id: UUID
  runnerId: UUID
  success: Boolean
  player: StolenBaseAttemptRunnerIdFkeyInput
  gameEvents: GameEventStolenBaseAttemptIdFkeyInverseInput
}

"""The `stolenBaseAttempt` to be created by this mutation."""
input GameEventStolenBaseAttemptIdFkeyStolenBaseAttemptCreateInput {
  id: UUID
  runnerId: UUID
  success: Boolean!
  player: StolenBaseAttemptRunnerIdFkeyInput
  gameEvents: GameEventStolenBaseAttemptIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input PlateAppearanceOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gameEvent` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gameEvent` being updated.
  """
  patch: GameEventPatch!
}

"""The `gameEvent` to be created by this mutation."""
input GameEventPlateAppearanceIdFkeyGameEventCreateInput {
  id: UUID
  stolenBaseAttemptId: UUID
  lineupChangeId: UUID
  plateAppearance: GameEventPlateAppearanceIdFkeyInput
  stolenBaseAttempt: GameEventStolenBaseAttemptIdFkeyInput
  lineupChange: GameEventLineupChangeIdFkeyInput
  gameEventRecords: GameEventRecordGameEventIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input GameEventOnGameEventForGameEventPlateAppearanceIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `plateAppearance` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `plateAppearance` being updated.
  """
  patch: PlateAppearancePatch!
}

"""
Represents an update to a `PlateAppearance`. Fields that are set will be updated.
"""
input PlateAppearancePatch {
  id: UUID
  type: PlateAppearanceType
  contact: ContactQuality
  fieldedBy: FieldingPosition
  runsScoredOnSacFly: Int
  routinePlay: Boolean
  basepathMovements: BasepathMovementPlateAppearanceIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput
  gameEvents: GameEventPlateAppearanceIdFkeyInverseInput
}

"""The `plateAppearance` to be created by this mutation."""
input GameEventPlateAppearanceIdFkeyPlateAppearanceCreateInput {
  id: UUID
  type: PlateAppearanceType!
  contact: ContactQuality
  fieldedBy: FieldingPosition
  runsScoredOnSacFly: Int
  routinePlay: Boolean
  basepathMovements: BasepathMovementPlateAppearanceIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput
  gameEvents: GameEventPlateAppearanceIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input GameEventRecordOnGameEventRecordForGameEventRecordGameEventIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gameEvent` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gameEvent` being updated.
  """
  patch: GameEventPatch!
}

"""The `gameEvent` to be created by this mutation."""
input GameEventRecordGameEventIdFkeyGameEventCreateInput {
  id: UUID
  plateAppearanceId: UUID
  stolenBaseAttemptId: UUID
  lineupChangeId: UUID
  plateAppearance: GameEventPlateAppearanceIdFkeyInput
  stolenBaseAttempt: GameEventStolenBaseAttemptIdFkeyInput
  lineupChange: GameEventLineupChangeIdFkeyInput
  gameEventRecords: GameEventRecordGameEventIdFkeyInverseInput
}

"""The fields on `gameEventRecord` to look up the row to update."""
input GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkUsingGameEventRecordGameIdEventIndexKeyUpdate {
  """
  An object where the defined keys will be set on the `gameEventRecord` being updated.
  """
  patch: updateGameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkPatch!
  gameId: UUID!
  eventIndex: Int!
}

"""The globally unique `ID` look up for the row to update."""
input GameStateOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gameEventRecord` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gameEventRecord` being updated.
  """
  patch: GameEventRecordPatch!
}

"""The `gameEventRecord` to be created by this mutation."""
input GameEventRecordGameStateAfterFkGameEventRecordCreateInput {
  id: UUID
  gameId: UUID
  eventIndex: Int!
  gameStateBeforeId: UUID
  gameEventId: UUID
  notes: String
  game: GameEventRecordGameIdFkeyInput
  gameStateBefore: GameEventRecordGameStateBeforeFkInput
  gameStateAfter: GameEventRecordGameStateAfterFkInput
  gameEvent: GameEventRecordGameEventIdFkeyInput
  scoredRunners: ScoredRunnerGameEventRecordIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input GameEventRecordOnGameEventRecordForGameEventRecordGameStateAfterFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gameState` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gameState` being updated.
  """
  patch: GameStatePatch!
}

"""
Represents an update to a `GameState`. Fields that are set will be updated.
"""
input GameStatePatch {
  id: UUID
  gameId: UUID
  gameStateIndex: Int
  playerAtBat: UUID
  inning: Int
  halfInning: HalfInning
  outs: Int
  score: [Int]
  game: GameStateGameIdFkeyInput
  player: GameStatePlayerAtBatFkeyInput
  baseRunners: BaseRunnerGameStateIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateGameStateIdFkeyInverseInput
  gameEventRecordsToGameStateBeforeIdUsingId: GameEventRecordGameStateBeforeFkInverseInput
  gameEventRecordsToGameStateAfterIdUsingId: GameEventRecordGameStateAfterFkInverseInput
}

"""The `gameState` to be created by this mutation."""
input GameEventRecordGameStateAfterFkGameStateCreateInput {
  id: UUID
  gameId: UUID
  gameStateIndex: Int!
  playerAtBat: UUID
  inning: Int!
  halfInning: HalfInning!
  outs: Int!
  score: [Int]!
  game: GameStateGameIdFkeyInput
  player: GameStatePlayerAtBatFkeyInput
  baseRunners: BaseRunnerGameStateIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateGameStateIdFkeyInverseInput
  gameEventRecordsToGameStateBeforeIdUsingId: GameEventRecordGameStateBeforeFkInverseInput
  gameEventRecordsToGameStateAfterIdUsingId: GameEventRecordGameStateAfterFkInverseInput
}

"""The fields on `gameEventRecord` to look up the row to update."""
input GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkUsingGameEventRecordGameIdEventIndexKeyUpdate {
  """
  An object where the defined keys will be set on the `gameEventRecord` being updated.
  """
  patch: updateGameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkPatch!
  gameId: UUID!
  eventIndex: Int!
}

"""The globally unique `ID` look up for the row to update."""
input GameStateOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gameEventRecord` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gameEventRecord` being updated.
  """
  patch: GameEventRecordPatch!
}

"""The `gameEventRecord` to be created by this mutation."""
input GameEventRecordGameStateBeforeFkGameEventRecordCreateInput {
  id: UUID
  gameId: UUID
  eventIndex: Int!
  gameStateAfterId: UUID
  gameEventId: UUID
  notes: String
  game: GameEventRecordGameIdFkeyInput
  gameStateBefore: GameEventRecordGameStateBeforeFkInput
  gameStateAfter: GameEventRecordGameStateAfterFkInput
  gameEvent: GameEventRecordGameEventIdFkeyInput
  scoredRunners: ScoredRunnerGameEventRecordIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input LineupForGameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gameState` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gameState` being updated.
  """
  patch: GameStatePatch!
}

"""The `gameState` to be created by this mutation."""
input LineupForGameStateGameStateIdFkeyGameStateCreateInput {
  id: UUID
  gameId: UUID
  gameStateIndex: Int!
  playerAtBat: UUID
  inning: Int!
  halfInning: HalfInning!
  outs: Int!
  score: [Int]!
  game: GameStateGameIdFkeyInput
  player: GameStatePlayerAtBatFkeyInput
  baseRunners: BaseRunnerGameStateIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateGameStateIdFkeyInverseInput
  gameEventRecordsToGameStateBeforeIdUsingId: GameEventRecordGameStateBeforeFkInverseInput
  gameEventRecordsToGameStateAfterIdUsingId: GameEventRecordGameStateAfterFkInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input GameStateOnLineupForGameStateForLineupForGameStateGameStateIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `lineupForGameState` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `lineupForGameState` being updated.
  """
  patch: LineupForGameStatePatch!
}

"""The `lineupForGameState` to be created by this mutation."""
input LineupForGameStateGameStateIdFkeyLineupForGameStateCreateInput {
  lineupId: UUID
  gameState: LineupForGameStateGameStateIdFkeyInput
  lineup: LineupForGameStateLineupIdFkeyInput
}

"""The globally unique `ID` look up for the row to update."""
input GameEventRecordOnGameEventRecordForGameEventRecordGameStateBeforeFkNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gameState` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gameState` being updated.
  """
  patch: GameStatePatch!
}

"""The `gameState` to be created by this mutation."""
input GameEventRecordGameStateBeforeFkGameStateCreateInput {
  id: UUID
  gameId: UUID
  gameStateIndex: Int!
  playerAtBat: UUID
  inning: Int!
  halfInning: HalfInning!
  outs: Int!
  score: [Int]!
  game: GameStateGameIdFkeyInput
  player: GameStatePlayerAtBatFkeyInput
  baseRunners: BaseRunnerGameStateIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateGameStateIdFkeyInverseInput
  gameEventRecordsToGameStateBeforeIdUsingId: GameEventRecordGameStateBeforeFkInverseInput
  gameEventRecordsToGameStateAfterIdUsingId: GameEventRecordGameStateAfterFkInverseInput
}

"""The fields on `gameEventRecord` to look up the row to update."""
input GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate {
  """
  An object where the defined keys will be set on the `gameEventRecord` being updated.
  """
  patch: updateGameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyPatch!
  gameId: UUID!
  eventIndex: Int!
}

"""The globally unique `ID` look up for the row to update."""
input GameOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gameEventRecord` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gameEventRecord` being updated.
  """
  patch: GameEventRecordPatch!
}

"""The `gameEventRecord` to be created by this mutation."""
input GameEventRecordGameIdFkeyGameEventRecordCreateInput {
  id: UUID
  eventIndex: Int!
  gameStateBeforeId: UUID
  gameStateAfterId: UUID
  gameEventId: UUID
  notes: String
  game: GameEventRecordGameIdFkeyInput
  gameStateBefore: GameEventRecordGameStateBeforeFkInput
  gameStateAfter: GameEventRecordGameStateAfterFkInput
  gameEvent: GameEventRecordGameEventIdFkeyInput
  scoredRunners: ScoredRunnerGameEventRecordIdFkeyInverseInput
}

"""The fields on `game` to look up the row to update."""
input GameOnGameEventRecordForGameEventRecordGameIdFkeyUsingGameNameKeyUpdate {
  """
  An object where the defined keys will be set on the `game` being updated.
  """
  patch: updateGameOnGameEventRecordForGameEventRecordGameIdFkeyPatch!
  name: String!
}

"""The globally unique `ID` look up for the row to update."""
input GameEventRecordOnGameEventRecordForGameEventRecordGameIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `game` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `game` being updated.
  """
  patch: GamePatch!
}

"""Represents an update to a `Game`. Fields that are set will be updated."""
input GamePatch {
  id: UUID
  groupId: UUID
  name: String
  fieldId: UUID
  score: [Int]
  gameLength: Int
  timeStarted: Datetime
  timeEnded: Datetime
  timeSaved: Datetime
  group: GameGroupIdFkeyInput
  field: GameFieldIdFkeyInput
  teams: TeamGameIdFkeyInverseInput
  gameStates: GameStateGameIdFkeyInverseInput
  gameEventRecords: GameEventRecordGameIdFkeyInverseInput
}

"""The `game` to be created by this mutation."""
input GameEventRecordGameIdFkeyGameCreateInput {
  id: UUID
  groupId: UUID
  name: String
  fieldId: UUID
  score: [Int]!
  gameLength: Int
  timeStarted: Datetime!
  timeEnded: Datetime!
  timeSaved: Datetime
  group: GameGroupIdFkeyInput
  field: GameFieldIdFkeyInput
  teams: TeamGameIdFkeyInverseInput
  gameStates: GameStateGameIdFkeyInverseInput
  gameEventRecords: GameEventRecordGameIdFkeyInverseInput
}

"""The fields on `gameEventRecord` to look up the row to update."""
input GameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyUsingGameEventRecordGameIdEventIndexKeyUpdate {
  """
  An object where the defined keys will be set on the `gameEventRecord` being updated.
  """
  patch: updateGameEventRecordOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyPatch!
  gameId: UUID!
  eventIndex: Int!
}

"""The globally unique `ID` look up for the row to update."""
input ScoredRunnerOnScoredRunnerForScoredRunnerGameEventRecordIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gameEventRecord` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gameEventRecord` being updated.
  """
  patch: GameEventRecordPatch!
}

"""The `gameEventRecord` to be created by this mutation."""
input ScoredRunnerGameEventRecordIdFkeyGameEventRecordCreateInput {
  id: UUID
  gameId: UUID
  eventIndex: Int!
  gameStateBeforeId: UUID
  gameStateAfterId: UUID
  gameEventId: UUID
  notes: String
  game: GameEventRecordGameIdFkeyInput
  gameStateBefore: GameEventRecordGameStateBeforeFkInput
  gameStateAfter: GameEventRecordGameStateAfterFkInput
  gameEvent: GameEventRecordGameEventIdFkeyInput
  scoredRunners: ScoredRunnerGameEventRecordIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input PlayerOnScoredRunnerForScoredRunnerRunnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `scoredRunner` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `scoredRunner` being updated.
  """
  patch: ScoredRunnerPatch!
}

"""The `scoredRunner` to be created by this mutation."""
input ScoredRunnerRunnerIdFkeyScoredRunnerCreateInput {
  gameEventRecordId: UUID
  battedIn: Boolean!
  gameEventRecord: ScoredRunnerGameEventRecordIdFkeyInput
  player: ScoredRunnerRunnerIdFkeyInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnBaseRunnerForBaseRunnerRunnerIdFkeyPatch!
  firstName: String!
  lastName: String!
}

"""The globally unique `ID` look up for the row to update."""
input BaseRunnerOnBaseRunnerForBaseRunnerRunnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `player` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: PlayerPatch!
}

"""The `player` to be created by this mutation."""
input BaseRunnerRunnerIdFkeyPlayerCreateInput {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String!
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input GameStateOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `baseRunner` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `baseRunner` being updated.
  """
  patch: BaseRunnerPatch!
}

"""The `baseRunner` to be created by this mutation."""
input BaseRunnerGameStateIdFkeyBaseRunnerCreateInput {
  runnerId: UUID
  base: BaseType!
  gameState: BaseRunnerGameStateIdFkeyInput
  player: BaseRunnerRunnerIdFkeyInput
}

"""The globally unique `ID` look up for the row to update."""
input PlayerOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gameState` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gameState` being updated.
  """
  patch: GameStatePatch!
}

"""The `gameState` to be created by this mutation."""
input GameStatePlayerAtBatFkeyGameStateCreateInput {
  id: UUID
  gameId: UUID
  gameStateIndex: Int!
  inning: Int!
  halfInning: HalfInning!
  outs: Int!
  score: [Int]!
  game: GameStateGameIdFkeyInput
  player: GameStatePlayerAtBatFkeyInput
  baseRunners: BaseRunnerGameStateIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateGameStateIdFkeyInverseInput
  gameEventRecordsToGameStateBeforeIdUsingId: GameEventRecordGameStateBeforeFkInverseInput
  gameEventRecordsToGameStateAfterIdUsingId: GameEventRecordGameStateAfterFkInverseInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyPatch!
  firstName: String!
  lastName: String!
}

"""The globally unique `ID` look up for the row to update."""
input StolenBaseAttemptOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `player` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: PlayerPatch!
}

"""The `player` to be created by this mutation."""
input StolenBaseAttemptRunnerIdFkeyPlayerCreateInput {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String!
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input PlayerOnStolenBaseAttemptForStolenBaseAttemptRunnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `stolenBaseAttempt` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `stolenBaseAttempt` being updated.
  """
  patch: StolenBaseAttemptPatch!
}

"""The `stolenBaseAttempt` to be created by this mutation."""
input StolenBaseAttemptRunnerIdFkeyStolenBaseAttemptCreateInput {
  id: UUID
  success: Boolean!
  player: StolenBaseAttemptRunnerIdFkeyInput
  gameEvents: GameEventStolenBaseAttemptIdFkeyInverseInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyPatch!
  firstName: String!
  lastName: String!
}

"""The globally unique `ID` look up for the row to update."""
input OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `player` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: PlayerPatch!
}

"""The `player` to be created by this mutation."""
input OutOnPlayRunnerRunnerIdFkeyPlayerCreateInput {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String!
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input PlateAppearanceOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `outOnPlayRunner` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `outOnPlayRunner` being updated.
  """
  patch: OutOnPlayRunnerPatch!
}

"""
Represents an update to a `OutOnPlayRunner`. Fields that are set will be updated.
"""
input OutOnPlayRunnerPatch {
  plateAppearanceId: UUID
  runnerId: UUID
  plateAppearance: OutOnPlayRunnerPlateAppearanceIdFkeyInput
  player: OutOnPlayRunnerRunnerIdFkeyInput
}

"""The `outOnPlayRunner` to be created by this mutation."""
input OutOnPlayRunnerPlateAppearanceIdFkeyOutOnPlayRunnerCreateInput {
  runnerId: UUID
  plateAppearance: OutOnPlayRunnerPlateAppearanceIdFkeyInput
  player: OutOnPlayRunnerRunnerIdFkeyInput
}

"""The globally unique `ID` look up for the row to update."""
input OutOnPlayRunnerOnOutOnPlayRunnerForOutOnPlayRunnerPlateAppearanceIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `plateAppearance` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `plateAppearance` being updated.
  """
  patch: PlateAppearancePatch!
}

"""The `plateAppearance` to be created by this mutation."""
input OutOnPlayRunnerPlateAppearanceIdFkeyPlateAppearanceCreateInput {
  id: UUID
  type: PlateAppearanceType!
  contact: ContactQuality
  fieldedBy: FieldingPosition
  runsScoredOnSacFly: Int
  routinePlay: Boolean
  basepathMovements: BasepathMovementPlateAppearanceIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput
  gameEvents: GameEventPlateAppearanceIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input PlayerOnOutOnPlayRunnerForOutOnPlayRunnerRunnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `outOnPlayRunner` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `outOnPlayRunner` being updated.
  """
  patch: OutOnPlayRunnerPatch!
}

"""The `outOnPlayRunner` to be created by this mutation."""
input OutOnPlayRunnerRunnerIdFkeyOutOnPlayRunnerCreateInput {
  plateAppearanceId: UUID
  plateAppearance: OutOnPlayRunnerPlateAppearanceIdFkeyInput
  player: OutOnPlayRunnerRunnerIdFkeyInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyPatch!
  firstName: String!
  lastName: String!
}

"""The globally unique `ID` look up for the row to update."""
input BasepathMovementOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `player` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: PlayerPatch!
}

"""The `player` to be created by this mutation."""
input BasepathMovementRunnerIdFkeyPlayerCreateInput {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String!
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input PlateAppearanceOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `basepathMovement` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `basepathMovement` being updated.
  """
  patch: BasepathMovementPatch!
}

"""
Represents an update to a `BasepathMovement`. Fields that are set will be updated.
"""
input BasepathMovementPatch {
  plateAppearanceId: UUID
  runnerId: UUID
  endBase: BaseType
  wasSafe: Boolean
  plateAppearance: BasepathMovementPlateAppearanceIdFkeyInput
  player: BasepathMovementRunnerIdFkeyInput
}

"""The `basepathMovement` to be created by this mutation."""
input BasepathMovementPlateAppearanceIdFkeyBasepathMovementCreateInput {
  runnerId: UUID
  endBase: BaseType
  wasSafe: Boolean!
  plateAppearance: BasepathMovementPlateAppearanceIdFkeyInput
  player: BasepathMovementRunnerIdFkeyInput
}

"""The globally unique `ID` look up for the row to update."""
input BasepathMovementOnBasepathMovementForBasepathMovementPlateAppearanceIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `plateAppearance` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `plateAppearance` being updated.
  """
  patch: PlateAppearancePatch!
}

"""The `plateAppearance` to be created by this mutation."""
input BasepathMovementPlateAppearanceIdFkeyPlateAppearanceCreateInput {
  id: UUID
  type: PlateAppearanceType!
  contact: ContactQuality
  fieldedBy: FieldingPosition
  runsScoredOnSacFly: Int
  routinePlay: Boolean
  basepathMovements: BasepathMovementPlateAppearanceIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput
  gameEvents: GameEventPlateAppearanceIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input PlayerOnBasepathMovementForBasepathMovementRunnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `basepathMovement` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `basepathMovement` being updated.
  """
  patch: BasepathMovementPatch!
}

"""The `basepathMovement` to be created by this mutation."""
input BasepathMovementRunnerIdFkeyBasepathMovementCreateInput {
  plateAppearanceId: UUID
  endBase: BaseType
  wasSafe: Boolean!
  plateAppearance: BasepathMovementPlateAppearanceIdFkeyInput
  player: BasepathMovementRunnerIdFkeyInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnLineupSpotForLineupSpotPlayerIdFkeyUsingPlayerFirstNameLastNameKeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnLineupSpotForLineupSpotPlayerIdFkeyPatch!
  firstName: String!
  lastName: String!
}

"""The globally unique `ID` look up for the row to update."""
input LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `player` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: PlayerPatch!
}

"""The `player` to be created by this mutation."""
input LineupSpotPlayerIdFkeyPlayerCreateInput {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String!
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""The fields on `lineupSpot` to look up the row to update."""
input LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate {
  """
  An object where the defined keys will be set on the `lineupSpot` being updated.
  """
  patch: updateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch!
  lineupId: UUID!
  battingOrder: Int!
}

"""The fields on `lineupSpot` to look up the row to update."""
input LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate {
  """
  An object where the defined keys will be set on the `lineupSpot` being updated.
  """
  patch: updateLineupSpotOnLineupSpotForLineupSpotLineupIdFkeyPatch!
  lineupId: UUID!
  position: FieldingPosition!
}

"""The globally unique `ID` look up for the row to update."""
input LineupOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `lineupSpot` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `lineupSpot` being updated.
  """
  patch: LineupSpotPatch!
}

"""
Represents an update to a `LineupSpot`. Fields that are set will be updated.
"""
input LineupSpotPatch {
  lineupId: UUID
  playerId: UUID
  battingOrder: Int
  position: FieldingPosition
  lineup: LineupSpotLineupIdFkeyInput
  player: LineupSpotPlayerIdFkeyInput
}

"""The `lineupSpot` to be created by this mutation."""
input LineupSpotLineupIdFkeyLineupSpotCreateInput {
  playerId: UUID
  battingOrder: Int!
  position: FieldingPosition
  lineup: LineupSpotLineupIdFkeyInput
  player: LineupSpotPlayerIdFkeyInput
}

"""The globally unique `ID` look up for the row to update."""
input TeamOnLineupForLineupTeamIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `lineup` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `lineup` being updated.
  """
  patch: LineupPatch!
}

"""The `lineup` to be created by this mutation."""
input LineupTeamIdFkeyLineupCreateInput {
  id: UUID
  team: LineupTeamIdFkeyInput
  lineupSpots: LineupSpotLineupIdFkeyInverseInput
  lineupChangesToLineupBeforeIdUsingId: LineupChangeLineupBeforeIdFkeyInverseInput
  lineupChangesToLineupAfterIdUsingId: LineupChangeLineupAfterIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateLineupIdFkeyInverseInput
}

"""The fields on `team` to look up the row to update."""
input TeamOnLineupForLineupTeamIdFkeyUsingTeamGameIdRoleKeyUpdate {
  """
  An object where the defined keys will be set on the `team` being updated.
  """
  patch: updateTeamOnLineupForLineupTeamIdFkeyPatch!
  gameId: UUID!
  role: TeamRole!
}

"""The globally unique `ID` look up for the row to update."""
input LineupOnLineupForLineupTeamIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `team` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `team` being updated.
  """
  patch: TeamPatch!
}

"""Represents an update to a `Team`. Fields that are set will be updated."""
input TeamPatch {
  id: UUID
  gameId: UUID
  role: TeamRole
  name: String
  captainId: UUID
  winner: Boolean
  game: TeamGameIdFkeyInput
  player: TeamCaptainIdFkeyInput
  lineups: LineupTeamIdFkeyInverseInput
}

"""The `team` to be created by this mutation."""
input LineupTeamIdFkeyTeamCreateInput {
  id: UUID
  gameId: UUID
  role: TeamRole!
  name: String
  captainId: UUID
  winner: Boolean
  game: TeamGameIdFkeyInput
  player: TeamCaptainIdFkeyInput
  lineups: LineupTeamIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input LineupSpotOnLineupSpotForLineupSpotLineupIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `lineup` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `lineup` being updated.
  """
  patch: LineupPatch!
}

"""The `lineup` to be created by this mutation."""
input LineupSpotLineupIdFkeyLineupCreateInput {
  id: UUID
  teamId: UUID
  team: LineupTeamIdFkeyInput
  lineupSpots: LineupSpotLineupIdFkeyInverseInput
  lineupChangesToLineupBeforeIdUsingId: LineupChangeLineupBeforeIdFkeyInverseInput
  lineupChangesToLineupAfterIdUsingId: LineupChangeLineupAfterIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateLineupIdFkeyInverseInput
}

"""The fields on `lineupSpot` to look up the row to update."""
input LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdBattingOrderKeyUpdate {
  """
  An object where the defined keys will be set on the `lineupSpot` being updated.
  """
  patch: updateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch!
  lineupId: UUID!
  battingOrder: Int!
}

"""The fields on `lineupSpot` to look up the row to update."""
input LineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyUsingLineupSpotLineupIdPositionKeyUpdate {
  """
  An object where the defined keys will be set on the `lineupSpot` being updated.
  """
  patch: updateLineupSpotOnLineupSpotForLineupSpotPlayerIdFkeyPatch!
  lineupId: UUID!
  position: FieldingPosition!
}

"""The globally unique `ID` look up for the row to update."""
input PlayerOnLineupSpotForLineupSpotPlayerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `lineupSpot` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `lineupSpot` being updated.
  """
  patch: LineupSpotPatch!
}

"""The `lineupSpot` to be created by this mutation."""
input LineupSpotPlayerIdFkeyLineupSpotCreateInput {
  lineupId: UUID
  battingOrder: Int!
  position: FieldingPosition
  lineup: LineupSpotLineupIdFkeyInput
  player: LineupSpotPlayerIdFkeyInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnTeamForTeamCaptainIdFkeyUsingPlayerFirstNameLastNameKeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnTeamForTeamCaptainIdFkeyPatch!
  firstName: String!
  lastName: String!
}

"""The globally unique `ID` look up for the row to update."""
input TeamOnTeamForTeamCaptainIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `player` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: PlayerPatch!
}

"""The `player` to be created by this mutation."""
input TeamCaptainIdFkeyPlayerCreateInput {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String!
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""The fields on `team` to look up the row to update."""
input TeamOnTeamForTeamCaptainIdFkeyUsingTeamGameIdRoleKeyUpdate {
  """
  An object where the defined keys will be set on the `team` being updated.
  """
  patch: updateTeamOnTeamForTeamCaptainIdFkeyPatch!
  gameId: UUID!
  role: TeamRole!
}

"""The globally unique `ID` look up for the row to update."""
input PlayerOnTeamForTeamCaptainIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `team` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `team` being updated.
  """
  patch: TeamPatch!
}

"""The `team` to be created by this mutation."""
input TeamCaptainIdFkeyTeamCreateInput {
  id: UUID
  gameId: UUID
  role: TeamRole!
  name: String
  winner: Boolean
  game: TeamGameIdFkeyInput
  player: TeamCaptainIdFkeyInput
  lineups: LineupTeamIdFkeyInverseInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnPlayerForFakePublicPlayerForeignKey0UsingPlayerFirstNameLastNameKeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnPlayerForFakePublicPlayerForeignKey0Patch!
  firstName: String!
  lastName: String!
}

"""The globally unique `ID` look up for the row to update."""
input LegacyPlayerOnPlayerForFakePublicPlayerForeignKey0NodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `player` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: PlayerPatch!
}

"""The `player` to be created by this mutation."""
input FakePublicPlayerForeignKey0PlayerCreateInput {
  id: UUID
  groupId: UUID
  firstName: String!
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input LegacyStatLineOnLegacyStatLineForFakePublicLegacyStatLineForeignKey0NodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `legacyPlayer` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `legacyPlayer` being updated.
  """
  patch: LegacyPlayerPatch!
}

"""
Represents an update to a `LegacyPlayer`. Fields that are set will be updated.
"""
input LegacyPlayerPatch {
  playerId: Int
  playerName: String
  playerImage: String
  memberId: String
  legacyStatLines: FakePublicLegacyStatLineForeignKey0InverseInput
  players: FakePublicPlayerForeignKey0InverseInput
}

"""The `legacyPlayer` to be created by this mutation."""
input FakePublicLegacyStatLineForeignKey0LegacyPlayerCreateInput {
  playerName: String!
  playerImage: String
  memberId: String
  legacyStatLines: FakePublicLegacyStatLineForeignKey0InverseInput
  players: FakePublicPlayerForeignKey0InverseInput
}

"""
Input for the nested mutation of `legacyGame` in the `LegacyStatLineInput` mutation.
"""
input FakePublicLegacyStatLineForeignKey1Input {
  """
  The primary key(s) for `legacyGame` for the far side of the relationship.
  """
  connectByGameId: LegacyGameFakePublicLegacyGamePrimaryKeyConnect

  """
  The primary key(s) for `legacyGame` for the far side of the relationship.
  """
  connectByNodeId: LegacyGameNodeIdConnect

  """
  The primary key(s) for `legacyGame` for the far side of the relationship.
  """
  deleteByGameId: LegacyGameFakePublicLegacyGamePrimaryKeyDelete

  """
  The primary key(s) for `legacyGame` for the far side of the relationship.
  """
  deleteByNodeId: LegacyGameNodeIdDelete

  """
  The primary key(s) and patch data for `legacyGame` for the far side of the relationship.
  """
  updateByGameId: LegacyGameOnLegacyStatLineForFakePublicLegacyStatLineForeignKey1UsingFakePublicLegacyGamePrimaryKeyUpdate

  """
  The primary key(s) and patch data for `legacyGame` for the far side of the relationship.
  """
  updateByNodeId: LegacyStatLineOnLegacyStatLineForFakePublicLegacyStatLineForeignKey1NodeIdUpdate

  """
  A `LegacyGameInput` object that will be created and connected to this object.
  """
  create: FakePublicLegacyStatLineForeignKey1LegacyGameCreateInput
}

"""The fields on `legacyGame` to look up the row to connect."""
input LegacyGameFakePublicLegacyGamePrimaryKeyConnect {
  gameId: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input LegacyGameNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `legacyGame` to be connected.
  """
  nodeId: ID!
}

"""The fields on `legacyGame` to look up the row to delete."""
input LegacyGameFakePublicLegacyGamePrimaryKeyDelete {
  gameId: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input LegacyGameNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `legacyGame` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `legacyGame` to look up the row to update."""
input LegacyGameOnLegacyStatLineForFakePublicLegacyStatLineForeignKey1UsingFakePublicLegacyGamePrimaryKeyUpdate {
  """
  An object where the defined keys will be set on the `legacyGame` being updated.
  """
  patch: updateLegacyGameOnLegacyStatLineForFakePublicLegacyStatLineForeignKey1Patch!
  gameId: Int!
}

"""
An object where the defined keys will be set on the `legacyGame` being updated.
"""
input updateLegacyGameOnLegacyStatLineForFakePublicLegacyStatLineForeignKey1Patch {
  gameTitle: String
  gameDate: Date
  gameStartTime: Time
  gameEndTime: Time
  gameTeamId1: Int
  gameTeamId2: Int
  season: Int
  legacyStatLines: FakePublicLegacyStatLineForeignKey1InverseInput
}

"""
Input for the nested mutation of `legacyStatLine` in the `LegacyGameInput` mutation.
"""
input FakePublicLegacyStatLineForeignKey1InverseInput {
  """
  A `LegacyStatLineInput` object that will be created and connected to this object.
  """
  create: [FakePublicLegacyStatLineForeignKey1LegacyStatLineCreateInput!]
}

"""The `legacyStatLine` to be created by this mutation."""
input FakePublicLegacyStatLineForeignKey1LegacyStatLineCreateInput {
  sbStatsId: Int!
  playerId: Int
  sbStatsTeam: Int
  atBats: Int!
  runs: Int!
  hits: Int!
  singles: Int!
  doubles: Int!
  triples: Int!
  homeruns: Int!
  rbi: Int!
  walks: Int!
  strikeouts: Int!
  sacFlies: Int!
  legacyPlayer: FakePublicLegacyStatLineForeignKey0Input
  legacyGame: FakePublicLegacyStatLineForeignKey1Input
  legacyTeam: FakePublicLegacyStatLineForeignKey2Input
}

"""
Input for the nested mutation of `legacyTeam` in the `LegacyStatLineInput` mutation.
"""
input FakePublicLegacyStatLineForeignKey2Input {
  """
  The primary key(s) for `legacyTeam` for the far side of the relationship.
  """
  connectByTeamId: LegacyTeamFakePublicLegacyTeamPrimaryKeyConnect

  """
  The primary key(s) for `legacyTeam` for the far side of the relationship.
  """
  connectByNodeId: LegacyTeamNodeIdConnect

  """
  The primary key(s) for `legacyTeam` for the far side of the relationship.
  """
  deleteByTeamId: LegacyTeamFakePublicLegacyTeamPrimaryKeyDelete

  """
  The primary key(s) for `legacyTeam` for the far side of the relationship.
  """
  deleteByNodeId: LegacyTeamNodeIdDelete

  """
  The primary key(s) and patch data for `legacyTeam` for the far side of the relationship.
  """
  updateByTeamId: LegacyTeamOnLegacyStatLineForFakePublicLegacyStatLineForeignKey2UsingFakePublicLegacyTeamPrimaryKeyUpdate

  """
  The primary key(s) and patch data for `legacyTeam` for the far side of the relationship.
  """
  updateByNodeId: LegacyStatLineOnLegacyStatLineForFakePublicLegacyStatLineForeignKey2NodeIdUpdate

  """
  A `LegacyTeamInput` object that will be created and connected to this object.
  """
  create: FakePublicLegacyStatLineForeignKey2LegacyTeamCreateInput
}

"""The fields on `legacyTeam` to look up the row to connect."""
input LegacyTeamFakePublicLegacyTeamPrimaryKeyConnect {
  teamId: Int!
}

"""The globally unique `ID` look up for the row to connect."""
input LegacyTeamNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `legacyTeam` to be connected.
  """
  nodeId: ID!
}

"""The fields on `legacyTeam` to look up the row to delete."""
input LegacyTeamFakePublicLegacyTeamPrimaryKeyDelete {
  teamId: Int!
}

"""The globally unique `ID` look up for the row to delete."""
input LegacyTeamNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `legacyTeam` to be deleted.
  """
  nodeId: ID!
}

"""The fields on `legacyTeam` to look up the row to update."""
input LegacyTeamOnLegacyStatLineForFakePublicLegacyStatLineForeignKey2UsingFakePublicLegacyTeamPrimaryKeyUpdate {
  """
  An object where the defined keys will be set on the `legacyTeam` being updated.
  """
  patch: updateLegacyTeamOnLegacyStatLineForFakePublicLegacyStatLineForeignKey2Patch!
  teamId: Int!
}

"""
An object where the defined keys will be set on the `legacyTeam` being updated.
"""
input updateLegacyTeamOnLegacyStatLineForFakePublicLegacyStatLineForeignKey2Patch {
  teamId: Int
  teamName: String
  legacyStatLines: FakePublicLegacyStatLineForeignKey2InverseInput
}

"""
Input for the nested mutation of `legacyStatLine` in the `LegacyTeamInput` mutation.
"""
input FakePublicLegacyStatLineForeignKey2InverseInput {
  """
  A `LegacyStatLineInput` object that will be created and connected to this object.
  """
  create: [FakePublicLegacyStatLineForeignKey2LegacyStatLineCreateInput!]
}

"""The `legacyStatLine` to be created by this mutation."""
input FakePublicLegacyStatLineForeignKey2LegacyStatLineCreateInput {
  sbStatsId: Int!
  playerId: Int
  gameId: Int
  atBats: Int!
  runs: Int!
  hits: Int!
  singles: Int!
  doubles: Int!
  triples: Int!
  homeruns: Int!
  rbi: Int!
  walks: Int!
  strikeouts: Int!
  sacFlies: Int!
  legacyPlayer: FakePublicLegacyStatLineForeignKey0Input
  legacyGame: FakePublicLegacyStatLineForeignKey1Input
  legacyTeam: FakePublicLegacyStatLineForeignKey2Input
}

"""The globally unique `ID` look up for the row to update."""
input LegacyStatLineOnLegacyStatLineForFakePublicLegacyStatLineForeignKey2NodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `legacyTeam` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `legacyTeam` being updated.
  """
  patch: LegacyTeamPatch!
}

"""
Represents an update to a `LegacyTeam`. Fields that are set will be updated.
"""
input LegacyTeamPatch {
  teamId: Int
  teamName: String
  legacyStatLines: FakePublicLegacyStatLineForeignKey2InverseInput
}

"""The `legacyTeam` to be created by this mutation."""
input FakePublicLegacyStatLineForeignKey2LegacyTeamCreateInput {
  teamId: Int!
  teamName: String!
  legacyStatLines: FakePublicLegacyStatLineForeignKey2InverseInput
}

"""The globally unique `ID` look up for the row to update."""
input LegacyStatLineOnLegacyStatLineForFakePublicLegacyStatLineForeignKey1NodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `legacyGame` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `legacyGame` being updated.
  """
  patch: LegacyGamePatch!
}

"""
Represents an update to a `LegacyGame`. Fields that are set will be updated.
"""
input LegacyGamePatch {
  gameId: Int
  gameTitle: String
  gameDate: Date
  gameStartTime: Time
  gameEndTime: Time
  gameTeamId1: Int
  gameTeamId2: Int
  season: Int
  legacyStatLines: FakePublicLegacyStatLineForeignKey1InverseInput
}

"""The `legacyGame` to be created by this mutation."""
input FakePublicLegacyStatLineForeignKey1LegacyGameCreateInput {
  gameTitle: String!
  gameDate: Date!
  gameStartTime: Time!
  gameEndTime: Time!
  gameTeamId1: Int!
  gameTeamId2: Int!
  season: Int!
  legacyStatLines: FakePublicLegacyStatLineForeignKey1InverseInput
}

"""The globally unique `ID` look up for the row to update."""
input PlayerOnPlayerForFakePublicPlayerForeignKey0NodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `legacyPlayer` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `legacyPlayer` being updated.
  """
  patch: LegacyPlayerPatch!
}

"""The `legacyPlayer` to be created by this mutation."""
input FakePublicPlayerForeignKey0LegacyPlayerCreateInput {
  playerId: Int!
  playerName: String!
  playerImage: String
  memberId: String
  legacyStatLines: FakePublicLegacyStatLineForeignKey0InverseInput
  players: FakePublicPlayerForeignKey0InverseInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnGameStateForGameStatePlayerAtBatFkeyUsingPlayerFirstNameLastNameKeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnGameStateForGameStatePlayerAtBatFkeyPatch!
  firstName: String!
  lastName: String!
}

"""The globally unique `ID` look up for the row to update."""
input GameStateOnGameStateForGameStatePlayerAtBatFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `player` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: PlayerPatch!
}

"""The `player` to be created by this mutation."""
input GameStatePlayerAtBatFkeyPlayerCreateInput {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String!
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input GameOnGameStateForGameStateGameIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gameState` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gameState` being updated.
  """
  patch: GameStatePatch!
}

"""The `gameState` to be created by this mutation."""
input GameStateGameIdFkeyGameStateCreateInput {
  id: UUID
  gameStateIndex: Int!
  playerAtBat: UUID
  inning: Int!
  halfInning: HalfInning!
  outs: Int!
  score: [Int]!
  game: GameStateGameIdFkeyInput
  player: GameStatePlayerAtBatFkeyInput
  baseRunners: BaseRunnerGameStateIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateGameStateIdFkeyInverseInput
  gameEventRecordsToGameStateBeforeIdUsingId: GameEventRecordGameStateBeforeFkInverseInput
  gameEventRecordsToGameStateAfterIdUsingId: GameEventRecordGameStateAfterFkInverseInput
}

"""The fields on `game` to look up the row to update."""
input GameOnTeamForTeamGameIdFkeyUsingGameNameKeyUpdate {
  """
  An object where the defined keys will be set on the `game` being updated.
  """
  patch: updateGameOnTeamForTeamGameIdFkeyPatch!
  name: String!
}

"""The globally unique `ID` look up for the row to update."""
input TeamOnTeamForTeamGameIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `game` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `game` being updated.
  """
  patch: GamePatch!
}

"""The `game` to be created by this mutation."""
input TeamGameIdFkeyGameCreateInput {
  id: UUID
  groupId: UUID
  name: String
  fieldId: UUID
  score: [Int]!
  gameLength: Int
  timeStarted: Datetime!
  timeEnded: Datetime!
  timeSaved: Datetime
  group: GameGroupIdFkeyInput
  field: GameFieldIdFkeyInput
  teams: TeamGameIdFkeyInverseInput
  gameStates: GameStateGameIdFkeyInverseInput
  gameEventRecords: GameEventRecordGameIdFkeyInverseInput
}

"""The fields on `team` to look up the row to update."""
input TeamOnTeamForTeamGameIdFkeyUsingTeamGameIdRoleKeyUpdate {
  """
  An object where the defined keys will be set on the `team` being updated.
  """
  patch: updateTeamOnTeamForTeamGameIdFkeyPatch!
  gameId: UUID!
  role: TeamRole!
}

"""The globally unique `ID` look up for the row to update."""
input GameOnTeamForTeamGameIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `team` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `team` being updated.
  """
  patch: TeamPatch!
}

"""The `team` to be created by this mutation."""
input TeamGameIdFkeyTeamCreateInput {
  id: UUID
  role: TeamRole!
  name: String
  captainId: UUID
  winner: Boolean
  game: TeamGameIdFkeyInput
  player: TeamCaptainIdFkeyInput
  lineups: LineupTeamIdFkeyInverseInput
}

"""The fields on `game` to look up the row to update."""
input GameOnGameForGameFieldIdFkeyUsingGameNameKeyUpdate {
  """
  An object where the defined keys will be set on the `game` being updated.
  """
  patch: updateGameOnGameForGameFieldIdFkeyPatch!
  name: String!
}

"""The globally unique `ID` look up for the row to update."""
input FieldOnGameForGameFieldIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `game` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `game` being updated.
  """
  patch: GamePatch!
}

"""The `game` to be created by this mutation."""
input GameFieldIdFkeyGameCreateInput {
  id: UUID
  groupId: UUID
  name: String
  score: [Int]!
  gameLength: Int
  timeStarted: Datetime!
  timeEnded: Datetime!
  timeSaved: Datetime
  group: GameGroupIdFkeyInput
  field: GameFieldIdFkeyInput
  teams: TeamGameIdFkeyInverseInput
  gameStates: GameStateGameIdFkeyInverseInput
  gameEventRecords: GameEventRecordGameIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input GameOnGameForGameFieldIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `field` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `field` being updated.
  """
  patch: FieldPatch!
}

"""
Represents an update to a `Field`. Fields that are set will be updated.
"""
input FieldPatch {
  id: UUID
  name: String
  notes: String
  games: GameFieldIdFkeyInverseInput
}

"""The `field` to be created by this mutation."""
input GameFieldIdFkeyFieldCreateInput {
  id: UUID
  name: String!
  notes: String
  games: GameFieldIdFkeyInverseInput
}

"""The fields on `game` to look up the row to update."""
input GameOnGameForGameGroupIdFkeyUsingGameNameKeyUpdate {
  """
  An object where the defined keys will be set on the `game` being updated.
  """
  patch: updateGameOnGameForGameGroupIdFkeyPatch!
  name: String!
}

"""The globally unique `ID` look up for the row to update."""
input GroupOnGameForGameGroupIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `game` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `game` being updated.
  """
  patch: GamePatch!
}

"""The `game` to be created by this mutation."""
input GameGroupIdFkeyGameCreateInput {
  id: UUID
  name: String
  fieldId: UUID
  score: [Int]!
  gameLength: Int
  timeStarted: Datetime!
  timeEnded: Datetime!
  timeSaved: Datetime
  group: GameGroupIdFkeyInput
  field: GameFieldIdFkeyInput
  teams: TeamGameIdFkeyInverseInput
  gameStates: GameStateGameIdFkeyInverseInput
  gameEventRecords: GameEventRecordGameIdFkeyInverseInput
}

"""The fields on `group` to look up the row to update."""
input GroupOnPlayerForPlayerGroupIdFkeyUsingGroupNameKeyUpdate {
  """
  An object where the defined keys will be set on the `group` being updated.
  """
  patch: updateGroupOnPlayerForPlayerGroupIdFkeyPatch!
  name: String!
}

"""The globally unique `ID` look up for the row to update."""
input PlayerOnPlayerForPlayerGroupIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `group` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `group` being updated.
  """
  patch: GroupPatch!
}

"""
Represents an update to a `Group`. Fields that are set will be updated.
"""
input GroupPatch {
  id: UUID
  name: String
  notes: String
  players: PlayerGroupIdFkeyInverseInput
  games: GameGroupIdFkeyInverseInput
}

"""The `group` to be created by this mutation."""
input PlayerGroupIdFkeyGroupCreateInput {
  id: UUID
  name: String!
  notes: String
  players: PlayerGroupIdFkeyInverseInput
  games: GameGroupIdFkeyInverseInput
}

"""The fields on `player` to look up the row to update."""
input PlayerOnPlayerForPlayerGroupIdFkeyUsingPlayerFirstNameLastNameKeyUpdate {
  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: updatePlayerOnPlayerForPlayerGroupIdFkeyPatch!
  firstName: String!
  lastName: String!
}

"""The globally unique `ID` look up for the row to update."""
input GroupOnPlayerForPlayerGroupIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `player` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `player` being updated.
  """
  patch: PlayerPatch!
}

"""The `player` to be created by this mutation."""
input PlayerGroupIdFkeyPlayerCreateInput {
  id: UUID
  legacyPlayerId: Int
  firstName: String!
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""The fields on `group` to look up the row to update."""
input GroupOnGameForGameGroupIdFkeyUsingGroupNameKeyUpdate {
  """
  An object where the defined keys will be set on the `group` being updated.
  """
  patch: updateGroupOnGameForGameGroupIdFkeyPatch!
  name: String!
}

"""The globally unique `ID` look up for the row to update."""
input GameOnGameForGameGroupIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `group` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `group` being updated.
  """
  patch: GroupPatch!
}

"""The `group` to be created by this mutation."""
input GameGroupIdFkeyGroupCreateInput {
  id: UUID
  name: String!
  notes: String
  players: PlayerGroupIdFkeyInverseInput
  games: GameGroupIdFkeyInverseInput
}

"""The fields on `game` to look up the row to update."""
input GameOnGameStateForGameStateGameIdFkeyUsingGameNameKeyUpdate {
  """
  An object where the defined keys will be set on the `game` being updated.
  """
  patch: updateGameOnGameStateForGameStateGameIdFkeyPatch!
  name: String!
}

"""The globally unique `ID` look up for the row to update."""
input GameStateOnGameStateForGameStateGameIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `game` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `game` being updated.
  """
  patch: GamePatch!
}

"""The `game` to be created by this mutation."""
input GameStateGameIdFkeyGameCreateInput {
  id: UUID
  groupId: UUID
  name: String
  fieldId: UUID
  score: [Int]!
  gameLength: Int
  timeStarted: Datetime!
  timeEnded: Datetime!
  timeSaved: Datetime
  group: GameGroupIdFkeyInput
  field: GameFieldIdFkeyInput
  teams: TeamGameIdFkeyInverseInput
  gameStates: GameStateGameIdFkeyInverseInput
  gameEventRecords: GameEventRecordGameIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to update."""
input BaseRunnerOnBaseRunnerForBaseRunnerGameStateIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gameState` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gameState` being updated.
  """
  patch: GameStatePatch!
}

"""The `gameState` to be created by this mutation."""
input BaseRunnerGameStateIdFkeyGameStateCreateInput {
  id: UUID
  gameId: UUID
  gameStateIndex: Int!
  playerAtBat: UUID
  inning: Int!
  halfInning: HalfInning!
  outs: Int!
  score: [Int]!
  game: GameStateGameIdFkeyInput
  player: GameStatePlayerAtBatFkeyInput
  baseRunners: BaseRunnerGameStateIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateGameStateIdFkeyInverseInput
  gameEventRecordsToGameStateBeforeIdUsingId: GameEventRecordGameStateBeforeFkInverseInput
  gameEventRecordsToGameStateAfterIdUsingId: GameEventRecordGameStateAfterFkInverseInput
}

"""The output of our create `BasepathMovement` mutation."""
type CreateBasepathMovementPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BasepathMovement` that was created by this mutation."""
  basepathMovement: BasepathMovement

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `PlateAppearance` that is related to this `BasepathMovement`.
  """
  plateAppearance: PlateAppearance

  """Reads a single `Player` that is related to this `BasepathMovement`."""
  runner: Player
}

"""All input for the create `BasepathMovement` mutation."""
input CreateBasepathMovementInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `BasepathMovement` to be created by this mutation."""
  basepathMovement: BasepathMovementInput!
}

"""An input for mutations affecting `BasepathMovement`"""
input BasepathMovementInput {
  plateAppearanceId: UUID
  runnerId: UUID
  endBase: BaseType
  wasSafe: Boolean!
  plateAppearance: BasepathMovementPlateAppearanceIdFkeyInput
  player: BasepathMovementRunnerIdFkeyInput
}

"""The output of our create `Field` mutation."""
type CreateFieldPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Field` that was created by this mutation."""
  field: Field

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `Field` mutation."""
input CreateFieldInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Field` to be created by this mutation."""
  field: FieldInput!
}

"""An input for mutations affecting `Field`"""
input FieldInput {
  id: UUID
  name: String!
  notes: String
  games: GameFieldIdFkeyInverseInput
}

"""The output of our create `Game` mutation."""
type CreateGamePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Game` that was created by this mutation."""
  game: Game

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Group` that is related to this `Game`."""
  group: Group

  """Reads a single `Field` that is related to this `Game`."""
  field: Field
}

"""All input for the create `Game` mutation."""
input CreateGameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Game` to be created by this mutation."""
  game: GameInput!
}

"""An input for mutations affecting `Game`"""
input GameInput {
  id: UUID
  groupId: UUID
  name: String
  fieldId: UUID
  score: [Int]!
  gameLength: Int
  timeStarted: Datetime!
  timeEnded: Datetime!
  timeSaved: Datetime
  group: GameGroupIdFkeyInput
  field: GameFieldIdFkeyInput
  teams: TeamGameIdFkeyInverseInput
  gameStates: GameStateGameIdFkeyInverseInput
  gameEventRecords: GameEventRecordGameIdFkeyInverseInput
}

"""The output of our create `GameEvent` mutation."""
type CreateGameEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `GameEvent` that was created by this mutation."""
  gameEvent: GameEvent

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `PlateAppearance` that is related to this `GameEvent`."""
  plateAppearance: PlateAppearance

  """
  Reads a single `StolenBaseAttempt` that is related to this `GameEvent`.
  """
  stolenBaseAttempt: StolenBaseAttempt

  """Reads a single `LineupChange` that is related to this `GameEvent`."""
  lineupChange: LineupChange
}

"""All input for the create `GameEvent` mutation."""
input CreateGameEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `GameEvent` to be created by this mutation."""
  gameEvent: GameEventInput!
}

"""An input for mutations affecting `GameEvent`"""
input GameEventInput {
  id: UUID
  plateAppearanceId: UUID
  stolenBaseAttemptId: UUID
  lineupChangeId: UUID
  plateAppearance: GameEventPlateAppearanceIdFkeyInput
  stolenBaseAttempt: GameEventStolenBaseAttemptIdFkeyInput
  lineupChange: GameEventLineupChangeIdFkeyInput
  gameEventRecords: GameEventRecordGameEventIdFkeyInverseInput
}

"""The output of our create `GameEventRecord` mutation."""
type CreateGameEventRecordPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `GameEventRecord` that was created by this mutation."""
  gameEventRecord: GameEventRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Game` that is related to this `GameEventRecord`."""
  game: Game

  """Reads a single `GameState` that is related to this `GameEventRecord`."""
  gameStateBefore: GameState

  """Reads a single `GameState` that is related to this `GameEventRecord`."""
  gameStateAfter: GameState

  """Reads a single `GameEvent` that is related to this `GameEventRecord`."""
  gameEvent: GameEvent
}

"""All input for the create `GameEventRecord` mutation."""
input CreateGameEventRecordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `GameEventRecord` to be created by this mutation."""
  gameEventRecord: GameEventRecordInput!
}

"""An input for mutations affecting `GameEventRecord`"""
input GameEventRecordInput {
  id: UUID
  gameId: UUID
  eventIndex: Int!
  gameStateBeforeId: UUID
  gameStateAfterId: UUID
  gameEventId: UUID
  notes: String
  game: GameEventRecordGameIdFkeyInput
  gameStateBefore: GameEventRecordGameStateBeforeFkInput
  gameStateAfter: GameEventRecordGameStateAfterFkInput
  gameEvent: GameEventRecordGameEventIdFkeyInput
  scoredRunners: ScoredRunnerGameEventRecordIdFkeyInverseInput
}

"""The output of our create `GameState` mutation."""
type CreateGameStatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `GameState` that was created by this mutation."""
  gameState: GameState

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Game` that is related to this `GameState`."""
  game: Game

  """Reads a single `Player` that is related to this `GameState`."""
  playerByPlayerAtBat: Player
}

"""All input for the create `GameState` mutation."""
input CreateGameStateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `GameState` to be created by this mutation."""
  gameState: GameStateInput!
}

"""An input for mutations affecting `GameState`"""
input GameStateInput {
  id: UUID
  gameId: UUID
  gameStateIndex: Int!
  playerAtBat: UUID
  inning: Int!
  halfInning: HalfInning!
  outs: Int!
  score: [Int]!
  game: GameStateGameIdFkeyInput
  player: GameStatePlayerAtBatFkeyInput
  baseRunners: BaseRunnerGameStateIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateGameStateIdFkeyInverseInput
  gameEventRecordsToGameStateBeforeIdUsingId: GameEventRecordGameStateBeforeFkInverseInput
  gameEventRecordsToGameStateAfterIdUsingId: GameEventRecordGameStateAfterFkInverseInput
}

"""The output of our create `Group` mutation."""
type CreateGroupPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Group` that was created by this mutation."""
  group: Group

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `Group` mutation."""
input CreateGroupInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Group` to be created by this mutation."""
  group: GroupInput!
}

"""An input for mutations affecting `Group`"""
input GroupInput {
  id: UUID
  name: String!
  notes: String
  players: PlayerGroupIdFkeyInverseInput
  games: GameGroupIdFkeyInverseInput
}

"""The output of our create `LegacyField` mutation."""
type CreateLegacyFieldPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LegacyField` that was created by this mutation."""
  legacyField: LegacyField

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `LegacyField` mutation."""
input CreateLegacyFieldInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `LegacyField` to be created by this mutation."""
  legacyField: LegacyFieldInput!
}

"""An input for mutations affecting `LegacyField`"""
input LegacyFieldInput {
  fieldId: Int!
  fieldName: String!
  fieldAddress: String!
  fieldNumber: String
}

"""The output of our create `LegacyGame` mutation."""
type CreateLegacyGamePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LegacyGame` that was created by this mutation."""
  legacyGame: LegacyGame

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `LegacyGame` mutation."""
input CreateLegacyGameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `LegacyGame` to be created by this mutation."""
  legacyGame: LegacyGameInput!
}

"""An input for mutations affecting `LegacyGame`"""
input LegacyGameInput {
  gameId: Int!
  gameTitle: String!
  gameDate: Date!
  gameStartTime: Time!
  gameEndTime: Time!
  gameTeamId1: Int!
  gameTeamId2: Int!
  season: Int!
  legacyStatLines: FakePublicLegacyStatLineForeignKey1InverseInput
}

"""The output of our create `LegacyPlayer` mutation."""
type CreateLegacyPlayerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LegacyPlayer` that was created by this mutation."""
  legacyPlayer: LegacyPlayer

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `LegacyPlayer` mutation."""
input CreateLegacyPlayerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `LegacyPlayer` to be created by this mutation."""
  legacyPlayer: LegacyPlayerInput!
}

"""An input for mutations affecting `LegacyPlayer`"""
input LegacyPlayerInput {
  playerId: Int!
  playerName: String!
  playerImage: String
  memberId: String
  legacyStatLines: FakePublicLegacyStatLineForeignKey0InverseInput
  players: FakePublicPlayerForeignKey0InverseInput
}

"""The output of our create `LegacyStatLine` mutation."""
type CreateLegacyStatLinePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LegacyStatLine` that was created by this mutation."""
  legacyStatLine: LegacyStatLine

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `LegacyPlayer` that is related to this `LegacyStatLine`.
  """
  player: LegacyPlayer

  """Reads a single `LegacyGame` that is related to this `LegacyStatLine`."""
  game: LegacyGame

  """Reads a single `LegacyTeam` that is related to this `LegacyStatLine`."""
  legacyTeamBySbStatsTeam: LegacyTeam
}

"""All input for the create `LegacyStatLine` mutation."""
input CreateLegacyStatLineInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `LegacyStatLine` to be created by this mutation."""
  legacyStatLine: LegacyStatLineInput!
}

"""An input for mutations affecting `LegacyStatLine`"""
input LegacyStatLineInput {
  sbStatsId: Int!
  playerId: Int
  gameId: Int
  sbStatsTeam: Int
  atBats: Int!
  runs: Int!
  hits: Int!
  singles: Int!
  doubles: Int!
  triples: Int!
  homeruns: Int!
  rbi: Int!
  walks: Int!
  strikeouts: Int!
  sacFlies: Int!
  legacyPlayer: FakePublicLegacyStatLineForeignKey0Input
  legacyGame: FakePublicLegacyStatLineForeignKey1Input
  legacyTeam: FakePublicLegacyStatLineForeignKey2Input
}

"""The output of our create `LegacyTeam` mutation."""
type CreateLegacyTeamPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LegacyTeam` that was created by this mutation."""
  legacyTeam: LegacyTeam

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `LegacyTeam` mutation."""
input CreateLegacyTeamInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `LegacyTeam` to be created by this mutation."""
  legacyTeam: LegacyTeamInput!
}

"""An input for mutations affecting `LegacyTeam`"""
input LegacyTeamInput {
  teamId: Int!
  teamName: String!
  legacyStatLines: FakePublicLegacyStatLineForeignKey2InverseInput
}

"""The output of our create `Lineup` mutation."""
type CreateLineupPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Lineup` that was created by this mutation."""
  lineup: Lineup

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Team` that is related to this `Lineup`."""
  team: Team
}

"""All input for the create `Lineup` mutation."""
input CreateLineupInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Lineup` to be created by this mutation."""
  lineup: LineupInput!
}

"""An input for mutations affecting `Lineup`"""
input LineupInput {
  id: UUID
  teamId: UUID
  team: LineupTeamIdFkeyInput
  lineupSpots: LineupSpotLineupIdFkeyInverseInput
  lineupChangesToLineupBeforeIdUsingId: LineupChangeLineupBeforeIdFkeyInverseInput
  lineupChangesToLineupAfterIdUsingId: LineupChangeLineupAfterIdFkeyInverseInput
  lineupForGameStates: LineupForGameStateLineupIdFkeyInverseInput
}

"""The output of our create `LineupChange` mutation."""
type CreateLineupChangePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LineupChange` that was created by this mutation."""
  lineupChange: LineupChange

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Lineup` that is related to this `LineupChange`."""
  lineupBefore: Lineup

  """Reads a single `Lineup` that is related to this `LineupChange`."""
  lineupAfter: Lineup
}

"""All input for the create `LineupChange` mutation."""
input CreateLineupChangeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `LineupChange` to be created by this mutation."""
  lineupChange: LineupChangeInput!
}

"""An input for mutations affecting `LineupChange`"""
input LineupChangeInput {
  id: UUID
  lineupBeforeId: UUID
  lineupAfterId: UUID
  lineup: LineupChangeLineupAfterIdFkeyInput
  gameEvents: GameEventLineupChangeIdFkeyInverseInput
}

"""The output of our create `LineupForGameState` mutation."""
type CreateLineupForGameStatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LineupForGameState` that was created by this mutation."""
  lineupForGameState: LineupForGameState

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `GameState` that is related to this `LineupForGameState`.
  """
  gameState: GameState

  """Reads a single `Lineup` that is related to this `LineupForGameState`."""
  lineup: Lineup
}

"""All input for the create `LineupForGameState` mutation."""
input CreateLineupForGameStateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `LineupForGameState` to be created by this mutation."""
  lineupForGameState: LineupForGameStateInput!
}

"""An input for mutations affecting `LineupForGameState`"""
input LineupForGameStateInput {
  gameStateId: UUID
  lineupId: UUID
  gameState: LineupForGameStateGameStateIdFkeyInput
  lineup: LineupForGameStateLineupIdFkeyInput
}

"""The output of our create `LineupSpot` mutation."""
type CreateLineupSpotPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LineupSpot` that was created by this mutation."""
  lineupSpot: LineupSpot

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Lineup` that is related to this `LineupSpot`."""
  lineup: Lineup

  """Reads a single `Player` that is related to this `LineupSpot`."""
  player: Player
}

"""All input for the create `LineupSpot` mutation."""
input CreateLineupSpotInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `LineupSpot` to be created by this mutation."""
  lineupSpot: LineupSpotInput!
}

"""An input for mutations affecting `LineupSpot`"""
input LineupSpotInput {
  lineupId: UUID
  playerId: UUID
  battingOrder: Int!
  position: FieldingPosition
  lineup: LineupSpotLineupIdFkeyInput
  player: LineupSpotPlayerIdFkeyInput
}

"""The output of our create `OutOnPlayRunner` mutation."""
type CreateOutOnPlayRunnerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `OutOnPlayRunner` that was created by this mutation."""
  outOnPlayRunner: OutOnPlayRunner

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`.
  """
  plateAppearance: PlateAppearance

  """Reads a single `Player` that is related to this `OutOnPlayRunner`."""
  runner: Player
}

"""All input for the create `OutOnPlayRunner` mutation."""
input CreateOutOnPlayRunnerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `OutOnPlayRunner` to be created by this mutation."""
  outOnPlayRunner: OutOnPlayRunnerInput!
}

"""An input for mutations affecting `OutOnPlayRunner`"""
input OutOnPlayRunnerInput {
  plateAppearanceId: UUID
  runnerId: UUID
  plateAppearance: OutOnPlayRunnerPlateAppearanceIdFkeyInput
  player: OutOnPlayRunnerRunnerIdFkeyInput
}

"""The output of our create `PlateAppearance` mutation."""
type CreatePlateAppearancePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlateAppearance` that was created by this mutation."""
  plateAppearance: PlateAppearance

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `PlateAppearance` mutation."""
input CreatePlateAppearanceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `PlateAppearance` to be created by this mutation."""
  plateAppearance: PlateAppearanceInput!
}

"""An input for mutations affecting `PlateAppearance`"""
input PlateAppearanceInput {
  id: UUID
  type: PlateAppearanceType!
  contact: ContactQuality
  fieldedBy: FieldingPosition
  runsScoredOnSacFly: Int
  routinePlay: Boolean
  basepathMovements: BasepathMovementPlateAppearanceIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerPlateAppearanceIdFkeyInverseInput
  gameEvents: GameEventPlateAppearanceIdFkeyInverseInput
}

"""The output of our create `Player` mutation."""
type CreatePlayerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Player` that was created by this mutation."""
  player: Player

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Group` that is related to this `Player`."""
  group: Group

  """Reads a single `LegacyPlayer` that is related to this `Player`."""
  legacyPlayer: LegacyPlayer
}

"""All input for the create `Player` mutation."""
input CreatePlayerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Player` to be created by this mutation."""
  player: PlayerInput!
}

"""An input for mutations affecting `Player`"""
input PlayerInput {
  id: UUID
  groupId: UUID
  legacyPlayerId: Int
  firstName: String!
  lastName: String
  nickname: String
  imageUrl: String
  timeCreated: Datetime
  group: PlayerGroupIdFkeyInput
  legacyPlayer: FakePublicPlayerForeignKey0Input
  teams: TeamCaptainIdFkeyInverseInput
  lineupSpots: LineupSpotPlayerIdFkeyInverseInput
  basepathMovements: BasepathMovementRunnerIdFkeyInverseInput
  outOnPlayRunners: OutOnPlayRunnerRunnerIdFkeyInverseInput
  stolenBaseAttempts: StolenBaseAttemptRunnerIdFkeyInverseInput
  gameStates: GameStatePlayerAtBatFkeyInverseInput
  baseRunners: BaseRunnerRunnerIdFkeyInverseInput
  scoredRunners: ScoredRunnerRunnerIdFkeyInverseInput
}

"""The output of our create `ScoredRunner` mutation."""
type CreateScoredRunnerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ScoredRunner` that was created by this mutation."""
  scoredRunner: ScoredRunner

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `GameEventRecord` that is related to this `ScoredRunner`.
  """
  gameEventRecord: GameEventRecord

  """Reads a single `Player` that is related to this `ScoredRunner`."""
  runner: Player
}

"""All input for the create `ScoredRunner` mutation."""
input CreateScoredRunnerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ScoredRunner` to be created by this mutation."""
  scoredRunner: ScoredRunnerInput!
}

"""An input for mutations affecting `ScoredRunner`"""
input ScoredRunnerInput {
  gameEventRecordId: UUID
  runnerId: UUID
  battedIn: Boolean!
  gameEventRecord: ScoredRunnerGameEventRecordIdFkeyInput
  player: ScoredRunnerRunnerIdFkeyInput
}

"""The output of our create `StolenBaseAttempt` mutation."""
type CreateStolenBaseAttemptPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StolenBaseAttempt` that was created by this mutation."""
  stolenBaseAttempt: StolenBaseAttempt

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Player` that is related to this `StolenBaseAttempt`."""
  runner: Player
}

"""All input for the create `StolenBaseAttempt` mutation."""
input CreateStolenBaseAttemptInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `StolenBaseAttempt` to be created by this mutation."""
  stolenBaseAttempt: StolenBaseAttemptInput!
}

"""An input for mutations affecting `StolenBaseAttempt`"""
input StolenBaseAttemptInput {
  id: UUID
  runnerId: UUID
  success: Boolean!
  player: StolenBaseAttemptRunnerIdFkeyInput
  gameEvents: GameEventStolenBaseAttemptIdFkeyInverseInput
}

"""The output of our create `Team` mutation."""
type CreateTeamPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Team` that was created by this mutation."""
  team: Team

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Game` that is related to this `Team`."""
  game: Game

  """Reads a single `Player` that is related to this `Team`."""
  captain: Player
}

"""All input for the create `Team` mutation."""
input CreateTeamInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Team` to be created by this mutation."""
  team: TeamInput!
}

"""An input for mutations affecting `Team`"""
input TeamInput {
  id: UUID
  gameId: UUID
  role: TeamRole!
  name: String
  captainId: UUID
  winner: Boolean
  game: TeamGameIdFkeyInput
  player: TeamCaptainIdFkeyInput
  lineups: LineupTeamIdFkeyInverseInput
}

"""The output of our update `BaseRunner` mutation."""
type UpdateBaseRunnerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BaseRunner` that was updated by this mutation."""
  baseRunner: BaseRunner

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `GameState` that is related to this `BaseRunner`."""
  gameState: GameState

  """Reads a single `Player` that is related to this `BaseRunner`."""
  runner: Player
}

"""All input for the `updateBaseRunnerByNodeId` mutation."""
input UpdateBaseRunnerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `BaseRunner` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `BaseRunner` being updated.
  """
  patch: BaseRunnerPatch!
}

"""All input for the `updateBaseRunner` mutation."""
input UpdateBaseRunnerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `BaseRunner` being updated.
  """
  patch: BaseRunnerPatch!
  gameStateId: UUID!
  runnerId: UUID!
}

"""The output of our update `BasepathMovement` mutation."""
type UpdateBasepathMovementPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BasepathMovement` that was updated by this mutation."""
  basepathMovement: BasepathMovement

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `PlateAppearance` that is related to this `BasepathMovement`.
  """
  plateAppearance: PlateAppearance

  """Reads a single `Player` that is related to this `BasepathMovement`."""
  runner: Player
}

"""All input for the `updateBasepathMovementByNodeId` mutation."""
input UpdateBasepathMovementByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `BasepathMovement` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `BasepathMovement` being updated.
  """
  patch: BasepathMovementPatch!
}

"""All input for the `updateBasepathMovement` mutation."""
input UpdateBasepathMovementInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `BasepathMovement` being updated.
  """
  patch: BasepathMovementPatch!
  plateAppearanceId: UUID!
  runnerId: UUID!
}

"""The output of our update `Field` mutation."""
type UpdateFieldPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Field` that was updated by this mutation."""
  field: Field

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateFieldByNodeId` mutation."""
input UpdateFieldByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Field` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Field` being updated.
  """
  patch: FieldPatch!
}

"""All input for the `updateField` mutation."""
input UpdateFieldInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Field` being updated.
  """
  patch: FieldPatch!
  id: UUID!
}

"""The output of our update `Game` mutation."""
type UpdateGamePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Game` that was updated by this mutation."""
  game: Game

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Group` that is related to this `Game`."""
  group: Group

  """Reads a single `Field` that is related to this `Game`."""
  field: Field
}

"""All input for the `updateGameByNodeId` mutation."""
input UpdateGameByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Game` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Game` being updated.
  """
  patch: GamePatch!
}

"""All input for the `updateGame` mutation."""
input UpdateGameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Game` being updated.
  """
  patch: GamePatch!
  id: UUID!
}

"""All input for the `updateGameByName` mutation."""
input UpdateGameByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Game` being updated.
  """
  patch: GamePatch!
  name: String!
}

"""The output of our update `GameEvent` mutation."""
type UpdateGameEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `GameEvent` that was updated by this mutation."""
  gameEvent: GameEvent

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `PlateAppearance` that is related to this `GameEvent`."""
  plateAppearance: PlateAppearance

  """
  Reads a single `StolenBaseAttempt` that is related to this `GameEvent`.
  """
  stolenBaseAttempt: StolenBaseAttempt

  """Reads a single `LineupChange` that is related to this `GameEvent`."""
  lineupChange: LineupChange
}

"""All input for the `updateGameEventByNodeId` mutation."""
input UpdateGameEventByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `GameEvent` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `GameEvent` being updated.
  """
  patch: GameEventPatch!
}

"""All input for the `updateGameEvent` mutation."""
input UpdateGameEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `GameEvent` being updated.
  """
  patch: GameEventPatch!
  id: UUID!
}

"""The output of our update `GameEventRecord` mutation."""
type UpdateGameEventRecordPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `GameEventRecord` that was updated by this mutation."""
  gameEventRecord: GameEventRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Game` that is related to this `GameEventRecord`."""
  game: Game

  """Reads a single `GameState` that is related to this `GameEventRecord`."""
  gameStateBefore: GameState

  """Reads a single `GameState` that is related to this `GameEventRecord`."""
  gameStateAfter: GameState

  """Reads a single `GameEvent` that is related to this `GameEventRecord`."""
  gameEvent: GameEvent
}

"""All input for the `updateGameEventRecordByNodeId` mutation."""
input UpdateGameEventRecordByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `GameEventRecord` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `GameEventRecord` being updated.
  """
  patch: GameEventRecordPatch!
}

"""All input for the `updateGameEventRecord` mutation."""
input UpdateGameEventRecordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `GameEventRecord` being updated.
  """
  patch: GameEventRecordPatch!
  id: UUID!
}

"""
All input for the `updateGameEventRecordByGameIdAndEventIndex` mutation.
"""
input UpdateGameEventRecordByGameIdAndEventIndexInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `GameEventRecord` being updated.
  """
  patch: GameEventRecordPatch!
  gameId: UUID!
  eventIndex: Int!
}

"""The output of our update `GameState` mutation."""
type UpdateGameStatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `GameState` that was updated by this mutation."""
  gameState: GameState

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Game` that is related to this `GameState`."""
  game: Game

  """Reads a single `Player` that is related to this `GameState`."""
  playerByPlayerAtBat: Player
}

"""All input for the `updateGameStateByNodeId` mutation."""
input UpdateGameStateByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `GameState` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `GameState` being updated.
  """
  patch: GameStatePatch!
}

"""All input for the `updateGameState` mutation."""
input UpdateGameStateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `GameState` being updated.
  """
  patch: GameStatePatch!
  id: UUID!
}

"""The output of our update `Group` mutation."""
type UpdateGroupPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Group` that was updated by this mutation."""
  group: Group

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateGroupByNodeId` mutation."""
input UpdateGroupByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Group` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Group` being updated.
  """
  patch: GroupPatch!
}

"""All input for the `updateGroup` mutation."""
input UpdateGroupInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Group` being updated.
  """
  patch: GroupPatch!
  id: UUID!
}

"""All input for the `updateGroupByName` mutation."""
input UpdateGroupByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Group` being updated.
  """
  patch: GroupPatch!
  name: String!
}

"""The output of our update `LegacyField` mutation."""
type UpdateLegacyFieldPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LegacyField` that was updated by this mutation."""
  legacyField: LegacyField

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateLegacyFieldByNodeId` mutation."""
input UpdateLegacyFieldByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LegacyField` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `LegacyField` being updated.
  """
  patch: LegacyFieldPatch!
}

"""
Represents an update to a `LegacyField`. Fields that are set will be updated.
"""
input LegacyFieldPatch {
  fieldId: Int
  fieldName: String
  fieldAddress: String
  fieldNumber: String
}

"""All input for the `updateLegacyField` mutation."""
input UpdateLegacyFieldInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `LegacyField` being updated.
  """
  patch: LegacyFieldPatch!
  fieldId: Int!
}

"""The output of our update `LegacyGame` mutation."""
type UpdateLegacyGamePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LegacyGame` that was updated by this mutation."""
  legacyGame: LegacyGame

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateLegacyGameByNodeId` mutation."""
input UpdateLegacyGameByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LegacyGame` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `LegacyGame` being updated.
  """
  patch: LegacyGamePatch!
}

"""All input for the `updateLegacyGame` mutation."""
input UpdateLegacyGameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `LegacyGame` being updated.
  """
  patch: LegacyGamePatch!
  gameId: Int!
}

"""The output of our update `LegacyPlayer` mutation."""
type UpdateLegacyPlayerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LegacyPlayer` that was updated by this mutation."""
  legacyPlayer: LegacyPlayer

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateLegacyPlayerByNodeId` mutation."""
input UpdateLegacyPlayerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LegacyPlayer` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `LegacyPlayer` being updated.
  """
  patch: LegacyPlayerPatch!
}

"""All input for the `updateLegacyPlayer` mutation."""
input UpdateLegacyPlayerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `LegacyPlayer` being updated.
  """
  patch: LegacyPlayerPatch!
  playerId: Int!
}

"""The output of our update `LegacyTeam` mutation."""
type UpdateLegacyTeamPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LegacyTeam` that was updated by this mutation."""
  legacyTeam: LegacyTeam

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateLegacyTeamByNodeId` mutation."""
input UpdateLegacyTeamByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LegacyTeam` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `LegacyTeam` being updated.
  """
  patch: LegacyTeamPatch!
}

"""All input for the `updateLegacyTeam` mutation."""
input UpdateLegacyTeamInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `LegacyTeam` being updated.
  """
  patch: LegacyTeamPatch!
  teamId: Int!
}

"""The output of our update `Lineup` mutation."""
type UpdateLineupPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Lineup` that was updated by this mutation."""
  lineup: Lineup

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Team` that is related to this `Lineup`."""
  team: Team
}

"""All input for the `updateLineupByNodeId` mutation."""
input UpdateLineupByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Lineup` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Lineup` being updated.
  """
  patch: LineupPatch!
}

"""All input for the `updateLineup` mutation."""
input UpdateLineupInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Lineup` being updated.
  """
  patch: LineupPatch!
  id: UUID!
}

"""The output of our update `LineupChange` mutation."""
type UpdateLineupChangePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LineupChange` that was updated by this mutation."""
  lineupChange: LineupChange

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Lineup` that is related to this `LineupChange`."""
  lineupBefore: Lineup

  """Reads a single `Lineup` that is related to this `LineupChange`."""
  lineupAfter: Lineup
}

"""All input for the `updateLineupChangeByNodeId` mutation."""
input UpdateLineupChangeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LineupChange` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `LineupChange` being updated.
  """
  patch: LineupChangePatch!
}

"""All input for the `updateLineupChange` mutation."""
input UpdateLineupChangeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `LineupChange` being updated.
  """
  patch: LineupChangePatch!
  id: UUID!
}

"""The output of our update `LineupForGameState` mutation."""
type UpdateLineupForGameStatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LineupForGameState` that was updated by this mutation."""
  lineupForGameState: LineupForGameState

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `GameState` that is related to this `LineupForGameState`.
  """
  gameState: GameState

  """Reads a single `Lineup` that is related to this `LineupForGameState`."""
  lineup: Lineup
}

"""All input for the `updateLineupForGameStateByNodeId` mutation."""
input UpdateLineupForGameStateByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LineupForGameState` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `LineupForGameState` being updated.
  """
  patch: LineupForGameStatePatch!
}

"""All input for the `updateLineupForGameState` mutation."""
input UpdateLineupForGameStateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `LineupForGameState` being updated.
  """
  patch: LineupForGameStatePatch!
  gameStateId: UUID!
  lineupId: UUID!
}

"""The output of our update `LineupSpot` mutation."""
type UpdateLineupSpotPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LineupSpot` that was updated by this mutation."""
  lineupSpot: LineupSpot

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Lineup` that is related to this `LineupSpot`."""
  lineup: Lineup

  """Reads a single `Player` that is related to this `LineupSpot`."""
  player: Player
}

"""All input for the `updateLineupSpotByNodeId` mutation."""
input UpdateLineupSpotByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LineupSpot` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `LineupSpot` being updated.
  """
  patch: LineupSpotPatch!
}

"""All input for the `updateLineupSpot` mutation."""
input UpdateLineupSpotInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `LineupSpot` being updated.
  """
  patch: LineupSpotPatch!
  lineupId: UUID!
  playerId: UUID!
}

"""
All input for the `updateLineupSpotByLineupIdAndBattingOrder` mutation.
"""
input UpdateLineupSpotByLineupIdAndBattingOrderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `LineupSpot` being updated.
  """
  patch: LineupSpotPatch!
  lineupId: UUID!
  battingOrder: Int!
}

"""All input for the `updateLineupSpotByLineupIdAndPosition` mutation."""
input UpdateLineupSpotByLineupIdAndPositionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `LineupSpot` being updated.
  """
  patch: LineupSpotPatch!
  lineupId: UUID!
  position: FieldingPosition!
}

"""The output of our update `OutOnPlayRunner` mutation."""
type UpdateOutOnPlayRunnerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `OutOnPlayRunner` that was updated by this mutation."""
  outOnPlayRunner: OutOnPlayRunner

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`.
  """
  plateAppearance: PlateAppearance

  """Reads a single `Player` that is related to this `OutOnPlayRunner`."""
  runner: Player
}

"""All input for the `updateOutOnPlayRunnerByNodeId` mutation."""
input UpdateOutOnPlayRunnerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `OutOnPlayRunner` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `OutOnPlayRunner` being updated.
  """
  patch: OutOnPlayRunnerPatch!
}

"""All input for the `updateOutOnPlayRunner` mutation."""
input UpdateOutOnPlayRunnerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `OutOnPlayRunner` being updated.
  """
  patch: OutOnPlayRunnerPatch!
  plateAppearanceId: UUID!
  runnerId: UUID!
}

"""The output of our update `PlateAppearance` mutation."""
type UpdatePlateAppearancePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlateAppearance` that was updated by this mutation."""
  plateAppearance: PlateAppearance

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updatePlateAppearanceByNodeId` mutation."""
input UpdatePlateAppearanceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PlateAppearance` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `PlateAppearance` being updated.
  """
  patch: PlateAppearancePatch!
}

"""All input for the `updatePlateAppearance` mutation."""
input UpdatePlateAppearanceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `PlateAppearance` being updated.
  """
  patch: PlateAppearancePatch!
  id: UUID!
}

"""The output of our update `Player` mutation."""
type UpdatePlayerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Player` that was updated by this mutation."""
  player: Player

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Group` that is related to this `Player`."""
  group: Group

  """Reads a single `LegacyPlayer` that is related to this `Player`."""
  legacyPlayer: LegacyPlayer
}

"""All input for the `updatePlayerByNodeId` mutation."""
input UpdatePlayerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Player` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Player` being updated.
  """
  patch: PlayerPatch!
}

"""All input for the `updatePlayer` mutation."""
input UpdatePlayerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Player` being updated.
  """
  patch: PlayerPatch!
  id: UUID!
}

"""All input for the `updatePlayerByFirstNameAndLastName` mutation."""
input UpdatePlayerByFirstNameAndLastNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Player` being updated.
  """
  patch: PlayerPatch!
  firstName: String!
  lastName: String!
}

"""The output of our update `ScoredRunner` mutation."""
type UpdateScoredRunnerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ScoredRunner` that was updated by this mutation."""
  scoredRunner: ScoredRunner

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `GameEventRecord` that is related to this `ScoredRunner`.
  """
  gameEventRecord: GameEventRecord

  """Reads a single `Player` that is related to this `ScoredRunner`."""
  runner: Player
}

"""All input for the `updateScoredRunnerByNodeId` mutation."""
input UpdateScoredRunnerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ScoredRunner` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ScoredRunner` being updated.
  """
  patch: ScoredRunnerPatch!
}

"""All input for the `updateScoredRunner` mutation."""
input UpdateScoredRunnerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `ScoredRunner` being updated.
  """
  patch: ScoredRunnerPatch!
  gameEventRecordId: UUID!
  runnerId: UUID!
}

"""The output of our update `StolenBaseAttempt` mutation."""
type UpdateStolenBaseAttemptPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StolenBaseAttempt` that was updated by this mutation."""
  stolenBaseAttempt: StolenBaseAttempt

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Player` that is related to this `StolenBaseAttempt`."""
  runner: Player
}

"""All input for the `updateStolenBaseAttemptByNodeId` mutation."""
input UpdateStolenBaseAttemptByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `StolenBaseAttempt` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `StolenBaseAttempt` being updated.
  """
  patch: StolenBaseAttemptPatch!
}

"""All input for the `updateStolenBaseAttempt` mutation."""
input UpdateStolenBaseAttemptInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `StolenBaseAttempt` being updated.
  """
  patch: StolenBaseAttemptPatch!
  id: UUID!
}

"""The output of our update `Team` mutation."""
type UpdateTeamPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Team` that was updated by this mutation."""
  team: Team

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Game` that is related to this `Team`."""
  game: Game

  """Reads a single `Player` that is related to this `Team`."""
  captain: Player
}

"""All input for the `updateTeamByNodeId` mutation."""
input UpdateTeamByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Team` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Team` being updated.
  """
  patch: TeamPatch!
}

"""All input for the `updateTeam` mutation."""
input UpdateTeamInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Team` being updated.
  """
  patch: TeamPatch!
  id: UUID!
}

"""All input for the `updateTeamByGameIdAndRole` mutation."""
input UpdateTeamByGameIdAndRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Team` being updated.
  """
  patch: TeamPatch!
  gameId: UUID!
  role: TeamRole!
}

"""The output of our delete `BaseRunner` mutation."""
type DeleteBaseRunnerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BaseRunner` that was deleted by this mutation."""
  baseRunner: BaseRunner
  deletedBaseRunnerNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `GameState` that is related to this `BaseRunner`."""
  gameState: GameState

  """Reads a single `Player` that is related to this `BaseRunner`."""
  runner: Player
}

"""All input for the `deleteBaseRunnerByNodeId` mutation."""
input DeleteBaseRunnerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `BaseRunner` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteBaseRunner` mutation."""
input DeleteBaseRunnerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  gameStateId: UUID!
  runnerId: UUID!
}

"""The output of our delete `BasepathMovement` mutation."""
type DeleteBasepathMovementPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `BasepathMovement` that was deleted by this mutation."""
  basepathMovement: BasepathMovement
  deletedBasepathMovementNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `PlateAppearance` that is related to this `BasepathMovement`.
  """
  plateAppearance: PlateAppearance

  """Reads a single `Player` that is related to this `BasepathMovement`."""
  runner: Player
}

"""All input for the `deleteBasepathMovementByNodeId` mutation."""
input DeleteBasepathMovementByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `BasepathMovement` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteBasepathMovement` mutation."""
input DeleteBasepathMovementInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  plateAppearanceId: UUID!
  runnerId: UUID!
}

"""The output of our delete `Field` mutation."""
type DeleteFieldPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Field` that was deleted by this mutation."""
  field: Field
  deletedFieldNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteFieldByNodeId` mutation."""
input DeleteFieldByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Field` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteField` mutation."""
input DeleteFieldInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Game` mutation."""
type DeleteGamePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Game` that was deleted by this mutation."""
  game: Game
  deletedGameNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Group` that is related to this `Game`."""
  group: Group

  """Reads a single `Field` that is related to this `Game`."""
  field: Field
}

"""All input for the `deleteGameByNodeId` mutation."""
input DeleteGameByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Game` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteGame` mutation."""
input DeleteGameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""All input for the `deleteGameByName` mutation."""
input DeleteGameByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""The output of our delete `GameEvent` mutation."""
type DeleteGameEventPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `GameEvent` that was deleted by this mutation."""
  gameEvent: GameEvent
  deletedGameEventNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `PlateAppearance` that is related to this `GameEvent`."""
  plateAppearance: PlateAppearance

  """
  Reads a single `StolenBaseAttempt` that is related to this `GameEvent`.
  """
  stolenBaseAttempt: StolenBaseAttempt

  """Reads a single `LineupChange` that is related to this `GameEvent`."""
  lineupChange: LineupChange
}

"""All input for the `deleteGameEventByNodeId` mutation."""
input DeleteGameEventByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `GameEvent` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteGameEvent` mutation."""
input DeleteGameEventInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `GameEventRecord` mutation."""
type DeleteGameEventRecordPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `GameEventRecord` that was deleted by this mutation."""
  gameEventRecord: GameEventRecord
  deletedGameEventRecordNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Game` that is related to this `GameEventRecord`."""
  game: Game

  """Reads a single `GameState` that is related to this `GameEventRecord`."""
  gameStateBefore: GameState

  """Reads a single `GameState` that is related to this `GameEventRecord`."""
  gameStateAfter: GameState

  """Reads a single `GameEvent` that is related to this `GameEventRecord`."""
  gameEvent: GameEvent
}

"""All input for the `deleteGameEventRecordByNodeId` mutation."""
input DeleteGameEventRecordByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `GameEventRecord` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteGameEventRecord` mutation."""
input DeleteGameEventRecordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""
All input for the `deleteGameEventRecordByGameIdAndEventIndex` mutation.
"""
input DeleteGameEventRecordByGameIdAndEventIndexInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  gameId: UUID!
  eventIndex: Int!
}

"""The output of our delete `GameState` mutation."""
type DeleteGameStatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `GameState` that was deleted by this mutation."""
  gameState: GameState
  deletedGameStateNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Game` that is related to this `GameState`."""
  game: Game

  """Reads a single `Player` that is related to this `GameState`."""
  playerByPlayerAtBat: Player
}

"""All input for the `deleteGameStateByNodeId` mutation."""
input DeleteGameStateByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `GameState` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteGameState` mutation."""
input DeleteGameStateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Group` mutation."""
type DeleteGroupPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Group` that was deleted by this mutation."""
  group: Group
  deletedGroupNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteGroupByNodeId` mutation."""
input DeleteGroupByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Group` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteGroup` mutation."""
input DeleteGroupInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""All input for the `deleteGroupByName` mutation."""
input DeleteGroupByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""The output of our delete `LegacyField` mutation."""
type DeleteLegacyFieldPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LegacyField` that was deleted by this mutation."""
  legacyField: LegacyField
  deletedLegacyFieldNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteLegacyFieldByNodeId` mutation."""
input DeleteLegacyFieldByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LegacyField` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteLegacyField` mutation."""
input DeleteLegacyFieldInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  fieldId: Int!
}

"""The output of our delete `LegacyGame` mutation."""
type DeleteLegacyGamePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LegacyGame` that was deleted by this mutation."""
  legacyGame: LegacyGame
  deletedLegacyGameNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteLegacyGameByNodeId` mutation."""
input DeleteLegacyGameByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LegacyGame` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteLegacyGame` mutation."""
input DeleteLegacyGameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  gameId: Int!
}

"""The output of our delete `LegacyPlayer` mutation."""
type DeleteLegacyPlayerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LegacyPlayer` that was deleted by this mutation."""
  legacyPlayer: LegacyPlayer
  deletedLegacyPlayerNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteLegacyPlayerByNodeId` mutation."""
input DeleteLegacyPlayerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LegacyPlayer` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteLegacyPlayer` mutation."""
input DeleteLegacyPlayerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  playerId: Int!
}

"""The output of our delete `LegacyTeam` mutation."""
type DeleteLegacyTeamPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LegacyTeam` that was deleted by this mutation."""
  legacyTeam: LegacyTeam
  deletedLegacyTeamNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteLegacyTeamByNodeId` mutation."""
input DeleteLegacyTeamByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LegacyTeam` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteLegacyTeam` mutation."""
input DeleteLegacyTeamInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  teamId: Int!
}

"""The output of our delete `Lineup` mutation."""
type DeleteLineupPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Lineup` that was deleted by this mutation."""
  lineup: Lineup
  deletedLineupNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Team` that is related to this `Lineup`."""
  team: Team
}

"""All input for the `deleteLineupByNodeId` mutation."""
input DeleteLineupByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Lineup` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteLineup` mutation."""
input DeleteLineupInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `LineupChange` mutation."""
type DeleteLineupChangePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LineupChange` that was deleted by this mutation."""
  lineupChange: LineupChange
  deletedLineupChangeNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Lineup` that is related to this `LineupChange`."""
  lineupBefore: Lineup

  """Reads a single `Lineup` that is related to this `LineupChange`."""
  lineupAfter: Lineup
}

"""All input for the `deleteLineupChangeByNodeId` mutation."""
input DeleteLineupChangeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LineupChange` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteLineupChange` mutation."""
input DeleteLineupChangeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `LineupForGameState` mutation."""
type DeleteLineupForGameStatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LineupForGameState` that was deleted by this mutation."""
  lineupForGameState: LineupForGameState
  deletedLineupForGameStateNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `GameState` that is related to this `LineupForGameState`.
  """
  gameState: GameState

  """Reads a single `Lineup` that is related to this `LineupForGameState`."""
  lineup: Lineup
}

"""All input for the `deleteLineupForGameStateByNodeId` mutation."""
input DeleteLineupForGameStateByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LineupForGameState` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteLineupForGameState` mutation."""
input DeleteLineupForGameStateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  gameStateId: UUID!
  lineupId: UUID!
}

"""The output of our delete `LineupSpot` mutation."""
type DeleteLineupSpotPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `LineupSpot` that was deleted by this mutation."""
  lineupSpot: LineupSpot
  deletedLineupSpotNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Lineup` that is related to this `LineupSpot`."""
  lineup: Lineup

  """Reads a single `Player` that is related to this `LineupSpot`."""
  player: Player
}

"""All input for the `deleteLineupSpotByNodeId` mutation."""
input DeleteLineupSpotByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LineupSpot` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteLineupSpot` mutation."""
input DeleteLineupSpotInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  lineupId: UUID!
  playerId: UUID!
}

"""
All input for the `deleteLineupSpotByLineupIdAndBattingOrder` mutation.
"""
input DeleteLineupSpotByLineupIdAndBattingOrderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  lineupId: UUID!
  battingOrder: Int!
}

"""All input for the `deleteLineupSpotByLineupIdAndPosition` mutation."""
input DeleteLineupSpotByLineupIdAndPositionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  lineupId: UUID!
  position: FieldingPosition!
}

"""The output of our delete `OutOnPlayRunner` mutation."""
type DeleteOutOnPlayRunnerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `OutOnPlayRunner` that was deleted by this mutation."""
  outOnPlayRunner: OutOnPlayRunner
  deletedOutOnPlayRunnerNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `PlateAppearance` that is related to this `OutOnPlayRunner`.
  """
  plateAppearance: PlateAppearance

  """Reads a single `Player` that is related to this `OutOnPlayRunner`."""
  runner: Player
}

"""All input for the `deleteOutOnPlayRunnerByNodeId` mutation."""
input DeleteOutOnPlayRunnerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `OutOnPlayRunner` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteOutOnPlayRunner` mutation."""
input DeleteOutOnPlayRunnerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  plateAppearanceId: UUID!
  runnerId: UUID!
}

"""The output of our delete `PlateAppearance` mutation."""
type DeletePlateAppearancePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PlateAppearance` that was deleted by this mutation."""
  plateAppearance: PlateAppearance
  deletedPlateAppearanceNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deletePlateAppearanceByNodeId` mutation."""
input DeletePlateAppearanceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PlateAppearance` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePlateAppearance` mutation."""
input DeletePlateAppearanceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Player` mutation."""
type DeletePlayerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Player` that was deleted by this mutation."""
  player: Player
  deletedPlayerNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Group` that is related to this `Player`."""
  group: Group

  """Reads a single `LegacyPlayer` that is related to this `Player`."""
  legacyPlayer: LegacyPlayer
}

"""All input for the `deletePlayerByNodeId` mutation."""
input DeletePlayerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Player` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePlayer` mutation."""
input DeletePlayerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""All input for the `deletePlayerByFirstNameAndLastName` mutation."""
input DeletePlayerByFirstNameAndLastNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  firstName: String!
  lastName: String!
}

"""The output of our delete `ScoredRunner` mutation."""
type DeleteScoredRunnerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ScoredRunner` that was deleted by this mutation."""
  scoredRunner: ScoredRunner
  deletedScoredRunnerNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `GameEventRecord` that is related to this `ScoredRunner`.
  """
  gameEventRecord: GameEventRecord

  """Reads a single `Player` that is related to this `ScoredRunner`."""
  runner: Player
}

"""All input for the `deleteScoredRunnerByNodeId` mutation."""
input DeleteScoredRunnerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ScoredRunner` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteScoredRunner` mutation."""
input DeleteScoredRunnerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  gameEventRecordId: UUID!
  runnerId: UUID!
}

"""The output of our delete `StolenBaseAttempt` mutation."""
type DeleteStolenBaseAttemptPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StolenBaseAttempt` that was deleted by this mutation."""
  stolenBaseAttempt: StolenBaseAttempt
  deletedStolenBaseAttemptNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Player` that is related to this `StolenBaseAttempt`."""
  runner: Player
}

"""All input for the `deleteStolenBaseAttemptByNodeId` mutation."""
input DeleteStolenBaseAttemptByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `StolenBaseAttempt` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteStolenBaseAttempt` mutation."""
input DeleteStolenBaseAttemptInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Team` mutation."""
type DeleteTeamPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Team` that was deleted by this mutation."""
  team: Team
  deletedTeamNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Game` that is related to this `Team`."""
  game: Game

  """Reads a single `Player` that is related to this `Team`."""
  captain: Player
}

"""All input for the `deleteTeamByNodeId` mutation."""
input DeleteTeamByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Team` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTeam` mutation."""
input DeleteTeamInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""All input for the `deleteTeamByGameIdAndRole` mutation."""
input DeleteTeamByGameIdAndRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  gameId: UUID!
  role: TeamRole!
}
